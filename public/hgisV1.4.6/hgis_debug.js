/*

  HGIS.js -- HGIS Map Viewer Library

  Copyright (c) 2006-2013 by HGIS Contributors
  Published under the 2-clause BSD license.
  See http://HGIS.org/dev/license.txt for the full text of the license, and http://HGIS.org/dev/authors.txt for full list of contributors.

  Includes compressed code under the following licenses:

  (For uncompressed versions of the code used, please see the
  HGIS Github repository: <https://github.com/HGIS/HGIS>)

 */

/**
 * Contains XMLHttpRequest.js <http://code.google.com/p/xmlhttprequest/>
 * Copyright 2007 Sergey Ilinsky (http://www.ilinsky.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/**
 * HGIS.Util.pagePosition is based on Yahoo's getXY method, which is
 * Copyright (c) 2006, Yahoo! Inc.
 * All rights reserved.
 * 
 * Redistribution and use of this software in source and binary forms, with or
 * without modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * Neither the name of Yahoo! Inc. nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission of Yahoo! Inc.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */
/* ======================================================================
    HGIS/SingleFile.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

var HGIS = {
	/**
	 * Constant: VERSION_NUMBER
	 */
	VERSION_NUMBER : "v1.4",

	/**
	 * Constant: singleFile
	 * 
	 * include HGIS.js
	 */
	singleFile : true,

	/**
	 * Method: _getScriptLocation
	 * Return the path to this script. This is also implemented in
	 * HGIS.js
	 *
	 * Returns:
	 * {String} Path to this script
	 */
	_getScriptLocation : (function() {
		var r = new RegExp("(^|(.*?\\/))(hgis[^\\/]*?\\.js)(\\?|$)"), s = document
				.getElementsByTagName('script'), src, m, l = "";
		for ( var i = 0, len = s.length; i < len; i++) {
			src = s[i].getAttribute('src');
			if (src) {
				m = src.match(r);
				if (m) {
					l = m[1];
					break;
				}
			}
		}
		return (function() {
			return l;
		});
	})(),

	/**
	 * Property: ImgPath
	 * {String} Set this to the path where control images are stored, a path  
	 * given here must end with a slash. If set to '' (which is the default) 
	 * HGIS will use its script location + "img/".
	 * 
	 * You will need to set this property when you have a singlefile build of 
	 * HGIS that either is not named "HGIS.js" or if you move
	 * the file in a way such that the image directory cannot be derived from 
	 * the script location.
	 * 
	 * If your custom HGIS build is named "my-custom-ol.js" and the images
	 * of HGIS are in a folder "/resources/external/images/ol" a correct
	 * way of including HGIS in your HTML would be:
	 * 
	 * (code)
	 *   <script src="/path/to/my-custom-ol.js" type="text/javascript"></script>
	 *   <script type="text/javascript">
	 *      // tell HGIS where the control images are
	 *      // remember the trailing slash
	 *      HGIS.ImgPath = "/resources/external/images/ol/";
	 *   </script>
	 * (end code)
	 * 
	 * Please remember that when your HGIS script is not named 
	 * "HGIS.js" you will have to make sure that the default theme is 
	 * loaded into the page by including an appropriate <link>-tag, 
	 * e.g.:
	 * 
	 * (code)
	 *   <link rel="stylesheet" href="/path/to/default/style.css"  type="text/css">
	 * (end code)
	 */
	ImgPath : ''
};
var APIAdress=HGIS._getScriptLocation();

/* ======================================================================
    HGIS/BaseTypes/Class.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/SingleFile.js
 */

/**
 * Constructor: HGIS.Class
 * Base class used to construct all other classes. Includes support for 
 *     multiple inheritance. 
 *     
 * This constructor is new in HGIS 2.5.  At HGIS 3.0, the old 
 *     syntax for creating classes and dealing with inheritance 
 *     will be removed.
 * 
 * To create a new HGIS-style class, use the following syntax:
 * (code)
 *     var MyClass = HGIS.Class(prototype);
 * (end)
 *
 * To create a new HGIS-style class with multiple inheritance, use the
 *     following syntax:
 * (code)
 *     var MyClass = HGIS.Class(Class1, Class2, prototype);
 * (end)
 * 
 * Note that instanceof reflection will only reveal Class1 as superclass.
 *
 */
HGIS.Class = function() {
	var len = arguments.length;
	var P = arguments[0];
	var F = arguments[len - 1];

	var C = typeof F.initialize == "function" ? F.initialize : function() {
		P.prototype.initialize.apply(this, arguments);
	};

	if (len > 1) {
		var newArgs = [ C, P ].concat(Array.prototype.slice.call(arguments)
				.slice(1, len - 1), F);
		HGIS.inherit.apply(null, newArgs);
	} else {
		C.prototype = F;
	}
	return C;
};

/**
 * Function: HGIS.inherit
 *
 * Parameters:
 * C - {Object} the class that inherits
 * P - {Object} the superclass to inherit from
 *
 * In addition to the mandatory C and P parameters, an arbitrary number of
 * objects can be passed, which will extend C.
 */
HGIS.inherit = function(C, P) {
	var F = function() {
	};
	//edit 坑爹的容错
	if(P==undefined){
		return;
	}
	F.prototype = P.prototype;
	C.prototype = new F;
	var i, l, o;
	for (i = 2, l = arguments.length; i < l; i++) {
		o = arguments[i];
		if (typeof o === "function") {
			o = o.prototype;
		}
		HGIS.Util.extend(C.prototype, o);
	}
};

/**
 * APIFunction: extend
 * Copy all properties of a source object to a destination object.  Modifies
 *     the passed in destination object.  Any properties on the source object
 *     that are set to undefined will not be (re)set on the destination object.
 *
 * Parameters:
 * destination - {Object} The object that will be modified
 * source - {Object} The object with properties to be set on the destination
 *
 * Returns:
 * {Object} The destination object.
 */
HGIS.Util = HGIS.Util || {};
HGIS.Util.extend = function(destination, source) {
	destination = destination || {};
	if (source) {
		for ( var property in source) {
			var value = source[property];
			if (value !== undefined) {
				destination[property] = value;
			}
		}

		/**
		 * IE doesn't include the toString property when iterating over an object's
		 * properties with the for(property in object) syntax.  Explicitly check if
		 * the source has its own toString property.
		 */

		/*
		 * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
		 * prototype object" when calling hawOwnProperty if the source object
		 * is an instance of window.Event.
		 */

		var sourceIsEvt = typeof window.Event == "function"
				&& source instanceof window.Event;

		if (!sourceIsEvt && source.hasOwnProperty
				&& source.hasOwnProperty("toString")) {
			destination.toString = source.toString;
		}
	}
	return destination;
};
/* ======================================================================
    HGIS/BaseTypes.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/SingleFile.js
 */

/** 
 * Header: HGIS Base Types
 * HGIS custom string, number and function functions are described here.
 */

/**
 * Namespace: HGIS.String
 * Contains convenience functions for string manipulation.
 */
HGIS.String = {

	/**
	 * APIFunction: startsWith
	 * Test whether a string starts with another string. 
	 * 
	 * Parameters:
	 * str - {String} The string to test.
	 * sub - {String} The substring to look for.
	 *  
	 * Returns:
	 * {Boolean} The first string starts with the second.
	 */
	startsWith : function(str, sub) {
		return (str.indexOf(sub) == 0);
	},

	/**
	 * APIFunction: contains
	 * Test whether a string contains another string.
	 * 
	 * Parameters:
	 * str - {String} The string to test.
	 * sub - {String} The substring to look for.
	 * 
	 * Returns:
	 * {Boolean} The first string contains the second.
	 */
	contains : function(str, sub) {
		return (str.indexOf(sub) != -1);
	},

	/**
	 * APIFunction: trim
	 * Removes leading and trailing whitespace characters from a string.
	 * 
	 * Parameters:
	 * str - {String} The (potentially) space padded string.  This string is not
	 *     modified.
	 * 
	 * Returns:
	 * {String} A trimmed version of the string with all leading and 
	 *     trailing spaces removed.
	 */
	trim : function(str) {
		return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	},

	/**
	 * APIFunction: camelize
	 * Camel-case a hyphenated string. 
	 *     Ex. "chicken-head" becomes "chickenHead", and
	 *     "-chicken-head" becomes "ChickenHead".
	 *
	 * Parameters:
	 * str - {String} The string to be camelized.  The original is not modified.
	 * 
	 * Returns:
	 * {String} The string, camelized
	 */
	camelize : function(str) {
		var oStringList = str.split('-');
		var camelizedString = oStringList[0];
		for ( var i = 1, len = oStringList.length; i < len; i++) {
			var s = oStringList[i];
			camelizedString += s.charAt(0).toUpperCase() + s.substring(1);
		}
		return camelizedString;
	},

	/**
	 * APIFunction: format
	 * Given a string with tokens in the form ${token}, return a string
	 *     with tokens replaced with properties from the given context
	 *     object.  Represent a literal "${" by doubling it, e.g. "${${".
	 *
	 * Parameters:
	 * template - {String} A string with tokens to be replaced.  A template
	 *     has the form "literal ${token}" where the token will be replaced
	 *     by the value of context["token"].
	 * context - {Object} An optional object with properties corresponding
	 *     to the tokens in the format string.  If no context is sent, the
	 *     window object will be used.
	 * args - {Array} Optional arguments to pass to any functions found in
	 *     the context.  If a context property is a function, the token
	 *     will be replaced by the return from the function called with
	 *     these arguments.
	 *
	 * Returns:
	 * {String} A string with tokens replaced from the context object.
	 */
	format : function(template, context, args) {
		if (!context) {
			context = window;
		}

		// Example matching: 
		// str   = ${foo.bar}
		// match = foo.bar
		var replacer = function(str, match) {
			var replacement;

			// Loop through all subs. Example: ${a.b.c}
			// 0 -> replacement = context[a];
			// 1 -> replacement = context[a][b];
			// 2 -> replacement = context[a][b][c];
			var subs = match.split(/\.+/);
			for ( var i = 0; i < subs.length; i++) {
				if (i == 0) {
					replacement = context;
				}
				if (replacement === undefined) {
					break;
				}
				replacement = replacement[subs[i]];
			}

			if (typeof replacement == "function") {
				replacement = args ? replacement.apply(null, args)
						: replacement();
			}

			// If replacement is undefined, return the string 'undefined'.
			// This is a workaround for a bugs in browsers not properly 
			// dealing with non-participating groups in regular expressions:
			// http://blog.stevenlevithan.com/archives/npcg-javascript
			if (typeof replacement == 'undefined') {
				return 'undefined';
			} else {
				return replacement;
			}
		};

		return template.replace(HGIS.String.tokenRegEx, replacer);
	},

	/**
	 * Property: tokenRegEx
	 * Used to find tokens in a string.
	 * Examples: ${a}, ${a.b.c}, ${a-b}, ${5}
	 */
	tokenRegEx : /\$\{([\w.]+?)\}/g,

	/**
	 * Property: numberRegEx
	 * Used to test strings as numbers.
	 */
	numberRegEx : /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/,

	/**
	 * APIFunction: isNumeric
	 * Determine whether a string contains only a numeric value.
	 *
	 * Examples:
	 * (code)
	 * HGIS.String.isNumeric("6.02e23") // true
	 * HGIS.String.isNumeric("12 dozen") // false
	 * HGIS.String.isNumeric("4") // true
	 * HGIS.String.isNumeric(" 4 ") // false
	 * (end)
	 *
	 * Returns:
	 * {Boolean} String contains only a number.
	 */
	isNumeric : function(value) {
		return HGIS.String.numberRegEx.test(value);
	},

	/**
	 * APIFunction: numericIf
	 * Converts a string that appears to be a numeric value into a number.
	 * 
	 * Parameters:
	 * value - {String}
	 * trimWhitespace - {Boolean}
	 *
	 * Returns:
	 * {Number|String} a Number if the passed value is a number, a String
	 *     otherwise. 
	 */
	numericIf : function(value, trimWhitespace) {
		var originalValue = value;
		if (trimWhitespace === true && value != null && value.replace) {
			value = value.replace(/^\s*|\s*$/g, "");
		}
		return HGIS.String.isNumeric(value) ? parseFloat(value)
				: originalValue;
	}

};

/**
 * Namespace: HGIS.Number
 * Contains convenience functions for manipulating numbers.
 */
HGIS.Number = {

	/**
	 * Property: decimalSeparator
	 * Decimal separator to use when formatting numbers.
	 */
	decimalSeparator : ".",

	/**
	 * Property: thousandsSeparator
	 * Thousands separator to use when formatting numbers.
	 */
	thousandsSeparator : ",",

	/**
	 * APIFunction: limitSigDigs
	 * Limit the number of significant digits on a float.
	 * 
	 * Parameters:
	 * num - {Float}
	 * sig - {Integer}
	 * 
	 * Returns:
	 * {Float} The number, rounded to the specified number of significant
	 *     digits.
	 */
	limitSigDigs : function(num, sig) {
		var fig = 0;
		if (sig > 0) {
			fig = parseFloat(num.toPrecision(sig));
		}
		return fig;
	},

	/**
	 * APIFunction: format
	 * Formats a number for output.
	 * 
	 * Parameters:
	 * num  - {Float}
	 * dec  - {Integer} Number of decimal places to round to.
	 *        Defaults to 0. Set to null to leave decimal places unchanged.
	 * tsep - {String} Thousands separator.
	 *        Default is ",".
	 * dsep - {String} Decimal separator.
	 *        Default is ".".
	 *
	 * Returns:
	 * {String} A string representing the formatted number.
	 */
	format : function(num, dec, tsep, dsep) {
		dec = (typeof dec != "undefined") ? dec : 0;
		tsep = (typeof tsep != "undefined") ? tsep
				: HGIS.Number.thousandsSeparator;
		dsep = (typeof dsep != "undefined") ? dsep
				: HGIS.Number.decimalSeparator;

		if (dec != null) {
			num = parseFloat(num.toFixed(dec));
		}

		var parts = num.toString().split(".");
		if (parts.length == 1 && dec == null) {
			// integer where we do not want to touch the decimals
			dec = 0;
		}

		var integer = parts[0];
		if (tsep) {
			var thousands = /(-?[0-9]+)([0-9]{3})/;
			while (thousands.test(integer)) {
				integer = integer.replace(thousands, "$1" + tsep + "$2");
			}
		}

		var str;
		if (dec == 0) {
			str = integer;
		} else {
			var rem = parts.length > 1 ? parts[1] : "0";
			if (dec != null) {
				rem = rem + new Array(dec - rem.length + 1).join("0");
			}
			str = integer + dsep + rem;
		}
		return str;
	},

	/**
	 * Method: zeroPad
	 * Create a zero padded string optionally with a radix for casting numbers.
	 *
	 * Parameters:
	 * num - {Number} The number to be zero padded.
	 * len - {Number} The length of the string to be returned.
	 * radix - {Number} An integer between 2 and 36 specifying the base to use
	 *     for representing numeric values.
	 */
	zeroPad : function(num, len, radix) {
		var str = num.toString(radix || 10);
		while (str.length < len) {
			str = "0" + str;
		}
		return str;
	}
};

/**
 * Namespace: HGIS.Function
 * Contains convenience functions for function manipulation.
 */
HGIS.Function = {
	/**
	 * APIFunction: bind
	 * Bind a function to an object.  Method to easily create closures with
	 *     'this' altered.
	 * 
	 * Parameters:
	 * func - {Function} Input function.
	 * object - {Object} The object to bind to the input function (as this).
	 * 
	 * Returns:
	 * {Function} A closure with 'this' set to the passed in object.
	 */
	bind : function(func, object) {
		// create a reference to all arguments past the second one
	var args = Array.prototype.slice.apply(arguments, [ 2 ]);
	return function() {
		// Push on any additional arguments from the actual function call.
		// These will come after those sent to the bind call.
		var newArgs = args
				.concat(Array.prototype.slice.apply(arguments, [ 0 ]));
		return func.apply(object, newArgs);
	};
},

/**
 * APIFunction: bindAsEventListener
 * Bind a function to an object, and configure it to receive the event
 *     object as first parameter when called. 
 * 
 * Parameters:
 * func - {Function} Input function to serve as an event listener.
 * object - {Object} A reference to this.
 * 
 * Returns:
 * {Function}
 */
bindAsEventListener : function(func, object) {
	return function(event) {
		return func.call(object, event || window.event);
	};
},

/**
 * APIFunction: False
 * A simple function to that just does "return false". We use this to 
 * avoid attaching anonymous functions to DOM event handlers, which 
 * causes "issues" on IE<8.
 * 
 * Usage:
 * document.onclick = HGIS.Function.False;
 * 
 * Returns:
 * {Boolean}
 */
False : function() {
	return false;
},

/**
 * APIFunction: True
 * A simple function to that just does "return true". We use this to 
 * avoid attaching anonymous functions to DOM event handlers, which 
 * causes "issues" on IE<8.
 * 
 * Usage:
 * document.onclick = HGIS.Function.True;
 * 
 * Returns:
 * {Boolean}
 */
True : function() {
	return true;
},

/**
 * APIFunction: Void
 * A reusable function that returns ``undefined``.
 *
 * Returns:
 * {undefined}
 */
Void : function() {
}

};

/**
 * Namespace: HGIS.Array
 * Contains convenience functions for array manipulation.
 */
HGIS.Array = {

	/**
	 * APIMethod: filter
	 * Filter an array.  Provides the functionality of the
	 *     Array.prototype.filter extension to the ECMA-262 standard.  Where
	 *     available, Array.prototype.filter will be used.
	 *
	 * Based on well known example from http://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter
	 *
	 * Parameters:
	 * array - {Array} The array to be filtered.  This array is not mutated.
	 *     Elements added to this array by the callback will not be visited.
	 * callback - {Function} A function that is called for each element in
	 *     the array.  If this function returns true, the element will be
	 *     included in the return.  The function will be called with three
	 *     arguments: the element in the array, the index of that element, and
	 *     the array itself.  If the optional caller parameter is specified
	 *     the callback will be called with this set to caller.
	 * caller - {Object} Optional object to be set as this when the callback
	 *     is called.
	 *
	 * Returns:
	 * {Array} An array of elements from the passed in array for which the
	 *     callback returns true.
	 */
	filter : function(array, callback, caller) {
		var selected = [];
		if (Array.prototype.filter) {
			selected = array.filter(callback, caller);
		} else {
			var len = array.length;
			if (typeof callback != "function") {
				throw new TypeError();
			}
			for ( var i = 0; i < len; i++) {
				if (i in array) {
					var val = array[i];
					if (callback.call(caller, val, i, array)) {
						selected.push(val);
					}
				}
			}
		}
		return selected;
	}

};
/* ======================================================================
    HGIS/BaseTypes/Bounds.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 */

/**
 * Class: HGIS.Bounds
 * Instances of this class represent bounding boxes.  Data stored as left,
 * bottom, right, top floats. All values are initialized to null, however,
 * you should make sure you set them before using the bounds for anything.
 * 
 * Possible use case:
 * (code)
 *     bounds = new HGIS.Bounds();
 *     bounds.extend(new HGIS.LonLat(4,5));
 *     bounds.extend(new HGIS.LonLat(5,6));
 *     bounds.toBBOX(); // returns 4,5,5,6
 * (end)
 */
HGIS.Bounds = HGIS
		.Class( {

			/**
			 * Property: left
			 * {Number} Minimum horizontal coordinate.
			 */
			left : null,

			/**
			 * Property: bottom
			 * {Number} Minimum vertical coordinate.
			 */
			bottom : null,

			/**
			 * Property: right
			 * {Number} Maximum horizontal coordinate.
			 */
			right : null,

			/**
			 * Property: top
			 * {Number} Maximum vertical coordinate.
			 */
			top : null,

			/**
			 * Property: centerLonLat
			 * {<HGIS.LonLat>} A cached center location.  This should not be
			 *     accessed directly.  Use <getCenterLonLat> instead.
			 */
			centerLonLat : null,

			/**
			 * Constructor: HGIS.Bounds
			 * Construct a new bounds object. Coordinates can either be passed as four
			 * arguments, or as a single argument.
			 *
			 * Parameters (four arguments):
			 * left - {Number} The left bounds of the box.  Note that for width
			 *        calculations, this is assumed to be less than the right value.
			 * bottom - {Number} The bottom bounds of the box.  Note that for height
			 *          calculations, this is assumed to be less than the top value.
			 * right - {Number} The right bounds.
			 * top - {Number} The top bounds.
			 *
			 * Parameters (single argument):
			 * bounds - {Array(Number)} [left, bottom, right, top]
			 */
			initialize : function(left, bottom, right, top) {
				if (HGIS.Util.isArray(left)) {
					top = left[3];
					right = left[2];
					bottom = left[1];
					left = left[0];
				}
				if (left != null) {
					this.left = HGIS.Util.toFloat(left);
				}
				if (bottom != null) {
					this.bottom = HGIS.Util.toFloat(bottom);
				}
				if (right != null) {
					this.right = HGIS.Util.toFloat(right);
				}
				if (top != null) {
					this.top = HGIS.Util.toFloat(top);
				}
			},

			/**
			 * Method: clone
			 * Create a cloned instance of this bounds.
			 *
			 * Returns:
			 * {<HGIS.Bounds>} A fresh copy of the bounds
			 */
			clone : function() {
				return new HGIS.Bounds(this.left, this.bottom,
						this.right, this.top);
			},

			/**
			 * Method: equals
			 * Test a two bounds for equivalence.
			 *
			 * Parameters:
			 * bounds - {<HGIS.Bounds>}
			 *
			 * Returns:
			 * {Boolean} The passed-in bounds object has the same left,
			 *           right, top, bottom components as this.  Note that if bounds 
			 *           passed in is null, returns false.
			 */
			equals : function(bounds) {
				var equals = false;
				if (bounds != null) {
					equals = ((this.left == bounds.left)
							&& (this.right == bounds.right)
							&& (this.top == bounds.top) && (this.bottom == bounds.bottom));
				}
				return equals;
			},

			/** 
			 * APIMethod: toString
			 * Returns a string representation of the bounds object.
			 * 
			 * Returns:
			 * {String} String representation of bounds object. 
			 */
			toString : function() {
				return [ this.left, this.bottom, this.right, this.top ]
						.join(",");
			},

			/**
			 * APIMethod: toArray
			 * Returns an array representation of the bounds object.
			 *
			 * Returns an array of left, bottom, right, top properties, or -- when the
			 *     optional parameter is true -- an array of the  bottom, left, top,
			 *     right properties.
			 *
			 * Parameters:
			 * reverseAxisOrder - {Boolean} Should we reverse the axis order?
			 *
			 * Returns:
			 * {Array} array of left, bottom, right, top
			 */
			toArray : function(reverseAxisOrder) {
				if (reverseAxisOrder === true) {
					return [ this.bottom, this.left, this.top, this.right ];
				} else {
					return [ this.left, this.bottom, this.right, this.top ];
				}
			},

			/** 
			 * APIMethod: toBBOX
			 * Returns a boundingbox-string representation of the bounds object.
			 * 
			 * Parameters:
			 * decimal - {Integer} How many significant digits in the bbox coords?
			 *                     Default is 6
			 * reverseAxisOrder - {Boolean} Should we reverse the axis order?
			 * 
			 * Returns:
			 * {String} Simple String representation of bounds object.
			 *          (e.g. "5,42,10,45")
			 */
			toBBOX : function(decimal, reverseAxisOrder) {
				if (decimal == null) {
					decimal = 6;
				}
				var mult = Math.pow(10, decimal);
				var xmin = Math.round(this.left * mult) / mult;
				var ymin = Math.round(this.bottom * mult) / mult;
				var xmax = Math.round(this.right * mult) / mult;
				var ymax = Math.round(this.top * mult) / mult;
				if (reverseAxisOrder === true) {
					return ymin + "," + xmin + "," + ymax + "," + xmax;
				} else {
					return xmin + "," + ymin + "," + xmax + "," + ymax;
				}
			},

			/**
			 * APIMethod: toGeometry
			 * Create a new polygon geometry based on this bounds.
			 *
			 * Returns:
			 * {<HGIS.Geometry.Polygon>} A new polygon with the coordinates
			 *     of this bounds.
			 */
			toGeometry : function() {
				return new HGIS.Geometry.Polygon(
						[ new HGIS.Geometry.LinearRing( [
								new HGIS.Geometry.Point(this.left,
										this.bottom),
								new HGIS.Geometry.Point(this.right,
										this.bottom),
								new HGIS.Geometry.Point(this.right,
										this.top),
								new HGIS.Geometry.Point(this.left,
										this.top) ]) ]);
			},

			/**
			 * APIMethod: getWidth
			 * Returns the width of the bounds.
			 * 
			 * Returns:
			 * {Float} The width of the bounds (right minus left).
			 */
			getWidth : function() {
				return (this.right - this.left);
			},

			/**
			 * APIMethod: getHeight
			 * Returns the height of the bounds.
			 * 
			 * Returns:
			 * {Float} The height of the bounds (top minus bottom).
			 */
			getHeight : function() {
				return (this.top - this.bottom);
			},

			/**
			 * APIMethod: getSize
			 * Returns an <HGIS.Size> object of the bounds.
			 * 
			 * Returns:
			 * {<HGIS.Size>} The size of the bounds.
			 */
			getSize : function() {
				return new HGIS.Size(this.getWidth(), this.getHeight());
			},

			/**
			 * APIMethod: getCenterPixel
			 * Returns the <HGIS.Pixel> object which represents the center of the
			 *     bounds.
			 * 
			 * Returns:
			 * {<HGIS.Pixel>} The center of the bounds in pixel space.
			 */
			getCenterPixel : function() {
				return new HGIS.Pixel((this.left + this.right) / 2,
						(this.bottom + this.top) / 2);
			},

			/**
			 * APIMethod: getCenterLonLat
			 * Returns the <HGIS.LonLat> object which represents the center of the
			 *     bounds.
			 *
			 * Returns:
			 * {<HGIS.LonLat>} The center of the bounds in map space.
			 */
			getCenterLonLat : function() {
				if (!this.centerLonLat) {
					this.centerLonLat = new HGIS.LonLat(
							(this.left + this.right) / 2,
							(this.bottom + this.top) / 2);
				}
				return this.centerLonLat;
			},

			/**
			 * APIMethod: scale
			 * Scales the bounds around a pixel or lonlat. Note that the new 
			 *     bounds may return non-integer properties, even if a pixel
			 *     is passed. 
			 * 
			 * Parameters:
			 * ratio - {Float} 
			 * origin - {<HGIS.Pixel> or <HGIS.LonLat>}
			 *          Default is center.
			 *
			 * Returns:
			 * {<HGIS.Bounds>} A new bounds that is scaled by ratio
			 *                      from origin.
			 */
			scale : function(ratio, origin) {
				if (origin == null) {
					origin = this.getCenterLonLat();
				}

				var origx, origy;

				// get origin coordinates
				if (origin.CLASS_NAME == "HGIS.LonLat") {
					origx = origin.lon;
					origy = origin.lat;
				} else {
					origx = origin.x;
					origy = origin.y;
				}

				var left = (this.left - origx) * ratio + origx;
				var bottom = (this.bottom - origy) * ratio + origy;
				var right = (this.right - origx) * ratio + origx;
				var top = (this.top - origy) * ratio + origy;

				return new HGIS.Bounds(left, bottom, right, top);
			},

			/**
			 * APIMethod: add
			 * Shifts the coordinates of the bound by the given horizontal and vertical
			 *     deltas.
			 *
			 * (start code)
			 * var bounds = new HGIS.Bounds(0, 0, 10, 10);
			 * bounds.toString();
			 * // => "0,0,10,10"
			 *
			 * bounds.add(-1.5, 4).toString();
			 * // => "-1.5,4,8.5,14"
			 * (end)
			 *
			 * This method will throw a TypeError if it is passed null as an argument.
			 *
			 * Parameters:
			 * x - {Float} horizontal delta
			 * y - {Float} vertical delta
			 *
			 * Returns:
			 * {<HGIS.Bounds>} A new bounds whose coordinates are the same as
			 *     this, but shifted by the passed-in x and y values.
			 */
			add : function(x, y) {
				if ((x == null) || (y == null)) {
					throw new TypeError('Bounds.add cannot receive null values');
				}
				return new HGIS.Bounds(this.left + x, this.bottom + y,
						this.right + x, this.top + y);
			},

			/**
			 * APIMethod: extend
			 * Extend the bounds to include the <HGIS.LonLat>,
			 *     <HGIS.Geometry.Point> or <HGIS.Bounds> specified.
			 *
			 * Please note that this function assumes that left < right and
			 *     bottom < top.
			 *
			 * Parameters:
			 * object - {<HGIS.LonLat>, <HGIS.Geometry.Point> or
			 *     <HGIS.Bounds>} The object to be included in the new bounds
			 *     object.
			 */
			extend : function(object) {
				if (object) {
					switch (object.CLASS_NAME) {
					case "HGIS.LonLat":
						this.extendXY(object.lon, object.lat);
						break;
					case "HGIS.Geometry.Point":
						this.extendXY(object.x, object.y);
						break;

					case "HGIS.Bounds":
						// clear cached center location
						this.centerLonLat = null;

						if ((this.left == null) || (object.left < this.left)) {
							this.left = object.left;
						}
						if ((this.bottom == null)
								|| (object.bottom < this.bottom)) {
							this.bottom = object.bottom;
						}
						if ((this.right == null) || (object.right > this.right)) {
							this.right = object.right;
						}
						if ((this.top == null) || (object.top > this.top)) {
							this.top = object.top;
						}
						break;
					}
				}
			},

			/**
			 * APIMethod: extendXY
			 * Extend the bounds to include the XY coordinate specified.
			 *
			 * Parameters:
			 * x - {number} The X part of the the coordinate.
			 * y - {number} The Y part of the the coordinate.
			 */
			extendXY : function(x, y) {
				// clear cached center location
				this.centerLonLat = null;

				if ((this.left == null) || (x < this.left)) {
					this.left = x;
				}
				if ((this.bottom == null) || (y < this.bottom)) {
					this.bottom = y;
				}
				if ((this.right == null) || (x > this.right)) {
					this.right = x;
				}
				if ((this.top == null) || (y > this.top)) {
					this.top = y;
				}
			},

			/**
			 * APIMethod: containsLonLat
			 * Returns whether the bounds object contains the given <HGIS.LonLat>.
			 * 
			 * Parameters:
			 * ll - {<HGIS.LonLat>|Object} HGIS.LonLat or an
			 *     object with a 'lon' and 'lat' properties.
			 * options - {Object} Optional parameters
			 *
			 * Acceptable options:
			 * inclusive - {Boolean} Whether or not to include the border.
			 *     Default is true.
			 * worldBounds - {<HGIS.Bounds>} If a worldBounds is provided, the
			 *     ll will be considered as contained if it exceeds the world bounds,
			 *     but can be wrapped around the dateline so it is contained by this
			 *     bounds.
			 *
			 * Returns:
			 * {Boolean} The passed-in lonlat is within this bounds.
			 */
			containsLonLat : function(ll, options) {
				if (typeof options === "boolean") {
					options = {
						inclusive : options
					};
				}
				options = options || {};
				var contains = this.contains(ll.lon, ll.lat, options.inclusive), worldBounds = options.worldBounds;
				if (worldBounds && !contains) {
					var worldWidth = worldBounds.getWidth();
					var worldCenterX = (worldBounds.left + worldBounds.right) / 2;
					var worldsAway = Math.round((ll.lon - worldCenterX)
							/ worldWidth);
					contains = this.containsLonLat( {
						lon : ll.lon - worldsAway * worldWidth,
						lat : ll.lat
					}, {
						inclusive : options.inclusive
					});
				}
				return contains;
			},

			/**
			 * APIMethod: containsPixel
			 * Returns whether the bounds object contains the given <HGIS.Pixel>.
			 * 
			 * Parameters:
			 * px - {<HGIS.Pixel>}
			 * inclusive - {Boolean} Whether or not to include the border. Default is
			 *     true.
			 *
			 * Returns:
			 * {Boolean} The passed-in pixel is within this bounds.
			 */
			containsPixel : function(px, inclusive) {
				return this.contains(px.x, px.y, inclusive);
			},

			/**
			 * APIMethod: contains
			 * Returns whether the bounds object contains the given x and y.
			 * 
			 * Parameters:
			 * x - {Float}
			 * y - {Float}
			 * inclusive - {Boolean} Whether or not to include the border. Default is
			 *     true.
			 *
			 * Returns:
			 * {Boolean} Whether or not the passed-in coordinates are within this
			 *     bounds.
			 */
			contains : function(x, y, inclusive) {
				//set default
				if (inclusive == null) {
					inclusive = true;
				}

				if (x == null || y == null) {
					return false;
				}

				x = HGIS.Util.toFloat(x);
				y = HGIS.Util.toFloat(y);

				var contains = false;
				if (inclusive) {
					contains = ((x >= this.left) && (x <= this.right)
							&& (y >= this.bottom) && (y <= this.top));
				} else {
					contains = ((x > this.left) && (x < this.right)
							&& (y > this.bottom) && (y < this.top));
				}
				return contains;
			},

			/**
			 * APIMethod: intersectsBounds
			 * Determine whether the target bounds intersects this bounds.  Bounds are
			 *     considered intersecting if any of their edges intersect or if one
			 *     bounds contains the other.
			 * 
			 * Parameters:
			 * bounds - {<HGIS.Bounds>} The target bounds.
			 * options - {Object} Optional parameters.
			 * 
			 * Acceptable options:
			 * inclusive - {Boolean} Treat coincident borders as intersecting.  Default
			 *     is true.  If false, bounds that do not overlap but only touch at the
			 *     border will not be considered as intersecting.
			 * worldBounds - {<HGIS.Bounds>} If a worldBounds is provided, two
			 *     bounds will be considered as intersecting if they intersect when 
			 *     shifted to within the world bounds.  This applies only to bounds that
			 *     cross or are completely outside the world bounds.
			 *
			 * Returns:
			 * {Boolean} The passed-in bounds object intersects this bounds.
			 */
			intersectsBounds : function(bounds, options) {
				if (typeof options === "boolean") {
					options = {
						inclusive : options
					};
				}
				options = options || {};
				if (options.worldBounds) {
					var self = this.wrapDateLine(options.worldBounds);
					bounds = bounds.wrapDateLine(options.worldBounds);
				} else {
					self = this;
				}
				if (options.inclusive == null) {
					options.inclusive = true;
				}
				var intersects = false;
				var mightTouch = (self.left == bounds.right
						|| self.right == bounds.left
						|| self.top == bounds.bottom || self.bottom == bounds.top);

				// if the two bounds only touch at an edge, and inclusive is false,
				// then the bounds don't *really* intersect.
				if (options.inclusive || !mightTouch) {
					// otherwise, if one of the boundaries even partially contains another,
					// inclusive of the edges, then they do intersect.
					var inBottom = (((bounds.bottom >= self.bottom) && (bounds.bottom <= self.top)) || ((self.bottom >= bounds.bottom) && (self.bottom <= bounds.top)));
					var inTop = (((bounds.top >= self.bottom) && (bounds.top <= self.top)) || ((self.top > bounds.bottom) && (self.top < bounds.top)));
					var inLeft = (((bounds.left >= self.left) && (bounds.left <= self.right)) || ((self.left >= bounds.left) && (self.left <= bounds.right)));
					var inRight = (((bounds.right >= self.left) && (bounds.right <= self.right)) || ((self.right >= bounds.left) && (self.right <= bounds.right)));
					intersects = ((inBottom || inTop) && (inLeft || inRight));
				}
				// document me
				if (options.worldBounds && !intersects) {
					var world = options.worldBounds;
					var width = world.getWidth();
					var selfCrosses = !world.containsBounds(self);
					var boundsCrosses = !world.containsBounds(bounds);
					if (selfCrosses && !boundsCrosses) {
						bounds = bounds.add(-width, 0);
						intersects = self.intersectsBounds(bounds, {
							inclusive : options.inclusive
						});
					} else if (boundsCrosses && !selfCrosses) {
						self = self.add(-width, 0);
						intersects = bounds.intersectsBounds(self, {
							inclusive : options.inclusive
						});
					}
				}
				return intersects;
			},

			/**
			 * APIMethod: containsBounds
			 * Returns whether the bounds object contains the given <HGIS.Bounds>.
			 * 
			 * bounds - {<HGIS.Bounds>} The target bounds.
			 * partial - {Boolean} If any of the target corners is within this bounds
			 *     consider the bounds contained.  Default is false.  If false, the
			 *     entire target bounds must be contained within this bounds.
			 * inclusive - {Boolean} Treat shared edges as contained.  Default is
			 *     true.
			 *
			 * Returns:
			 * {Boolean} The passed-in bounds object is contained within this bounds. 
			 */
			containsBounds : function(bounds, partial, inclusive) {
				if (partial == null) {
					partial = false;
				}
				if (inclusive == null) {
					inclusive = true;
				}
				var bottomLeft = this.contains(bounds.left, bounds.bottom,
						inclusive);
				var bottomRight = this.contains(bounds.right, bounds.bottom,
						inclusive);
				var topLeft = this.contains(bounds.left, bounds.top, inclusive);
				var topRight = this.contains(bounds.right, bounds.top,
						inclusive);

				return (partial) ? (bottomLeft || bottomRight || topLeft || topRight)
						: (bottomLeft && bottomRight && topLeft && topRight);
			},

			/** 
			 * APIMethod: determineQuadrant
			 * Returns the the quadrant ("br", "tr", "tl", "bl") in which the given
			 *     <HGIS.LonLat> lies.
			 *
			 * Parameters:
			 * lonlat - {<HGIS.LonLat>}
			 *
			 * Returns:
			 * {String} The quadrant ("br" "tr" "tl" "bl") of the bounds in which the
			 *     coordinate lies.
			 */
			determineQuadrant : function(lonlat) {

				var quadrant = "";
				var center = this.getCenterLonLat();

				quadrant += (lonlat.lat < center.lat) ? "b" : "t";
				quadrant += (lonlat.lon < center.lon) ? "l" : "r";

				return quadrant;
			},

			/**
			 * APIMethod: transform
			 * Transform the Bounds object from source to dest. 
			 *
			 * Parameters: 
			 * source - {<HGIS.Projection>} Source projection. 
			 * dest   - {<HGIS.Projection>} Destination projection. 
			 *
			 * Returns:
			 * {<HGIS.Bounds>} Itself, for use in chaining operations.
			 */
			transform : function(source, dest) {
				// clear cached center location
				this.centerLonLat = null;
				var ll = HGIS.Projection.transform( {
					'x' : this.left,
					'y' : this.bottom
				}, source, dest);
				var lr = HGIS.Projection.transform( {
					'x' : this.right,
					'y' : this.bottom
				}, source, dest);
				var ul = HGIS.Projection.transform( {
					'x' : this.left,
					'y' : this.top
				}, source, dest);
				var ur = HGIS.Projection.transform( {
					'x' : this.right,
					'y' : this.top
				}, source, dest);
				this.left = Math.min(ll.x, ul.x);
				this.bottom = Math.min(ll.y, lr.y);
				this.right = Math.max(lr.x, ur.x);
				this.top = Math.max(ul.y, ur.y);
				return this;
			},

			/**
			 * APIMethod: wrapDateLine
			 * Wraps the bounds object around the dateline.
			 *  
			 * Parameters:
			 * maxExtent - {<HGIS.Bounds>}
			 * options - {Object} Some possible options are:
			 *
			 * Allowed Options:
			 *                    leftTolerance - {float} Allow for a margin of error 
			 *                                            with the 'left' value of this 
			 *                                            bound.
			 *                                            Default is 0.
			 *                    rightTolerance - {float} Allow for a margin of error 
			 *                                             with the 'right' value of 
			 *                                             this bound.
			 *                                             Default is 0.
			 * 
			 * Returns:
			 * {<HGIS.Bounds>} A copy of this bounds, but wrapped around the 
			 *                       "dateline" (as specified by the borders of 
			 *                       maxExtent). Note that this function only returns 
			 *                       a different bounds value if this bounds is 
			 *                       *entirely* outside of the maxExtent. If this 
			 *                       bounds straddles the dateline (is part in/part 
			 *                       out of maxExtent), the returned bounds will always 
			 *                       cross the left edge of the given maxExtent.
			 *.
			 */
			wrapDateLine : function(maxExtent, options) {
				options = options || {};

				var leftTolerance = options.leftTolerance || 0;
				var rightTolerance = options.rightTolerance || 0;

				var newBounds = this.clone();

				if (maxExtent) {
					var width = maxExtent.getWidth();

					//shift right?
					while (newBounds.left < maxExtent.left
							&& newBounds.right - rightTolerance <= maxExtent.left) {
						newBounds = newBounds.add(width, 0);
					}

					//shift left?
					while (newBounds.left + leftTolerance >= maxExtent.right
							&& newBounds.right > maxExtent.right) {
						newBounds = newBounds.add(-width, 0);
					}

					// crosses right only? force left
					var newLeft = newBounds.left + leftTolerance;
					if (newLeft < maxExtent.right
							&& newLeft > maxExtent.left
							&& newBounds.right - rightTolerance > maxExtent.right) {
						newBounds = newBounds.add(-width, 0);
					}
				}

				return newBounds;
			},

			CLASS_NAME : "HGIS.Bounds"
		});

/** 
 * APIFunction: fromString
 * Alternative constructor that builds a new HGIS.Bounds from a 
 *     parameter string.
 *
 * (begin code)
 * HGIS.Bounds.fromString("5,42,10,45");
 * // => equivalent to ...
 * new HGIS.Bounds(5, 42, 10, 45);
 * (end)
 *
 * Parameters: 
 * str - {String} Comma-separated bounds string. (e.g. "5,42,10,45")
 * reverseAxisOrder - {Boolean} Does the string use reverse axis order?
 *
 * Returns:
 * {<HGIS.Bounds>} New bounds object built from the 
 *                       passed-in String.
 */
HGIS.Bounds.fromString = function(str, reverseAxisOrder) {
	var bounds = str.split(",");
	return HGIS.Bounds.fromArray(bounds, reverseAxisOrder);
};

/** 
 * APIFunction: fromArray
 * Alternative constructor that builds a new HGIS.Bounds from an array.
 *
 * (begin code)
 * HGIS.Bounds.fromArray( [5, 42, 10, 45] );
 * // => equivalent to ...
 * new HGIS.Bounds(5, 42, 10, 45);
 * (end)
 *
 * Parameters:
 * bbox - {Array(Float)} Array of bounds values (e.g. [5,42,10,45])
 * reverseAxisOrder - {Boolean} Does the array use reverse axis order?
 *
 * Returns:
 * {<HGIS.Bounds>} New bounds object built from the passed-in Array.
 */
HGIS.Bounds.fromArray = function(bbox, reverseAxisOrder) {
	return reverseAxisOrder === true ? new HGIS.Bounds(bbox[1], bbox[0],
			bbox[3], bbox[2]) : new HGIS.Bounds(bbox[0], bbox[1],
			bbox[2], bbox[3]);
};

/** 
 * APIFunction: fromSize
 * Alternative constructor that builds a new HGIS.Bounds from a size.
 *
 * (begin code)
 * HGIS.Bounds.fromSize( new HGIS.Size(10, 20) );
 * // => equivalent to ...
 * new HGIS.Bounds(0, 20, 10, 0);
 * (end)
 *
 * Parameters:
 * size - {<HGIS.Size> or Object} <HGIS.Size> or an object with
 *     both 'w' and 'h' properties.
 *
 * Returns:
 * {<HGIS.Bounds>} New bounds object built from the passed-in size.
 */
HGIS.Bounds.fromSize = function(size) {
	return new HGIS.Bounds(0, size.h, size.w, 0);
};

/**
 * Function: oppositeQuadrant
 * Get the opposite quadrant for a given quadrant string.
 *
 * (begin code)
 * HGIS.Bounds.oppositeQuadrant( "tl" );
 * // => "br"
 *
 * HGIS.Bounds.oppositeQuadrant( "tr" );
 * // => "bl"
 * (end)
 *
 * Parameters:
 * quadrant - {String} two character quadrant shortstring
 *
 * Returns:
 * {String} The opposing quadrant ("br" "tr" "tl" "bl"). For Example, if 
 *          you pass in "bl" it returns "tr", if you pass in "br" it 
 *          returns "tl", etc.
 */
HGIS.Bounds.oppositeQuadrant = function(quadrant) {
	var opp = "";

	opp += (quadrant.charAt(0) == 't') ? 'b' : 't';
	opp += (quadrant.charAt(1) == 'l') ? 'r' : 'l';

	return opp;
};
/* ======================================================================
    HGIS/BaseTypes/Element.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Util.js
 * @requires HGIS/BaseTypes.js
 */

/**
 * Namespace: HGIS.Element
 */
HGIS.Element = {

	/**
	 * APIFunction: visible
	 * 
	 * Parameters: 
	 * element - {DOMElement}
	 * 
	 * Returns:
	 * {Boolean} Is the element visible?
	 */
	visible : function(element) {
		return HGIS.Util.getElement(element).style.display != 'none';
	},

	/**
	 * APIFunction: toggle
	 * Toggle the visibility of element(s) passed in
	 * 
	 * Parameters:
	 * element - {DOMElement} Actually user can pass any number of elements
	 */
	toggle : function() {
		for ( var i = 0, len = arguments.length; i < len; i++) {
			var element = HGIS.Util.getElement(arguments[i]);
			var display = HGIS.Element.visible(element) ? 'none' : '';
			element.style.display = display;
		}
	},

	/**
	 * APIFunction: remove
	 * Remove the specified element from the DOM.
	 * 
	 * Parameters:
	 * element - {DOMElement}
	 */
	remove : function(element) {
		element = HGIS.Util.getElement(element);
		element.parentNode.removeChild(element);
	},

	/**
	 * APIFunction: getHeight
	 *  
	 * Parameters:
	 * element - {DOMElement}
	 * 
	 * Returns:
	 * {Integer} The offset height of the element passed in
	 */
	getHeight : function(element) {
		element = HGIS.Util.getElement(element);
		return element.offsetHeight;
	},

	/**
	 * Function: hasClass
	 * Tests if an element has the given CSS class name.
	 *
	 * Parameters:
	 * element - {DOMElement} A DOM element node.
	 * name - {String} The CSS class name to search for.
	 *
	 * Returns:
	 * {Boolean} The element has the given class name.
	 */
	hasClass : function(element, name) {
		var names = element.className;
		return (!!names && new RegExp("(^|\\s)" + name + "(\\s|$)").test(names));
	},

	/**
	 * Function: addClass
	 * Add a CSS class name to an element.  Safe where element already has
	 *     the class name.
	 *
	 * Parameters:
	 * element - {DOMElement} A DOM element node.
	 * name - {String} The CSS class name to add.
	 *
	 * Returns:
	 * {DOMElement} The element.
	 */
	addClass : function(element, name) {
		if (!HGIS.Element.hasClass(element, name)) {
			element.className += (element.className ? " " : "") + name;
		}
		return element;
	},

	/**
	 * Function: removeClass
	 * Remove a CSS class name from an element.  Safe where element does not
	 *     have the class name.
	 *
	 * Parameters:
	 * element - {DOMElement} A DOM element node.
	 * name - {String} The CSS class name to remove.
	 *
	 * Returns:
	 * {DOMElement} The element.
	 */
	removeClass : function(element, name) {
		var names = element.className;
		if (names) {
			element.className = HGIS.String.trim(names.replace(
					new RegExp("(^|\\s+)" + name + "(\\s+|$)"), " "));
		}
		return element;
	},

	/**
	 * Function: toggleClass
	 * Remove a CSS class name from an element if it exists.  Add the class name
	 *     if it doesn't exist.
	 *
	 * Parameters:
	 * element - {DOMElement} A DOM element node.
	 * name - {String} The CSS class name to toggle.
	 *
	 * Returns:
	 * {DOMElement} The element.
	 */
	toggleClass : function(element, name) {
		if (HGIS.Element.hasClass(element, name)) {
			HGIS.Element.removeClass(element, name);
		} else {
			HGIS.Element.addClass(element, name);
		}
		return element;
	},

	/**
	 * APIFunction: getStyle
	 * 
	 * Parameters:
	 * element - {DOMElement}
	 * style - {?}
	 * 
	 * Returns:
	 * {?}
	 */
	getStyle : function(element, style) {
		element = HGIS.Util.getElement(element);

		var value = null;
		if (element && element.style) {
			value = element.style[HGIS.String.camelize(style)];
			if (!value) {
				if (document.defaultView
						&& document.defaultView.getComputedStyle) {

					var css = document.defaultView.getComputedStyle(element,
							null);
					value = css ? css.getPropertyValue(style) : null;
				} else if (element.currentStyle) {
					value = element.currentStyle[HGIS.String
							.camelize(style)];
				}
			}

			var positions = [ 'left', 'top', 'right', 'bottom' ];
			if (window.opera
					&& (HGIS.Util.indexOf(positions, style) != -1)
					&& (HGIS.Element.getStyle(element, 'position') == 'static')) {
				value = 'auto';
			}
		}

		return value == 'auto' ? null : value;
	}

};
/* ======================================================================
    HGIS/BaseTypes/LonLat.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 */

/**
 * Class: HGIS.LonLat
 * This class represents a longitude and latitude pair
 */
HGIS.LonLat = HGIS
		.Class( {

			/** 
			 * APIProperty: lon
			 * {Float} The x-axis coodinate in map units
			 */
			lon : 0.0,

			/** 
			 * APIProperty: lat
			 * {Float} The y-axis coordinate in map units
			 */
			lat : 0.0,

			/**
			 * Constructor: HGIS.LonLat
			 * Create a new map location. Coordinates can be passed either as two
			 * arguments, or as a single argument.
			 *
			 * Parameters (two arguments):
			 * lon - {Number} The x-axis coordinate in map units.  If your map is in
			 *     a geographic projection, this will be the Longitude.  Otherwise,
			 *     it will be the x coordinate of the map location in your map units.
			 * lat - {Number} The y-axis coordinate in map units.  If your map is in
			 *     a geographic projection, this will be the Latitude.  Otherwise,
			 *     it will be the y coordinate of the map location in your map units.
			 *
			 * Parameters (single argument):
			 * location - {Array(Float)} [lon, lat]
			 */
			initialize : function(lon, lat) {
				if (HGIS.Util.isArray(lon)) {
					lat = lon[1];
					lon = lon[0];
				}
				this.lon = HGIS.Util.toFloat(lon);
				this.lat = HGIS.Util.toFloat(lat);
			},

			/**
			 * Method: toString
			 * Return a readable string version of the lonlat
			 *
			 * Returns:
			 * {String} String representation of HGIS.LonLat object. 
			 *           (e.g. <i>"lon=5,lat=42"</i>)
			 */
			toString : function() {
				return ("lon=" + this.lon + ",lat=" + this.lat);
			},

			/** 
			 * APIMethod: toShortString
			 * 
			 * Returns:
			 * {String} Shortened String representation of HGIS.LonLat object. 
			 *         (e.g. <i>"5, 42"</i>)
			 */
			toShortString : function() {
				return (this.lon + ", " + this.lat);
			},

			/** 
			 * APIMethod: clone
			 * 
			 * Returns:
			 * {<HGIS.LonLat>} New HGIS.LonLat object with the same lon 
			 *                       and lat values
			 */
			clone : function() {
				return new HGIS.LonLat(this.lon, this.lat);
			},

			/** 
			 * APIMethod: add
			 * 
			 * Parameters:
			 * lon - {Float}
			 * lat - {Float}
			 * 
			 * Returns:
			 * {<HGIS.LonLat>} A new HGIS.LonLat object with the lon and 
			 *                       lat passed-in added to this's. 
			 */
			add : function(lon, lat) {
				if ((lon == null) || (lat == null)) {
					throw new TypeError('LonLat.add cannot receive null values');
				}
				return new HGIS.LonLat(this.lon
						+ HGIS.Util.toFloat(lon), this.lat
						+ HGIS.Util.toFloat(lat));
			},

			/** 
			 * APIMethod: equals
			 * 
			 * Parameters:
			 * ll - {<HGIS.LonLat>}
			 * 
			 * Returns:
			 * {Boolean} Boolean value indicating whether the passed-in 
			 *           <HGIS.LonLat> object has the same lon and lat 
			 *           components as this.
			 *           Note: if ll passed in is null, returns false
			 */
			equals : function(ll) {
				var equals = false;
				if (ll != null) {
					equals = ((this.lon == ll.lon && this.lat == ll.lat) || (isNaN(this.lon)
							&& isNaN(this.lat) && isNaN(ll.lon) && isNaN(ll.lat)));
				}
				return equals;
			},

			/**
			 * APIMethod: transform
			 * Transform the LonLat object from source to dest. This transformation is
			 *    *in place*: if you want a *new* lonlat, use .clone() first.
			 *
			 * Parameters: 
			 * source - {<HGIS.Projection>} Source projection. 
			 * dest   - {<HGIS.Projection>} Destination projection. 
			 *
			 * Returns:
			 * {<HGIS.LonLat>} Itself, for use in chaining operations.
			 */
			transform : function(source, dest) {
				var point = HGIS.Projection.transform( {
					'x' : this.lon,
					'y' : this.lat
				}, source, dest);
				this.lon = point.x;
				this.lat = point.y;
				return this;
			},

			/**
			 * APIMethod: wrapDateLine
			 * 
			 * Parameters:
			 * maxExtent - {<HGIS.Bounds>}
			 * 
			 * Returns:
			 * {<HGIS.LonLat>} A copy of this lonlat, but wrapped around the 
			 *                       "dateline" (as specified by the borders of 
			 *                       maxExtent)
			 */
			wrapDateLine : function(maxExtent) {

				var newLonLat = this.clone();

				if (maxExtent) {
					//shift right?
			while (newLonLat.lon < maxExtent.left) {
				newLonLat.lon += maxExtent.getWidth();
			}

			//shift left?
			while (newLonLat.lon > maxExtent.right) {
				newLonLat.lon -= maxExtent.getWidth();
			}
		}

		return newLonLat;
	},

	CLASS_NAME : "HGIS.LonLat"
		});

/** 
 * Function: fromString
 * Alternative constructor that builds a new <HGIS.LonLat> from a 
 *     parameter string
 * 
 * Parameters:
 * str - {String} Comma-separated Lon,Lat coordinate string. 
 *                 (e.g. <i>"5,40"</i>)
 * 
 * Returns:
 * {<HGIS.LonLat>} New <HGIS.LonLat> object built from the 
 *                       passed-in String.
 */
HGIS.LonLat.fromString = function(str) {
	var pair = str.split(",");
	return new HGIS.LonLat(pair[0], pair[1]);
};

/** 
 * Function: fromArray
 * Alternative constructor that builds a new <HGIS.LonLat> from an 
 *     array of two numbers that represent lon- and lat-values.
 * 
 * Parameters:
 * arr - {Array(Float)} Array of lon/lat values (e.g. [5,-42])
 * 
 * Returns:
 * {<HGIS.LonLat>} New <HGIS.LonLat> object built from the 
 *                       passed-in array.
 */
HGIS.LonLat.fromArray = function(arr) {
	var gotArr = HGIS.Util.isArray(arr), lon = gotArr && arr[0], lat = gotArr
			&& arr[1];
	return new HGIS.LonLat(lon, lat);
};
/* ======================================================================
    HGIS/BaseTypes/Pixel.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 */

/**
 * Class: HGIS.Pixel
 * This class represents a screen coordinate, in x and y coordinates
 */
HGIS.Pixel = HGIS.Class( {

	/**
	 * APIProperty: x
	 * {Number} The x coordinate
	 */
	x : 0.0,

	/**
	 * APIProperty: y
	 * {Number} The y coordinate
	 */
	y : 0.0,

	/**
	 * Constructor: HGIS.Pixel
	 * Create a new HGIS.Pixel instance
	 *
	 * Parameters:
	 * x - {Number} The x coordinate
	 * y - {Number} The y coordinate
	 *
	 * Returns:
	 * An instance of HGIS.Pixel
	 */
	initialize : function(x, y) {
		this.x = parseFloat(x);
		this.y = parseFloat(y);
	},

	/**
	 * Method: toString
	 * Cast this object into a string
	 *
	 * Returns:
	 * {String} The string representation of Pixel. ex: "x=200.4,y=242.2"
	 */
	toString : function() {
		return ("x=" + this.x + ",y=" + this.y);
	},

	/**
	 * APIMethod: clone
	 * Return a clone of this pixel object
	 *
	 * Returns:
	 * {<HGIS.Pixel>} A clone pixel
	 */
	clone : function() {
		return new HGIS.Pixel(this.x, this.y);
	},

	/**
	 * APIMethod: equals
	 * Determine whether one pixel is equivalent to another
	 *
	 * Parameters:
	 * px - {<HGIS.Pixel>|Object} An HGIS.Pixel or an object with
	 *                                  a 'x' and 'y' properties.
	 *
	 * Returns:
	 * {Boolean} The point passed in as parameter is equal to this. Note that
	 * if px passed in is null, returns false.
	 */
	equals : function(px) {
		var equals = false;
		if (px != null) {
			equals = ((this.x == px.x && this.y == px.y) || (isNaN(this.x)
					&& isNaN(this.y) && isNaN(px.x) && isNaN(px.y)));
		}
		return equals;
	},

	/**
	 * APIMethod: distanceTo
	 * Returns the distance to the pixel point passed in as a parameter.
	 *
	 * Parameters:
	 * px - {<HGIS.Pixel>}
	 *
	 * Returns:
	 * {Float} The pixel point passed in as parameter to calculate the
	 *     distance to.
	 */
	distanceTo : function(px) {
		return Math.sqrt(Math.pow(this.x - px.x, 2)
				+ Math.pow(this.y - px.y, 2));
	},

	/**
	 * APIMethod: add
	 *
	 * Parameters:
	 * x - {Integer}
	 * y - {Integer}
	 *
	 * Returns:
	 * {<HGIS.Pixel>} A new Pixel with this pixel's x&y augmented by the 
	 * values passed in.
	 */
	add : function(x, y) {
		if ((x == null) || (y == null)) {
			throw new TypeError('Pixel.add cannot receive null values');
		}
		return new HGIS.Pixel(this.x + x, this.y + y);
	},

	/**
	 * APIMethod: offset
	 * 
	 * Parameters
	 * px - {<HGIS.Pixel>|Object} An HGIS.Pixel or an object with
	 *                                  a 'x' and 'y' properties.
	 * 
	 * Returns:
	 * {<HGIS.Pixel>} A new Pixel with this pixel's x&y augmented by the 
	 *                      x&y values of the pixel passed in.
	 */
	offset : function(px) {
		var newPx = this.clone();
		if (px) {
			newPx = this.add(px.x, px.y);
		}
		return newPx;
	},

	CLASS_NAME : "HGIS.Pixel"
});
/* ======================================================================
    HGIS/BaseTypes/Size.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 */

/**
 * Class: HGIS.Size
 * Instances of this class represent a width/height pair
 */
HGIS.Size = HGIS.Class( {

	/**
	 * APIProperty: w
	 * {Number} width
	 */
	w : 0.0,

	/**
	 * APIProperty: h
	 * {Number} height
	 */
	h : 0.0,

	/**
	 * Constructor: HGIS.Size
	 * Create an instance of HGIS.Size
	 *
	 * Parameters:
	 * w - {Number} width
	 * h - {Number} height
	 */
	initialize : function(w, h) {
		this.w = parseFloat(w);
		this.h = parseFloat(h);
	},

	/**
	 * Method: toString
	 * Return the string representation of a size object
	 *
	 * Returns:
	 * {String} The string representation of HGIS.Size object. 
	 * (e.g. <i>"w=55,h=66"</i>)
	 */
	toString : function() {
		return ("w=" + this.w + ",h=" + this.h);
	},

	/**
	 * APIMethod: clone
	 * Create a clone of this size object
	 *
	 * Returns:
	 * {<HGIS.Size>} A new HGIS.Size object with the same w and h
	 * values
	 */
	clone : function() {
		return new HGIS.Size(this.w, this.h);
	},

	/**
	 *
	 * APIMethod: equals
	 * Determine where this size is equal to another
	 *
	 * Parameters:
	 * sz - {<HGIS.Size>|Object} An HGIS.Size or an object with
	 *                                  a 'w' and 'h' properties.
	 *
	 * Returns: 
	 * {Boolean} The passed in size has the same h and w properties as this one.
	 * Note that if sz passed in is null, returns false.
	 */
	equals : function(sz) {
		var equals = false;
		if (sz != null) {
			equals = ((this.w == sz.w && this.h == sz.h) || (isNaN(this.w)
					&& isNaN(this.h) && isNaN(sz.w) && isNaN(sz.h)));
		}
		return equals;
	},

	CLASS_NAME : "HGIS.Size"
});
/* ======================================================================
    HGIS/Console.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 */

/**
 * Namespace: HGIS.Console
 * The HGIS.Console namespace is used for debugging and error logging.
 * If the Firebug Lite (../Firebug/firebug.js) is included before this script,
 * calls to HGIS.Console methods will get redirected to window.console.
 * This makes use of the Firebug extension where available and allows for
 * cross-browser debugging Firebug style.
 *
 * Note:
 * Note that behavior will differ with the Firebug extention and Firebug Lite.
 * Most notably, the Firebug Lite console does not currently allow for
 * hyperlinks to code or for clicking on object to explore their properties.
 * 
 */
HGIS.Console = {
	/**
	 * Create empty functions for all console methods.  The real value of these
	 * properties will be set if Firebug Lite (../Firebug/firebug.js script) is
	 * included.  We explicitly require the Firebug Lite script to trigger
	 * functionality of the HGIS.Console methods.
	 */

	/**
	 * APIFunction: log
	 * Log an object in the console.  The Firebug Lite console logs string
	 * representation of objects.  Given multiple arguments, they will
	 * be cast to strings and logged with a space delimiter.  If the first
	 * argument is a string with printf-like formatting, subsequent arguments
	 * will be used in string substitution.  Any additional arguments (beyond
	 * the number substituted in a format string) will be appended in a space-
	 * delimited line.
	 * 
	 * Parameters:
	 * object - {Object}
	 */
	log : function() {
	},

	/**
	 * APIFunction: debug
	 * Writes a message to the console, including a hyperlink to the line
	 * where it was called.
	 *
	 * May be called with multiple arguments as with HGIS.Console.log().
	 * 
	 * Parameters:
	 * object - {Object}
	 */
	debug : function() {
	},

	/**
	 * APIFunction: info
	 * Writes a message to the console with the visual "info" icon and color
	 * coding and a hyperlink to the line where it was called.
	 *
	 * May be called with multiple arguments as with HGIS.Console.log().
	 * 
	 * Parameters:
	 * object - {Object}
	 */
	info : function() {
	},

	/**
	 * APIFunction: warn
	 * Writes a message to the console with the visual "warning" icon and
	 * color coding and a hyperlink to the line where it was called.
	 *
	 * May be called with multiple arguments as with HGIS.Console.log().
	 * 
	 * Parameters:
	 * object - {Object}
	 */
	warn : function() {
	},

	/**
	 * APIFunction: error
	 * Writes a message to the console with the visual "error" icon and color
	 * coding and a hyperlink to the line where it was called.
	 *
	 * May be called with multiple arguments as with HGIS.Console.log().
	 * 
	 * Parameters:
	 * object - {Object}
	 */
	error : function() {
	},

	/**
	 * APIFunction: userError
	 * A single interface for showing error messages to the user. The default
	 * behavior is a Javascript alert, though this can be overridden by
	 * reassigning HGIS.Console.userError to a different function.
	 *
	 * Expects a single error message
	 * 
	 * Parameters:
	 * error - {Object}
	 */
	userError : function(error) {
		alert(error);
	},

	/**
	 * APIFunction: assert
	 * Tests that an expression is true. If not, it will write a message to
	 * the console and throw an exception.
	 *
	 * May be called with multiple arguments as with HGIS.Console.log().
	 * 
	 * Parameters:
	 * object - {Object}
	 */
	assert : function() {
	},

	/**
	 * APIFunction: dir
	 * Prints an interactive listing of all properties of the object. This
	 * looks identical to the view that you would see in the DOM tab.
	 * 
	 * Parameters:
	 * object - {Object}
	 */
	dir : function() {
	},

	/**
	 * APIFunction: dirxml
	 * Prints the XML source tree of an HTML or XML element. This looks
	 * identical to the view that you would see in the HTML tab. You can click
	 * on any node to inspect it in the HTML tab.
	 * 
	 * Parameters:
	 * object - {Object}
	 */
	dirxml : function() {
	},

	/**
	 * APIFunction: trace
	 * Prints an interactive stack trace of JavaScript execution at the point
	 * where it is called.  The stack trace details the functions on the stack,
	 * as well as the values that were passed as arguments to each function.
	 * You can click each function to take you to its source in the Script tab,
	 * and click each argument value to inspect it in the DOM or HTML tabs.
	 * 
	 */
	trace : function() {
	},

	/**
	 * APIFunction: group
	 * Writes a message to the console and opens a nested block to indent all
	 * future messages sent to the console. Call HGIS.Console.groupEnd()
	 * to close the block.
	 *
	 * May be called with multiple arguments as with HGIS.Console.log().
	 * 
	 * Parameters:
	 * object - {Object}
	 */
	group : function() {
	},

	/**
	 * APIFunction: groupEnd
	 * Closes the most recently opened block created by a call to
	 * HGIS.Console.group
	 */
	groupEnd : function() {
	},

	/**
	 * APIFunction: time
	 * Creates a new timer under the given name. Call
	 * HGIS.Console.timeEnd(name)
	 * with the same name to stop the timer and print the time elapsed.
	 *
	 * Parameters:
	 * name - {String}
	 */
	time : function() {
	},

	/**
	 * APIFunction: timeEnd
	 * Stops a timer created by a call to HGIS.Console.time(name) and
	 * writes the time elapsed.
	 *
	 * Parameters:
	 * name - {String}
	 */
	timeEnd : function() {
	},

	/**
	 * APIFunction: profile
	 * Turns on the JavaScript profiler. The optional argument title would
	 * contain the text to be printed in the header of the profile report.
	 *
	 * This function is not currently implemented in Firebug Lite.
	 * 
	 * Parameters:
	 * title - {String} Optional title for the profiler
	 */
	profile : function() {
	},

	/**
	 * APIFunction: profileEnd
	 * Turns off the JavaScript profiler and prints its report.
	 * 
	 * This function is not currently implemented in Firebug Lite.
	 */
	profileEnd : function() {
	},

	/**
	 * APIFunction: count
	 * Writes the number of times that the line of code where count was called
	 * was executed. The optional argument title will print a message in
	 * addition to the number of the count.
	 *
	 * This function is not currently implemented in Firebug Lite.
	 *
	 * Parameters:
	 * title - {String} Optional title to be printed with count
	 */
	count : function() {
	},

	CLASS_NAME : "HGIS.Console"
};

/**
 * Execute an anonymous function to extend the HGIS.Console namespace
 * if the firebug.js script is included.  This closure is used so that the
 * "scripts" and "i" variables don't pollute the global namespace.
 */
(function() {
	/**
	 * If Firebug Lite is included (before this script), re-route all
	 * HGIS.Console calls to the console object.
	 */
	var scripts = document.getElementsByTagName("script");
	for ( var i = 0, len = scripts.length; i < len; ++i) {
		if (scripts[i].src.indexOf("firebug.js") != -1) {
			if (console) {
				HGIS.Util.extend(HGIS.Console, console);
				break;
			}
		}
	}
})();
/* ======================================================================
    HGIS/Lang.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes.js
 * @requires HGIS/Console.js
 */

/**
 * Namespace: HGIS.Lang
 * Internationalization namespace.  Contains dictionaries in various languages
 *     and methods to set and get the current language.
 */
HGIS.Lang = {

	/** 
	 * Property: code
	 * {String}  Current language code to use in HGIS.  Use the
	 *     <setCode> method to set this value and the <getCode> method to
	 *     retrieve it.
	 */
	code : null,

	/** 
	 * APIProperty: defaultCode
	 * {String} Default language to use when a specific language can't be
	 *     found.  Default is "en".
	 */
	defaultCode : "en",

	/**
	 * APIFunction: getCode
	 * Get the current language code.
	 *
	 * Returns:
	 * {String} The current language code.
	 */
	getCode : function() {
		if (!HGIS.Lang.code) {
			HGIS.Lang.setCode();
		}
		return HGIS.Lang.code;
	},

	/**
	 * APIFunction: setCode
	 * Set the language code for string translation.  This code is used by
	 *     the <HGIS.Lang.translate> method.
	 *
	 * Parameters:
	 * code - {String} These codes follow the IETF recommendations at
	 *     http://www.ietf.org/rfc/rfc3066.txt.  If no value is set, the
	 *     browser's language setting will be tested.  If no <HGIS.Lang>
	 *     dictionary exists for the code, the <HGIS.String.defaultLang>
	 *     will be used.
	 */
	setCode : function(code) {
		var lang;
		if (!code) {
			code = (HGIS.BROWSER_NAME == "msie") ? navigator.userLanguage
					: navigator.language;
		}
		var parts = code.split('-');
		parts[0] = parts[0].toLowerCase();
		if (typeof HGIS.Lang[parts[0]] == "object") {
			lang = parts[0];
		}

		// check for regional extensions
		if (parts[1]) {
			var testLang = parts[0] + '-' + parts[1].toUpperCase();
			if (typeof HGIS.Lang[testLang] == "object") {
				lang = testLang;
			}
		}
		if (!lang) {
			HGIS.Console
					.warn('Failed to find HGIS.Lang.' + parts.join("-") + ' dictionary, falling back to default language');
			lang = HGIS.Lang.defaultCode;
		}

		HGIS.Lang.code = lang;
	},

	/**
	 * APIMethod: translate
	 * Looks up a key from a dictionary based on the current language string.
	 *     The value of <getCode> will be used to determine the appropriate
	 *     dictionary.  Dictionaries are stored in <HGIS.Lang>.
	 *
	 * Parameters:
	 * key - {String} The key for an i18n string value in the dictionary.
	 * context - {Object} Optional context to be used with
	 *     <HGIS.String.format>.
	 * 
	 * Returns:
	 * {String} A internationalized string.
	 */
	translate : function(key, context) {
		var dictionary = HGIS.Lang[HGIS.Lang.getCode()];
		var message = dictionary && dictionary[key];
		if (!message) {
			// Message not found, fall back to message key
	message = key;
}
if (context) {
	message = HGIS.String.format(message, context);
}
return message;
}

};

/**
 * APIMethod: HGIS.i18n
 * Alias for <HGIS.Lang.translate>.  Looks up a key from a dictionary
 *     based on the current language string. The value of
 *     <HGIS.Lang.getCode> will be used to determine the appropriate
 *     dictionary.  Dictionaries are stored in <HGIS.Lang>.
 *
 * Parameters:
 * key - {String} The key for an i18n string value in the dictionary.
 * context - {Object} Optional context to be used with
 *     <HGIS.String.format>.
 * 
 * Returns:
 * {String} A internationalized string.
 */
HGIS.i18n = HGIS.Lang.translate;
/* ======================================================================
    HGIS/Util.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes.js
 * @requires HGIS/BaseTypes/Bounds.js
 * @requires HGIS/BaseTypes/Element.js
 * @requires HGIS/BaseTypes/LonLat.js
 * @requires HGIS/BaseTypes/Pixel.js
 * @requires HGIS/BaseTypes/Size.js
 * @requires HGIS/Lang.js
 */

/**
 * Namespace: Util
 */
HGIS.Util = HGIS.Util || {};

/** 
 * Function: getElement
 * This is the old $() from prototype
 *
 * Parameters:
 * e - {String or DOMElement or Window}
 *
 * Returns:
 * {Array(DOMElement) or DOMElement}
 */
HGIS.Util.getElement = function() {
	var elements = [];

	for ( var i = 0, len = arguments.length; i < len; i++) {
		var element = arguments[i];
		if (typeof element == 'string') {
			element = document.getElementById(element);
		}
		if (arguments.length == 1) {
			return element;
		}
		elements.push(element);
	}
	return elements;
};

/**
 * Function: isElement
 * A cross-browser implementation of "e instanceof Element".
 *
 * Parameters:
 * o - {Object} The object to test.
 *
 * Returns:
 * {Boolean}
 */
HGIS.Util.isElement = function(o) {
	return !!(o && o.nodeType === 1);
};

/**
 * Function: isArray
 * Tests that the provided object is an array.
 * This test handles the cross-IFRAME case not caught
 * by "a instanceof Array" and should be used instead.
 * 
 * Parameters:
 * a - {Object} the object test.
 * 
 * Returns:
 * {Boolean} true if the object is an array.
 */
HGIS.Util.isArray = function(a) {
	return (Object.prototype.toString.call(a) === '[object Array]');
};

/** 
 * Function: removeItem
 * Remove an object from an array. Iterates through the array
 *     to find the item, then removes it.
 *
 * Parameters:
 * array - {Array}
 * item - {Object}
 * 
 * Returns:
 * {Array} A reference to the array
 */
HGIS.Util.removeItem = function(array, item) {
	for ( var i = array.length - 1; i >= 0; i--) {
		if (array[i] == item) {
			array.splice(i, 1);
			//break;more than once??
		}
	}
	return array;
};

/** 
 * Function: indexOf
 * Seems to exist already in FF, but not in MOZ.
 * 
 * Parameters:
 * array - {Array}
 * obj - {*}
 * 
 * Returns:
 * {Integer} The index at which the first object was found in the array.
 *           If not found, returns -1.
 */
HGIS.Util.indexOf = function(array, obj) {
	// use the build-in function if available.
	if (typeof array.indexOf == "function") {
		return array.indexOf(obj);
	} else {
		for ( var i = 0, len = array.length; i < len; i++) {
			if (array[i] == obj) {
				return i;
			}
		}
		return -1;
	}
};

/**
 * Property: dotless
 * {RegExp}
 * Compiled regular expression to match dots (".").  This is used for replacing
 *     dots in identifiers.  Because object identifiers are frequently used for
 *     DOM element identifiers by the library, we avoid using dots to make for
 *     more sensible CSS selectors.
 *
 * TODO: Use a module pattern to avoid bloating the API with stuff like this.
 */
HGIS.Util.dotless = /\./g;

/**
 * Function: modifyDOMElement
 * 
 * Modifies many properties of a DOM element all at once.  Passing in 
 * null to an individual parameter will avoid setting the attribute.
 *
 * Parameters:
 * element - {DOMElement} DOM element to modify.
 * id - {String} The element id attribute to set.  Note that dots (".") will be
 *     replaced with underscore ("_") in setting the element id.
 * px - {<HGIS.Pixel>|Object} The element left and top position,
 *                                  HGIS.Pixel or an object with
 *                                  a 'x' and 'y' properties.
 * sz - {<HGIS.Size>|Object} The element width and height,
 *                                 HGIS.Size or an object with a
 *                                 'w' and 'h' properties.
 * position - {String}       The position attribute.  eg: absolute, 
 *                           relative, etc.
 * border - {String}         The style.border attribute.  eg:
 *                           solid black 2px
 * overflow - {String}       The style.overview attribute.  
 * opacity - {Float}         Fractional value (0.0 - 1.0)
 */
HGIS.Util.modifyDOMElement = function(element, id, px, sz, position,
		border, overflow, opacity) {

	if (id) {
		element.id = id.replace(HGIS.Util.dotless, "_");
	}
	if (px) {
		element.style.left = px.x + "px";
		element.style.top = px.y + "px";
	}
	if (sz) {
		element.style.width = sz.w + "px";
		element.style.height = sz.h + "px";
	}
	if (position) {
		element.style.position = position;
	}
	if (border) {
		element.style.border = border;
	}
	if (overflow) {
		element.style.overflow = overflow;
	}
	if (parseFloat(opacity) >= 0.0 && parseFloat(opacity) < 1.0) {
		element.style.filter = 'alpha(opacity=' + (opacity * 100) + ')';
		element.style.opacity = opacity;
	} else if (parseFloat(opacity) == 1.0) {
		element.style.filter = '';
		element.style.opacity = '';
	}
};

/** 
 * Function: createDiv
 * Creates a new div and optionally set some standard attributes.
 * Null may be passed to each parameter if you do not wish to
 * set a particular attribute.
 * Note - zIndex is NOT set on the resulting div.
 * 
 * Parameters:
 * id - {String} An identifier for this element.  If no id is
 *               passed an identifier will be created 
 *               automatically.  Note that dots (".") will be replaced with
 *               underscore ("_") when generating ids.
 * px - {<HGIS.Pixel>|Object} The element left and top position,
 *                                  HGIS.Pixel or an object with
 *                                  a 'x' and 'y' properties.
 * sz - {<HGIS.Size>|Object} The element width and height,
 *                                 HGIS.Size or an object with a
 *                                 'w' and 'h' properties.
 * imgURL - {String} A url pointing to an image to use as a 
 *                   background image.
 * position - {String} The style.position value. eg: absolute,
 *                     relative etc.
 * border - {String} The the style.border value. 
 *                   eg: 2px solid black
 * overflow - {String} The style.overflow value. Eg. hidden
 * opacity - {Float} Fractional value (0.0 - 1.0)
 * 
 * Returns: 
 * {DOMElement} A DOM Div created with the specified attributes.
 */
HGIS.Util.createDiv = function(id, px, sz, imgURL, position, border,
		overflow, opacity) {

	var dom = document.createElement('div');

	if (imgURL) {
		dom.style.backgroundImage = 'url(' + imgURL + ')';
	}

	//set generic properties
	if (!id) {
		id = HGIS.Util.createUniqueID("HGISDiv");
	}
	if (!position) {
		position = "absolute";
	}
	HGIS.Util.modifyDOMElement(dom, id, px, sz, position, border,
			overflow, opacity);

	return dom;
};

/**
 * Function: createImage
 * Creates an img element with specific attribute values.
 *  
 * Parameters:
 * id - {String} The id field for the img.  If none assigned one will be
 *               automatically generated.
 * px - {<HGIS.Pixel>|Object} The element left and top position,
 *                                  HGIS.Pixel or an object with
 *                                  a 'x' and 'y' properties.
 * sz - {<HGIS.Size>|Object} The element width and height,
 *                                 HGIS.Size or an object with a
 *                                 'w' and 'h' properties.
 * imgURL - {String} The url to use as the image source.
 * position - {String} The style.position value.
 * border - {String} The border to place around the image.
 * opacity - {Float} Fractional value (0.0 - 1.0)
 * delayDisplay - {Boolean} If true waits until the image has been
 *                          loaded.
 * 
 * Returns:
 * {DOMElement} A DOM Image created with the specified attributes.
 */
HGIS.Util.createImage = function(id, px, sz, imgURL, position, border,
		opacity, delayDisplay) {

	var image = document.createElement("img");

	//set generic properties
	if (!id) {
		id = HGIS.Util.createUniqueID("HGISDiv");
	}
	if (!position) {
		position = "relative";
	}
	HGIS.Util.modifyDOMElement(image, id, px, sz, position, border, null,
			opacity);

	if (delayDisplay) {
		image.style.display = "none";
		function display() {
			image.style.display = "";
			HGIS.Event.stopObservingElement(image);
		}
		HGIS.Event.observe(image, "load", display);
		HGIS.Event.observe(image, "error", display);
	}

	//set special properties
	image.style.alt = id;
	image.galleryImg = "no";
	if (imgURL) {
		image.src = imgURL;
	}

	return image;
};

/**
 * Property: IMAGE_RELOAD_ATTEMPTS
 * {Integer} How many times should we try to reload an image before giving up?
 *           Default is 0
 */
HGIS.IMAGE_RELOAD_ATTEMPTS = 0;

/**
 * Property: alphaHackNeeded
 * {Boolean} true if the png alpha hack is necessary and possible, false otherwise.
 */
HGIS.Util.alphaHackNeeded = null;

/**
 * Function: alphaHack
 * Checks whether it's necessary (and possible) to use the png alpha
 * hack which allows alpha transparency for png images under Internet
 * Explorer.
 * 
 * Returns:
 * {Boolean} true if the png alpha hack is necessary and possible, false otherwise.
 */
HGIS.Util.alphaHack = function() {
	if (HGIS.Util.alphaHackNeeded == null) {
		var arVersion = navigator.appVersion.split("MSIE");
		var version = parseFloat(arVersion[1]);
		var filter = false;

		// IEs4Lin dies when trying to access document.body.filters, because 
		// the property is there, but requires a DLL that can't be provided. This
		// means that we need to wrap this in a try/catch so that this can
		// continue.

		try {
			filter = !!(document.body.filters);
		} catch (e) {
		}

		HGIS.Util.alphaHackNeeded = (filter && (version >= 5.5) && (version < 7));
	}
	return HGIS.Util.alphaHackNeeded;
};

/** 
 * Function: modifyAlphaImageDiv
 * 
 * Parameters:
 * div - {DOMElement} Div containing Alpha-adjusted Image
 * id - {String}
 * px - {<HGIS.Pixel>|Object} HGIS.Pixel or an object with
 *                                  a 'x' and 'y' properties.
 * sz - {<HGIS.Size>|Object} HGIS.Size or an object with
 *                                 a 'w' and 'h' properties.
 * imgURL - {String}
 * position - {String}
 * border - {String}
 * sizing - {String} 'crop', 'scale', or 'image'. Default is "scale"
 * opacity - {Float} Fractional value (0.0 - 1.0)
 */
HGIS.Util.modifyAlphaImageDiv = function(div, id, px, sz, imgURL,
		position, border, sizing, opacity) {

	HGIS.Util.modifyDOMElement(div, id, px, sz, position, null, null,
			opacity);

	var img = div.childNodes[0];

	if (imgURL) {
		img.src = imgURL;
	}
	HGIS.Util.modifyDOMElement(img, div.id + "_innerImage", null, sz,
			"relative", border);

	if (HGIS.Util.alphaHack()) {
		if (div.style.display != "none") {
			div.style.display = "inline-block";
		}
		if (sizing == null) {
			sizing = "scale";
		}

		div.style.filter = "progid:DXImageTransform.Microsoft"
				+ ".AlphaImageLoader(src='" + img.src + "', "
				+ "sizingMethod='" + sizing + "')";
		if (parseFloat(div.style.opacity) >= 0.0
				&& parseFloat(div.style.opacity) < 1.0) {
			div.style.filter += " alpha(opacity=" + div.style.opacity * 100
					+ ")";
		}

		img.style.filter = "alpha(opacity=0)";
	}
};

/** 
 * Function: createAlphaImageDiv
 * 
 * Parameters:
 * id - {String}
 * px - {<HGIS.Pixel>|Object} HGIS.Pixel or an object with
 *                                  a 'x' and 'y' properties.
 * sz - {<HGIS.Size>|Object} HGIS.Size or an object with
 *                                 a 'w' and 'h' properties.
 * imgURL - {String}
 * position - {String}
 * border - {String}
 * sizing - {String} 'crop', 'scale', or 'image'. Default is "scale"
 * opacity - {Float} Fractional value (0.0 - 1.0)
 * delayDisplay - {Boolean} If true waits until the image has been
 *                          loaded.
 * 
 * Returns:
 * {DOMElement} A DOM Div created with a DOM Image inside it. If the hack is 
 *              needed for transparency in IE, it is added.
 */
HGIS.Util.createAlphaImageDiv = function(id, px, sz, imgURL, position,
		border, sizing, opacity, delayDisplay) {

	var div = HGIS.Util.createDiv();
	var img = HGIS.Util.createImage(null, null, null, null, null, null,
			null, delayDisplay);
	img.className = "olAlphaImg";
	div.appendChild(img);

	HGIS.Util.modifyAlphaImageDiv(div, id, px, sz, imgURL, position,
			border, sizing, opacity);

	return div;
};

/** 
 * Function: upperCaseObject
 * Creates a new hashtable and copies over all the keys from the 
 *     passed-in object, but storing them under an uppercased
 *     version of the key at which they were stored.
 * 
 * Parameters: 
 * object - {Object}
 * 
 * Returns: 
 * {Object} A new Object with all the same keys but uppercased
 */
HGIS.Util.upperCaseObject = function(object) {
	var uObject = {};
	for ( var key in object) {
		uObject[key.toUpperCase()] = object[key];
	}
	return uObject;
};

/** 
 * Function: applyDefaults
 * Takes an object and copies any properties that don't exist from
 *     another properties, by analogy with HGIS.Util.extend() from
 *     Prototype.js.
 * 
 * Parameters:
 * to - {Object} The destination object.
 * from - {Object} The source object.  Any properties of this object that
 *     are undefined in the to object will be set on the to object.
 *
 * Returns:
 * {Object} A reference to the to object.  Note that the to argument is modified
 *     in place and returned by this function.
 */
HGIS.Util.applyDefaults = function(to, from) {
	to = to || {};
	/*
	 * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
	 * prototype object" when calling hawOwnProperty if the source object is an
	 * instance of window.Event.
	 */
	var fromIsEvt = typeof window.Event == "function"
			&& from instanceof window.Event;

	for ( var key in from) {
		if (to[key] === undefined
				|| (!fromIsEvt && from.hasOwnProperty
						&& from.hasOwnProperty(key) && !to.hasOwnProperty(key))) {
			to[key] = from[key];
		}
	}
	/**
	 * IE doesn't include the toString property when iterating over an object's
	 * properties with the for(property in object) syntax.  Explicitly check if
	 * the source has its own toString property.
	 */
	if (!fromIsEvt && from && from.hasOwnProperty
			&& from.hasOwnProperty('toString')
			&& !to.hasOwnProperty('toString')) {
		to.toString = from.toString;
	}

	return to;
};

/**
 * Function: getParameterString
 * 
 * Parameters:
 * params - {Object}
 * 
 * Returns:
 * {String} A concatenation of the properties of an object in 
 *          http parameter notation. 
 *          (ex. <i>"key1=value1&key2=value2&key3=value3"</i>)
 *          If a parameter is actually a list, that parameter will then
 *          be set to a comma-seperated list of values (foo,bar) instead
 *          of being URL escaped (foo%3Abar). 
 */
HGIS.Util.getParameterString = function(params) {
	var paramsArray = [];

	for ( var key in params) {
		var value = params[key];
		if ((value != null) && (typeof value != 'function')) {
			var encodedValue;
			if (typeof value == 'object' && value.constructor == Array) {
				/* value is an array; encode items and separate with "," */
				var encodedItemArray = [];
				var item;
				for ( var itemIndex = 0, len = value.length; itemIndex < len; itemIndex++) {
					item = value[itemIndex];
					encodedItemArray
							.push(encodeURIComponent((item === null || item === undefined) ? ""
									: item));
				}
				encodedValue = encodedItemArray.join(",");
			} else {
				/* value is a string; simply encode */
				encodedValue = encodeURIComponent(value);
			}
			paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
		}
	}

	return paramsArray.join("&");
};

/**
 * Function: urlAppend
 * Appends a parameter string to a url. This function includes the logic for
 * using the appropriate character (none, & or ?) to append to the url before
 * appending the param string.
 * 
 * Parameters:
 * url - {String} The url to append to
 * paramStr - {String} The param string to append
 * 
 * Returns:
 * {String} The new url
 */
HGIS.Util.urlAppend = function(url, paramStr) {
	var newUrl = url;
	if (paramStr) {
		var parts = (url + " ").split(/[?&]/);
		newUrl += (parts.pop() === " " ? paramStr : parts.length ? "&"
				+ paramStr : "?" + paramStr);
	}
	return newUrl;
};

/** 
 * Function: getImagesLocation
 * 
 * Returns:
 * {String} The fully formatted image location string
 */
HGIS.Util.getImagesLocation = function() {
	return HGIS.ImgPath || (HGIS._getScriptLocation() + "gisapi/theme/img/");
};

/** 
 * Function: getImageLocation
 * 
 * Returns:
 * {String} The fully formatted location string for a specified image
 */
HGIS.Util.getImageLocation = function(image) {
	return HGIS.Util.getImagesLocation() + image;
};

/** 
 * Function: Try
 * Execute functions until one of them doesn't throw an error. 
 *     Capitalized because "try" is a reserved word in JavaScript.
 *     Taken directly from HGIS.Util.Try()
 * 
 * Parameters:
 * [*] - {Function} Any number of parameters may be passed to Try()
 *    It will attempt to execute each of them until one of them 
 *    successfully executes. 
 *    If none executes successfully, returns null.
 * 
 * Returns:
 * {*} The value returned by the first successfully executed function.
 */
HGIS.Util.Try = function() {
	var returnValue = null;

	for ( var i = 0, len = arguments.length; i < len; i++) {
		var lambda = arguments[i];
		try {
			returnValue = lambda();
			break;
		} catch (e) {
		}
	}

	return returnValue;
};

/**
 * Function: getXmlNodeValue
 * 
 * Parameters:
 * node - {XMLNode}
 * 
 * Returns:
 * {String} The text value of the given node, without breaking in firefox or IE
 */
HGIS.Util.getXmlNodeValue = function(node) {
	var val = null;
	HGIS.Util.Try(function() {
		val = node.text;
		if (!val) {
			val = node.textContent;
		}
		if (!val) {
			val = node.firstChild.nodeValue;
		}
	}, function() {
		val = node.textContent;
	});
	return val;
};

/** 
 * Function: mouseLeft
 * 
 * Parameters:
 * evt - {Event}
 * div - {HTMLDivElement}
 * 
 * Returns:
 * {Boolean}
 */
HGIS.Util.mouseLeft = function(evt, div) {
	// start with the element to which the mouse has moved
	var target = (evt.relatedTarget) ? evt.relatedTarget : evt.toElement;
	// walk up the DOM tree.
	while (target != div && target != null) {
		target = target.parentNode;
	}
	// if the target we stop at isn't the div, then we've left the div.
	return (target != div);
};

/**
 * Property: precision
 * {Number} The number of significant digits to retain to avoid
 * floating point precision errors.
 *
 * We use 14 as a "safe" default because, although IEEE 754 double floats
 * (standard on most modern operating systems) support up to about 16
 * significant digits, 14 significant digits are sufficient to represent
 * sub-millimeter accuracy in any coordinate system that anyone is likely to
 * use with HGIS.
 *
 * If DEFAULT_PRECISION is set to 0, the original non-truncating behavior
 * of HGIS <2.8 is preserved. Be aware that this will cause problems
 * with certain projections, e.g. spherical Mercator.
 *
 */
HGIS.Util.DEFAULT_PRECISION = 14;

/**
 * Function: toFloat
 * Convenience method to cast an object to a Number, rounded to the
 * desired floating point precision.
 *
 * Parameters:
 * number    - {Number} The number to cast and round.
 * precision - {Number} An integer suitable for use with
 *      Number.toPrecision(). Defaults to HGIS.Util.DEFAULT_PRECISION.
 *      If set to 0, no rounding is performed.
 *
 * Returns:
 * {Number} The cast, rounded number.
 */
HGIS.Util.toFloat = function(number, precision) {
	if (precision == null) {
		precision = HGIS.Util.DEFAULT_PRECISION;
	}
	if (typeof number !== "number") {
		number = parseFloat(number);
	}
	return precision === 0 ? number : parseFloat(number.toPrecision(precision));
};

/**
 * Function: rad
 * 
 * Parameters:
 * x - {Float}
 * 
 * Returns:
 * {Float}
 */
HGIS.Util.rad = function(x) {
	return x * Math.PI / 180;
};

/**
 * Function: deg
 *
 * Parameters:
 * x - {Float}
 *
 * Returns:
 * {Float}
 */
HGIS.Util.deg = function(x) {
	return x * 180 / Math.PI;
};

/**
 * Property: VincentyConstants
 * {Object} Constants for Vincenty functions.
 */
HGIS.Util.VincentyConstants = {
	a : 6378137,
	b : 6356752.3142,
	f : 1 / 298.257223563
};

/**
 * APIFunction: distVincenty
 * Given two objects representing points with geographic coordinates, this
 *     calculates the distance between those points on the surface of an
 *     ellipsoid.
 *
 * Parameters:
 * p1 - {<HGIS.LonLat>} (or any object with both .lat, .lon properties)
 * p2 - {<HGIS.LonLat>} (or any object with both .lat, .lon properties)
 *
 * Returns:
 * {Float} The distance (in km) between the two input points as measured on an
 *     ellipsoid.  Note that the input point objects must be in geographic
 *     coordinates (decimal degrees) and the return distance is in kilometers.
 */
HGIS.Util.distVincenty = function(p1, p2) {
	var ct = HGIS.Util.VincentyConstants;
	var a = ct.a, b = ct.b, f = ct.f;

	var L = HGIS.Util.rad(p2.lon - p1.lon);
	var U1 = Math.atan((1 - f) * Math.tan(HGIS.Util.rad(p1.lat)));
	var U2 = Math.atan((1 - f) * Math.tan(HGIS.Util.rad(p2.lat)));
	var sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
	var sinU2 = Math.sin(U2), cosU2 = Math.cos(U2);
	var lambda = L, lambdaP = 2 * Math.PI;
	var iterLimit = 20;
	while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {
		var sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda);
		var sinSigma = Math.sqrt((cosU2 * sinLambda) * (cosU2 * sinLambda)
				+ (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda)
				* (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
		if (sinSigma == 0) {
			return 0; // co-incident points
		}
		var cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
		var sigma = Math.atan2(sinSigma, cosSigma);
		var alpha = Math.asin(cosU1 * cosU2 * sinLambda / sinSigma);
		var cosSqAlpha = Math.cos(alpha) * Math.cos(alpha);
		var cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;
		var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
		lambdaP = lambda;
		lambda = L
				+ (1 - C)
				* f
				* Math.sin(alpha)
				* (sigma + C
						* sinSigma
						* (cos2SigmaM + C * cosSigma
								* (-1 + 2 * cos2SigmaM * cos2SigmaM)));
	}
	if (iterLimit == 0) {
		return NaN; // formula failed to converge
	}
	var uSq = cosSqAlpha * (a * a - b * b) / (b * b);
	var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
	var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
	var deltaSigma = B
			* sinSigma
			* (cos2SigmaM + B
					/ 4
					* (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6
							* cos2SigmaM * (-3 + 4 * sinSigma * sinSigma)
							* (-3 + 4 * cos2SigmaM * cos2SigmaM)));
	var s = b * A * (sigma - deltaSigma);
	var d = s.toFixed(3) / 1000; // round to 1mm precision
	return d;
};

/**
 * APIFunction: destinationVincenty
 * Calculate destination point given start point lat/long (numeric degrees),
 * bearing (numeric degrees) & distance (in m).
 * Adapted from Chris Veness work, see
 * http://www.movable-type.co.uk/scripts/latlong-vincenty-direct.html
 *
 * Parameters:
 * lonlat  - {<HGIS.LonLat>} (or any object with both .lat, .lon
 *     properties) The start point.
 * brng     - {Float} The bearing (degrees).
 * dist     - {Float} The ground distance (meters).
 *
 * Returns:
 * {<HGIS.LonLat>} The destination point.
 */
HGIS.Util.destinationVincenty = function(lonlat, brng, dist) {
	var u = HGIS.Util;
	var ct = u.VincentyConstants;
	var a = ct.a, b = ct.b, f = ct.f;

	var lon1 = lonlat.lon;
	var lat1 = lonlat.lat;

	var s = dist;
	var alpha1 = u.rad(brng);
	var sinAlpha1 = Math.sin(alpha1);
	var cosAlpha1 = Math.cos(alpha1);

	var tanU1 = (1 - f) * Math.tan(u.rad(lat1));
	var cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)), sinU1 = tanU1 * cosU1;
	var sigma1 = Math.atan2(tanU1, cosAlpha1);
	var sinAlpha = cosU1 * sinAlpha1;
	var cosSqAlpha = 1 - sinAlpha * sinAlpha;
	var uSq = cosSqAlpha * (a * a - b * b) / (b * b);
	var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
	var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));

	var sigma = s / (b * A), sigmaP = 2 * Math.PI;
	while (Math.abs(sigma - sigmaP) > 1e-12) {
		var cos2SigmaM = Math.cos(2 * sigma1 + sigma);
		var sinSigma = Math.sin(sigma);
		var cosSigma = Math.cos(sigma);
		var deltaSigma = B
				* sinSigma
				* (cos2SigmaM + B
						/ 4
						* (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B
								/ 6 * cos2SigmaM
								* (-3 + 4 * sinSigma * sinSigma)
								* (-3 + 4 * cos2SigmaM * cos2SigmaM)));
		sigmaP = sigma;
		sigma = s / (b * A) + deltaSigma;
	}

	var tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;
	var lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1,
			(1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp));
	var lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1
			* sinSigma * cosAlpha1);
	var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
	var L = lambda
			- (1 - C)
			* f
			* sinAlpha
			* (sigma + C
					* sinSigma
					* (cos2SigmaM + C * cosSigma
							* (-1 + 2 * cos2SigmaM * cos2SigmaM)));

	var revAz = Math.atan2(sinAlpha, -tmp); // final bearing

	return new HGIS.LonLat(lon1 + u.deg(L), u.deg(lat2));
};

/**
 * Function: getParameters
 * Parse the parameters from a URL or from the current page itself into a 
 *     JavaScript Object. Note that parameter values with commas are separated
 *     out into an Array.
 * 
 * Parameters:
 * url - {String} Optional url used to extract the query string.
 *                If url is null or is not supplied, query string is taken 
 *                from the page location.
 * options - {Object} Additional options. Optional.
 *
 * Valid options:
 *   splitArgs - {Boolean} Split comma delimited params into arrays? Default is
 *       true.
 * 
 * Returns:
 * {Object} An object of key/value pairs from the query string.
 */
HGIS.Util.getParameters = function(url, options) {
	options = options || {};
	// if no url specified, take it from the location bar
	url = (url === null || url === undefined) ? window.location.href : url;

	//parse out parameters portion of url string
	var paramsString = "";
	if (HGIS.String.contains(url, '?')) {
		var start = url.indexOf('?') + 1;
		var end = HGIS.String.contains(url, "#") ? url.indexOf('#')
				: url.length;
		paramsString = url.substring(start, end);
	}

	var parameters = {};
	var pairs = paramsString.split(/[&;]/);
	for ( var i = 0, len = pairs.length; i < len; ++i) {
		var keyValue = pairs[i].split('=');
		if (keyValue[0]) {

			var key = keyValue[0];
			try {
				key = decodeURIComponent(key);
			} catch (err) {
				key = unescape(key);
			}

			// being liberal by replacing "+" with " "
			var value = (keyValue[1] || '').replace(/\+/g, " ");

			try {
				value = decodeURIComponent(value);
			} catch (err) {
				value = unescape(value);
			}

			// follow OGC convention of comma delimited values
			if (options.splitArgs !== false) {
				value = value.split(",");
			}

			//if there's only one value, do not return as array                    
			if (value.length == 1) {
				value = value[0];
			}

			parameters[key] = value;
		}
	}
	return parameters;
};

/**
 * Property: lastSeqID
 * {Integer} The ever-incrementing count variable.
 *           Used for generating unique ids.
 */
HGIS.Util.lastSeqID = 0;

/**
 * Function: createUniqueID
 * Create a unique identifier for this session.  Each time this function
 *     is called, a counter is incremented.  The return will be the optional
 *     prefix (defaults to "id_") appended with the counter value.
 * 
 * Parameters:
 * prefix - {String} Optional string to prefix unique id. Default is "id_".
 *     Note that dots (".") in the prefix will be replaced with underscore ("_").
 * 
 * Returns:
 * {String} A unique id string, built on the passed in prefix.
 */
HGIS.Util.createUniqueID = function(prefix) {
	if (prefix == null) {
		prefix = "id_";
	} else {
		prefix = prefix.replace(HGIS.Util.dotless, "_");
	}
	HGIS.Util.lastSeqID += 1;
	return prefix + HGIS.Util.lastSeqID;
};

/**
 * Constant: INCHES_PER_UNIT
 * {Object} Constant inches per unit -- borrowed from MapServer mapscale.c
 * derivation of nautical miles from http://en.wikipedia.org/wiki/Nautical_mile
 * Includes the full set of units supported by CS-MAP (http://trac.osgeo.org/csmap/)
 * and PROJ.4 (http://trac.osgeo.org/proj/)
 * The hardcoded table is maintain in a CS-MAP source code module named CSdataU.c
 * The hardcoded table of PROJ.4 units are in pj_units.c.
 */
HGIS.INCHES_PER_UNIT = {
	'inches' : 1.0,
	'ft' : 12.0,
	'mi' : 63360.0,
	'm' : 39.37,
	'km' : 39370,
	'dd' : 4374754,
	'yd' : 36
};
HGIS.INCHES_PER_UNIT["in"] = HGIS.INCHES_PER_UNIT.inches;
HGIS.INCHES_PER_UNIT["degrees"] = HGIS.INCHES_PER_UNIT.dd;
HGIS.INCHES_PER_UNIT["nmi"] = 1852 * HGIS.INCHES_PER_UNIT.m;

// Units from CS-Map
HGIS.METERS_PER_INCH = 0.02540005080010160020;HGIS.Util.extend(HGIS.INCHES_PER_UNIT, {
    "Inch": HGIS.INCHES_PER_UNIT.inches,
    "Meter": 1.0 / HGIS.METERS_PER_INCH,   //EPSG:9001
    "Foot": 0.30480060960121920243 / HGIS.METERS_PER_INCH,   //EPSG:9003
    "IFoot": 0.30480000000000000000 / HGIS.METERS_PER_INCH,   //EPSG:9002
    "ClarkeFoot": 0.3047972651151 / HGIS.METERS_PER_INCH,   //EPSG:9005
    "SearsFoot": 0.30479947153867624624 / HGIS.METERS_PER_INCH,   //EPSG:9041
    "GoldCoastFoot": 0.30479971018150881758 / HGIS.METERS_PER_INCH,   //EPSG:9094
    "IInch": 0.02540000000000000000 / HGIS.METERS_PER_INCH,
    "MicroInch": 0.00002540000000000000 / HGIS.METERS_PER_INCH,
    "Mil": 0.00000002540000000000 / HGIS.METERS_PER_INCH,
    "Centimeter": 0.01000000000000000000 / HGIS.METERS_PER_INCH,
    "Kilometer": 1000.00000000000000000000 / HGIS.METERS_PER_INCH,   //EPSG:9036
    "Yard": 0.91440182880365760731 / HGIS.METERS_PER_INCH,
    "SearsYard": 0.914398414616029 / HGIS.METERS_PER_INCH,   //EPSG:9040
    "IndianYard": 0.91439853074444079983 / HGIS.METERS_PER_INCH,   //EPSG:9084
    "IndianYd37": 0.91439523 / HGIS.METERS_PER_INCH,   //EPSG:9085
    "IndianYd62": 0.9143988 / HGIS.METERS_PER_INCH,   //EPSG:9086
    "IndianYd75": 0.9143985 / HGIS.METERS_PER_INCH,   //EPSG:9087
    "IndianFoot": 0.30479951 / HGIS.METERS_PER_INCH,   //EPSG:9080
    "IndianFt37": 0.30479841 / HGIS.METERS_PER_INCH,   //EPSG:9081
    "IndianFt62": 0.3047996 / HGIS.METERS_PER_INCH,   //EPSG:9082
    "IndianFt75": 0.3047995 / HGIS.METERS_PER_INCH,   //EPSG:9083
    "Mile": 1609.34721869443738887477 / HGIS.METERS_PER_INCH,
    "IYard": 0.91440000000000000000 / HGIS.METERS_PER_INCH,   //EPSG:9096
    "IMile": 1609.34400000000000000000 / HGIS.METERS_PER_INCH,   //EPSG:9093
    "NautM": 1852.00000000000000000000 / HGIS.METERS_PER_INCH,   //EPSG:9030
    "Lat-66": 110943.316488932731 / HGIS.METERS_PER_INCH,
    "Lat-83": 110946.25736872234125 / HGIS.METERS_PER_INCH,
    "Decimeter": 0.10000000000000000000 / HGIS.METERS_PER_INCH,
    "Millimeter": 0.00100000000000000000 / HGIS.METERS_PER_INCH,
    "Dekameter": 10.00000000000000000000 / HGIS.METERS_PER_INCH,
    "Decameter": 10.00000000000000000000 / HGIS.METERS_PER_INCH,
    "Hectometer": 100.00000000000000000000 / HGIS.METERS_PER_INCH,
    "GermanMeter": 1.0000135965 / HGIS.METERS_PER_INCH,   //EPSG:9031
    "CaGrid": 0.999738 / HGIS.METERS_PER_INCH,
    "ClarkeChain": 20.1166194976 / HGIS.METERS_PER_INCH,   //EPSG:9038
    "GunterChain": 20.11684023368047 / HGIS.METERS_PER_INCH,   //EPSG:9033
    "BenoitChain": 20.116782494375872 / HGIS.METERS_PER_INCH,   //EPSG:9062
    "SearsChain": 20.11676512155 / HGIS.METERS_PER_INCH,   //EPSG:9042
    "ClarkeLink": 0.201166194976 / HGIS.METERS_PER_INCH,   //EPSG:9039
    "GunterLink": 0.2011684023368047 / HGIS.METERS_PER_INCH,   //EPSG:9034
    "BenoitLink": 0.20116782494375872 / HGIS.METERS_PER_INCH,   //EPSG:9063
    "SearsLink": 0.2011676512155 / HGIS.METERS_PER_INCH,   //EPSG:9043
    "Rod": 5.02921005842012 / HGIS.METERS_PER_INCH,
    "IntnlChain": 20.1168 / HGIS.METERS_PER_INCH,   //EPSG:9097
    "IntnlLink": 0.201168 / HGIS.METERS_PER_INCH,   //EPSG:9098
    "Perch": 5.02921005842012 / HGIS.METERS_PER_INCH,
    "Pole": 5.02921005842012 / HGIS.METERS_PER_INCH,
    "Furlong": 201.1684023368046 / HGIS.METERS_PER_INCH,
    "Rood": 3.778266898 / HGIS.METERS_PER_INCH,
    "CapeFoot": 0.3047972615 / HGIS.METERS_PER_INCH,
    "Brealey": 375.00000000000000000000 / HGIS.METERS_PER_INCH,
    "ModAmFt": 0.304812252984505969011938 / HGIS.METERS_PER_INCH,
    "Fathom": 1.8288 / HGIS.METERS_PER_INCH,
    "NautM-UK": 1853.184 / HGIS.METERS_PER_INCH,
    "50kilometers": 50000.0 / HGIS.METERS_PER_INCH,
    "150kilometers": 150000.0 / HGIS.METERS_PER_INCH
});

//unit abbreviations supported by PROJ.4
HGIS.Util.extend(HGIS.INCHES_PER_UNIT, {
    "mm": HGIS.INCHES_PER_UNIT["Meter"] / 1000.0,
    "cm": HGIS.INCHES_PER_UNIT["Meter"] / 100.0,
    "dm": HGIS.INCHES_PER_UNIT["Meter"] * 100.0,
    "km": HGIS.INCHES_PER_UNIT["Meter"] * 1000.0,
    "kmi": HGIS.INCHES_PER_UNIT["nmi"],    //International Nautical Mile
    "fath": HGIS.INCHES_PER_UNIT["Fathom"], //International Fathom
    "ch": HGIS.INCHES_PER_UNIT["IntnlChain"],  //International Chain
    "link": HGIS.INCHES_PER_UNIT["IntnlLink"], //International Link
    "us-in": HGIS.INCHES_PER_UNIT["inches"], //U.S. Surveyor's Inch
    "us-ft": HGIS.INCHES_PER_UNIT["Foot"], //U.S. Surveyor's Foot
    "us-yd": HGIS.INCHES_PER_UNIT["Yard"], //U.S. Surveyor's Yard
    "us-ch": HGIS.INCHES_PER_UNIT["GunterChain"], //U.S. Surveyor's Chain
    "us-mi": HGIS.INCHES_PER_UNIT["Mile"],   //U.S. Surveyor's Statute Mile
    "ind-yd": HGIS.INCHES_PER_UNIT["IndianYd37"],  //Indian Yard
    "ind-ft": HGIS.INCHES_PER_UNIT["IndianFt37"],  //Indian Foot
    "ind-ch": 20.11669506 / HGIS.METERS_PER_INCH  //Indian Chain
});

/** 
 * Constant: DOTS_PER_INCH
 * {Integer} 72 (A sensible default)
 */
HGIS.DOTS_PER_INCH = 72;

/**
 * Function: normalizeScale
 * 
 * Parameters:
 * scale - {float}
 * 
 * Returns:
 * {Float} A normalized scale value, in 1 / X format. 
 *         This means that if a value less than one ( already 1/x) is passed
 *         in, it just returns scale directly. Otherwise, it returns 
 *         1 / scale
 */
HGIS.Util.normalizeScale = function (scale) {
    var normScale = (scale > 1.0) ? (1.0 / scale) 
                                  : scale;
    return normScale;
};

/**
 * Function: getResolutionFromScale
 * 
 * Parameters:
 * scale - {Float}
 * units - {String} Index into HGIS.INCHES_PER_UNIT hashtable.
 *                  Default is degrees
 * 
 * Returns:
 * {Float} The corresponding resolution given passed-in scale and unit 
 *     parameters.  If the given scale is falsey, the returned resolution will
 *     be undefined.
 */
HGIS.Util.getResolutionFromScale = function (scale, units) {
    var resolution;
    if (scale) {
        if (units == null) {
            units = "degrees";
        }
        var normScale = HGIS.Util.normalizeScale(scale);
        resolution = 1 / (normScale * HGIS.INCHES_PER_UNIT[units]
                                        * HGIS.DOTS_PER_INCH);        
    }
    return resolution;
};

/**
 * Function: getScaleFromResolution
 * 
 * Parameters:
 * resolution - {Float}
 * units - {String} Index into HGIS.INCHES_PER_UNIT hashtable.
 *                  Default is degrees
 * 
 * Returns:
 * {Float} The corresponding scale given passed-in resolution and unit 
 *         parameters.
 */
HGIS.Util.getScaleFromResolution = function (resolution, units) {

    if (units == null) {
        units = "degrees";
    }

    var scale = resolution * HGIS.INCHES_PER_UNIT[units] *
                    HGIS.DOTS_PER_INCH;
    return scale;
};

/**
 * Function: pagePosition
 * Calculates the position of an element on the page (see
 * http://code.google.com/p/doctype/wiki/ArticlePageOffset)
 *
 * HGIS.Util.pagePosition is based on Yahoo's getXY method, which is
 * Copyright (c) 2006, Yahoo! Inc.
 * All rights reserved.
 * 
 * Redistribution and use of this software in source and binary forms, with or
 * without modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * Neither the name of Yahoo! Inc. nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission of Yahoo! Inc.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Parameters:
 * forElement - {DOMElement}
 * 
 * Returns:
 * {Array} two item array, Left value then Top value.
 */
HGIS.Util.pagePosition =  function(forElement) {
    // NOTE: If element is hidden (display none or disconnected or any the
    // ancestors are hidden) we get (0,0) by default but we still do the
    // accumulation of scroll position.

    var pos = [0, 0];
    var viewportElement = HGIS.Util.getViewportElement();
    if (!forElement || forElement == window || forElement == viewportElement) {
        // viewport is always at 0,0 as that defined the coordinate system for
        // this function - this avoids special case checks in the code below
        return pos;
    }

    // Gecko browsers normally use getBoxObjectFor to calculate the position.
    // When invoked for an element with an implicit absolute position though it
    // can be off by one. Therefore the recursive implementation is used in
    // those (relatively rare) cases.
    var BUGGY_GECKO_BOX_OBJECT =
        HGIS.IS_GECKO && document.getBoxObjectFor &&
        HGIS.Element.getStyle(forElement, 'position') == 'absolute' &&
        (forElement.style.top == '' || forElement.style.left == '');

    var parent = null;
    var box;

    if (forElement.getBoundingClientRect) { // IE
        box = forElement.getBoundingClientRect();
        var scrollTop = window.pageYOffset || viewportElement.scrollTop;
        var scrollLeft = window.pageXOffset || viewportElement.scrollLeft;
        
        pos[0] = box.left + scrollLeft;
        pos[1] = box.top + scrollTop;

    } else if (document.getBoxObjectFor && !BUGGY_GECKO_BOX_OBJECT) { // gecko
        // Gecko ignores the scroll values for ancestors, up to 1.9.  See:
        // https://bugzilla.mozilla.org/show_bug.cgi?id=328881 and
        // https://bugzilla.mozilla.org/show_bug.cgi?id=330619

        box = document.getBoxObjectFor(forElement);
        var vpBox = document.getBoxObjectFor(viewportElement);
        pos[0] = box.screenX - vpBox.screenX;
        pos[1] = box.screenY - vpBox.screenY;

    } else { // safari/opera
        pos[0] = forElement.offsetLeft;
        pos[1] = forElement.offsetTop;
        parent = forElement.offsetParent;
        if (parent != forElement) {
            while (parent) {
                pos[0] += parent.offsetLeft;
                pos[1] += parent.offsetTop;
                parent = parent.offsetParent;
            }
        }

        var browser = HGIS.BROWSER_NAME;

        // opera & (safari absolute) incorrectly account for body offsetTop
        if (browser == "opera" || (browser == "safari" &&
              HGIS.Element.getStyle(forElement, 'position') == 'absolute')) {
            pos[1] -= document.body.offsetTop;
        }

        // accumulate the scroll positions for everything but the body element
        parent = forElement.offsetParent;
        while (parent && parent != document.body) {
            pos[0] -= parent.scrollLeft;
            // see https://bugs.opera.com/show_bug.cgi?id=249965
            if (browser != "opera" || parent.tagName != 'TR') {
                pos[1] -= parent.scrollTop;
            }
            parent = parent.offsetParent;
        }
    }
    
    return pos;
};

/**
 * Function: getViewportElement
 * Returns die viewport element of the document. The viewport element is
 * usually document.documentElement, except in IE,where it is either
 * document.body or document.documentElement, depending on the document's
 * compatibility mode (see
 * http://code.google.com/p/doctype/wiki/ArticleClientViewportElement)
 *
 * Returns:
 * {DOMElement}
 */
HGIS.Util.getViewportElement = function() {
//	 var viewportElement = arguments.callee.viewportElement;
//    if (viewportElement == undefined) {
	 var viewportElement = HGIS.Util.getViewportElement.prototype.viewportElement;
	 if (viewportElement == undefined) {
        viewportElement = (HGIS.BROWSER_NAME == "msie" &&
            document.compatMode != 'CSS1Compat') ? document.body :
            document.documentElement;
        HGIS.Util.getViewportElement.prototype.viewportElement = viewportElement;
    }
    return viewportElement;
};

/** 
 * Function: isEquivalentUrl
 * Test two URLs for equivalence. 
 * 
 * Setting 'ignoreCase' allows for case-independent comparison.
 * 
 * Comparison is based on: 
 *  - Protocol
 *  - Host (evaluated without the port)
 *  - Port (set 'ignorePort80' to ignore "80" values)
 *  - Hash ( set 'ignoreHash' to disable)
 *  - Pathname (for relative <-> absolute comparison) 
 *  - Arguments (so they can be out of order)
 *  
 * Parameters:
 * url1 - {String}
 * url2 - {String}
 * options - {Object} Allows for customization of comparison:
 *                    'ignoreCase' - Default is True
 *                    'ignorePort80' - Default is True
 *                    'ignoreHash' - Default is True
 *
 * Returns:
 * {Boolean} Whether or not the two URLs are equivalent
 */
HGIS.Util.isEquivalentUrl = function(url1, url2, options) {
    options = options || {};

    HGIS.Util.applyDefaults(options, {
        ignoreCase: true,
        ignorePort80: true,
        ignoreHash: true,
        splitArgs: false
    });

    var urlObj1 = HGIS.Util.createUrlObject(url1, options);
    var urlObj2 = HGIS.Util.createUrlObject(url2, options);

    //compare all keys except for "args" (treated below)
    for(var key in urlObj1) {
        if(key !== "args") {
            if(urlObj1[key] != urlObj2[key]) {
                return false;
            }
        }
    }

    // compare search args - irrespective of order
    for(var key in urlObj1.args) {
        if(urlObj1.args[key] != urlObj2.args[key]) {
            return false;
        }
        delete urlObj2.args[key];
    }
    // urlObj2 shouldn't have any args left
    for(var key in urlObj2.args) {
        return false;
    }
    
    return true;
};

/**
 * Function: createUrlObject
 * 
 * Parameters:
 * url - {String}
 * options - {Object} A hash of options.
 *
 * Valid options:
 *   ignoreCase - {Boolean} lowercase url,
 *   ignorePort80 - {Boolean} don't include explicit port if port is 80,
 *   ignoreHash - {Boolean} Don't include part of url after the hash (#).
 *   splitArgs - {Boolean} Split comma delimited params into arrays? Default is
 *       true.
 * 
 * Returns:
 * {Object} An object with separate url, a, port, host, and args parsed out 
 *          and ready for comparison
 */
HGIS.Util.createUrlObject = function(url, options) {
    options = options || {};

    // deal with relative urls first
    if(!(/^\w+:\/\//).test(url)) {
        var loc = window.location;
        var port = loc.port ? ":" + loc.port : "";
        var fullUrl = loc.protocol + "//" + loc.host.split(":").shift() + port;
        if(url.indexOf("/") === 0) {
            // full pathname
            url = fullUrl + url;
        } else {
            // relative to current path
            var parts = loc.pathname.split("/");
            parts.pop();
            url = fullUrl + parts.join("/") + "/" + url;
        }
    }
  
    if (options.ignoreCase) {
        url = url.toLowerCase(); 
    }

    var a = document.createElement('a');
    a.href = url;
    
    var urlObject = {};
    
    //host (without port)
    urlObject.host = a.host.split(":").shift();

    //protocol
    urlObject.protocol = a.protocol;  

    //port (get uniform browser behavior with port 80 here)
    if(options.ignorePort80) {
        urlObject.port = (a.port == "80" || a.port == "0") ? "" : a.port;
    } else {
        urlObject.port = (a.port == "" || a.port == "0") ? "80" : a.port;
    }

    //hash
    urlObject.hash = (options.ignoreHash || a.hash === "#") ? "" : a.hash;  
    
    //args
    var queryString = a.search;
    if (!queryString) {
        var qMark = url.indexOf("?");
        queryString = (qMark != -1) ? url.substr(qMark) : "";
    }
    urlObject.args = HGIS.Util.getParameters(queryString,
            {splitArgs: options.splitArgs});

    // pathname
    //
    // This is a workaround for Internet Explorer where
    // window.location.pathname has a leading "/", but
    // a.pathname has no leading "/".
    urlObject.pathname = (a.pathname.charAt(0) == "/") ? a.pathname : "/" + a.pathname;
    
    return urlObject; 
};
 
/**
 * Function: removeTail
 * Takes a url and removes everything after the ? and #
 * 
 * Parameters:
 * url - {String} The url to process
 * 
 * Returns:
 * {String} The string with all queryString and Hash removed
 */
HGIS.Util.removeTail = function(url) {
    var head = null;
    
    var qMark = url.indexOf("?");
    var hashMark = url.indexOf("#");

    if (qMark == -1) {
        head = (hashMark != -1) ? url.substr(0,hashMark) : url;
    } else {
        head = (hashMark != -1) ? url.substr(0,Math.min(qMark, hashMark)) 
                                  : url.substr(0, qMark);
    }
    return head;
};

/**
 * Constant: IS_GECKO
 * {Boolean} True if the userAgent reports the browser to use the Gecko engine
 */
HGIS.IS_GECKO = (function() {
    var ua = navigator.userAgent.toLowerCase();
    return ua.indexOf("webkit") == -1 && ua.indexOf("gecko") != -1;
})();

/**
 * Constant: CANVAS_SUPPORTED
 * {Boolean} True if canvas 2d is supported.
 */
HGIS.CANVAS_SUPPORTED = (function() {
    var elem = document.createElement('canvas');
    return !!(elem.getContext && elem.getContext('2d'));
})();

/**
 * Constant: BROWSER_NAME
 * {String}
 * A substring of the navigator.userAgent property.  Depending on the userAgent
 *     property, this will be the empty string or one of the following:
 *     * "opera" -- Opera
 *     * "msie"  -- Internet Explorer
 *     * "safari" -- Safari
 *     * "firefox" -- Firefox
 *     * "mozilla" -- Mozilla
 */
HGIS.BROWSER_NAME = (function() {
    var name = "";
    var ua = navigator.userAgent.toLowerCase();
    if (ua.indexOf("opera") != -1) {
        name = "opera";
    } else if (ua.indexOf("msie") != -1) {
        name = "msie";
    } else if (ua.indexOf("safari") != -1) {
        name = "safari";
    } else if (ua.indexOf("mozilla") != -1) {
        if (ua.indexOf("firefox") != -1) {
            name = "firefox";
        } else {
            name = "mozilla";
        }
    }
    return name;
})();

/**
 * Function: getBrowserName
 * 
 * Returns:
 * {String} A string which specifies which is the current 
 *          browser in which we are running. 
 * 
 *          Currently-supported browser detection and codes:
 *           * 'opera' -- Opera
 *           * 'msie'  -- Internet Explorer
 *           * 'safari' -- Safari
 *           * 'firefox' -- Firefox
 *           * 'mozilla' -- Mozilla
 * 
 *          If we are unable to property identify the browser, we 
 *           return an empty string.
 */
HGIS.Util.getBrowserName = function() {
    return HGIS.BROWSER_NAME;
};

/**
 * Method: getRenderedDimensions
 * Renders the contentHTML offscreen to determine actual dimensions for
 *     popup sizing. As we need layout to determine dimensions the content
 *     is rendered -9999px to the left and absolute to ensure the 
 *     scrollbars do not flicker
 *     
 * Parameters:
 * contentHTML
 * size - {<HGIS.Size>} If either the 'w' or 'h' properties is 
 *     specified, we fix that dimension of the div to be measured. This is 
 *     useful in the case where we have a limit in one dimension and must 
 *     therefore meaure the flow in the other dimension.
 * options - {Object}
 *
 * Allowed Options:
 *     displayClass - {String} Optional parameter.  A CSS class name(s) string
 *         to provide the CSS context of the rendered content.
 *     containerElement - {DOMElement} Optional parameter. Insert the HTML to 
 *         this node instead of the body root when calculating dimensions. 
 * 
 * Returns:
 * {<HGIS.Size>}
 */
HGIS.Util.getRenderedDimensions = function(contentHTML, size, options) {
    
    var w, h;
    
    // create temp container div with restricted size
    var container = document.createElement("div");
    container.style.visibility = "hidden";
        
    var containerElement = (options && options.containerElement) 
        ? options.containerElement : document.body;
    
    // Opera and IE7 can't handle a node with position:aboslute if it inherits
    // position:absolute from a parent.
    var parentHasPositionAbsolute = false;
    var superContainer = null;
    var parent = containerElement;
    while (parent && parent.tagName.toLowerCase()!="body") {
        var parentPosition = HGIS.Element.getStyle(parent, "position");
        if(parentPosition == "absolute") {
            parentHasPositionAbsolute = true;
            break;
        } else if (parentPosition && parentPosition != "static") {
            break;
        }
        parent = parent.parentNode;
    }
    if(parentHasPositionAbsolute && (containerElement.clientHeight === 0 || 
                                     containerElement.clientWidth === 0) ){
        superContainer = document.createElement("div");
        superContainer.style.visibility = "hidden";
        superContainer.style.position = "absolute";
        superContainer.style.overflow = "visible";
        superContainer.style.width = document.body.clientWidth + "px";
        superContainer.style.height = document.body.clientHeight + "px";
        superContainer.appendChild(container);
    }
    container.style.position = "absolute";

    //fix a dimension, if specified.
    if (size) {
        if (size.w) {
            w = size.w;
            container.style.width = w + "px";
        } else if (size.h) {
            h = size.h;
            container.style.height = h + "px";
        }
    }

    //add css classes, if specified
    if (options && options.displayClass) {
        container.className = options.displayClass;
    }
    
    // create temp content div and assign content
    var content = document.createElement("div");
    content.innerHTML = contentHTML;
    
    // we need overflow visible when calculating the size
    content.style.overflow = "visible";
    if (content.childNodes) {
        for (var i=0, l=content.childNodes.length; i<l; i++) {
            if (!content.childNodes[i].style) continue;
            content.childNodes[i].style.overflow = "visible";
        }
    }
    
    // add content to restricted container 
    container.appendChild(content);
    
    // append container to body for rendering
    if (superContainer) {
        containerElement.appendChild(superContainer);
    } else {
        containerElement.appendChild(container);
    }
    
    // calculate scroll width of content and add corners and shadow width
    if (!w) {
        w = parseInt(content.scrollWidth);
    
        // update container width to allow height to adjust
        container.style.width = w + "px";
    }        
    // capture height and add shadow and corner image widths
    if (!h) {
        h = parseInt(content.scrollHeight);
    }

    // remove elements
    container.removeChild(content);
    if (superContainer) {
        superContainer.removeChild(container);
        containerElement.removeChild(superContainer);
    } else {
        containerElement.removeChild(container);
    }
    
    return new HGIS.Size(w, h);
};

/**
 * APIFunction: getScrollbarWidth
 * This function has been modified by the HGIS from the original version,
 *     written by Matthew Eernisse and released under the Apache 2 
 *     license here:
 * 
 *     http://www.fleegix.org/articles/2006/05/30/getting-the-scrollbar-width-in-pixels
 * 
 *     It has been modified simply to cache its value, since it is physically 
 *     impossible that this code could ever run in more than one browser at 
 *     once. 
 * 
 * Returns:
 * {Integer}
 */
HGIS.Util.getScrollbarWidth = function() {
    
    var scrollbarWidth = HGIS.Util._scrollbarWidth;
    
    if (scrollbarWidth == null) {
        var scr = null;
        var inn = null;
        var wNoScroll = 0;
        var wScroll = 0;
    
        // Outer scrolling div
        scr = document.createElement('div');
        scr.style.position = 'absolute';
        scr.style.top = '-1000px';
        scr.style.left = '-1000px';
        scr.style.width = '100px';
        scr.style.height = '50px';
        // Start with no scrollbar
        scr.style.overflow = 'hidden';
    
        // Inner content div
        inn = document.createElement('div');
        inn.style.width = '100%';
        inn.style.height = '200px';
    
        // Put the inner div in the scrolling div
        scr.appendChild(inn);
        // Append the scrolling div to the doc
        document.body.appendChild(scr);
    
        // Width of the inner div sans scrollbar
        wNoScroll = inn.offsetWidth;
    
        // Add the scrollbar
        scr.style.overflow = 'scroll';
        // Width of the inner div width scrollbar
        wScroll = inn.offsetWidth;
    
        // Remove the scrolling div from the doc
        document.body.removeChild(document.body.lastChild);
    
        // Pixel width of the scroller
        HGIS.Util._scrollbarWidth = (wNoScroll - wScroll);
        scrollbarWidth = HGIS.Util._scrollbarWidth;
    }

    return scrollbarWidth;
};

/**
 * APIFunction: getFormattedLonLat
 * This function will return latitude or longitude value formatted as 
 *
 * Parameters:
 * coordinate - {Float} the coordinate value to be formatted
 * axis - {String} value of either 'lat' or 'lon' to indicate which axis is to
 *          to be formatted (default = lat)
 * dmsOption - {String} specify the precision of the output can be one of:
 *           'dms' show degrees minutes and seconds
 *           'dm' show only degrees and minutes
 *           'd' show only degrees
 * 
 * Returns:
 * {String} the coordinate value formatted as a string
 */
HGIS.Util.getFormattedLonLat = function(coordinate, axis, dmsOption) {
    if (!dmsOption) {
        dmsOption = 'dms';    //default to show degree, minutes, seconds
    }

    coordinate = (coordinate+540)%360 - 180; // normalize for sphere being round

    var abscoordinate = Math.abs(coordinate);
    var coordinatedegrees = Math.floor(abscoordinate);

    var coordinateminutes = (abscoordinate - coordinatedegrees)/(1/60);
    var tempcoordinateminutes = coordinateminutes;
    coordinateminutes = Math.floor(coordinateminutes);
    var coordinateseconds = (tempcoordinateminutes - coordinateminutes)/(1/60);
    coordinateseconds =  Math.round(coordinateseconds*10);
    coordinateseconds /= 10;

    if( coordinateseconds >= 60) { 
        coordinateseconds -= 60; 
        coordinateminutes += 1; 
        if( coordinateminutes >= 60) { 
            coordinateminutes -= 60; 
            coordinatedegrees += 1; 
        } 
    }
    
    if( coordinatedegrees < 10 ) {
        coordinatedegrees = "0" + coordinatedegrees;
    }
    var str = coordinatedegrees + "\u00B0";

    if (dmsOption.indexOf('dm') >= 0) {
        if( coordinateminutes < 10 ) {
            coordinateminutes = "0" + coordinateminutes;
        }
        str += coordinateminutes + "'";
  
        if (dmsOption.indexOf('dms') >= 0) {
            if( coordinateseconds < 10 ) {
                coordinateseconds = "0" + coordinateseconds;
            }
            str += coordinateseconds + '"';
        }
    }
    
    if (axis == "lon") {
        str += coordinate < 0 ? HGIS.i18n("W") : HGIS.i18n("E");
    } else {
        str += coordinate < 0 ? HGIS.i18n("S") : HGIS.i18n("N");
    }
    return str;
};

/* ======================================================================
    HGIS/Format.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Util.js
 */

/**
 * Class: HGIS.Format
 * Base class for format reading/writing a variety of formats.  Subclasses
 *     of HGIS.Format are expected to have read and write methods.
 */
HGIS.Format = HGIS.Class({
    
    /**
     * Property: options
     * {Object} A reference to options passed to the constructor.
     */
    options: null,
    
    /**
     * APIProperty: externalProjection
     * {<HGIS.Projection>} When passed a externalProjection and
     *     internalProjection, the format will reproject the geometries it
     *     reads or writes. The externalProjection is the projection used by
     *     the content which is passed into read or which comes out of write.
     *     In order to reproject, a projection transformation function for the
     *     specified projections must be available. This support may be 
     *     provided via proj4js or via a custom transformation function. See
     *     {<HGIS.Projection.addTransform>} for more information on
     *     custom transformations.
     */
    externalProjection: null,

    /**
     * APIProperty: internalProjection
     * {<HGIS.Projection>} When passed a externalProjection and
     *     internalProjection, the format will reproject the geometries it
     *     reads or writes. The internalProjection is the projection used by
     *     the geometries which are returned by read or which are passed into
     *     write.  In order to reproject, a projection transformation function
     *     for the specified projections must be available. This support may be
     *     provided via proj4js or via a custom transformation function. See
     *     {<HGIS.Projection.addTransform>} for more information on
     *     custom transformations.
     */
    internalProjection: null,

    /**
     * APIProperty: data
     * {Object} When <keepData> is true, this is the parsed string sent to
     *     <read>.
     */
    data: null,

    /**
     * APIProperty: keepData
     * {Object} Maintain a reference (<data>) to the most recently read data.
     *     Default is false.
     */
    keepData: false,

    /**
     * Constructor: HGIS.Format
     * Instances of this class are not useful.  See one of the subclasses.
     *
     * Parameters:
     * options - {Object} An optional object with properties to set on the
     *           format
     *
     * Valid options:
     * keepData - {Boolean} If true, upon <read>, the data property will be
     *     set to the parsed object (e.g. the json or xml object).
     *
     * Returns:
     * An instance of HGIS.Format
     */
    initialize: function(options) {
        HGIS.Util.extend(this, options);
        this.options = options;
    },
    
    /**
     * APIMethod: destroy
     * Clean up.
     */
    destroy: function() {
    },

    /**
     * Method: read
     * Read data from a string, and return an object whose type depends on the
     * subclass. 
     * 
     * Parameters:
     * data - {string} Data to read/parse.
     *
     * Returns:
     * Depends on the subclass
     */
    read: function(data) {
        throw new Error('Read not implemented.');
    },
    
    /**
     * Method: write
     * Accept an object, and return a string. 
     *
     * Parameters:
     * object - {Object} Object to be serialized
     *
     * Returns:
     * {String} A string representation of the object.
     */
    write: function(object) {
        throw new Error('Write not implemented.');
    },

    CLASS_NAME: "HGIS.Format"
});     
/* ======================================================================
    HGIS/Format/CSWGetRecords.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format.js
 */

/**
 * Class: HGIS.Format.CSWGetRecords
 * Default version is 2.0.2.
 *
 * Returns:
 * {<HGIS.Format>} A CSWGetRecords format of the given version.
 */
HGIS.Format.CSWGetRecords = function(options) {
    options = HGIS.Util.applyDefaults(
        options, HGIS.Format.CSWGetRecords.DEFAULTS
    );
    var cls = HGIS.Format.CSWGetRecords["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported CSWGetRecords version: " + options.version;
    }
    return new cls(options);
};

/**
 * Constant: DEFAULTS
 * {Object} Default properties for the CSWGetRecords format.
 */
HGIS.Format.CSWGetRecords.DEFAULTS = {
    "version": "2.0.2"
};
/* ======================================================================
    HGIS/Control.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 */

/**
 * Class: HGIS.Control
 * Controls affect the display or behavior of the map. They allow everything
 * from panning and zooming to displaying a scale indicator. Controls by 
 * default are added to the map they are contained within however it is
 * possible to add a control to an external div by passing the div in the
 * options parameter.
 * 
 * Example:
 * The following example shows how to add many of the common controls
 * to a map.
 * 
 * > var map = new HGIS.Map('map', { controls: [] });
 * >
 * > map.addControl(new HGIS.Control.PanZoomBar());
 * > map.addControl(new HGIS.Control.LayerSwitcher({'ascending':false}));
 * > map.addControl(new HGIS.Control.Permalink());
 * > map.addControl(new HGIS.Control.Permalink('permalink'));
 * > map.addControl(new HGIS.Control.MousePosition());
 * > map.addControl(new HGIS.Control.OverviewMap());
 * > map.addControl(new HGIS.Control.KeyboardDefaults());
 *
 * The next code fragment is a quick example of how to intercept 
 * shift-mouse click to display the extent of the bounding box
 * dragged out by the user.  Usually controls are not created
 * in exactly this manner.  See the source for a more complete 
 * example:
 *
 * > var control = new HGIS.Control();
 * > HGIS.Util.extend(control, {
 * >     draw: function () {
 * >         // this Handler.Box will intercept the shift-mousedown
 * >         // before Control.MouseDefault gets to see it
 * >         this.box = new HGIS.Handler.Box( control, 
 * >             {"done": this.notice},
 * >             {keyMask: HGIS.Handler.MOD_SHIFT});
 * >         this.box.activate();
 * >     },
 * >
 * >     notice: function (bounds) {
 * >         HGIS.Console.userError(bounds);
 * >     }
 * > }); 
 * > map.addControl(control);
 * 
 */
HGIS.Control = HGIS.Class({

    /** 
     * Property: id 
     * {String} 
     */
    id: null,
    
    /** 
     * Property: map 
     * {<HGIS.Map>} this gets set in the addControl() function in
     * HGIS.Map 
     */
    map: null,

    /** 
     * APIProperty: div 
     * {DOMElement} The element that contains the control, if not present the 
     *     control is placed inside the map.
     */
    div: null,

    /** 
     * APIProperty: type 
     * {Number} Controls can have a 'type'. The type determines the type of
     * interactions which are possible with them when they are placed in an
     * <HGIS.Control.Panel>. 
     */
    type: null, 

    /** 
     * Property: allowSelection
     * {Boolean} By default, controls do not allow selection, because
     * it may interfere with map dragging. If this is true, HGIS
     * will not prevent selection of the control.
     * Default is false.
     */
    allowSelection: false,  

    /** 
     * Property: displayClass 
     * {string}  This property is used for CSS related to the drawing of the
     * Control. 
     */
    displayClass: "",
    
    /**
    * APIProperty: title  
    * {string}  This property is used for showing a tooltip over the  
    * Control.  
    */ 
    title: "",

    /**
     * APIProperty: autoActivate
     * {Boolean} Activate the control when it is added to a map.  Default is
     *     false.
     */
    autoActivate: false,

    /** 
     * APIProperty: active 
     * {Boolean} The control is active (read-only).  Use <activate> and 
     *     <deactivate> to change control state.
     */
    active: null,

    /**
     * Property: handlerOptions
     * {Object} Used to set non-default properties on the control's handler
     */
    handlerOptions: null,

    /** 
     * Property: handler 
     * {<HGIS.Handler>} null
     */
    handler: null,

    /**
     * APIProperty: eventListeners
     * {Object} If set as an option at construction, the eventListeners
     *     object will be registered with <HGIS.Events.on>.  Object
     *     structure must be a listeners object as shown in the example for
     *     the events.on method.
     */
    eventListeners: null,

    /** 
     * APIProperty: events
     * {<HGIS.Events>} Events instance for listeners and triggering
     *     control specific events.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * Listeners will be called with a reference to an event object.  The
     *     properties of this event depends on exactly what happened.
     *
     * All event objects have at least the following properties:
     * object - {Object} A reference to control.events.object (a reference
     *      to the control).
     * element - {DOMElement} A reference to control.events.element (which
     *      will be null unless documented otherwise).
     *
     * Supported map event types:
     * activate - Triggered when activated.
     * deactivate - Triggered when deactivated.
     */
    events: null,

    /**
     * Constructor: HGIS.Control
     * Create an HGIS Control.  The options passed as a parameter
     * directly extend the control.  For example passing the following:
     * 
     * > var control = new HGIS.Control({div: myDiv});
     *
     * Overrides the default div attribute value of null.
     * 
     * Parameters:
     * options - {Object} 
     */
    initialize: function (options) {
        // We do this before the extend so that instances can override
        // className in options.
        this.displayClass = 
            this.CLASS_NAME.replace("HGIS.", "ol").replace(/\./g, "");
        
        HGIS.Util.extend(this, options);
        
        this.events = new HGIS.Events(this);
        if(this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
        if (this.id == null) {
            this.id = HGIS.Util.createUniqueID(this.CLASS_NAME + "_");
        }
    },

    /**
     * Method: destroy
     * The destroy method is used to perform any clean up before the control
     * is dereferenced.  Typically this is where event listeners are removed
     * to prevent memory leaks.
     */
    destroy: function () {
        if(this.events) {
            if(this.eventListeners) {
                this.events.un(this.eventListeners);
            }
            this.events.destroy();
            this.events = null;
        }
        this.eventListeners = null;

        // eliminate circular references
        if (this.handler) {
            this.handler.destroy();
            this.handler = null;
        }
        if(this.handlers) {
            for(var key in this.handlers) {
                if(this.handlers.hasOwnProperty(key) &&
                   typeof this.handlers[key].destroy == "function") {
                    this.handlers[key].destroy();
                }
            }
            this.handlers = null;
        }
        if (this.map) {
            this.map.removeControl(this);
            this.map = null;
        }
        this.div = null;
    },

    /** 
     * Method: setMap
     * Set the map property for the control. This is done through an accessor
     * so that subclasses can override this and take special action once 
     * they have their map variable set. 
     *
     * Parameters:
     * map - {<HGIS.Map>} 
     */
    setMap: function(map) {
        this.map = map;
        if (this.handler) {
            this.handler.setMap(map);
        }
    },
  
    /**
     * Method: draw
     * The draw method is called when the control is ready to be displayed
     * on the page.  If a div has not been created one is created.  Controls
     * with a visual component will almost always want to override this method 
     * to customize the look of control. 
     *
     * Parameters:
     * px - {<HGIS.Pixel>} The top-left pixel position of the control
     *      or null.
     *
     * Returns:
     * {DOMElement} A reference to the DIV DOMElement containing the control
     */
    draw: function (px) {
        if (this.div == null) {
            this.div = HGIS.Util.createDiv(this.id);
            this.div.className = this.displayClass;
            if (!this.allowSelection) {
                this.div.className += " olControlNoSelect";
                this.div.setAttribute("unselectable", "on", 0);
                this.div.onselectstart = HGIS.Function.False; 
            }    
            if (this.title != "") {
                this.div.title = this.title;
            }
        }
        if (px != null) {
            this.position = px.clone();
        }
        this.moveTo(this.position);
        return this.div;
    },

    /**
     * Method: moveTo
     * Sets the left and top style attributes to the passed in pixel 
     * coordinates.
     *
     * Parameters:
     * px - {<HGIS.Pixel>}
     */
    moveTo: function (px) {
        if ((px != null) && (this.div != null)) {
            this.div.style.left = px.x + "px";
            this.div.style.top = px.y + "px";
        }
    },

    /**
     * APIMethod: activate
     * Explicitly activates a control and it's associated
     * handler if one has been set.  Controls can be
     * deactivated by calling the deactivate() method.
     * 
     * Returns:
     * {Boolean}  True if the control was successfully activated or
     *            false if the control was already active.
     */
    activate: function () {
        if (this.active) {
            return false;
        }
        if (this.handler) {
            this.handler.activate();
        }
        this.active = true;
        if(this.map) {
            HGIS.Element.addClass(
                this.map.viewPortDiv,
                this.displayClass.replace(/ /g, "") + "Active"
            );
        }
        this.events.triggerEvent("activate");
        return true;
    },
    
    /**
     * APIMethod: deactivate
     * Deactivates a control and it's associated handler if any.  The exact
     * effect of this depends on the control itself.
     * 
     * Returns:
     * {Boolean} True if the control was effectively deactivated or false
     *           if the control was already inactive.
     */
    deactivate: function () {
        if (this.active) {
            if (this.handler) {
                this.handler.deactivate();
            }
            this.active = false;
            if(this.map) {
                HGIS.Element.removeClass(
                    this.map.viewPortDiv,
                    this.displayClass.replace(/ /g, "") + "Active"
                );
            }
            this.events.triggerEvent("deactivate");
            return true;
        }
        return false;
    },

    CLASS_NAME: "HGIS.Control"
});

/**
 * Constant: HGIS.Control.TYPE_BUTTON
 */
HGIS.Control.TYPE_BUTTON = 1;

/**
 * Constant: HGIS.Control.TYPE_TOGGLE
 */
HGIS.Control.TYPE_TOGGLE = 2;

/**
 * Constant: HGIS.Control.TYPE_TOOL
 */
HGIS.Control.TYPE_TOOL   = 3;
/* ======================================================================
    HGIS/Events.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Util.js
 */

/**
 * Namespace: HGIS.Event
 * Utility functions for event handling.
 */
HGIS.Event = {

    /** 
     * Property: observers 
     * {Object} A hashtable cache of the event observers. Keyed by
     * element._eventCacheID 
     */
    observers: false,

    /**
     * Constant: KEY_SPACE
     * {int}
     */
    KEY_SPACE: 32,
    
    /** 
     * Constant: KEY_BACKSPACE 
     * {int} 
     */
    KEY_BACKSPACE: 8,

    /** 
     * Constant: KEY_TAB 
     * {int} 
     */
    KEY_TAB: 9,

    /** 
     * Constant: KEY_RETURN 
     * {int} 
     */
    KEY_RETURN: 13,

    /** 
     * Constant: KEY_ESC 
     * {int} 
     */
    KEY_ESC: 27,

    /** 
     * Constant: KEY_LEFT 
     * {int} 
     */
    KEY_LEFT: 37,

    /** 
     * Constant: KEY_UP 
     * {int} 
     */
    KEY_UP: 38,

    /** 
     * Constant: KEY_RIGHT 
     * {int} 
     */
    KEY_RIGHT: 39,

    /** 
     * Constant: KEY_DOWN 
     * {int} 
     */
    KEY_DOWN: 40,

    /** 
     * Constant: KEY_DELETE 
     * {int} 
     */
    KEY_DELETE: 46,


    /**
     * Method: element
     * Cross browser event element detection.
     * 
     * Parameters:
     * event - {Event} 
     * 
     * Returns:
     * {DOMElement} The element that caused the event 
     */
    element: function(event) {
        return event.target || event.srcElement;
    },

    /**
     * Method: isSingleTouch
     * Determine whether event was caused by a single touch
     *
     * Parameters:
     * event - {Event}
     *
     * Returns:
     * {Boolean}
     */
    isSingleTouch: function(event) {
        return event.touches && event.touches.length == 1;
    },

    /**
     * Method: isMultiTouch
     * Determine whether event was caused by a multi touch
     *
     * Parameters:
     * event - {Event}
     *
     * Returns:
     * {Boolean}
     */
    isMultiTouch: function(event) {
        return event.touches && event.touches.length > 1;
    },

    /**
     * Method: isLeftClick
     * Determine whether event was caused by a left click. 
     *
     * Parameters:
     * event - {Event} 
     * 
     * Returns:
     * {Boolean}
     */
    isLeftClick: function(event) {
        return (((event.which) && (event.which == 1)) ||
                ((event.button) && (event.button == 1)));
    },

    /**
     * Method: isRightClick
     * Determine whether event was caused by a right mouse click. 
     *
     * Parameters:
     * event - {Event} 
     * 
     * Returns:
     * {Boolean}
     */
     isRightClick: function(event) {
        return (((event.which) && (event.which == 3)) ||
                ((event.button) && (event.button == 2)));
    },
     
    /**
     * Method: stop
     * Stops an event from propagating. 
     *
     * Parameters: 
     * event - {Event} 
     * allowDefault - {Boolean} If true, we stop the event chain but 
     *     still allow the default browser behaviour (text selection,
     *     radio-button clicking, etc).  Default is false.
     */
    stop: function(event, allowDefault) {
        
        if (!allowDefault) { 
            HGIS.Event.preventDefault(event);
        }
                
        if (event.stopPropagation) {
            event.stopPropagation();
        } else {
            event.cancelBubble = true;
        }
    },

    /**
     * Method: preventDefault
     * Cancels the event if it is cancelable, without stopping further
     * propagation of the event.
     *
     * Parameters:
     * event - {Event}
     */
    preventDefault: function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },

    /** 
     * Method: findElement
     * 
     * Parameters:
     * event - {Event} 
     * tagName - {String} 
     * 
     * Returns:
     * {DOMElement} The first node with the given tagName, starting from the
     * node the event was triggered on and traversing the DOM upwards
     */
    findElement: function(event, tagName) {
        var element = HGIS.Event.element(event);
        while (element.parentNode && (!element.tagName ||
              (element.tagName.toUpperCase() != tagName.toUpperCase()))){
            element = element.parentNode;
        }
        return element;
    },

    /** 
     * Method: observe
     * 
     * Parameters:
     * elementParam - {DOMElement || String} 
     * name - {String} 
     * observer - {function} 
     * useCapture - {Boolean} 
     */
    observe: function(elementParam, name, observer, useCapture) {
        var element = HGIS.Util.getElement(elementParam);
        useCapture = useCapture || false;

        if (name == 'keypress' &&
           (navigator.appVersion.match(/Konqueror|Safari|KHTML/)
           || element.attachEvent)) {
            name = 'keydown';
        }

        //if observers cache has not yet been created, create it
        if (!this.observers) {
            this.observers = {};
        }

        //if not already assigned, make a new unique cache ID
        if (!element._eventCacheID) {
            var idPrefix = "eventCacheID_";
            if (element.id) {
                idPrefix = element.id + "_" + idPrefix;
            }
            element._eventCacheID = HGIS.Util.createUniqueID(idPrefix);
        }

        var cacheID = element._eventCacheID;

        //if there is not yet a hash entry for this element, add one
        if (!this.observers[cacheID]) {
            this.observers[cacheID] = [];
        }

        //add a new observer to this element's list
        this.observers[cacheID].push({
            'element': element,
            'name': name,
            'observer': observer,
            'useCapture': useCapture
        });

        //add the actual browser event listener
        if (element.addEventListener) {
            element.addEventListener(name, observer, useCapture);
        } else if (element.attachEvent) {
            element.attachEvent('on' + name, observer);
        }
    },

    /** 
     * Method: stopObservingElement
     * Given the id of an element to stop observing, cycle through the 
     *   element's cached observers, calling stopObserving on each one, 
     *   skipping those entries which can no longer be removed.
     * 
     * parameters:
     * elementParam - {DOMElement || String} 
     */
    stopObservingElement: function(elementParam) {
        var element = HGIS.Util.getElement(elementParam);
        var cacheID = element._eventCacheID;

        this._removeElementObservers(HGIS.Event.observers[cacheID]);
    },

    /**
     * Method: _removeElementObservers
     *
     * Parameters:
     * elementObservers - {Array(Object)} Array of (element, name, 
     *                                         observer, usecapture) objects, 
     *                                         taken directly from hashtable
     */
    _removeElementObservers: function(elementObservers) {
        if (elementObservers) {
            for(var i = elementObservers.length-1; i >= 0; i--) {
                var entry = elementObservers[i];
                HGIS.Event.stopObserving.apply(this, [
                    entry.element, entry.name, entry.observer, entry.useCapture
                ]);
            }
        }
    },

    /**
     * Method: stopObserving
     * 
     * Parameters:
     * elementParam - {DOMElement || String} 
     * name - {String} 
     * observer - {function} 
     * useCapture - {Boolean} 
     *  
     * Returns:
     * {Boolean} Whether or not the event observer was removed
     */
    stopObserving: function(elementParam, name, observer, useCapture) {
        useCapture = useCapture || false;
    
        var element = HGIS.Util.getElement(elementParam);
        var cacheID = element._eventCacheID;

        if (name == 'keypress') {
            if ( navigator.appVersion.match(/Konqueror|Safari|KHTML/) || 
                 element.detachEvent) {
              name = 'keydown';
            }
        }

        // find element's entry in this.observers cache and remove it
        var foundEntry = false;
        var elementObservers = HGIS.Event.observers[cacheID];
        if (elementObservers) {
    
            // find the specific event type in the element's list
            var i=0;
            while(!foundEntry && i < elementObservers.length) {
                var cacheEntry = elementObservers[i];
    
                if ((cacheEntry.name == name) &&
                    (cacheEntry.observer == observer) &&
                    (cacheEntry.useCapture == useCapture)) {
    
                    elementObservers.splice(i, 1);
                    if (elementObservers.length == 0) {
                        delete HGIS.Event.observers[cacheID];
                    }
                    foundEntry = true;
                    break; 
                }
                i++;           
            }
        }
    
        //actually remove the event listener from browser
        if (foundEntry) {
            if (element.removeEventListener) {
                element.removeEventListener(name, observer, useCapture);
            } else if (element && element.detachEvent) {
                element.detachEvent('on' + name, observer);
            }
        }
        return foundEntry;
    },
    
    /** 
     * Method: unloadCache
     * Cycle through all the element entries in the events cache and call
     *   stopObservingElement on each. 
     */
    unloadCache: function() {
        // check for HGIS.Event before checking for observers, because
        // HGIS.Event may be undefined in IE if no map instance was
        // created
        if (HGIS.Event && HGIS.Event.observers) {
            for (var cacheID in HGIS.Event.observers) {
                var elementObservers = HGIS.Event.observers[cacheID];
                HGIS.Event._removeElementObservers.apply(this, 
                                                           [elementObservers]);
            }
            HGIS.Event.observers = false;
        }
    },

    CLASS_NAME: "HGIS.Event"
};

/* prevent memory leaks in IE */
HGIS.Event.observe(window, 'unload', HGIS.Event.unloadCache, false);

/**
 * Class: HGIS.Events
 */
HGIS.Events = HGIS.Class({

    /** 
     * Constant: BROWSER_EVENTS
     * {Array(String)} supported events 
     */
    BROWSER_EVENTS: [
        "mouseover", "mouseout",
        "mousedown", "mouseup", "mousemove", 
        "click", "dblclick", "rightclick", "dblrightclick",
        "resize", "focus", "blur",
        "touchstart", "touchmove", "touchend",
        "keydown"
    ],

    /** 
     * Property: listeners 
     * {Object} Hashtable of Array(Function): events listener functions  
     */
    listeners: null,

    /** 
     * Property: object 
     * {Object}  the code object issuing application events 
     */
    object: null,

    /** 
     * Property: element 
     * {DOMElement}  the DOM element receiving browser events 
     */
    element: null,

    /** 
     * Property: eventHandler 
     * {Function}  bound event handler attached to elements 
     */
    eventHandler: null,

    /** 
     * APIProperty: fallThrough 
     * {Boolean} 
     */
    fallThrough: null,

    /** 
     * APIProperty: includeXY
     * {Boolean} Should the .xy property automatically be created for browser
     *    mouse events? In general, this should be false. If it is true, then
     *    mouse events will automatically generate a '.xy' property on the 
     *    event object that is passed. (Prior to HGIS 2.7, this was true
     *    by default.) Otherwise, you can call the getMousePosition on the
     *    relevant events handler on the object available via the 'evt.object'
     *    property of the evt object. So, for most events, you can call:
     *    function named(evt) { 
     *        this.xy = this.object.events.getMousePosition(evt) 
     *    } 
     *
     *    This option typically defaults to false for performance reasons:
     *    when creating an events object whose primary purpose is to manage
     *    relatively positioned mouse events within a div, it may make
     *    sense to set it to true.
     *
     *    This option is also used to control whether the events object caches
     *    offsets. If this is false, it will not: the reason for this is that
     *    it is only expected to be called many times if the includeXY property
     *    is set to true. If you set this to true, you are expected to clear 
     *    the offset cache manually (using this.clearMouseCache()) if:
     *        the border of the element changes
     *        the location of the element in the page changes
    */
    includeXY: false,      
    
    /**
     * APIProperty: extensions
     * {Object} Event extensions registered with this instance. Keys are
     *     event types, values are {HGIS.Events.*} extension instances or
     *     {Boolean} for events that an instantiated extension provides in
     *     addition to the one it was created for.
     *
     * Extensions create an event in addition to browser events, which usually
     * fires when a sequence of browser events is completed. Extensions are
     * automatically instantiated when a listener is registered for an event
     * provided by an extension.
     *
     * Extensions are created in the <HGIS.Events> namespace using
     * <HGIS.Class>, and named after the event they provide.
     * The constructor receives the target <HGIS.Events> instance as
     * argument. Extensions that need to capture browser events before they
     * propagate can register their listeners events using <register>, with
     * {extension: true} as 4th argument.
     *
     * If an extension creates more than one event, an alias for each event
     * type should be created and reference the same class. The constructor
     * should set a reference in the target's extensions registry to itself.
     *
     * Below is a minimal extension that provides the "foostart" and "fooend"
     * event types, which replace the native "click" event type if clicked on
     * an element with the css class "foo":
     *
     * (code)
     *   HGIS.Events.foostart = HGIS.Class({
     *       initialize: function(target) {
     *           this.target = target;
     *           this.target.register("click", this, this.doStuff, {extension: true});
     *           // only required if extension provides more than one event type
     *           this.target.extensions["foostart"] = true;
     *           this.target.extensions["fooend"] = true;
     *       },
     *       destroy: function() {
     *           var target = this.target;
     *           target.unregister("click", this, this.doStuff);
     *           delete this.target;
     *           // only required if extension provides more than one event type
     *           delete target.extensions["foostart"];
     *           delete target.extensions["fooend"];
     *       },
     *       doStuff: function(evt) {
     *           var propagate = true;
     *           if (HGIS.Event.element(evt).className === "foo") {
     *               propagate = false;
     *               var target = this.target;
     *               target.triggerEvent("foostart");
     *               window.setTimeout(function() {
     *                   target.triggerEvent("fooend");
     *               }, 1000);
     *           }
     *           return propagate;
     *       }
     *   });
     *   // only required if extension provides more than one event type
     *   HGIS.Events.fooend = HGIS.Events.foostart;
     * (end)
     * 
     */
    extensions: null,
    
    /**
     * Property: extensionCount
     * {Object} Keys are event types (like in <listeners>), values are the
     *     number of extension listeners for each event type.
     */
    extensionCount: null,

    /**
     * Method: clearMouseListener
     * A version of <clearMouseCache> that is bound to this instance so that
     *     it can be used with <HGIS.Event.observe> and
     *     <HGIS.Event.stopObserving>.
     */
    clearMouseListener: null,

    /**
     * Constructor: HGIS.Events
     * Construct an HGIS.Events object.
     *
     * Parameters:
     * object - {Object} The js object to which this Events object  is being added
     * element - {DOMElement} A dom element to respond to browser events
     * eventTypes - {Array(String)} Deprecated.  Array of custom application
     *     events.  A listener may be registered for any named event, regardless
     *     of the values provided here.
     * fallThrough - {Boolean} Allow events to fall through after these have
     *                         been handled?
     * options - {Object} Options for the events object.
     */
    initialize: function (object, element, eventTypes, fallThrough, options) {
        HGIS.Util.extend(this, options);
        this.object     = object;
        this.fallThrough = fallThrough;
        this.listeners  = {};
        this.extensions = {};
        this.extensionCount = {};
        this._msTouches = [];
        
        // if a dom element is specified, add a listeners list 
        // for browser events on the element and register them
        if (element != null) {
            this.attachToElement(element);
        }
    },

    /**
     * APIMethod: destroy
     */
    destroy: function () {
        for (var e in this.extensions) {
            if (typeof this.extensions[e] !== "boolean") {
                this.extensions[e].destroy();
            }
        }
        this.extensions = null;
        if (this.element) {
            HGIS.Event.stopObservingElement(this.element);
            if(this.element.hasScrollEvent) {
                HGIS.Event.stopObserving(
                    window, "scroll", this.clearMouseListener
                );
            }
        }
        this.element = null;

        this.listeners = null;
        this.object = null;
        this.fallThrough = null;
        this.eventHandler = null;
    },

    /**
     * APIMethod: addEventType
     * Deprecated.  Any event can be triggered without adding it first.
     * 
     * Parameters:
     * eventName - {String}
     */
    addEventType: function(eventName) {
    },

    /**
     * Method: attachToElement
     *
     * Parameters:
     * element - {HTMLDOMElement} a DOM element to attach browser events to
     */
    attachToElement: function (element) {
        if (this.element) {
            HGIS.Event.stopObservingElement(this.element);
        } else {
            // keep a bound copy of handleBrowserEvent() so that we can
            // pass the same function to both Event.observe() and .stopObserving()
            this.eventHandler = HGIS.Function.bindAsEventListener(
                this.handleBrowserEvent, this
            );
            
            // to be used with observe and stopObserving
            this.clearMouseListener = HGIS.Function.bind(
                this.clearMouseCache, this
            );
        }
        this.element = element;
        var msTouch = !!window.navigator.msMaxTouchPoints;
        var type;
        for (var i = 0, len = this.BROWSER_EVENTS.length; i < len; i++) {
            type = this.BROWSER_EVENTS[i];
            // register the event cross-browser
            HGIS.Event.observe(element, type, this.eventHandler
            );
            if (msTouch && type.indexOf('touch') === 0) {
                this.addMsTouchListener(element, type, this.eventHandler);
            }
        }
        // disable dragstart in IE so that mousedown/move/up works normally
        HGIS.Event.observe(element, "dragstart", HGIS.Event.stop);
    },
    
    /**
     * APIMethod: on
     * Convenience method for registering listeners with a common scope.
     *     Internally, this method calls <register> as shown in the examples
     *     below.
     *
     * Example use:
     * (code)
     * // register a single listener for the "loadstart" event
     * events.on({"loadstart": loadStartListener});
     *
     * // this is equivalent to the following
     * events.register("loadstart", undefined, loadStartListener);
     *
     * // register multiple listeners to be called with the same `this` object
     * events.on({
     *     "loadstart": loadStartListener,
     *     "loadend": loadEndListener,
     *     scope: object
     * });
     *
     * // this is equivalent to the following
     * events.register("loadstart", object, loadStartListener);
     * events.register("loadend", object, loadEndListener);
     * (end)
     *
     * Parameters:
     *  object - {Object}     
     */
    on: function(object) {
        for(var type in object) {
            if(type != "scope" && object.hasOwnProperty(type)) {
                this.register(type, object.scope, object[type]);
            }
        }
    },

    /**
     * APIMethod: register
     * Register an event on the events object.
     *
     * When the event is triggered, the 'func' function will be called, in the
     * context of 'obj'. Imagine we were to register an event, specifying an 
     * HGIS.Bounds Object as 'obj'. When the event is triggered, the 
     * context in the callback function will be our Bounds object. This means
     * that within our callback function, we can access the properties and 
     * methods of the Bounds object through the "this" variable. So our 
     * callback could execute something like: 
     * :    leftStr = "Left: " + this.left;
     *   
     *                   or
     *  
     * :    centerStr = "Center: " + this.getCenterLonLat();
     *
     * Parameters:
     * type - {String} Name of the event to register
     * obj - {Object} The object to bind the context to for the callback#.
     *     If no object is specified, default is the Events's 'object' property.
     * func - {Function} The callback function. If no callback is 
     *     specified, this function does nothing.
     * priority - {Boolean|Object} If true, adds the new listener to the
     *     *front* of the events queue instead of to the end.
     *
     * Valid options for priority:
     * extension - {Boolean} If true, then the event will be registered as
     *     extension event. Extension events are handled before all other
     *     events.
     */
    register: function (type, obj, func, priority) {
        if (type in HGIS.Events && !this.extensions[type]) {
            this.extensions[type] = new HGIS.Events[type](this);
        }
        if (func != null) {
            if (obj == null)  {
                obj = this.object;
            }
            var listeners = this.listeners[type];
            if (!listeners) {
                listeners = [];
                this.listeners[type] = listeners;
                this.extensionCount[type] = 0;
            }
            var listener = {obj: obj, func: func};
            if (priority) {
                listeners.splice(this.extensionCount[type], 0, listener);
                if (typeof priority === "object" && priority.extension) {
                    this.extensionCount[type]++;
                }
            } else {
                listeners.push(listener);
            }
        }
    },

    /**
     * APIMethod: registerPriority
     * Same as register() but adds the new listener to the *front* of the
     *     events queue instead of to the end.
     *    
     *     TODO: get rid of this in 3.0 - Decide whether listeners should be 
     *     called in the order they were registered or in reverse order.
     *
     *
     * Parameters:
     * type - {String} Name of the event to register
     * obj - {Object} The object to bind the context to for the callback#.
     *                If no object is specified, default is the Events's 
     *                'object' property.
     * func - {Function} The callback function. If no callback is 
     *                   specified, this function does nothing.
     */
    registerPriority: function (type, obj, func) {
        this.register(type, obj, func, true);
    },
    
    /**
     * APIMethod: un
     * Convenience method for unregistering listeners with a common scope.
     *     Internally, this method calls <unregister> as shown in the examples
     *     below.
     *
     * Example use:
     * (code)
     * // unregister a single listener for the "loadstart" event
     * events.un({"loadstart": loadStartListener});
     *
     * // this is equivalent to the following
     * events.unregister("loadstart", undefined, loadStartListener);
     *
     * // unregister multiple listeners with the same `this` object
     * events.un({
     *     "loadstart": loadStartListener,
     *     "loadend": loadEndListener,
     *     scope: object
     * });
     *
     * // this is equivalent to the following
     * events.unregister("loadstart", object, loadStartListener);
     * events.unregister("loadend", object, loadEndListener);
     * (end)
     */
    un: function(object) {
        for(var type in object) {
            if(type != "scope" && object.hasOwnProperty(type)) {
                this.unregister(type, object.scope, object[type]);
            }
        }
    },

    /**
     * APIMethod: unregister
     *
     * Parameters:
     * type - {String} 
     * obj - {Object} If none specified, defaults to this.object
     * func - {Function} 
     */
    unregister: function (type, obj, func) {
        if (obj == null)  {
            obj = this.object;
        }
        var listeners = this.listeners[type];
        if (listeners != null) {
            for (var i=0, len=listeners.length; i<len; i++) {
                if (listeners[i].obj == obj && listeners[i].func == func) {
                    listeners.splice(i, 1);
                    break;
                }
            }
        }
    },

    /** 
     * Method: remove
     * Remove all listeners for a given event type. If type is not registered,
     *     does nothing.
     *
     * Parameters:
     * type - {String} 
     */
    remove: function(type) {
        if (this.listeners[type] != null) {
            this.listeners[type] = [];
        }
    },

    /**
     * APIMethod: triggerEvent
     * Trigger a specified registered event.  
     * 
     * Parameters:
     * type - {String} 
     * evt - {Event || Object} will be passed to the listeners.
     *
     * Returns:
     * {Boolean} The last listener return.  If a listener returns false, the
     *     chain of listeners will stop getting called.
     */
    triggerEvent: function (type, evt) {
        var listeners = this.listeners[type];

        // fast path
        if(!listeners || listeners.length == 0) {
            return undefined;
        }

        // prep evt object with object & div references
        if (evt == null) {
            evt = {};
        }
        evt.object = this.object;
        evt.element = this.element;
        if(!evt.type) {
            evt.type = type;
        }
    
        // execute all callbacks registered for specified type
        // get a clone of the listeners array to
        // allow for splicing during callbacks
        listeners = listeners.slice();
        var continueChain;
        for (var i=0, len=listeners.length; i<len; i++) {
            var callback = listeners[i];
            // bind the context to callback.obj
            continueChain = callback.func.apply(callback.obj, [evt]);

            if ((continueChain != undefined) && (continueChain == false)) {
                // if callback returns false, execute no more callbacks.
                break;
            }
        }
        // don't fall through to other DOM elements
        if (!this.fallThrough) {           
            HGIS.Event.stop(evt, true);
        }
        return continueChain;
    },

    /**
     * Method: handleBrowserEvent
     * Basically just a wrapper to the triggerEvent() function, but takes 
     *     care to set a property 'xy' on the event with the current mouse 
     *     position.
     *
     * Parameters:
     * evt - {Event} 
     */
    handleBrowserEvent: function (evt) {
        var type = evt.type, listeners = this.listeners[type];
        if(!listeners || listeners.length == 0) {
            // noone's listening, bail out
            return;
        }
        // add clientX & clientY to all events - corresponds to average x, y
        var touches = evt.touches;
        if (touches && touches[0]) {
            var x = 0;
            var y = 0;
            var num = touches.length;
            var touch;
            for (var i=0; i<num; ++i) {
                touch = this.getTouchClientXY(touches[i]);
                x += touch.clientX;
                y += touch.clientY;
            }
            evt.clientX = x / num;
            evt.clientY = y / num;
        }
        if (this.includeXY) {
            evt.xy = this.getMousePosition(evt);
        } 
        this.triggerEvent(type, evt);
    },
    
    /**
     * Method: getTouchClientXY
     * WebKit has a few bugs for clientX/clientY. This method detects them
     * and calculate the correct values.
     *
     * Parameters:
     * evt - {Touch} a Touch object from a TouchEvent
     * 
     * Returns:
     * {Object} An object with only clientX and clientY properties with the
     * calculated values.
     */
    getTouchClientXY: function (evt) {
        // olMochWin is to override window, used for testing
        var win = window.olMockWin || window,
            winPageX = win.pageXOffset,
            winPageY = win.pageYOffset,
            x = evt.clientX,
            y = evt.clientY;
        
        if (evt.pageY === 0 && Math.floor(y) > Math.floor(evt.pageY) ||
            evt.pageX === 0 && Math.floor(x) > Math.floor(evt.pageX)) {
            // iOS4 include scroll offset in clientX/Y
            x = x - winPageX;
            y = y - winPageY;
        } else if (y < (evt.pageY - winPageY) || x < (evt.pageX - winPageX) ) {
            // Some Android browsers have totally bogus values for clientX/Y
            // when scrolling/zooming a page
            x = evt.pageX - winPageX;
            y = evt.pageY - winPageY;
        }
        
        evt.olClientX = x;
        evt.olClientY = y;
        
        return {
            clientX: x,
            clientY: y
        };
    },
    
    /**
     * APIMethod: clearMouseCache
     * Clear cached data about the mouse position. This should be called any 
     *     time the element that events are registered on changes position 
     *     within the page.
     */
    clearMouseCache: function() { 
        this.element.scrolls = null;
        this.element.lefttop = null;
        this.element.offsets = null;
    },      

    /**
     * Method: getMousePosition
     * 
     * Parameters:
     * evt - {Event} 
     * 
     * Returns:
     * {<HGIS.Pixel>} The current xy coordinate of the mouse, adjusted
     *                      for offsets
     */
    getMousePosition: function (evt) {
        if (!this.includeXY) {
            this.clearMouseCache();
        } else if (!this.element.hasScrollEvent) {
            HGIS.Event.observe(window, "scroll", this.clearMouseListener);
            this.element.hasScrollEvent = true;
        }
        
        if (!this.element.scrolls) {
            var viewportElement = HGIS.Util.getViewportElement();
            this.element.scrolls = [
                window.pageXOffset || viewportElement.scrollLeft,
                window.pageYOffset || viewportElement.scrollTop
            ];
        }

        if (!this.element.lefttop) {
            this.element.lefttop = [
                (document.documentElement.clientLeft || 0),
                (document.documentElement.clientTop  || 0)
            ];
        }
        
        if (!this.element.offsets) {
            this.element.offsets = HGIS.Util.pagePosition(this.element);
        }

        return new HGIS.Pixel(
            (evt.clientX + this.element.scrolls[0]) - this.element.offsets[0]
                         - this.element.lefttop[0], 
            (evt.clientY + this.element.scrolls[1]) - this.element.offsets[1]
                         - this.element.lefttop[1]
        ); 
    },

    /**
     * Method: addMsTouchListener
     *
     * Parameters:
     * element - {DOMElement} The DOM element to register the listener on
     * type - {String} The event type
     * handler - {Function} the handler
     */
    addMsTouchListener: function (element, type, handler) {
        var eventHandler = this.eventHandler;
        var touches = this._msTouches;

        function msHandler(evt) {
            handler(HGIS.Util.applyDefaults({
                stopPropagation: function() {
                    for (var i=touches.length-1; i>=0; --i) {
                        touches[i].stopPropagation();
                    }
                },
                preventDefault: function() {
                    for (var i=touches.length-1; i>=0; --i) {
                        touches[i].preventDefault();
                    }
                },
                type: type
            }, evt));
        }

        switch (type) {
            case 'touchstart':
                return this.addMsTouchListenerStart(element, type, msHandler);
            case 'touchend':
                return this.addMsTouchListenerEnd(element, type, msHandler);
            case 'touchmove':
                return this.addMsTouchListenerMove(element, type, msHandler);
            default:
                throw 'Unknown touch event type';
        }
    },

    /**
     * Method: addMsTouchListenerStart
     *
     * Parameters:
     * element - {DOMElement} The DOM element to register the listener on
     * type - {String} The event type
     * handler - {Function} the handler
     */
    addMsTouchListenerStart: function(element, type, handler) {
        var touches = this._msTouches;

        var cb = function(e) {

            var alreadyInArray = false;
            for (var i=0, ii=touches.length; i<ii; ++i) {
                if (touches[i].pointerId == e.pointerId) {
                    alreadyInArray = true;
                    break;
                }
            }
            if (!alreadyInArray) {
                touches.push(e);
            }

            e.touches = touches.slice();
            handler(e);
        };

        HGIS.Event.observe(element, 'MSPointerDown', cb);

        // Need to also listen for end events to keep the _msTouches list
        // accurate
        var internalCb = function(e) {
            for (var i=0, ii=touches.length; i<ii; ++i) {
                if (touches[i].pointerId == e.pointerId) {
                    touches.splice(i, 1);
                    break;
                }
            }
        };
        HGIS.Event.observe(element, 'MSPointerUp', internalCb);
    },

    /**
     * Method: addMsTouchListenerMove
     *
     * Parameters:
     * element - {DOMElement} The DOM element to register the listener on
     * type - {String} The event type
     * handler - {Function} the handler
     */
    addMsTouchListenerMove: function (element, type, handler) {
        var touches = this._msTouches;
        var cb = function(e) {

            //Don't fire touch moves when mouse isn't down
            if (e.pointerType == e.MSPOINTER_TYPE_MOUSE && e.buttons == 0) {
                return;
            }

            if (touches.length == 1 && touches[0].pageX == e.pageX &&
                    touches[0].pageY == e.pageY) {
                // don't trigger event when pointer has not moved
                return;
            }
            for (var i=0, ii=touches.length; i<ii; ++i) {
                if (touches[i].pointerId == e.pointerId) {
                    touches[i] = e;
                    break;
                }
            }

            e.touches = touches.slice();
            handler(e);
        };

        HGIS.Event.observe(element, 'MSPointerMove', cb);
    },

    /**
     * Method: addMsTouchListenerEnd
     *
     * Parameters:
     * element - {DOMElement} The DOM element to register the listener on
     * type - {String} The event type
     * handler - {Function} the handler
     */
    addMsTouchListenerEnd: function (element, type, handler) {
        var touches = this._msTouches;

        var cb = function(e) {

            for (var i=0, ii=touches.length; i<ii; ++i) {
                if (touches[i].pointerId == e.pointerId) {
                    touches.splice(i, 1);
                    break;
                }
            }
            
            e.touches = touches.slice();
            handler(e);
        };

        HGIS.Event.observe(element, 'MSPointerUp', cb);
    },

    CLASS_NAME: "HGIS.Events"
});
/* ======================================================================
    HGIS/Events/buttonclick.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Events.js
 */

/**
 * Class: HGIS.Events.buttonclick
 * Extension event type for handling buttons on top of a dom element. This
 *     event type fires "buttonclick" on its <target> when a button was
 *     clicked. Buttons are detected by the "olButton" class.
 *
 * This event type makes sure that button clicks do not interfere with other
 *     events that are registered on the same <element>.
 *
 * Event types provided by this extension:
 * - *buttonclick* Triggered when a button is clicked. Listeners receive an
 *     object with a *buttonElement* property referencing the dom element of
 *     the clicked button, and an *buttonXY* property with the click position
 *     relative to the button.
 */
HGIS.Events.buttonclick = HGIS.Class({
    
    /**
     * Property: target
     * {<HGIS.Events>} The events instance that the buttonclick event will
     * be triggered on.
     */
    target: null,
    
    /**
     * Property: events
     * {Array} Events to observe and conditionally stop from propagating when
     *     an element with the olButton class (or its olAlphaImg child) is
     *     clicked.
     */
    events: [
        'mousedown', 'mouseup', 'click', 'dblclick',
        'touchstart', 'touchmove', 'touchend', 'keydown'
    ],
    
    /**
     * Property: startRegEx
     * {RegExp} Regular expression to test Event.type for events that start
     *     a buttonclick sequence.
     */
    startRegEx: /^mousedown|touchstart$/,

    /**
     * Property: cancelRegEx
     * {RegExp} Regular expression to test Event.type for events that cancel
     *     a buttonclick sequence.
     */
    cancelRegEx: /^touchmove$/,

    /**
     * Property: completeRegEx
     * {RegExp} Regular expression to test Event.type for events that complete
     *     a buttonclick sequence.
     */
    completeRegEx: /^mouseup|touchend$/,
    
    /**
     * Property: startEvt
     * {Event} The event that started the click sequence
     */
    
    /**
     * Constructor: HGIS.Events.buttonclick
     * Construct a buttonclick event type. Applications are not supposed to
     *     create instances of this class - they are created on demand by
     *     <HGIS.Events> instances.
     *
     * Parameters:
     * target - {<HGIS.Events>} The events instance that the buttonclick
     *     event will be triggered on.
     */
    initialize: function(target) {
        this.target = target;
        for (var i=this.events.length-1; i>=0; --i) {
            this.target.register(this.events[i], this, this.buttonClick, {
                extension: true
            });
        }
    },
    
    /**
     * Method: destroy
     */
    destroy: function() {
        for (var i=this.events.length-1; i>=0; --i) {
            this.target.unregister(this.events[i], this, this.buttonClick);
        }
        delete this.target;
    },

    /**
     * Method: getPressedButton
     * Get the pressed button, if any. Returns undefined if no button
     * was pressed.
     *
     * Arguments:
     * element - {DOMElement} The event target.
     *
     * Returns:
     * {DOMElement} The button element, or undefined.
     */
    getPressedButton: function(element) {
        var depth = 3, // limit the search depth
            button;
        do {
            if(HGIS.Element.hasClass(element, "olButton")) {
                // hit!
                button = element;
                break;
            }
            element = element.parentNode;
        } while(--depth > 0 && element);
        return button;
    },
    
    /**
     * Method: ignore
     * Check for event target elements that should be ignored by HGIS.
     *
     * Parameters:
     * element - {DOMElement} The event target.
     */
    ignore: function(element) {
        var depth = 3,
            ignore = false;
        do {
            if (element.nodeName.toLowerCase() === 'a') {
                ignore = true;
                break;
            }
            element = element.parentNode;
        } while (--depth > 0 && element);
        return ignore;
    },

    /**
     * Method: buttonClick
     * Check if a button was clicked, and fire the buttonclick event
     *
     * Parameters:
     * evt - {Event}
     */
    buttonClick: function(evt) {
        var propagate = true,
            element = HGIS.Event.element(evt);
        if (element && (HGIS.Event.isLeftClick(evt) || !~evt.type.indexOf("mouse"))) {
            // was a button pressed?
            var button = this.getPressedButton(element);
            if (button) {
                if (evt.type === "keydown") {
                    switch (evt.keyCode) {
                    case HGIS.Event.KEY_RETURN:
                    case HGIS.Event.KEY_SPACE:
                        this.target.triggerEvent("buttonclick", {
                            buttonElement: button
                        });
                        HGIS.Event.stop(evt);
                        propagate = false;
                        break;
                    }
                } else if (this.startEvt) {
                    if (this.completeRegEx.test(evt.type)) {
                        var pos = HGIS.Util.pagePosition(button);
                        var viewportElement = HGIS.Util.getViewportElement();
                        var scrollTop = window.pageYOffset || viewportElement.scrollTop;
                        var scrollLeft = window.pageXOffset || viewportElement.scrollLeft;
                        pos[0] = pos[0] - scrollLeft;
                        pos[1] = pos[1] - scrollTop;
                        
                        this.target.triggerEvent("buttonclick", {
                            buttonElement: button,
                            buttonXY: {
                                x: this.startEvt.clientX - pos[0],
                                y: this.startEvt.clientY - pos[1]
                            }
                        });
                    }
                    if (this.cancelRegEx.test(evt.type)) {
                        delete this.startEvt;
                    }
                    HGIS.Event.stop(evt);
                    propagate = false;
                }
                if (this.startRegEx.test(evt.type)) {
                    this.startEvt = evt;
                    HGIS.Event.stop(evt);
                    propagate = false;
                }
            } else {
                propagate = !this.ignore(HGIS.Event.element(evt));
                delete this.startEvt;
            }
        }
        return propagate;
    }
    
});
/* ======================================================================
    HGIS/Util/vendorPrefix.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/SingleFile.js
 */

HGIS.Util = HGIS.Util || {};
/**
 * Namespace: HGIS.Util.vendorPrefix
 * A collection of utility functions to detect vendor prefixed features
 */
HGIS.Util.vendorPrefix = (function() {
    "use strict";
    
    var VENDOR_PREFIXES = ["", "O", "ms", "Moz", "Webkit"],
        divStyle = document.createElement("div").style,
        cssCache = {},
        jsCache = {};

    
    /**
     * Function: domToCss
     * Converts a upper camel case DOM style property name to a CSS property
     *      i.e. transformOrigin -> transform-origin
     *      or   WebkitTransformOrigin -> -webkit-transform-origin
     *
     * Parameters:
     * prefixedDom - {String} The property to convert
     *
     * Returns:
     * {String} The CSS property
     */
    function domToCss(prefixedDom) {
        if (!prefixedDom) { return null; }
        return prefixedDom.
            replace(/([A-Z])/g, function(c) { return "-" + c.toLowerCase(); }).
            replace(/^ms-/, "-ms-");
    }

    /**
     * APIMethod: css
     * Detect which property is used for a CSS property
     *
     * Parameters:
     * property - {String} The standard (unprefixed) CSS property name
     *
     * Returns:
     * {String} The standard CSS property, prefixed property or null if not
     *          supported
     */
    function css(property) {
        if (cssCache[property] === undefined) {
            var domProperty = property.
                replace(/(-[\s\S])/g, function(c) { return c.charAt(1).toUpperCase(); });
            var prefixedDom = style(domProperty);
            cssCache[property] = domToCss(prefixedDom);
        }
        return cssCache[property];
    }

    /**
     * APIMethod: js
     * Detect which property is used for a JS property/method
     *
     * Parameters:
     * obj - {Object} The object to test on
     * property - {String} The standard (unprefixed) JS property name
     *
     * Returns:
     * {String} The standard JS property, prefixed property or null if not
     *          supported
     */
    function js(obj, property) {
        if (jsCache[property] === undefined) {
            var tmpProp,
                i = 0,
                l = VENDOR_PREFIXES.length,
                prefix,
                isStyleObj = (typeof obj.cssText !== "undefined");

            jsCache[property] = null;
            for(; i<l; i++) {
                prefix = VENDOR_PREFIXES[i];
                if(prefix) {
                    if (!isStyleObj) {
                        // js prefix should be lower-case, while style
                        // properties have upper case on first character
                        prefix = prefix.toLowerCase();
                    }
                    tmpProp = prefix + property.charAt(0).toUpperCase() + property.slice(1);
                } else {
                    tmpProp = property;
                }

                if(obj[tmpProp] !== undefined) {
                    jsCache[property] = tmpProp;
                    break;
                }
            }
        }
        return jsCache[property];
    }
    
    /**
     * APIMethod: style
     * Detect which property is used for a DOM style property
     *
     * Parameters:
     * property - {String} The standard (unprefixed) style property name
     *
     * Returns:
     * {String} The standard style property, prefixed property or null if not
     *          supported
     */
    function style(property) {
        return js(divStyle, property);
    }
    
    return {
        css:      css,
        js:       js,
        style:    style,
        
        // used for testing
        cssCache:       cssCache,
        jsCache:        jsCache
    };
}());
/* ======================================================================
    HGIS/Animation.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/SingleFile.js
 * @requires HGIS/Util/vendorPrefix.js
 */

/**
 * Namespace: HGIS.Animation
 * A collection of utility functions for executing methods that repaint a 
 *     portion of the browser window.  These methods take advantage of the
 *     browser's scheduled repaints where requestAnimationFrame is available.
 */
HGIS.Animation = (function(window) {
    
    /**
     * Property: isNative
     * {Boolean} true if a native requestAnimationFrame function is available
     */
    var requestAnimationFrame = HGIS.Util.vendorPrefix.js(window, "requestAnimationFrame");
    var isNative = !!(requestAnimationFrame);
    
    /**
     * Function: requestFrame
     * Schedule a function to be called at the next available animation frame.
     *     Uses the native method where available.  Where requestAnimationFrame is
     *     not available, setTimeout will be called with a 16ms delay.
     *
     * Parameters:
     * callback - {Function} The function to be called at the next animation frame.
     * element - {DOMElement} Optional element that visually bounds the animation.
     */
    var requestFrame = (function() {
        var request = window[requestAnimationFrame] ||
            function(callback, element) {
                window.setTimeout(callback, 16);
            };
        // bind to window to avoid illegal invocation of native function
        return function(callback, element) {
            request.apply(window, [callback, element]);
        };
    })();
    
    // private variables for animation loops
    var counter = 0;
    var loops = {};
    
    /**
     * Function: start
     * Executes a method with <requestFrame> in series for some 
     *     duration.
     *
     * Parameters:
     * callback - {Function} The function to be called at the next animation frame.
     * duration - {Number} Optional duration for the loop.  If not provided, the
     *     animation loop will execute indefinitely.
     * element - {DOMElement} Optional element that visually bounds the animation.
     *
     * Returns:
     * {Number} Identifier for the animation loop.  Used to stop animations with
     *     <stop>.
     */
    function start(callback, duration, element) {
        duration = duration > 0 ? duration : Number.POSITIVE_INFINITY;
        var id = ++counter;
        var start = +new Date;
        loops[id] = function() {
            if (loops[id] && +new Date - start <= duration) {
                callback();
                if (loops[id]) {
                    requestFrame(loops[id], element);
                }
            } else {
                delete loops[id];
            }
        };
        requestFrame(loops[id], element);
        return id;
    }
    
    /**
     * Function: stop
     * Terminates an animation loop started with <start>.
     *
     * Parameters:
     * id - {Number} Identifier returned from <start>.
     */
    function stop(id) {
        delete loops[id];
    }
    
    return {
        isNative: isNative,
        requestFrame: requestFrame,
        start: start,
        stop: stop
    };
    
})(window);
/* ======================================================================
    HGIS/Tween.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Animation.js
 */

/**
 * Namespace: HGIS.Tween
 */
HGIS.Tween = HGIS.Class({
    
    /**
     * APIProperty: easing
     * {<HGIS.Easing>(Function)} Easing equation used for the animation
     *     Defaultly set to HGIS.Easing.Expo.easeOut
     */
    easing: null,
    
    /**
     * APIProperty: begin
     * {Object} Values to start the animation with
     */
    begin: null,
    
    /**
     * APIProperty: finish
     * {Object} Values to finish the animation with
     */
    finish: null,
    
    /**
     * APIProperty: duration
     * {int} duration of the tween (number of steps)
     */
    duration: null,
    
    /**
     * APIProperty: callbacks
     * {Object} An object with start, eachStep and done properties whose values
     *     are functions to be call during the animation. They are passed the
     *     current computed value as argument.
     */
    callbacks: null,
    
    /**
     * Property: time
     * {int} Step counter
     */
    time: null,
    
    /**
     * APIProperty: minFrameRate
     * {Number} The minimum framerate for animations in frames per second. After
     * each step, the time spent in the animation is compared to the calculated
     * time at this frame rate. If the animation runs longer than the calculated
     * time, the next step is skipped. Default is 30.
     */
    minFrameRate: null,

    /**
     * Property: startTime
     * {Number} The timestamp of the first execution step. Used for skipping
     * frames
     */
    startTime: null,
    
    /**
     * Property: animationId
     * {int} Loop id returned by HGIS.Animation.start
     */
    animationId: null,
    
    /**
     * Property: playing
     * {Boolean} Tells if the easing is currently playing
     */
    playing: false,
    
    /** 
     * Constructor: HGIS.Tween
     * Creates a Tween.
     *
     * Parameters:
     * easing - {<HGIS.Easing>(Function)} easing function method to use
     */ 
    initialize: function(easing) {
        this.easing = (easing) ? easing : HGIS.Easing.Expo.easeOut;
    },
    
    /**
     * APIMethod: start
     * Plays the Tween, and calls the callback method on each step
     * 
     * Parameters:
     * begin - {Object} values to start the animation with
     * finish - {Object} values to finish the animation with
     * duration - {int} duration of the tween (number of steps)
     * options - {Object} hash of options (callbacks (start, eachStep, done),
     *     minFrameRate)
     */
    start: function(begin, finish, duration, options) {
        this.playing = true;
        this.begin = begin;
        this.finish = finish;
        this.duration = duration;
        this.callbacks = options.callbacks;
        this.minFrameRate = options.minFrameRate || 30;
        this.time = 0;
        this.startTime = new Date().getTime();
        HGIS.Animation.stop(this.animationId);
        this.animationId = null;
        if (this.callbacks && this.callbacks.start) {
            this.callbacks.start.call(this, this.begin);
        }
        this.animationId = HGIS.Animation.start(
            HGIS.Function.bind(this.play, this)
        );
    },
    
    /**
     * APIMethod: stop
     * Stops the Tween, and calls the done callback
     *     Doesn't do anything if animation is already finished
     */
    stop: function() {
        if (!this.playing) {
            return;
        }
        
        if (this.callbacks && this.callbacks.done) {
            this.callbacks.done.call(this, this.finish);
        }
        HGIS.Animation.stop(this.animationId);
        this.animationId = null;
        this.playing = false;
    },
    
    /**
     * Method: play
     * Calls the appropriate easing method
     */
    play: function() {
        var value = {};
        for (var i in this.begin) {
            var b = this.begin[i];
            var f = this.finish[i];
            if (b == null || f == null || isNaN(b) || isNaN(f)) {
                throw new TypeError('invalid value for Tween');
            }

            var c = f - b;
            value[i] = this.easing.apply(this, [this.time, b, c, this.duration]);
        }
        this.time++;
        
        if (this.callbacks && this.callbacks.eachStep) {
            // skip frames if frame rate drops below threshold
            if ((new Date().getTime() - this.startTime) / this.time <= 1000 / this.minFrameRate) {
                this.callbacks.eachStep.call(this, value);
            }
        }
        
        if (this.time > this.duration) {
            this.stop();
        }
    },
    
    /**
     * Create empty functions for all easing methods.
     */
    CLASS_NAME: "HGIS.Tween"
});

/**
 * Namespace: HGIS.Easing
 * 
 * Credits:
 *      Easing Equations by Robert Penner, <http://www.robertpenner.com/easing/>
 */
HGIS.Easing = {
    /**
     * Create empty functions for all easing methods.
     */
    CLASS_NAME: "HGIS.Easing"
};

/**
 * Namespace: HGIS.Easing.Linear
 */
HGIS.Easing.Linear = {
    
    /**
     * Function: easeIn
     * 
     * Parameters:
     * t - {Float} time
     * b - {Float} beginning position
     * c - {Float} total change
     * d - {Float} duration of the transition
     *
     * Returns:
     * {Float}
     */
    easeIn: function(t, b, c, d) {
        return c*t/d + b;
    },
    
    /**
     * Function: easeOut
     * 
     * Parameters:
     * t - {Float} time
     * b - {Float} beginning position
     * c - {Float} total change
     * d - {Float} duration of the transition
     *
     * Returns:
     * {Float}
     */
    easeOut: function(t, b, c, d) {
        return c*t/d + b;
    },
    
    /**
     * Function: easeInOut
     * 
     * Parameters:
     * t - {Float} time
     * b - {Float} beginning position
     * c - {Float} total change
     * d - {Float} duration of the transition
     *
     * Returns:
     * {Float}
     */
    easeInOut: function(t, b, c, d) {
        return c*t/d + b;
    },

    CLASS_NAME: "HGIS.Easing.Linear"
};

/**
 * Namespace: HGIS.Easing.Expo
 */
HGIS.Easing.Expo = {
    
    /**
     * Function: easeIn
     * 
     * Parameters:
     * t - {Float} time
     * b - {Float} beginning position
     * c - {Float} total change
     * d - {Float} duration of the transition
     *
     * Returns:
     * {Float}
     */
    easeIn: function(t, b, c, d) {
        return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
    },
    
    /**
     * Function: easeOut
     * 
     * Parameters:
     * t - {Float} time
     * b - {Float} beginning position
     * c - {Float} total change
     * d - {Float} duration of the transition
     *
     * Returns:
     * {Float}
     */
    easeOut: function(t, b, c, d) {
        return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
    },
    
    /**
     * Function: easeInOut
     * 
     * Parameters:
     * t - {Float} time
     * b - {Float} beginning position
     * c - {Float} total change
     * d - {Float} duration of the transition
     *
     * Returns:
     * {Float}
     */
    easeInOut: function(t, b, c, d) {
        if (t==0) return b;
        if (t==d) return b+c;
        if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
        return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
    },

    CLASS_NAME: "HGIS.Easing.Expo"
};

/**
 * Namespace: HGIS.Easing.Quad
 */
HGIS.Easing.Quad = {
    
    /**
     * Function: easeIn
     * 
     * Parameters:
     * t - {Float} time
     * b - {Float} beginning position
     * c - {Float} total change
     * d - {Float} duration of the transition
     *
     * Returns:
     * {Float}
     */
    easeIn: function(t, b, c, d) {
        return c*(t/=d)*t + b;
    },
    
    /**
     * Function: easeOut
     * 
     * Parameters:
     * t - {Float} time
     * b - {Float} beginning position
     * c - {Float} total change
     * d - {Float} duration of the transition
     *
     * Returns:
     * {Float}
     */
    easeOut: function(t, b, c, d) {
        return -c *(t/=d)*(t-2) + b;
    },
    
    /**
     * Function: easeInOut
     * 
     * Parameters:
     * t - {Float} time
     * b - {Float} beginning position
     * c - {Float} total change
     * d - {Float} duration of the transition
     *
     * Returns:
     * {Float}
     */
    easeInOut: function(t, b, c, d) {
        if ((t/=d/2) < 1) return c/2*t*t + b;
        return -c/2 * ((--t)*(t-2) - 1) + b;
    },

    CLASS_NAME: "HGIS.Easing.Quad"
};
/* ======================================================================
    HGIS/Projection.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Util.js
 */
/**
 * Namespace: HGIS.Projection2
 * 坐标转换类.
 * HGIS默认情况下支持地理坐标系（EPSG:4326）与墨卡托（EPSG:900913）两种坐标系之间的转换.其它坐标系的转换需要引入<proj4js at http://proj4js.org/>这个库，才能在各种不同的坐标系之间转换.
 * 
 * 如果没有引入proj4js，仍然希望能转换坐标系，那么使用<addTransform>方法，注册一个自定义的转换方法.
 * 
 * 备注，proj4js支持的坐标系：WGS84, EPSG:4326, EPSG:4269, EPSG:3875, EPSG:3785, EPSG4139,EPSG:4181, EPSG:4272, EPSG:4302, EPSG:21781, EPSG:102113,EPSG:26591,EPSG:26912, EPSG:27200, EPSG:27563, EPSG:41001, EPSG:42304,EPSG:102067, EPSG:102757, EPSG:102758, EPSG:900913, GOOGLE
 */
HGIS.Projection = HGIS.Class({

	/**
	 * Property: proj
	 * {Object} Proj4js.Proj instance.
	 */
	proj : null,

	/**
	 * Property: projCode
	 * {String}
	 */
	projCode : null,

	/**
	 * Property: titleRegEx
	 * {RegExp} regular expression to strip the title from a proj4js definition
	 */
	titleRegEx : /\+title=[^\+]*/,

	/**
	 * Constructor: HGIS.Projection
	 * 构造一个投影转换对象。
	 *
	 * Parameters:
	 * projCode - {String} 投影编码标识
	 * options - {Object} 设置图层上的的附加属性。
	 *
	 * Returns:
	 * {<HGIS.Projection>} 投影对象
	 *
	 * 示例：
	 * (code)
	 * 	var geographic = new HGIS.Projection("EPSG:4326");
	 * (end)
	 */
	initialize : function(projCode, options) {
		HGIS.Util.extend(this, options);
		this.projCode = projCode;
		if( typeof Proj4js == "object") {
			this.proj = new Proj4js.Proj(projCode);
		}
	},
	/**
	 * APIMethod: getCode
	 * 获取SRS代码字符串.
	 *
	 * Returns:
	 * {String} SRS代码.
	 */
	getCode : function() {
		return this.proj ? this.proj.srsCode : this.projCode;
	},
	/**
	 * APIMethod: getUnits
	 * 获取投影的单位字符串。如果 proj4js 不可用则返回null.
	 *
	 * Returns:
	 * {String} 获取的单位.
	 */
	getUnits : function() {
		return this.proj ? this.proj.units : null;
	},
	/**
	 * Method: toString
	 * Convert projection to string (getCode wrapper).
	 *
	 * Returns:
	 * {String} The projection code.
	 */
	toString : function() {
		return this.getCode();
	},
	/**
	 * Method: equals
	 * Test equality of two projection instances.  Determines equality based
	 *     soley on the projection code.
	 *
	 * Returns:
	 * {Boolean} The two projections are equivalent.
	 */
	equals : function(projection) {
		var p = projection, equals = false;
		if(p) {
			if(!( p instanceof HGIS.Projection)) {
				p = new HGIS.Projection(p);
			}
			if(( typeof Proj4js == "object") && this.proj.defData && p.proj.defData) {
				equals = this.proj.defData.replace(this.titleRegEx, "") == p.proj.defData.replace(this.titleRegEx, "");
			} else if(p.getCode) {
				var source = this.getCode(), target = p.getCode();
				equals = source == target || !!HGIS.Projection.transforms[source] && HGIS.Projection.transforms[source][target] === HGIS.Projection.nullTransform;
			}
		}
		return equals;
	},
	/* Method: destroy
	 * Destroy projection object.
	 */
	destroy : function() {
		delete this.proj;
		delete this.projCode;
	},
	CLASS_NAME : "HGIS.Projection"
});

/**
 * Property: transforms
 * {Object} Transforms is an object, with from properties, each of which may
 * have a to property. This allows you to define projections without
 * requiring support for proj4js to be included.
 *
 * This object has keys which correspond to a 'source' projection object.  The
 * keys should be strings, corresponding to the projection.getCode() value.
 * Each source projection object should have a set of destination projection
 * keys included in the object.
 *
 * Each value in the destination object should be a transformation function,
 * where the function is expected to be passed an object with a .x and a .y
 * property.  The function should return the object, with the .x and .y
 * transformed according to the transformation function.
 *
 * Note - Properties on this object should not be set directly.  To add a
 *     transform method to this object, use the <addTransform> method.  For an
 *     example of usage, see the HGIS.Layer.SphericalMercator file.
 */
HGIS.Projection.transforms = {};

/**
 * APIProperty: defaults
 * {Object} 默认支持坐标系.
 *  HGIS 默认支持 EPSG:4326, CRS:84, urn:ogc:def:crs:EPSG:6.6:4326, EPSG:900913, EPSG:3857, EPSG:102113, EPSG:102100 投影间的转换。defaults 定义的关键字为坐标系统编码，相应的属性值为 units, maxExtent(坐标系统的有效范围)和yx(当坐标系统有反向坐标轴时为true)
 */
HGIS.Projection.defaults = {
	"EPSG:4326" : {
		units : "degrees",
		maxExtent : [-180, -90, 180, 90],
		yx : true
	},
	"CRS:84" : {
		units : "degrees",
		maxExtent : [-180, -90, 180, 90]
	},
	"EPSG:900913" : {
		units : "m",
		maxExtent : [-20037508.34, -20037508.34, 20037508.34, 20037508.34]
	}
};

/**
 * APIMethod: addTransform
 * 设置自定义投影转换方法。在proj4js库不可用或者自定义的投影需要处理时使用此方法
 *
 * Parameters:
 * from - {String} 源投影代码
 * to - {String} 目标投影代码
 * method - {Function} 将作为参数的点的源投影转化为目标投影的方法
 */
HGIS.Projection.addTransform = function(from, to, method) {
	if(method === HGIS.Projection.nullTransform) {
		var defaults = HGIS.Projection.defaults[from];
		if(defaults && !HGIS.Projection.defaults[to]) {
			HGIS.Projection.defaults[to] = defaults;
		}
	}
	if(!HGIS.Projection.transforms[from]) {
		HGIS.Projection.transforms[from] = {};
	}
	HGIS.Projection.transforms[from][to] = method;
};
/**
 * APIMethod: transform
 * 点投影转.
 * 将数据由4326转为900913时需进行加密处理，所以数据满足数据在中国区范围内；将数据由900913转为4326时，如果需要对数据进行纠偏，需将HGIS.InitParam.factor变更为1
 * 注意，输入的点将被转换掉
 * 
 * Parameters:
 * point - {<HGIS.Geometry.Point> | Object} 带有x,y坐标的点对象
 * source - {HGIS.Projection} 源地图坐标系统。
 * dest - {HGIS.Projection}  目标地图坐标系统
 *
 * Returns:
 * point - {object}  转换后的坐标.  原始点已被改变
 */
HGIS.Projection.transform = function(point, source, dest) {
		var dProj="",sProj="";
		//获取原坐标系和目标坐标系
		if(dest){
			if(!(dest instanceof HGIS.Projection)){
				dProj=dest;
			}else{
				dProj=dest.getCode();
			}
		}
		if(source){
			if(!(source instanceof HGIS.Projection)){
				sProj=source;
			}else{
				sProj=source.getCode();
			}
		}
		point.oldx=point.x;
		point.oldy=point.y;
		//如果原坐标系和目标坐标系相当，直接返回原数据
		if(sProj == dProj){
			return point;
		}
		//加密
		if(dProj=="EPSG:900913" && HGIS.InitParam.factor=="1"){
			//HGIS.Converter.decry(point)
			if( point.y > 0.8293 && point.y < 55.827 && point.x > 72.004000000000005 && point.x < 137.8347 ){
				var temppoint=HGIS.Converter.encryToGCJ02(point);
				point.x=temppoint.x;
				point.y=temppoint.y;
			}
		}
		if(source && dest) {
			if(!( source instanceof HGIS.Projection)) {
				source = new HGIS.Projection(source);
			}
			if(!( dest instanceof HGIS.Projection)) {
				dest = new HGIS.Projection(dest);
			}
			if(source.proj && dest.proj) {
				point = Proj4js.transform(source.proj, dest.proj, point);
			} else {
				var sourceCode = source.getCode();
				var destCode = dest.getCode();
				var transforms = HGIS.Projection.transforms;
				if(transforms[sourceCode] && transforms[sourceCode][destCode]) {
					transforms[sourceCode][destCode](point);
				}
			}
		}
		//如果有脱密因子则需要进行脱密和加密
		if(HGIS.InitParam.factor=="1" && dProj=="EPSG:4326"){
			//脱密
			var factor=HGIS.Converter.getFactor(point);
//			point.x =HGIS.InitParam.factor.A * point.x * point.x + HGIS.InitParam.factor.B  * point.x * point.y + HGIS.InitParam.factor.C  * point.y * point.y + HGIS.InitParam.factor.D  * point.x + HGIS.InitParam.factor.E  * point.y + HGIS.InitParam.factor.F ;
//			point.y = HGIS.InitParam.factor.H * point.x * point.x + HGIS.InitParam.factor.I  * point.x * point.y + HGIS.InitParam.factor.J * point.y * point.y + HGIS.InitParam.factor.K  * point.x +  HGIS.InitParam.factor.L *point.y + HGIS.InitParam.factor.M;
			point.x =factor.A * point.x * point.x + factor.B  * point.x * point.y + factor.C  * point.y * point.y + factor.D  * point.x + factor.E  * point.y + factor.F ;
			point.y = factor.H * point.x * point.x + factor.I  * point.x * point.y + factor.J * point.y * point.y + factor.K  * point.x +  factor.L *point.y +factor.M;
		}
		return point;
		
};
/**
 * APIFunction: nullTransform
 * 空转换.
 * 当proj4js不可用时，定义投影别名非常有用。
 *
 * 示例：
 * (code)
 * HGIS.Projection.addTransform("EPSG:3857", "EPSG:900913", HGIS.Projection.nullTransform);
 * HGIS.Projection.addTransform("EPSG:900913", "EPSG:3857", HGIS.Projection.nullTransform);
 * (end)
 */
HGIS.Projection.nullTransform = function(point) {
	return point;
};
/**
 * Note: Transforms for web mercator <-> geographic
 * HGIS recognizes EPSG:3857, EPSG:900913, EPSG:102113 and EPSG:102100.
 * HGIS originally started referring to EPSG:900913 as web mercator.
 * The EPSG has declared EPSG:3857 to be web mercator.
 * ArcGIS 10 recognizes the EPSG:3857, EPSG:102113, and EPSG:102100 as
 * equivalent.  See http://blogs.esri.com/Dev/blogs/arcgisserver/archive/2009/11/20/ArcGIS-Online-moving-to-Google-_2F00_-Bing-tiling-scheme_3A00_-What-does-this-mean-for-you_3F00_.aspx#12084.
 * For geographic, HGIS recognizes EPSG:4326, CRS:84 and
 * urn:ogc:def:crs:EPSG:6.6:4326. HGIS also knows about the reverse axis
 * order for EPSG:4326.
 */
(function() {

	var pole = 20037508.34;

	function inverseMercator(xy) {
		xy.x = 180 * xy.x / pole;
		xy.y = 180 / Math.PI * (2 * Math.atan(Math.exp((xy.y / pole) * Math.PI)) - Math.PI / 2);
		return xy;
	}

	function forwardMercator(xy) {
		xy.x = xy.x * pole / 180;
		var y = Math.log(Math.tan((90 + xy.y) * Math.PI / 360)) / Math.PI * pole;
		xy.y = Math.max(-20037508.34, Math.min(y, 20037508.34));
		return xy;
	}

	function map(base, codes) {
		var add = HGIS.Projection.addTransform;
		var same = HGIS.Projection.nullTransform;
		var i, len, code, other, j;
		for( i = 0, len = codes.length; i < len; ++i) {
			code = codes[i];
			add(base, code, forwardMercator);
			add(code, base, inverseMercator);
			for( j = i + 1; j < len; ++j) {
				other = codes[j];
				add(code, other, same);
				add(other, code, same);
			}
		}
	}

	// list of equivalent codes for web mercator
	var mercator = ["EPSG:900913", "EPSG:3857", "EPSG:102113", "EPSG:102100"], geographic = ["CRS:84", "urn:ogc:def:crs:EPSG:6.6:4326", "EPSG:4326"], i;
	for( i = mercator.length - 1; i >= 0; --i) {
		map(mercator[i], geographic);
	}
	for( i = geographic.length - 1; i >= 0; --i) {
		map(geographic[i], mercator);
	}

})();
/* ======================================================================
    HGIS/Map.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Util.js
 * @requires HGIS/Util/vendorPrefix.js
 * @requires HGIS/Events.js
 * @requires HGIS/Tween.js
 * @requires HGIS/Projection.js
 */

/**
 * Class: HGIS.Map
 * Instances of HGIS.Map are interactive maps embedded in a web page.
 * Create a new map with the <HGIS.Map> constructor.
 * 
 * On their own maps do not provide much functionality.  To extend a map
 * it's necessary to add controls (<HGIS.Control>) and 
 * layers (<HGIS.Layer>) to the map. 
 */
HGIS.Map = HGIS.Class({
    
    /**
     * Constant: Z_INDEX_BASE
     * {Object} Base z-indexes for different classes of thing 
     */
    Z_INDEX_BASE: {
        BaseLayer: 100,
        Overlay: 325,
        Feature: 725,
        Popup: 750,
        Control: 1000
    },

    /**
     * APIProperty: events
     * {<HGIS.Events>}
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * map.events.register(type, obj, listener);
     * (end)
     *
     * Listeners will be called with a reference to an event object.  The
     *     properties of this event depends on exactly what happened.
     *
     * All event objects have at least the following properties:
     * object - {Object} A reference to map.events.object.
     * element - {DOMElement} A reference to map.events.element.
     *
     * Browser events have the following additional properties:
     * xy - {<HGIS.Pixel>} The pixel location of the event (relative
     *     to the the map viewport).
     *
     * Supported map event types:
     * preaddlayer - triggered before a layer has been added.  The event
     *     object will include a *layer* property that references the layer  
     *     to be added. When a listener returns "false" the adding will be 
     *     aborted.
     * addlayer - triggered after a layer has been added.  The event object
     *     will include a *layer* property that references the added layer.
     * preremovelayer - triggered before a layer has been removed. The event
     *     object will include a *layer* property that references the layer  
     *     to be removed. When a listener returns "false" the removal will be 
     *     aborted.
     * removelayer - triggered after a layer has been removed.  The event
     *     object will include a *layer* property that references the removed
     *     layer.
     * changelayer - triggered after a layer name change, order change,
     *     opacity change, params change, visibility change (actual visibility,
     *     not the layer's visibility property) or attribution change (due to
     *     extent change). Listeners will receive an event object with *layer*
     *     and *property* properties. The *layer* property will be a reference
     *     to the changed layer. The *property* property will be a key to the
     *     changed property (name, order, opacity, params, visibility or
     *     attribution).
     * movestart - triggered after the start of a drag, pan, or zoom. The event
     *     object may include a *zoomChanged* property that tells whether the
     *     zoom has changed.
     * move - triggered after each drag, pan, or zoom
     * moveend - triggered after a drag, pan, or zoom completes
     * zoomend - triggered after a zoom completes
     * mouseover - triggered after mouseover the map
     * mouseout - triggered after mouseout the map
     * mousemove - triggered after mousemove the map
     * changebaselayer - triggered after the base layer changes
     * updatesize - triggered after the <updateSize> method was executed
     */

    /**
     * Property: id
     * {String} Unique identifier for the map
     */
    id: null,
    
    /**
     * Property: fractionalZoom
     * {Boolean} For a base layer that supports it, allow the map resolution
     *     to be set to a value between one of the values in the resolutions
     *     array.  Default is false.
     *
     * When fractionalZoom is set to true, it is possible to zoom to
     *     an arbitrary extent.  This requires a base layer from a source
     *     that supports requests for arbitrary extents (i.e. not cached
     *     tiles on a regular lattice).  This means that fractionalZoom
     *     will not work with commercial layers (Google, Yahoo, VE), layers
     *     using TileCache, or any other pre-cached data sources.
     *
     * If you are using fractionalZoom, then you should also use
     *     <getResolutionForZoom> instead of layer.resolutions[zoom] as the
     *     former works for non-integer zoom levels.
     */
    fractionalZoom: false,
    
    /**
     * APIProperty: events
     * {<HGIS.Events>} An events object that handles all 
     *                       events on the map
     */
    events: null,
    
    /**
     * APIProperty: allOverlays
     * {Boolean} Allow the map to function with "overlays" only.  Defaults to
     *     false.  If true, the lowest layer in the draw order will act as
     *     the base layer.  In addition, if set to true, all layers will
     *     have isBaseLayer set to false when they are added to the map.
     *
     * Note:
     * If you set map.allOverlays to true, then you *cannot* use
     *     map.setBaseLayer or layer.setIsBaseLayer.  With allOverlays true,
     *     the lowest layer in the draw layer is the base layer.  So, to change
     *     the base layer, use <setLayerIndex> or <raiseLayer> to set the layer
     *     index to 0.
     */
    allOverlays: false,

    /**
     * APIProperty: div
     * {DOMElement|String} The element that contains the map (or an id for
     *     that element).  If the <HGIS.Map> constructor is called
     *     with two arguments, this should be provided as the first argument.
     *     Alternatively, the map constructor can be called with the options
     *     object as the only argument.  In this case (one argument), a
     *     div property may or may not be provided.  If the div property
     *     is not provided, the map can be rendered to a container later
     *     using the <render> method.
     *     
     * Note:
     * If you are calling <render> after map construction, do not use
     *     <maxResolution>  auto.  Instead, divide your <maxExtent> by your
     *     maximum expected dimension.
     */
    div: null,
    
    /**
     * Property: dragging
     * {Boolean} The map is currently being dragged.
     */
    dragging: false,

    /**
     * Property: size
     * {<HGIS.Size>} Size of the main div (this.div)
     */
    size: null,
    
    /**
     * Property: viewPortDiv
     * {HTMLDivElement} The element that represents the map viewport
     */
    viewPortDiv: null,

    /**
     * Property: layerContainerOrigin
     * {<HGIS.LonLat>} The lonlat at which the later container was
     *                       re-initialized (on-zoom)
     */
    layerContainerOrigin: null,

    /**
     * Property: layerContainerDiv
     * {HTMLDivElement} The element that contains the layers.
     */
    layerContainerDiv: null,

    /**
     * APIProperty: layers
     * {Array(<HGIS.Layer>)} Ordered list of layers in the map
     */
    layers: null,

    /**
     * APIProperty: controls
     * {Array(<HGIS.Control>)} List of controls associated with the map.
     *
     * If not provided in the map options at construction, the map will
     *     by default be given the following controls if present in the build:
     *  - <HGIS.Control.Navigation> or <HGIS.Control.TouchNavigation>
     *  - <HGIS.Control.Zoom> or <HGIS.Control.PanZoom>
     *  - <HGIS.Control.ArgParser>
     *  - <HGIS.Control.Attribution>
     */
    controls: null,

    /**
     * Property: popups
     * {Array(<HGIS.Popup>)} List of popups associated with the map
     */
    popups: null,

    /**
     * APIProperty: baseLayer
     * {<HGIS.Layer>} The currently selected base layer.  This determines
     * min/max zoom level, projection, etc.
     */
    baseLayer: null,
    
    /**
     * Property: center
     * {<HGIS.LonLat>} The current center of the map
     */
    center: null,

    /**
     * Property: resolution
     * {Float} The resolution of the map.
     */
    resolution: null,

    /**
     * Property: zoom
     * {Integer} The current zoom level of the map
     */
    zoom: 0,    

    /**
     * Property: panRatio
     * {Float} The ratio of the current extent within
     *         which panning will tween.
     */
    panRatio: 1.5,    

    /**
     * APIProperty: options
     * {Object} The options object passed to the class constructor. Read-only.
     */
    options: null,

  // Options

    /**
     * APIProperty: tileSize
     * {<HGIS.Size>} Set in the map options to override the default tile
     *                     size for this map.
     */
    tileSize: null,

    /**
     * APIProperty: projection
     * {String} Set in the map options to specify the default projection 
     *          for layers added to this map. When using a projection other than EPSG:4326
     *          (CRS:84, Geographic) or EPSG:3857 (EPSG:900913, Web Mercator),
     *          also set maxExtent, maxResolution or resolutions.  Default is "EPSG:4326".
     *          Note that the projection of the map is usually determined
     *          by that of the current baseLayer (see <baseLayer> and <getProjectionObject>).
     */
    projection: "EPSG:4326",    
        
    /**
     * APIProperty: units
     * {String} The map units.  Possible values are 'degrees' (or 'dd'), 'm', 
     *     'ft', 'km', 'mi', 'inches'.  Normally taken from the projection.
     *     Only required if both map and layers do not define a projection,
     *     or if they define a projection which does not define units
     */
    units: null,

    /**
     * APIProperty: resolutions
     * {Array(Float)} A list of map resolutions (map units per pixel) in 
     *     descending order.  If this is not set in the layer constructor, it 
     *     will be set based on other resolution related properties 
     *     (maxExtent, maxResolution, maxScale, etc.).
     */
    resolutions: null,

    /**
     * APIProperty: maxResolution
     * {Float} Required if you are not displaying the whole world on a tile
     * with the size specified in <tileSize>.
     */
    maxResolution: null,

    /**
     * APIProperty: minResolution
     * {Float}
     */
    minResolution: null,

    /**
     * APIProperty: maxScale
     * {Float}
     */
    maxScale: null,

    /**
     * APIProperty: minScale
     * {Float}
     */
    minScale: null,

    /**
     * APIProperty: maxExtent
     * {<HGIS.Bounds>|Array} If provided as an array, the array
     *     should consist of four values (left, bottom, right, top).
     *     The maximum extent for the map.
     *     Default depends on projection; if this is one of those defined in HGIS.Projection.defaults
     *     (EPSG:4326 or web mercator), maxExtent will be set to the value defined there;
     *     else, defaults to null.
     *     To restrict user panning and zooming of the map, use <restrictedExtent> instead.
     *     The value for <maxExtent> will change calculations for tile URLs.
     */
    maxExtent: null,
    
    /**
     * APIProperty: minExtent
     * {<HGIS.Bounds>|Array} If provided as an array, the array
     *     should consist of four values (left, bottom, right, top).
     *     The minimum extent for the map.  Defaults to null.
     */
    minExtent: null,
    
    /**
     * APIProperty: restrictedExtent
     * {<HGIS.Bounds>|Array} If provided as an array, the array
     *     should consist of four values (left, bottom, right, top).
     *     Limit map navigation to this extent where possible.
     *     If a non-null restrictedExtent is set, panning will be restricted
     *     to the given bounds.  In addition, zooming to a resolution that
     *     displays more than the restricted extent will center the map
     *     on the restricted extent.  If you wish to limit the zoom level
     *     or resolution, use maxResolution.
     */
    restrictedExtent: null,

    /**
     * APIProperty: numZoomLevels
     * {Integer} Number of zoom levels for the map.  Defaults to 16.  Set a
     *           different value in the map options if needed.
     */
    numZoomLevels: 16,

    /**
     * APIProperty: theme
     * {String} Relative path to a CSS file from which to load theme styles.
     *          Specify null in the map options (e.g. {theme: null}) if you 
     *          want to get cascading style declarations - by putting links to 
     *          stylesheets or style declarations directly in your page.
     */
    theme: null,
    
    /** 
     * APIProperty: displayProjection
     * {<HGIS.Projection>} Requires proj4js support for projections other
     *     than EPSG:4326 or EPSG:900913/EPSG:3857. Projection used by
     *     several controls to display data to user. If this property is set,
     *     it will be set on any control which has a null displayProjection
     *     property at the time the control is added to the map. 
     */
    displayProjection: null,

    /**
     * APIProperty: tileManager
     * {<HGIS.TileManager>|Object} By default, and if the build contains
     * TileManager.js, the map will use the TileManager to queue image requests
     * and to cache tile image elements. To create a map without a TileManager
     * configure the map with tileManager: null. To create a TileManager with
     * non-default options, supply the options instead or alternatively supply
     * an instance of {<HGIS.TileManager>}.
     */

    /**
     * APIProperty: fallThrough
     * {Boolean} Should HGIS allow events on the map to fall through to
     *           other elements on the page, or should it swallow them? (#457)
     *           Default is to swallow.
     */
    fallThrough: false,

    /**
     * APIProperty: autoUpdateSize
     * {Boolean} Should HGIS automatically update the size of the map
     * when the resize event is fired. Default is true.
     */
    autoUpdateSize: true,
    
    /**
     * APIProperty: eventListeners
     * {Object} If set as an option at construction, the eventListeners
     *     object will be registered with <HGIS.Events.on>.  Object
     *     structure must be a listeners object as shown in the example for
     *     the events.on method.
     */
    eventListeners: null,

    /**
     * Property: panTween
     * {<HGIS.Tween>} Animated panning tween object, see panTo()
     */
    panTween: null,

    /**
     * APIProperty: panMethod
     * {Function} The Easing function to be used for tweening.  Default is
     * HGIS.Easing.Expo.easeOut. Setting this to 'null' turns off
     * animated panning.
     */
    panMethod: HGIS.Easing.Expo.easeOut,
    
    /**
     * Property: panDuration
     * {Integer} The number of steps to be passed to the
     * HGIS.Tween.start() method when the map is
     * panned.
     * Default is 50.
     */
    panDuration: 50,
    
    /**
     * Property: zoomTween
     * {<HGIS.Tween>} Animated zooming tween object, see zoomTo()
     */
    zoomTween: null,

    /**
     * APIProperty: zoomMethod
     * {Function} The Easing function to be used for tweening.  Default is
     * HGIS.Easing.Quad.easeOut. Setting this to 'null' turns off
     * animated zooming.
     */
    zoomMethod: HGIS.Easing.Quad.easeOut,
    
    /**
     * Property: zoomDuration
     * {Integer} The number of steps to be passed to the
     * HGIS.Tween.start() method when the map is zoomed.
     * Default is 20.
     */
    zoomDuration: 20,
    
    /**
     * Property: paddingForPopups
     * {<HGIS.Bounds>} Outside margin of the popup. Used to prevent 
     *     the popup from getting too close to the map border.
     */
    paddingForPopups : null,
    
    /**
     * Property: layerContainerOriginPx
     * {Object} Cached object representing the layer container origin (in pixels).
     */
    layerContainerOriginPx: null,
    
    /**
     * Property: minPx
     * {Object} An object with a 'x' and 'y' values that is the lower
     *     left of maxExtent in viewport pixel space.
     *     Used to verify in moveByPx that the new location we're moving to
     *     is valid. It is also used in the getLonLatFromViewPortPx function
     *     of Layer.
     */
    minPx: null,
    
    /**
     * Property: maxPx
     * {Object} An object with a 'x' and 'y' values that is the top
     *     right of maxExtent in viewport pixel space.
     *     Used to verify in moveByPx that the new location we're moving to
     *     is valid.
     */
    maxPx: null,
    
    /**
     * Constructor: HGIS.Map
     * Constructor for a new HGIS.Map instance.  There are two possible
     *     ways to call the map constructor.  See the examples below.
     *
     * Parameters:
     * div - {DOMElement|String}  The element or id of an element in your page
     *     that will contain the map.  May be omitted if the <div> option is
     *     provided or if you intend to call the <render> method later.
     * options - {Object} Optional object with properties to tag onto the map.
     *
     * Valid options (in addition to the listed API properties):
     * center - {<HGIS.LonLat>|Array} The default initial center of the map.
     *     If provided as array, the first value is the x coordinate,
     *     and the 2nd value is the y coordinate.
     *     Only specify if <layers> is provided.
     *     Note that if an ArgParser/Permalink control is present,
     *     and the querystring contains coordinates, center will be set
     *     by that, and this option will be ignored.
     * zoom - {Number} The initial zoom level for the map. Only specify if
     *     <layers> is provided.
     *     Note that if an ArgParser/Permalink control is present,
     *     and the querystring contains a zoom level, zoom will be set
     *     by that, and this option will be ignored.
     * extent - {<HGIS.Bounds>|Array} The initial extent of the map.
     *     If provided as an array, the array should consist of
     *     four values (left, bottom, right, top).
     *     Only specify if <center> and <zoom> are not provided.
     * 
     * Examples:
     * (code)
     * // create a map with default options in an element with the id "map1"
     * var map = new HGIS.Map("map1");
     *
     * // create a map with non-default options in an element with id "map2"
     * var options = {
     *     projection: "EPSG:3857",
     *     maxExtent: new HGIS.Bounds(-200000, -200000, 200000, 200000),
     *     center: new HGIS.LonLat(-12356463.476333, 5621521.4854095)
     * };
     * var map = new HGIS.Map("map2", options);
     *
     * // map with non-default options - same as above but with a single argument,
     * // a restricted extent, and using arrays for bounds and center
     * var map = new HGIS.Map({
     *     div: "map_id",
     *     projection: "EPSG:3857",
     *     maxExtent: [-18924313.432222, -15538711.094146, 18924313.432222, 15538711.094146],
     *     restrictedExtent: [-13358338.893333, -9608371.5085962, 13358338.893333, 9608371.5085962],
     *     center: [-12356463.476333, 5621521.4854095]
     * });
     *
     * // create a map without a reference to a container - call render later
     * var map = new HGIS.Map({
     *     projection: "EPSG:3857",
     *     maxExtent: new HGIS.Bounds(-200000, -200000, 200000, 200000)
     * });
     * (end)
     */    
    initialize: function (div, options) {
        
        // If only one argument is provided, check if it is an object.
        if(arguments.length === 1 && typeof div === "object") {
            options = div;
            div = options && options.div;
        }

        // Simple-type defaults are set in class definition. 
        //  Now set complex-type defaults 
        this.tileSize = new HGIS.Size(HGIS.Map.TILE_WIDTH,
                                            HGIS.Map.TILE_HEIGHT);
        
        this.paddingForPopups = new HGIS.Bounds(15, 15, 15, 15);

        // backup original options
        this.options = HGIS.Util.extend({}, options);

        // now override default options 
        HGIS.Util.extend(this, options);
        
        var projCode = this.projection instanceof HGIS.Projection ?
            this.projection.projCode : this.projection;
        HGIS.Util.applyDefaults(this, HGIS.Projection.defaults[projCode]);
        
        // allow extents and center to be arrays
        if (this.maxExtent && !(this.maxExtent instanceof HGIS.Bounds)) {
            this.maxExtent = new HGIS.Bounds(this.maxExtent);
        }
        if (this.minExtent && !(this.minExtent instanceof HGIS.Bounds)) {
            this.minExtent = new HGIS.Bounds(this.minExtent);
        }
        if (this.restrictedExtent && !(this.restrictedExtent instanceof HGIS.Bounds)) {
            this.restrictedExtent = new HGIS.Bounds(this.restrictedExtent);
        }
        if (this.center && !(this.center instanceof HGIS.LonLat)) {
            this.center = new HGIS.LonLat(this.center);
        }

        // initialize layers array
        this.layers = [];

        this.id = HGIS.Util.createUniqueID("HGIS.Map_");

        this.div = HGIS.Util.getElement(div);
        if(!this.div) {
            this.div = document.createElement("div");
            this.div.style.height = "1px";
            this.div.style.width = "1px";
        }
        
        HGIS.Element.addClass(this.div, 'olMap');

        // the viewPortDiv is the outermost div we modify
        var id = this.id + "_HGIS_ViewPort";
        this.viewPortDiv = HGIS.Util.createDiv(id, null, null, null,
                                                     "relative", null,
                                                     "hidden");
        this.viewPortDiv.style.width = "100%";
        this.viewPortDiv.style.height = "100%";
        this.viewPortDiv.className = "olMapViewport";
        this.div.appendChild(this.viewPortDiv);

        this.events = new HGIS.Events(
            this, this.viewPortDiv, null, this.fallThrough, 
            {includeXY: true}
        );
        
        if (HGIS.TileManager && this.tileManager !== null) {
            if (!(this.tileManager instanceof HGIS.TileManager)) {
                this.tileManager = new HGIS.TileManager(this.tileManager);
            }
            this.tileManager.addMap(this);
        }

        // the layerContainerDiv is the one that holds all the layers
        id = this.id + "_HGIS_Container";
        this.layerContainerDiv = HGIS.Util.createDiv(id);
        this.layerContainerDiv.style.zIndex=this.Z_INDEX_BASE['Popup']-1;
        this.layerContainerOriginPx = {x: 0, y: 0};
        this.applyTransform();
        
        this.viewPortDiv.appendChild(this.layerContainerDiv);

        this.updateSize();
        if(this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }

        if (this.autoUpdateSize === true) {
            // updateSize on catching the window's resize
            // Note that this is ok, as updateSize() does nothing if the 
            // map's size has not actually changed.
            this.updateSizeDestroy = HGIS.Function.bind(this.updateSize, 
                this);
            HGIS.Event.observe(window, 'resize',
                            this.updateSizeDestroy);
        }
        
        // only append link stylesheet if the theme property is set
        if(this.theme) {
            // check existing links for equivalent url
            var addNode = true;
            var nodes = document.getElementsByTagName('link');
            for(var i=0, len=nodes.length; i<len; ++i) {
                if(HGIS.Util.isEquivalentUrl(nodes.item(i).href,
                                                   this.theme)) {
                    addNode = false;
                    break;
                }
            }
            // only add a new node if one with an equivalent url hasn't already
            // been added
            if(addNode) {
                var cssNode = document.createElement('link');
                cssNode.setAttribute('rel', 'stylesheet');
                cssNode.setAttribute('type', 'text/css');
                cssNode.setAttribute('href', this.theme);
                document.getElementsByTagName('head')[0].appendChild(cssNode);
            }
        }
        
        if (this.controls == null) { // default controls
            this.controls = [];
            if (HGIS.Control != null) { // running full or lite?
                // Navigation or TouchNavigation depending on what is in build
                if (HGIS.Control.Navigation) {
                    this.controls.push(new HGIS.Control.Navigation());
                } else if (HGIS.Control.TouchNavigation) {
                    this.controls.push(new HGIS.Control.TouchNavigation());
                }
                if (HGIS.Control.Zoom) {
                    this.controls.push(new HGIS.Control.Zoom());
                } else if (HGIS.Control.PanZoom) {
                    this.controls.push(new HGIS.Control.PanZoom());
                }

                if (HGIS.Control.ArgParser) {
                    this.controls.push(new HGIS.Control.ArgParser());
                }
                if (HGIS.Control.Attribution) {
                    this.controls.push(new HGIS.Control.Attribution());
                }
            }
        }

        for(var i=0, len=this.controls.length; i<len; i++) {
            this.addControlToMap(this.controls[i]);
        }

        this.popups = [];

        this.unloadDestroy = HGIS.Function.bind(this.destroy, this);
        

        // always call map.destroy()
        HGIS.Event.observe(window, 'unload', this.unloadDestroy);
        
        // add any initial layers
        if (options && options.layers) {
            /** 
             * If you have set options.center, the map center property will be
             * set at this point.  However, since setCenter has not been called,
             * addLayers gets confused.  So we delete the map center in this 
             * case.  Because the check below uses options.center, it will
             * be properly set below.
             */
            delete this.center;
            delete this.zoom;
            this.addLayers(options.layers);
            // set center (and optionally zoom)
            if (options.center && !this.getCenter()) {
                // zoom can be undefined here
                this.setCenter(options.center, options.zoom);
            }
        }

        if (this.panMethod) {
            this.panTween = new HGIS.Tween(this.panMethod);
        }
        if (this.zoomMethod && this.applyTransform.transform) {
            this.zoomTween = new HGIS.Tween(this.zoomMethod);
        }
    },

    /** 
     * APIMethod: getViewport
     * Get the DOMElement representing the view port.
     *
     * Returns:
     * {DOMElement}
     */
    getViewport: function() {
        return this.viewPortDiv;
    },
    
    /**
     * APIMethod: render
     * Render the map to a specified container.
     * 
     * Parameters:
     * div - {String|DOMElement} The container that the map should be rendered
     *     to. If different than the current container, the map viewport
     *     will be moved from the current to the new container.
     */
    render: function(div) {
        this.div = HGIS.Util.getElement(div);
        HGIS.Element.addClass(this.div, 'olMap');
        this.viewPortDiv.parentNode.removeChild(this.viewPortDiv);
        this.div.appendChild(this.viewPortDiv);
        this.updateSize();
    },

    /**
     * Method: unloadDestroy
     * Function that is called to destroy the map on page unload. stored here
     *     so that if map is manually destroyed, we can unregister this.
     */
    unloadDestroy: null,
    
    /**
     * Method: updateSizeDestroy
     * When the map is destroyed, we need to stop listening to updateSize
     *    events: this method stores the function we need to unregister in 
     *    non-IE browsers.
     */
    updateSizeDestroy: null,

    /**
     * APIMethod: destroy
     * Destroy this map.
     *    Note that if you are using an application which removes a container
     *    of the map from the DOM, you need to ensure that you destroy the
     *    map *before* this happens; otherwise, the page unload handler
     *    will fail because the DOM elements that map.destroy() wants
     *    to clean up will be gone. (See 
     *    http://trac.osgeo.org/HGIS/ticket/2277 for more information).
     *    This will apply to GeoExt and also to other applications which
     *    modify the DOM of the container of the HGIS Map.
     */
    destroy:function() {
        // if unloadDestroy is null, we've already been destroyed
        if (!this.unloadDestroy) {
            return false;
        }
        
        // make sure panning doesn't continue after destruction
        if(this.panTween) {
            this.panTween.stop();
            this.panTween = null;
        }
        // make sure zooming doesn't continue after destruction
        if(this.zoomTween) {
            this.zoomTween.stop();
            this.zoomTween = null;
        }

        // map has been destroyed. dont do it again!
        HGIS.Event.stopObserving(window, 'unload', this.unloadDestroy);
        this.unloadDestroy = null;

        if (this.updateSizeDestroy) {
            HGIS.Event.stopObserving(window, 'resize', 
                                           this.updateSizeDestroy);
        }
        
        this.paddingForPopups = null;    

        if (this.controls != null) {
            for (var i = this.controls.length - 1; i>=0; --i) {
                this.controls[i].destroy();
            } 
            this.controls = null;
        }
        if (this.layers != null) {
            for (var i = this.layers.length - 1; i>=0; --i) {
                //pass 'false' to destroy so that map wont try to set a new 
                // baselayer after each baselayer is removed
                this.layers[i].destroy(false);
            } 
            this.layers = null;
        }
        if (this.viewPortDiv && this.viewPortDiv.parentNode) {
            this.viewPortDiv.parentNode.removeChild(this.viewPortDiv);
        }
        this.viewPortDiv = null;
        
        if (this.tileManager) {
            this.tileManager.removeMap(this);
            this.tileManager = null;
        }

        if(this.eventListeners) {
            this.events.un(this.eventListeners);
            this.eventListeners = null;
        }
        this.events.destroy();
        this.events = null;

        this.options = null;
    },

    /**
     * APIMethod: setOptions
     * Change the map options
     *
     * Parameters:
     * options - {Object} Hashtable of options to tag to the map
     */
    setOptions: function(options) {
        var updatePxExtent = this.minPx &&
            options.restrictedExtent != this.restrictedExtent;
        HGIS.Util.extend(this, options);
        // force recalculation of minPx and maxPx
        updatePxExtent && this.moveTo(this.getCachedCenter(), this.zoom, {
            forceZoomChange: true
        });
    },

    /**
     * APIMethod: getTileSize
     * Get the tile size for the map
     *
     * Returns:
     * {<HGIS.Size>}
     */
     getTileSize: function() {
         return this.tileSize;
     },


    /**
     * APIMethod: getBy
     * Get a list of objects given a property and a match item.
     *
     * Parameters:
     * array - {String} A property on the map whose value is an array.
     * property - {String} A property on each item of the given array.
     * match - {String | Object} A string to match.  Can also be a regular
     *     expression literal or object.  In addition, it can be any object
     *     with a method named test.  For reqular expressions or other, if
     *     match.test(map[array][i][property]) evaluates to true, the item will
     *     be included in the array returned.  If no items are found, an empty
     *     array is returned.
     *
     * Returns:
     * {Array} An array of items where the given property matches the given
     *     criteria.
     */
    getBy: function(array, property, match) {
        var test = (typeof match.test == "function");
        var found = HGIS.Array.filter(this[array], function(item) {
            return item[property] == match || (test && match.test(item[property]));
        });
        return found;
    },

    /**
     * APIMethod: getLayersBy
     * Get a list of layers with properties matching the given criteria.
     *
     * Parameters:
     * property - {String} A layer property to be matched.
     * match - {String | Object} A string to match.  Can also be a regular
     *     expression literal or object.  In addition, it can be any object
     *     with a method named test.  For reqular expressions or other, if
     *     match.test(layer[property]) evaluates to true, the layer will be
     *     included in the array returned.  If no layers are found, an empty
     *     array is returned.
     *
     * Returns:
     * {Array(<HGIS.Layer>)} A list of layers matching the given criteria.
     *     An empty array is returned if no matches are found.
     */
    getLayersBy: function(property, match) {
        return this.getBy("layers", property, match);
    },

    /**
     * APIMethod: getLayersByName
     * Get a list of layers with names matching the given name.
     *
     * Parameters:
     * match - {String | Object} A layer name.  The name can also be a regular
     *     expression literal or object.  In addition, it can be any object
     *     with a method named test.  For reqular expressions or other, if
     *     name.test(layer.name) evaluates to true, the layer will be included
     *     in the list of layers returned.  If no layers are found, an empty
     *     array is returned.
     *
     * Returns:
     * {Array(<HGIS.Layer>)} A list of layers matching the given name.
     *     An empty array is returned if no matches are found.
     */
    getLayersByName: function(match) {
        return this.getLayersBy("name", match);
    },

    /**
     * APIMethod: getLayersByClass
     * Get a list of layers of a given class (CLASS_NAME).
     *
     * Parameters:
     * match - {String | Object} A layer class name.  The match can also be a
     *     regular expression literal or object.  In addition, it can be any
     *     object with a method named test.  For reqular expressions or other,
     *     if type.test(layer.CLASS_NAME) evaluates to true, the layer will
     *     be included in the list of layers returned.  If no layers are
     *     found, an empty array is returned.
     *
     * Returns:
     * {Array(<HGIS.Layer>)} A list of layers matching the given class.
     *     An empty array is returned if no matches are found.
     */
    getLayersByClass: function(match) {
        return this.getLayersBy("CLASS_NAME", match);
    },

    /**
     * APIMethod: getControlsBy
     * Get a list of controls with properties matching the given criteria.
     *
     * Parameters:
     * property - {String} A control property to be matched.
     * match - {String | Object} A string to match.  Can also be a regular
     *     expression literal or object.  In addition, it can be any object
     *     with a method named test.  For reqular expressions or other, if
     *     match.test(layer[property]) evaluates to true, the layer will be
     *     included in the array returned.  If no layers are found, an empty
     *     array is returned.
     *
     * Returns:
     * {Array(<HGIS.Control>)} A list of controls matching the given
     *     criteria.  An empty array is returned if no matches are found.
     */
    getControlsBy: function(property, match) {
        return this.getBy("controls", property, match);
    },

    /**
     * APIMethod: getControlsByClass
     * Get a list of controls of a given class (CLASS_NAME).
     *
     * Parameters:
     * match - {String | Object} A control class name.  The match can also be a
     *     regular expression literal or object.  In addition, it can be any
     *     object with a method named test.  For reqular expressions or other,
     *     if type.test(control.CLASS_NAME) evaluates to true, the control will
     *     be included in the list of controls returned.  If no controls are
     *     found, an empty array is returned.
     *
     * Returns:
     * {Array(<HGIS.Control>)} A list of controls matching the given class.
     *     An empty array is returned if no matches are found.
     */
    getControlsByClass: function(match) {
        return this.getControlsBy("CLASS_NAME", match);
    },

  /********************************************************/
  /*                                                      */
  /*                  Layer Functions                     */
  /*                                                      */
  /*     The following functions deal with adding and     */
  /*        removing Layers to and from the Map           */
  /*                                                      */
  /********************************************************/         

    /**
     * APIMethod: getLayer
     * Get a layer based on its id
     *
     * Parameters:
     * id - {String} A layer id
     *
     * Returns:
     * {<HGIS.Layer>} The Layer with the corresponding id from the map's 
     *                      layer collection, or null if not found.
     */
    getLayer: function(id) {
        var foundLayer = null;
        for (var i=0, len=this.layers.length; i<len; i++) {
            var layer = this.layers[i];
            if (layer.id == id) {
                foundLayer = layer;
                break;
            }
        }
        return foundLayer;
    },

    /**
    * Method: setLayerZIndex
    * 
    * Parameters:
    * layer - {<HGIS.Layer>} 
    * zIdx - {int} 
    */    
    setLayerZIndex: function (layer, zIdx) {
        layer.setZIndex(
            this.Z_INDEX_BASE[layer.isBaseLayer ? 'BaseLayer' : 'Overlay']
            + zIdx * 5 );
    },

    /**
     * Method: resetLayersZIndex
     * Reset each layer's z-index based on layer's array index
     */
    resetLayersZIndex: function() {
        for (var i=0, len=this.layers.length; i<len; i++) {
            var layer = this.layers[i];
            this.setLayerZIndex(layer, i);
        }
    },

    /**
    * APIMethod: addLayer
    *
    * Parameters:
    * layer - {<HGIS.Layer>} 
    *
    * Returns:
    * {Boolean} True if the layer has been added to the map.
    */    
    addLayer: function (layer) {
        for(var i = 0, len = this.layers.length; i < len; i++) {
            if (this.layers[i] == layer) {
                return false;
            }
        }
        if (this.events.triggerEvent("preaddlayer", {layer: layer}) === false) {
            return false;
        }
        if(this.allOverlays) {
            layer.isBaseLayer = false;
        }
        
        layer.div.className = "olLayerDiv";
        layer.div.style.overflow = "";
        this.setLayerZIndex(layer, this.layers.length);

        if (layer.isFixed) {
            this.viewPortDiv.appendChild(layer.div);
        } else {
            this.layerContainerDiv.appendChild(layer.div);
        }
        this.layers.push(layer);
        layer.setMap(this);

        if (layer.isBaseLayer || (this.allOverlays && !this.baseLayer))  {
            if (this.baseLayer == null) {
                // set the first baselaye we add as the baselayer
                this.setBaseLayer(layer);
            } else {
                layer.setVisibility(false);
            }
        } else {
            layer.redraw();
        }

        this.events.triggerEvent("addlayer", {layer: layer});
        layer.events.triggerEvent("added", {map: this, layer: layer});
        layer.afterAdd();

        return true;
    },

    /**
    * APIMethod: addLayers 
    *
    * Parameters:
    * layers - {Array(<HGIS.Layer>)} 
    */    
    addLayers: function (layers) {
        for (var i=0, len=layers.length; i<len; i++) {
            this.addLayer(layers[i]);
        }
    },

    /** 
     * APIMethod: removeLayer
     * Removes a layer from the map by removing its visual element (the 
     *   layer.div property), then removing it from the map's internal list 
     *   of layers, setting the layer's map property to null. 
     * 
     *   a "removelayer" event is triggered.
     * 
     *   very worthy of mention is that simply removing a layer from a map
     *   will not cause the removal of any popups which may have been created
     *   by the layer. this is due to the fact that it was decided at some
     *   point that popups would not belong to layers. thus there is no way 
     *   for us to know here to which layer the popup belongs.
     *    
     *     A simple solution to this is simply to call destroy() on the layer.
     *     the default HGIS.Layer class's destroy() function
     *     automatically takes care to remove itself from whatever map it has
     *     been attached to. 
     * 
     *     The correct solution is for the layer itself to register an 
     *     event-handler on "removelayer" and when it is called, if it 
     *     recognizes itself as the layer being removed, then it cycles through
     *     its own personal list of popups, removing them from the map.
     * 
     * Parameters:
     * layer - {<HGIS.Layer>} 
     * setNewBaseLayer - {Boolean} Default is true
     */
    removeLayer: function(layer, setNewBaseLayer) {
        if (this.events.triggerEvent("preremovelayer", {layer: layer}) === false) {
            return;
        }
        if (setNewBaseLayer == null) {
            setNewBaseLayer = true;
        }

        if (layer.isFixed) {
            this.viewPortDiv.removeChild(layer.div);
        } else {
            this.layerContainerDiv.removeChild(layer.div);
        }
        HGIS.Util.removeItem(this.layers, layer);
        layer.removeMap(this);
        layer.map = null;

        // if we removed the base layer, need to set a new one
        if(this.baseLayer == layer) {
            this.baseLayer = null;
            if(setNewBaseLayer) {
                for(var i=0, len=this.layers.length; i<len; i++) {
                    var iLayer = this.layers[i];
                    if (iLayer.isBaseLayer || this.allOverlays) {
                        this.setBaseLayer(iLayer);
                        break;
                    }
                }
            }
        }

        this.resetLayersZIndex();

        this.events.triggerEvent("removelayer", {layer: layer});
        layer.events.triggerEvent("removed", {map: this, layer: layer});
    },

    /**
     * APIMethod: getNumLayers
     * 
     * Returns:
     * {Int} The number of layers attached to the map.
     */
    getNumLayers: function () {
        return this.layers.length;
    },

    /** 
     * APIMethod: getLayerIndex
     *
     * Parameters:
     * layer - {<HGIS.Layer>}
     *
     * Returns:
     * {Integer} The current (zero-based) index of the given layer in the map's
     *           layer stack. Returns -1 if the layer isn't on the map.
     */
    getLayerIndex: function (layer) {
        return HGIS.Util.indexOf(this.layers, layer);
    },
    
    /** 
     * APIMethod: setLayerIndex
     * Move the given layer to the specified (zero-based) index in the layer
     *     list, changing its z-index in the map display. Use
     *     map.getLayerIndex() to find out the current index of a layer. Note
     *     that this cannot (or at least should not) be effectively used to
     *     raise base layers above overlays.
     *
     * Parameters:
     * layer - {<HGIS.Layer>} 
     * idx - {int} 
     */
    setLayerIndex: function (layer, idx) {
        var base = this.getLayerIndex(layer);
        if (idx < 0) {
            idx = 0;
        } else if (idx > this.layers.length) {
            idx = this.layers.length;
        }
        if (base != idx) {
            this.layers.splice(base, 1);
            this.layers.splice(idx, 0, layer);
            for (var i=0, len=this.layers.length; i<len; i++) {
                this.setLayerZIndex(this.layers[i], i);
            }
            this.events.triggerEvent("changelayer", {
                layer: layer, property: "order"
            });
            if(this.allOverlays) {
                if(idx === 0) {
                    this.setBaseLayer(layer);
                } else if(this.baseLayer !== this.layers[0]) {
                    this.setBaseLayer(this.layers[0]);
                }
            }
        }
    },

    /** 
     * APIMethod: raiseLayer
     * Change the index of the given layer by delta. If delta is positive, 
     *     the layer is moved up the map's layer stack; if delta is negative,
     *     the layer is moved down.  Again, note that this cannot (or at least
     *     should not) be effectively used to raise base layers above overlays.
     *
     * Paremeters:
     * layer - {<HGIS.Layer>} 
     * delta - {int} 
     */
    raiseLayer: function (layer, delta) {
        var idx = this.getLayerIndex(layer) + delta;
        this.setLayerIndex(layer, idx);
    },
    
    /** 
     * APIMethod: setBaseLayer
     * Allows user to specify one of the currently-loaded layers as the Map's
     *     new base layer.
     * 
     * Parameters:
     * newBaseLayer - {<HGIS.Layer>}
     */
    setBaseLayer: function(newBaseLayer) {
        
        if (newBaseLayer != this.baseLayer) {
          
            // ensure newBaseLayer is already loaded
            if (HGIS.Util.indexOf(this.layers, newBaseLayer) != -1) {

                // preserve center and scale when changing base layers
                var center = this.getCachedCenter();
                var newResolution = HGIS.Util.getResolutionFromScale(
                    this.getScale(), newBaseLayer.units
                );

                // make the old base layer invisible 
                if (this.baseLayer != null && !this.allOverlays) {
                    this.baseLayer.setVisibility(false);
                }

                // set new baselayer
                this.baseLayer = newBaseLayer;
                
                if(!this.allOverlays || this.baseLayer.visibility) {
                    this.baseLayer.setVisibility(true);
                    // Layer may previously have been visible but not in range.
                    // In this case we need to redraw it to make it visible.
                    if (this.baseLayer.inRange === false) {
                        this.baseLayer.redraw();
                    }
                }

                // recenter the map
                if (center != null) {
                    // new zoom level derived from old scale
                    var newZoom = this.getZoomForResolution(
                        newResolution || this.resolution, true
                    );
                    // zoom and force zoom change
                    this.setCenter(center, newZoom, false, true);
                }

                this.events.triggerEvent("changebaselayer", {
                    layer: this.baseLayer
                });
            }        
        }
    },


  /********************************************************/
  /*                                                      */
  /*                 Control Functions                    */
  /*                                                      */
  /*     The following functions deal with adding and     */
  /*        removing Controls to and from the Map         */
  /*                                                      */
  /********************************************************/         

    /**
     * APIMethod: addControl
     * Add the passed over control to the map. Optionally 
     *     position the control at the given pixel.
     * 
     * Parameters:
     * control - {<HGIS.Control>}
     * px - {<HGIS.Pixel>}
     */    
    addControl: function (control, px) {
        this.controls.push(control);
        this.addControlToMap(control, px);
    },
    
    /**
     * APIMethod: addControls
     * Add all of the passed over controls to the map. 
     *     You can pass over an optional second array
     *     with pixel-objects to position the controls.
     *     The indices of the two arrays should match and
     *     you can add null as pixel for those controls 
     *     you want to be autopositioned.   
     *     
     * Parameters:
     * controls - {Array(<HGIS.Control>)}
     * pixels - {Array(<HGIS.Pixel>)}
     */    
    addControls: function (controls, pixels) {
        var pxs = (arguments.length === 1) ? [] : pixels;
        for (var i=0, len=controls.length; i<len; i++) {
            var ctrl = controls[i];
            var px = (pxs[i]) ? pxs[i] : null;
            this.addControl( ctrl, px );
        }
    },

    /**
     * Method: addControlToMap
     * 
     * Parameters:
     * 
     * control - {<HGIS.Control>}
     * px - {<HGIS.Pixel>}
     */    
    addControlToMap: function (control, px) {
        // If a control doesn't have a div at this point, it belongs in the
        // viewport.
        control.outsideViewport = (control.div != null);
        
        // If the map has a displayProjection, and the control doesn't, set 
        // the display projection.
        if (this.displayProjection && !control.displayProjection) {
            control.displayProjection = this.displayProjection;
        }    
        
        control.setMap(this);
        var div = control.draw(px);
        if (div) {
            if(!control.outsideViewport) {
                div.style.zIndex = this.Z_INDEX_BASE['Control'] +
                                    this.controls.length;
                this.viewPortDiv.appendChild( div );
            }
        }
        if(control.autoActivate) {
            control.activate();
        }
    },
    
    /**
     * APIMethod: getControl
     * 
     * Parameters:
     * id - {String} ID of the control to return.
     * 
     * Returns:
     * {<HGIS.Control>} The control from the map's list of controls 
     *                        which has a matching 'id'. If none found, 
     *                        returns null.
     */    
    getControl: function (id) {
        var returnControl = null;
        for(var i=0, len=this.controls.length; i<len; i++) {
            var control = this.controls[i];
            if (control.id == id) {
                returnControl = control;
                break;
            }
        }
        return returnControl;
    },
    
    /** 
     * APIMethod: removeControl
     * Remove a control from the map. Removes the control both from the map 
     *     object's internal array of controls, as well as from the map's 
     *     viewPort (assuming the control was not added outsideViewport)
     * 
     * Parameters:
     * control - {<HGIS.Control>} The control to remove.
     */    
    removeControl: function (control) {
        //make sure control is non-null and actually part of our map
        if ( (control) && (control == this.getControl(control.id)) ) {
            if (control.div && (control.div.parentNode == this.viewPortDiv)) {
                this.viewPortDiv.removeChild(control.div);
            }
            HGIS.Util.removeItem(this.controls, control);
        }
    },

  /********************************************************/
  /*                                                      */
  /*                  Popup Functions                     */
  /*                                                      */
  /*     The following functions deal with adding and     */
  /*        removing Popups to and from the Map           */
  /*                                                      */
  /********************************************************/         

    /** 
     * APIMethod: addPopup
     * 
     * Parameters:
     * popup - {<HGIS.Popup>}
     * exclusive - {Boolean} If true, closes all other popups first
     */
    addPopup: function(popup, exclusive) {

        if (exclusive) {
            //remove all other popups from screen
            for (var i = this.popups.length - 1; i >= 0; --i) {
                this.removePopup(this.popups[i]);
            }
        }

        popup.map = this;
        this.popups.push(popup);
        var popupDiv = popup.draw();
        if (popupDiv) {
            popupDiv.style.zIndex = this.Z_INDEX_BASE['Popup'] +
                                    this.popups.length;
            this.layerContainerDiv.appendChild(popupDiv);
        }
    },
    
    /** 
    * APIMethod: removePopup
    * 
    * Parameters:
    * popup - {<HGIS.Popup>}
    */
    removePopup: function(popup) {
        HGIS.Util.removeItem(this.popups, popup);
        if (popup.div) {
            try { this.layerContainerDiv.removeChild(popup.div); }
            catch (e) { } // Popups sometimes apparently get disconnected
                      // from the layerContainerDiv, and cause complaints.
        }
        popup.map = null;
    },

  /********************************************************/
  /*                                                      */
  /*              Container Div Functions                 */
  /*                                                      */
  /*   The following functions deal with the access to    */
  /*    and maintenance of the size of the container div  */
  /*                                                      */
  /********************************************************/     

    /**
     * APIMethod: getSize
     * 
     * Returns:
     * {<HGIS.Size>} An <HGIS.Size> object that represents the 
     *                     size, in pixels, of the div into which HGIS 
     *                     has been loaded. 
     *                     Note - A clone() of this locally cached variable is
     *                     returned, so as not to allow users to modify it.
     */
    getSize: function () {
        var size = null;
        if (this.size != null) {
            size = this.size.clone();
        }
        return size;
    },

    /**
     * APIMethod: updateSize
     * This function should be called by any external code which dynamically
     *     changes the size of the map div (because mozilla wont let us catch 
     *     the "onresize" for an element)
     */
    updateSize: function() {
        // the div might have moved on the page, also
        var newSize = this.getCurrentSize();
        if (newSize && !isNaN(newSize.h) && !isNaN(newSize.w)) {
            this.events.clearMouseCache();
            var oldSize = this.getSize();
            if (oldSize == null) {
                this.size = oldSize = newSize;
            }
            if (!newSize.equals(oldSize)) {
                
                // store the new size
                this.size = newSize;
    
                //notify layers of mapresize
                for(var i=0, len=this.layers.length; i<len; i++) {
                    this.layers[i].onMapResize();                
                }
    
                var center = this.getCachedCenter();
    
                if (this.baseLayer != null && center != null) {
                    var zoom = this.getZoom();
                    this.zoom = null;
                    this.setCenter(center, zoom);
                }
    
            }
        }
        this.events.triggerEvent("updatesize");
    },
    
    /**
     * Method: getCurrentSize
     * 
     * Returns:
     * {<HGIS.Size>} A new <HGIS.Size> object with the dimensions 
     *                     of the map div
     */
    getCurrentSize: function() {

        var size = new HGIS.Size(this.div.clientWidth, 
                                       this.div.clientHeight);
        if (size.w == 0 && size.h == 0 || isNaN(size.w) && isNaN(size.h)) {
            size.w = this.div.offsetWidth;
            size.h = this.div.offsetHeight;
        }
        if (size.w == 0 && size.h == 0 || isNaN(size.w) && isNaN(size.h)) {
            size.w = parseInt(this.div.style.width);
            size.h = parseInt(this.div.style.height);
        }
        return size;
    },

    /** 
     * Method: calculateBounds
     * 
     * Parameters:
     * center - {<HGIS.LonLat>} Default is this.getCenter()
     * resolution - {float} Default is this.getResolution() 
     * 
     * Returns:
     * {<HGIS.Bounds>} A bounds based on resolution, center, and 
     *                       current mapsize.
     */
    calculateBounds: function(center, resolution) {

        var extent = null;
        
        if (center == null) {
            center = this.getCachedCenter();
        }                
        if (resolution == null) {
            resolution = this.getResolution();
        }
    
        if ((center != null) && (resolution != null)) {
            var halfWDeg = (this.size.w * resolution) / 2;
            var halfHDeg = (this.size.h * resolution) / 2;
        
            extent = new HGIS.Bounds(center.lon - halfWDeg,
                                           center.lat - halfHDeg,
                                           center.lon + halfWDeg,
                                           center.lat + halfHDeg);
        }

        return extent;
    },


  /********************************************************/
  /*                                                      */
  /*            Zoom, Center, Pan Functions               */
  /*                                                      */
  /*    The following functions handle the validation,    */
  /*   getting and setting of the Zoom Level and Center   */
  /*       as well as the panning of the Map              */
  /*                                                      */
  /********************************************************/
    /**
     * APIMethod: getCenter
     * 
     * Returns:
     * {<HGIS.LonLat>}
     */
    getCenter: function () {
        var center = null;
        var cachedCenter = this.getCachedCenter();
        if (cachedCenter) {
            center = cachedCenter.clone();
        }
        return center;
    },

    /**
     * Method: getCachedCenter
     *
     * Returns:
     * {<HGIS.LonLat>}
     */
    getCachedCenter: function() {
        if (!this.center && this.size) {
            this.center = this.getLonLatFromViewPortPx({
                x: this.size.w / 2,
                y: this.size.h / 2
            });
        }
        return this.center;
    },

    /**
     * APIMethod: getZoom
     * 
     * Returns:
     * {Integer}
     */
    getZoom: function () {
        return this.zoom;
    },
    
    /** 
     * APIMethod: pan
     * Allows user to pan by a value of screen pixels
     * 
     * Parameters:
     * dx - {Integer}
     * dy - {Integer}
     * options - {Object} Options to configure panning:
     *  - *animate* {Boolean} Use panTo instead of setCenter. Default is true.
     *  - *dragging* {Boolean} Call setCenter with dragging true.  Default is
     *    false.
     */
    pan: function(dx, dy, options) {
        options = HGIS.Util.applyDefaults(options, {
            animate: true,
            dragging: false
        });
        if (options.dragging) {
            if (dx != 0 || dy != 0) {
                this.moveByPx(dx, dy);
            }
        } else {
            // getCenter
            var centerPx = this.getViewPortPxFromLonLat(this.getCachedCenter());

            // adjust
            var newCenterPx = centerPx.add(dx, dy);

            if (this.dragging || !newCenterPx.equals(centerPx)) {
                var newCenterLonLat = this.getLonLatFromViewPortPx(newCenterPx);
                if (options.animate) {
                    this.panTo(newCenterLonLat);
                } else {
                    this.moveTo(newCenterLonLat);
                    if(this.dragging) {
                        this.dragging = false;
                        this.events.triggerEvent("moveend");
                    }
                }    
            }
        }        

   },
   
   /** 
     * APIMethod: panTo
     * Allows user to pan to a new lonlat
     * If the new lonlat is in the current extent the map will slide smoothly
     * 
     * Parameters:
     * lonlat - {<HGIS.LonLat>}
     */
    panTo: function(lonlat) {
        if (this.panTween && this.getExtent().scale(this.panRatio).containsLonLat(lonlat)) {
            var center = this.getCachedCenter();

            // center will not change, don't do nothing
            if (lonlat.equals(center)) {
                return;
            }

            var from = this.getPixelFromLonLat(center);
            var to = this.getPixelFromLonLat(lonlat);
            var vector = { x: to.x - from.x, y: to.y - from.y };
            var last = { x: 0, y: 0 };

            this.panTween.start( { x: 0, y: 0 }, vector, this.panDuration, {
                callbacks: {
                    eachStep: HGIS.Function.bind(function(px) {
                        var x = px.x - last.x,
                            y = px.y - last.y;
                        this.moveByPx(x, y);
                        last.x = Math.round(px.x);
                        last.y = Math.round(px.y);
                    }, this),
                    done: HGIS.Function.bind(function(px) {
                        this.moveTo(lonlat);
                        this.dragging = false;
                        this.events.triggerEvent("moveend");
                    }, this)
                }
            });
        } else {
            this.setCenter(lonlat);
        }
    },

    /**
     * APIMethod: setCenter
     * Set the map center (and optionally, the zoom level).
     * 
     * Parameters:
     * lonlat - {<HGIS.LonLat>|Array} The new center location.
     *     If provided as array, the first value is the x coordinate,
     *     and the 2nd value is the y coordinate.
     * zoom - {Integer} Optional zoom level.
     * dragging - {Boolean} Specifies whether or not to trigger 
     *                      movestart/end events
     * forceZoomChange - {Boolean} Specifies whether or not to trigger zoom 
     *                             change events (needed on baseLayer change)
     *
     * TBD: reconsider forceZoomChange in 3.0
     */
    setCenter: function(lonlat, zoom, dragging, forceZoomChange) {
        if (this.panTween) {
            this.panTween.stop();
        }
        if (this.zoomTween) {
            this.zoomTween.stop();
        }            
        this.moveTo(lonlat, zoom, {
            'dragging': dragging,
            'forceZoomChange': forceZoomChange
        });
    },
    
    /** 
     * Method: moveByPx
     * Drag the map by pixels.
     *
     * Parameters:
     * dx - {Number}
     * dy - {Number}
     */
    moveByPx: function(dx, dy) {
        var hw = this.size.w / 2;
        var hh = this.size.h / 2;
        var x = hw + dx;
        var y = hh + dy;
        var wrapDateLine = this.baseLayer.wrapDateLine;
        var xRestriction = 0;
        var yRestriction = 0;
        if (this.restrictedExtent) {
            xRestriction = hw;
            yRestriction = hh;
            // wrapping the date line makes no sense for restricted extents
            wrapDateLine = false;
        }
        dx = wrapDateLine ||
                    x <= this.maxPx.x - xRestriction &&
                    x >= this.minPx.x + xRestriction ? Math.round(dx) : 0;
        dy = y <= this.maxPx.y - yRestriction &&
                    y >= this.minPx.y + yRestriction ? Math.round(dy) : 0;
        if (dx || dy) {
            if (!this.dragging) {
                this.dragging = true;
                this.events.triggerEvent("movestart");
            }
            this.center = null;
            if (dx) {
                this.layerContainerOriginPx.x -= dx;
                this.minPx.x -= dx;
                this.maxPx.x -= dx;
            }
            if (dy) {
                this.layerContainerOriginPx.y -= dy;
                this.minPx.y -= dy;
                this.maxPx.y -= dy;
            }
            this.applyTransform();
            var layer, i, len;
            for (i=0, len=this.layers.length; i<len; ++i) {
                layer = this.layers[i];
                if (layer.visibility &&
                    (layer === this.baseLayer || layer.inRange)) {
                    layer.moveByPx(dx, dy);
                    layer.events.triggerEvent("move");
                }
            }
            this.events.triggerEvent("move");
        }
    },
    
    /**
     * Method: adjustZoom
     *
     * Parameters:
     * zoom - {Number} The zoom level to adjust
     *
     * Returns:
     * {Integer} Adjusted zoom level that shows a map not wider than its
     * <baseLayer>'s maxExtent.
     */
    adjustZoom: function(zoom) {
        if (this.baseLayer && this.baseLayer.wrapDateLine) {
            var resolution, resolutions = this.baseLayer.resolutions,
                maxResolution = this.getMaxExtent().getWidth() / this.size.w;
            if (this.getResolutionForZoom(zoom) > maxResolution) {
                if (this.fractionalZoom) {
                    zoom = this.getZoomForResolution(maxResolution);
                } else {
                    for (var i=zoom|0, ii=resolutions.length; i<ii; ++i) {
                        if (resolutions[i] <= maxResolution) {
                            zoom = i;
                            break;
                        }
                    }
                } 
            }
        }
        return zoom;
    },
    
    /**
     * APIMethod: getMinZoom
     * Returns the minimum zoom level for the current map view. If the base
     * layer is configured with <wrapDateLine> set to true, this will be the
     * first zoom level that shows no more than one world width in the current
     * map viewport. Components that rely on this value (e.g. zoom sliders)
     * should also listen to the map's "updatesize" event and call this method
     * in the "updatesize" listener.
     *
     * Returns:
     * {Number} Minimum zoom level that shows a map not wider than its
     * <baseLayer>'s maxExtent. This is an Integer value, unless the map is
     * configured with <fractionalZoom> set to true.
     */
    getMinZoom: function() {
        return this.adjustZoom(0);
    },

    /**
     * Method: moveTo
     *
     * Parameters:
     * lonlat - {<HGIS.LonLat>}
     * zoom - {Integer}
     * options - {Object}
     */
    moveTo: function(lonlat, zoom, options) {
        if (lonlat != null && !(lonlat instanceof HGIS.LonLat)) {
            lonlat = new HGIS.LonLat(lonlat);
        }
        if (!options) { 
            options = {};
        }
        if (zoom != null) {
            zoom = parseFloat(zoom);
            if (!this.fractionalZoom) {
                zoom = Math.round(zoom);
            }
        }
        var requestedZoom = zoom;
        zoom = this.adjustZoom(zoom);
        if (zoom !== requestedZoom) {
            // zoom was adjusted, so keep old lonlat to avoid panning
            lonlat = this.getCenter();
        }
        // dragging is false by default
        var dragging = options.dragging || this.dragging;
        // forceZoomChange is false by default
        var forceZoomChange = options.forceZoomChange;

        if (!this.getCachedCenter() && !this.isValidLonLat(lonlat)) {
            lonlat = this.maxExtent.getCenterLonLat();
            this.center = lonlat.clone();
        }

        if(this.restrictedExtent != null) {
            // In 3.0, decide if we want to change interpretation of maxExtent.
            if(lonlat == null) { 
                lonlat = this.center; 
            }
            if(zoom == null) { 
                zoom = this.getZoom(); 
            }
            var resolution = this.getResolutionForZoom(zoom);
            var extent = this.calculateBounds(lonlat, resolution); 
            if(!this.restrictedExtent.containsBounds(extent)) {
                var maxCenter = this.restrictedExtent.getCenterLonLat(); 
                if(extent.getWidth() > this.restrictedExtent.getWidth()) { 
                    lonlat = new HGIS.LonLat(maxCenter.lon, lonlat.lat); 
                } else if(extent.left < this.restrictedExtent.left) {
                    lonlat = lonlat.add(this.restrictedExtent.left -
                                        extent.left, 0); 
                } else if(extent.right > this.restrictedExtent.right) { 
                    lonlat = lonlat.add(this.restrictedExtent.right -
                                        extent.right, 0); 
                } 
                if(extent.getHeight() > this.restrictedExtent.getHeight()) { 
                    lonlat = new HGIS.LonLat(lonlat.lon, maxCenter.lat); 
                } else if(extent.bottom < this.restrictedExtent.bottom) { 
                    lonlat = lonlat.add(0, this.restrictedExtent.bottom -
                                        extent.bottom); 
                } 
                else if(extent.top > this.restrictedExtent.top) { 
                    lonlat = lonlat.add(0, this.restrictedExtent.top -
                                        extent.top); 
                } 
            }
        }
        
        var zoomChanged = forceZoomChange || (
                            (this.isValidZoomLevel(zoom)) && 
                            (zoom != this.getZoom()) );

        var centerChanged = (this.isValidLonLat(lonlat)) && 
                            (!lonlat.equals(this.center));

        // if neither center nor zoom will change, no need to do anything
        if (zoomChanged || centerChanged || dragging) {
            dragging || this.events.triggerEvent("movestart", {
                zoomChanged: zoomChanged
            });

            if (centerChanged) {
                if (!zoomChanged && this.center) { 
                    // if zoom hasnt changed, just slide layerContainer
                    //  (must be done before setting this.center to new value)
                    this.centerLayerContainer(lonlat);
                }
                this.center = lonlat.clone();
            }

            var res = zoomChanged ?
                this.getResolutionForZoom(zoom) : this.getResolution();
            // (re)set the layerContainerDiv's location
            if (zoomChanged || this.layerContainerOrigin == null) {
                this.layerContainerOrigin = this.getCachedCenter();
                this.layerContainerOriginPx.x = 0;
                this.layerContainerOriginPx.y = 0;
                this.applyTransform();
                var maxExtent = this.getMaxExtent({restricted: true});
                var maxExtentCenter = maxExtent.getCenterLonLat();
                var lonDelta = this.center.lon - maxExtentCenter.lon;
                var latDelta = maxExtentCenter.lat - this.center.lat;
                var extentWidth = Math.round(maxExtent.getWidth() / res);
                var extentHeight = Math.round(maxExtent.getHeight() / res);
                this.minPx = {
                    x: (this.size.w - extentWidth) / 2 - lonDelta / res,
                    y: (this.size.h - extentHeight) / 2 - latDelta / res
                };
                this.maxPx = {
                    x: this.minPx.x + Math.round(maxExtent.getWidth() / res),
                    y: this.minPx.y + Math.round(maxExtent.getHeight() / res)
                };
            }

            if (zoomChanged) {
                this.zoom = zoom;
                this.resolution = res;
            }    
            
            var bounds = this.getExtent();
            
            //send the move call to the baselayer and all the overlays    

            if(this.baseLayer.visibility) {
                this.baseLayer.moveTo(bounds, zoomChanged, options.dragging);
                options.dragging || this.baseLayer.events.triggerEvent(
                    "moveend", {zoomChanged: zoomChanged}
                );
            }
            
            bounds = this.baseLayer.getExtent();
            
            for (var i=this.layers.length-1; i>=0; --i) {
                var layer = this.layers[i];
                if (layer !== this.baseLayer && !layer.isBaseLayer) {
                    var inRange = layer.calculateInRange();
                    if (layer.inRange != inRange) {
                        // the inRange property has changed. If the layer is
                        // no longer in range, we turn it off right away. If
                        // the layer is no longer out of range, the moveTo
                        // call below will turn on the layer.
                        layer.inRange = inRange;
                        if (!inRange) {
                            layer.display(false);
                        }
                        this.events.triggerEvent("changelayer", {
                            layer: layer, property: "visibility"
                        });
                    }
                    if (inRange && layer.visibility) {
                        layer.moveTo(bounds, zoomChanged, options.dragging);
                        options.dragging || layer.events.triggerEvent(
                            "moveend", {zoomChanged: zoomChanged}
                        );
                    }
                }                
            }
            
            this.events.triggerEvent("move");
            dragging || this.events.triggerEvent("moveend");

            if (zoomChanged) {
                //redraw popups
                for (var i=0, len=this.popups.length; i<len; i++) {
                    this.popups[i].updatePosition();
                }
                this.events.triggerEvent("zoomend");
            }
        }
    },

    /** 
     * Method: centerLayerContainer
     * This function takes care to recenter the layerContainerDiv.
     * 
     * Parameters:
     * lonlat - {<HGIS.LonLat>}
     */
    centerLayerContainer: function (lonlat) {
        var originPx = this.getViewPortPxFromLonLat(this.layerContainerOrigin);
        var newPx = this.getViewPortPxFromLonLat(lonlat);

        if ((originPx != null) && (newPx != null)) {
            var oldLeft = this.layerContainerOriginPx.x;
            var oldTop = this.layerContainerOriginPx.y;
            var newLeft = Math.round(originPx.x - newPx.x);
            var newTop = Math.round(originPx.y - newPx.y);
            this.applyTransform(
                (this.layerContainerOriginPx.x = newLeft),
                (this.layerContainerOriginPx.y = newTop));
            var dx = oldLeft - newLeft;
            var dy = oldTop - newTop;
            this.minPx.x -= dx;
            this.maxPx.x -= dx;
            this.minPx.y -= dy;
            this.maxPx.y -= dy;
        }        
    },

    /**
     * Method: isValidZoomLevel
     * 
     * Parameters:
     * zoomLevel - {Integer}
     * 
     * Returns:
     * {Boolean} Whether or not the zoom level passed in is non-null and 
     *           within the min/max range of zoom levels.
     */
    isValidZoomLevel: function(zoomLevel) {
        return ( (zoomLevel != null) &&
                 (zoomLevel >= 0) && 
                 (zoomLevel < this.getNumZoomLevels()) );
    },
    
    /**
     * Method: isValidLonLat
     * 
     * Parameters:
     * lonlat - {<HGIS.LonLat>}
     * 
     * Returns:
     * {Boolean} Whether or not the lonlat passed in is non-null and within
     *           the maxExtent bounds
     */
    isValidLonLat: function(lonlat) {
        var valid = false;
        if (lonlat != null) {
            var maxExtent = this.getMaxExtent();
            var worldBounds = this.baseLayer.wrapDateLine && maxExtent;
            valid = maxExtent.containsLonLat(lonlat, {worldBounds: worldBounds});
        }
        return valid;
    },

  /********************************************************/
  /*                                                      */
  /*                 Layer Options                        */
  /*                                                      */
  /*    Accessor functions to Layer Options parameters    */
  /*                                                      */
  /********************************************************/
    
    /**
     * APIMethod: getProjection
     * This method returns a string representing the projection. In 
     *     the case of projection support, this will be the srsCode which
     *     is loaded -- otherwise it will simply be the string value that
     *     was passed to the projection at startup.
     *
     * FIXME: In 3.0, we will remove getProjectionObject, and instead
     *     return a Projection object from this function. 
     * 
     * Returns:
     * {String} The Projection string from the base layer or null. 
     */
    getProjection: function() {
        var projection = this.getProjectionObject();
        return projection ? projection.getCode() : null;
    },
    
    /**
     * APIMethod: getProjectionObject
     * Returns the projection obect from the baselayer.
     *
     * Returns:
     * {<HGIS.Projection>} The Projection of the base layer.
     */
    getProjectionObject: function() {
        var projection = null;
        if (this.baseLayer != null) {
            projection = this.baseLayer.projection;
        }
        return projection;
    },
    
    /**
     * APIMethod: getMaxResolution
     * 
     * Returns:
     * {String} The Map's Maximum Resolution
     */
    getMaxResolution: function() {
        var maxResolution = null;
        if (this.baseLayer != null) {
            maxResolution = this.baseLayer.maxResolution;
        }
        return maxResolution;
    },
        
    /**
     * APIMethod: getMaxExtent
     *
     * Parameters:
     * options - {Object} 
     * 
     * Allowed Options:
     * restricted - {Boolean} If true, returns restricted extent (if it is 
     *     available.)
     *
     * Returns:
     * {<HGIS.Bounds>} The maxExtent property as set on the current 
     *     baselayer, unless the 'restricted' option is set, in which case
     *     the 'restrictedExtent' option from the map is returned (if it
     *     is set).
     */
    getMaxExtent: function (options) {
        var maxExtent = null;
        if(options && options.restricted && this.restrictedExtent){
            maxExtent = this.restrictedExtent;
        } else if (this.baseLayer != null) {
            maxExtent = this.baseLayer.maxExtent;
        }        
        return maxExtent;
    },
    
    /**
     * APIMethod: getNumZoomLevels
     * 
     * Returns:
     * {Integer} The total number of zoom levels that can be displayed by the 
     *           current baseLayer.
     */
    getNumZoomLevels: function() {
        var numZoomLevels = null;
        if (this.baseLayer != null) {
            numZoomLevels = this.baseLayer.numZoomLevels;
        }
        return numZoomLevels;
    },

  /********************************************************/
  /*                                                      */
  /*                 Baselayer Functions                  */
  /*                                                      */
  /*    The following functions, all publicly exposed     */
  /*       in the API?, are all merely wrappers to the    */
  /*       the same calls on whatever layer is set as     */
  /*                the current base layer                */
  /*                                                      */
  /********************************************************/

    /**
     * APIMethod: getExtent
     * 
     * Returns:
     * {<HGIS.Bounds>} A Bounds object which represents the lon/lat 
     *                       bounds of the current viewPort. 
     *                       If no baselayer is set, returns null.
     */
    getExtent: function () {
        var extent = null;
        if (this.baseLayer != null) {
            extent = this.baseLayer.getExtent();
        }
        return extent;
    },

    /**
     * APIMethod: getResolution
     * 
     * Returns:
     * {Float} The current resolution of the map. 
     *         If no baselayer is set, returns null.
     */
    getResolution: function () {
        var resolution = null;
        if (this.baseLayer != null) {
            resolution = this.baseLayer.getResolution();
        } else if(this.allOverlays === true && this.layers.length > 0) {
            // while adding the 1st layer to the map in allOverlays mode,
            // this.baseLayer is not set yet when we need the resolution
            // for calculateInRange.
            resolution = this.layers[0].getResolution();
        }
        return resolution;
    },

    /**
     * APIMethod: getUnits
     * 
     * Returns:
     * {Float} The current units of the map. 
     *         If no baselayer is set, returns null.
     */
    getUnits: function () {
        var units = null;
        if (this.baseLayer != null) {
            units = this.baseLayer.units;
        }
        return units;
    },

     /**
      * APIMethod: getScale
      * 
      * Returns:
      * {Float} The current scale denominator of the map. 
      *         If no baselayer is set, returns null.
      */
    getScale: function () {
        var scale = null;
        if (this.baseLayer != null) {
            var res = this.getResolution();
            var units = this.baseLayer.units;
            scale = HGIS.Util.getScaleFromResolution(res, units);
        }
        return scale;
    },


    /**
     * APIMethod: getZoomForExtent
     * 
     * Parameters: 
     * bounds - {<HGIS.Bounds>}
     * closest - {Boolean} Find the zoom level that most closely fits the 
     *     specified bounds. Note that this may result in a zoom that does 
     *     not exactly contain the entire extent.
     *     Default is false.
     * 
     * Returns:
     * {Integer} A suitable zoom level for the specified bounds.
     *           If no baselayer is set, returns null.
     */
    getZoomForExtent: function (bounds, closest) {
        var zoom = null;
        if (this.baseLayer != null) {
            zoom = this.baseLayer.getZoomForExtent(bounds, closest);
        }
        return zoom;
    },

    /**
     * APIMethod: getResolutionForZoom
     * 
     * Parameters:
     * zoom - {Float}
     * 
     * Returns:
     * {Float} A suitable resolution for the specified zoom.  If no baselayer
     *     is set, returns null.
     */
    getResolutionForZoom: function(zoom) {
        var resolution = null;
        if(this.baseLayer) {
            resolution = this.baseLayer.getResolutionForZoom(zoom);
        }
        return resolution;
    },

    /**
     * APIMethod: getZoomForResolution
     * 
     * Parameters:
     * resolution - {Float}
     * closest - {Boolean} Find the zoom level that corresponds to the absolute 
     *     closest resolution, which may result in a zoom whose corresponding
     *     resolution is actually smaller than we would have desired (if this
     *     is being called from a getZoomForExtent() call, then this means that
     *     the returned zoom index might not actually contain the entire 
     *     extent specified... but it'll be close).
     *     Default is false.
     * 
     * Returns:
     * {Integer} A suitable zoom level for the specified resolution.
     *           If no baselayer is set, returns null.
     */
    getZoomForResolution: function(resolution, closest) {
        var zoom = null;
        if (this.baseLayer != null) {
            zoom = this.baseLayer.getZoomForResolution(resolution, closest);
        }
        return zoom;
    },

  /********************************************************/
  /*                                                      */
  /*                  Zooming Functions                   */
  /*                                                      */
  /*    The following functions, all publicly exposed     */
  /*       in the API, are all merely wrappers to the     */
  /*               the setCenter() function               */
  /*                                                      */
  /********************************************************/
  
    /** 
     * APIMethod: zoomTo
     * Zoom to a specific zoom level. Zooming will be animated unless the map
     * is configured with {zoomMethod: null}. To zoom without animation, use
     * <setCenter> without a lonlat argument.
     * 
     * Parameters:
     * zoom - {Integer}
     */
    zoomTo: function(zoom, xy) {
        // non-API arguments:
        // xy - {<HGIS.Pixel>} optional zoom origin
        
        var map = this;
        if (map.isValidZoomLevel(zoom)) {
            if (map.baseLayer.wrapDateLine) {
                zoom = map.adjustZoom(zoom);
            }
            if (map.zoomTween) {
                var currentRes = map.getResolution(),
                    targetRes = map.getResolutionForZoom(zoom),
                    start = {scale: 1},
                    end = {scale: currentRes / targetRes};
                if (map.zoomTween.playing && map.zoomTween.duration < 3 * map.zoomDuration) {
                    // update the end scale, and reuse the running zoomTween
                    map.zoomTween.finish = {
                        scale: map.zoomTween.finish.scale * end.scale
                    };
                } else {
                    if (!xy) {
                        var size = map.getSize();
                        xy = {x: size.w / 2, y: size.h / 2};
                    }
                    map.zoomTween.start(start, end, map.zoomDuration, {
                        minFrameRate: 50, // don't spend much time zooming
                        callbacks: {
                            eachStep: function(data) {
                                var containerOrigin = map.layerContainerOriginPx,
                                    scale = data.scale,
                                    dx = ((scale - 1) * (containerOrigin.x - xy.x)) | 0,
                                    dy = ((scale - 1) * (containerOrigin.y - xy.y)) | 0;
                                map.applyTransform(containerOrigin.x + dx, containerOrigin.y + dy, scale);
                            },
                            done: function(data) {
                                map.applyTransform();
                                var resolution = map.getResolution() / data.scale,
                                    zoom = map.getZoomForResolution(resolution, true)
                                map.moveTo(map.getZoomTargetCenter(xy, resolution), zoom, true);
                            }
                        }
                    });
                }
            } else {
                var center = xy ?
                    map.getZoomTargetCenter(xy, map.getResolutionForZoom(zoom)) :
                    null;
                map.setCenter(center, zoom);
            }
        }
    },
        
    /**
     * APIMethod: zoomIn
     * 
     */
    zoomIn: function() {
        this.zoomTo(this.getZoom() + 1);
    },
    
    /**
     * APIMethod: zoomOut
     * 
     */
    zoomOut: function() {
        this.zoomTo(this.getZoom() - 1);
    },

    /**
     * APIMethod: zoomToExtent
     * Zoom to the passed in bounds, recenter
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>|Array} If provided as an array, the array
     *     should consist of four values (left, bottom, right, top).
     * closest - {Boolean} Find the zoom level that most closely fits the 
     *     specified bounds. Note that this may result in a zoom that does 
     *     not exactly contain the entire extent.
     *     Default is false.
     * 
     */
    zoomToExtent: function(bounds, closest) {
        if (!(bounds instanceof HGIS.Bounds)) {
            bounds = new HGIS.Bounds(bounds);
        }
        var center = bounds.getCenterLonLat();
        if (this.baseLayer&&this.baseLayer.wrapDateLine) {
            var maxExtent = this.getMaxExtent();

            //fix straddling bounds (in the case of a bbox that straddles the 
            // dateline, it's left and right boundaries will appear backwards. 
            // we fix this by allowing a right value that is greater than the
            // max value at the dateline -- this allows us to pass a valid 
            // bounds to calculate zoom)
            //
            bounds = bounds.clone();
            while (bounds.right < bounds.left) {
                bounds.right += maxExtent.getWidth();
            }
            //if the bounds was straddling (see above), then the center point 
            // we got from it was wrong. So we take our new bounds and ask it
            // for the center.
            //
            center = bounds.getCenterLonLat().wrapDateLine(maxExtent);
        }
        this.setCenter(center, this.getZoomForExtent(bounds, closest));
    },

    /** 
     * APIMethod: zoomToMaxExtent
     * Zoom to the full extent and recenter.
     *
     * Parameters:
     * options - {Object}
     * 
     * Allowed Options:
     * restricted - {Boolean} True to zoom to restricted extent if it is 
     *     set. Defaults to true.
     */
    zoomToMaxExtent: function(options) {
        //restricted is true by default
        var restricted = (options) ? options.restricted : true;

        var maxExtent = this.getMaxExtent({
            'restricted': restricted 
        });
        this.zoomToExtent(maxExtent);
    },

    /** 
     * APIMethod: zoomToScale
     * Zoom to a specified scale 
     * 
     * Parameters:
     * scale - {float}
     * closest - {Boolean} Find the zoom level that most closely fits the 
     *     specified scale. Note that this may result in a zoom that does 
     *     not exactly contain the entire extent.
     *     Default is false.
     * 
     */
    zoomToScale: function(scale, closest) {
        var res = HGIS.Util.getResolutionFromScale(scale, 
                                                         this.baseLayer.units);

        var halfWDeg = (this.size.w * res) / 2;
        var halfHDeg = (this.size.h * res) / 2;
        var center = this.getCachedCenter();

        var extent = new HGIS.Bounds(center.lon - halfWDeg,
                                           center.lat - halfHDeg,
                                           center.lon + halfWDeg,
                                           center.lat + halfHDeg);
        this.zoomToExtent(extent, closest);
    },
    
  /********************************************************/
  /*                                                      */
  /*             Translation Functions                    */
  /*                                                      */
  /*      The following functions translate between       */
  /*           LonLat, LayerPx, and ViewPortPx            */
  /*                                                      */
  /********************************************************/
      
  //
  // TRANSLATION: LonLat <-> ViewPortPx
  //

    /**
     * Method: getLonLatFromViewPortPx
     * 
     * Parameters:
     * viewPortPx - {<HGIS.Pixel>|Object} An HGIS.Pixel or
     *                                          an object with a 'x'
     *                                          and 'y' properties.
     * 
     * Returns:
     * {<HGIS.LonLat>} An HGIS.LonLat which is the passed-in view 
     *                       port <HGIS.Pixel>, translated into lon/lat
     *                       by the current base layer.
     */
    getLonLatFromViewPortPx: function (viewPortPx) {
        var lonlat = null; 
        if (this.baseLayer != null) {
            lonlat = this.baseLayer.getLonLatFromViewPortPx(viewPortPx);
        }
        return lonlat;
    },

    /**
     * APIMethod: getViewPortPxFromLonLat
     * 
     * Parameters:
     * lonlat - {<HGIS.LonLat>}
     * 
     * Returns:
     * {<HGIS.Pixel>} An HGIS.Pixel which is the passed-in 
     *                      <HGIS.LonLat>, translated into view port 
     *                      pixels by the current base layer.
     */
    getViewPortPxFromLonLat: function (lonlat) {
        var px = null; 
        if (this.baseLayer != null) {
            px = this.baseLayer.getViewPortPxFromLonLat(lonlat);
        }
        return px;
    },

    /**
     * Method: getZoomTargetCenter
     *
     * Parameters:
     * xy - {<HGIS.Pixel>} The zoom origin pixel location on the screen
     * resolution - {Float} The resolution we want to get the center for
     *
     * Returns:
     * {<HGIS.LonLat>} The location of the map center after the
     *     transformation described by the origin xy and the target resolution.
     */
    getZoomTargetCenter: function (xy, resolution) {
        var lonlat = null,
            size = this.getSize(),
            deltaX  = size.w/2 - xy.x,
            deltaY  = xy.y - size.h/2,
            zoomPoint = this.getLonLatFromPixel(xy);
        if (zoomPoint) {
            lonlat = new HGIS.LonLat(
                zoomPoint.lon + deltaX * resolution,
                zoomPoint.lat + deltaY * resolution
            );
        }
        return lonlat;
    },
        
  //
  // CONVENIENCE TRANSLATION FUNCTIONS FOR API
  //

    /**
     * APIMethod: getLonLatFromPixel
     * 
     * Parameters:
     * px - {<HGIS.Pixel>|Object} An HGIS.Pixel or an object with
     *                                  a 'x' and 'y' properties.
     *
     * Returns:
     * {<HGIS.LonLat>} An HGIS.LonLat corresponding to the given
     *                       HGIS.Pixel, translated into lon/lat by the 
     *                       current base layer
     */
    getLonLatFromPixel: function (px) {
        return this.getLonLatFromViewPortPx(px);
    },

    /**
     * APIMethod: getPixelFromLonLat
     * Returns a pixel location given a map location.  The map location is
     *     translated to an integer pixel location (in viewport pixel
     *     coordinates) by the current base layer.
     * 
     * Parameters:
     * lonlat - {<HGIS.LonLat>} A map location.
     * 
     * Returns: 
     * {<HGIS.Pixel>} An HGIS.Pixel corresponding to the 
     *     <HGIS.LonLat> translated into view port pixels by the current
     *     base layer.
     */
    getPixelFromLonLat: function (lonlat) {
        var px = this.getViewPortPxFromLonLat(lonlat);
        px.x = Math.round(px.x);
        px.y = Math.round(px.y);
        return px;
    },
    
    /**
     * Method: getGeodesicPixelSize
     * 
     * Parameters:
     * px - {<HGIS.Pixel>} The pixel to get the geodesic length for. If
     *     not provided, the center pixel of the map viewport will be used.
     * 
     * Returns:
     * {<HGIS.Size>} The geodesic size of the pixel in kilometers.
     */
    getGeodesicPixelSize: function(px) {
        var lonlat = px ? this.getLonLatFromPixel(px) : (
            this.getCachedCenter() || new HGIS.LonLat(0, 0));
        var res = this.getResolution();
        var left = lonlat.add(-res / 2, 0);
        var right = lonlat.add(res / 2, 0);
        var bottom = lonlat.add(0, -res / 2);
        var top = lonlat.add(0, res / 2);
        var dest = new HGIS.Projection("EPSG:4326");
        var source = this.getProjectionObject() || dest;
        if(!source.equals(dest)) {
            left.transform(source, dest);
            right.transform(source, dest);
            bottom.transform(source, dest);
            top.transform(source, dest);
        }
        
        return new HGIS.Size(
            HGIS.Util.distVincenty(left, right),
            HGIS.Util.distVincenty(bottom, top)
        );
    },



  //
  // TRANSLATION: ViewPortPx <-> LayerPx
  //

    /**
     * APIMethod: getViewPortPxFromLayerPx
     * 
     * Parameters:
     * layerPx - {<HGIS.Pixel>}
     * 
     * Returns:
     * {<HGIS.Pixel>} Layer Pixel translated into ViewPort Pixel 
     *                      coordinates
     */
    getViewPortPxFromLayerPx:function(layerPx) {
        var viewPortPx = null;
        if (layerPx != null) {
            var dX = this.layerContainerOriginPx.x;
            var dY = this.layerContainerOriginPx.y;
            viewPortPx = layerPx.add(dX, dY);            
        }
        return viewPortPx;
    },
    
    /**
     * APIMethod: getLayerPxFromViewPortPx
     * 
     * Parameters:
     * viewPortPx - {<HGIS.Pixel>}
     * 
     * Returns:
     * {<HGIS.Pixel>} ViewPort Pixel translated into Layer Pixel 
     *                      coordinates
     */
    getLayerPxFromViewPortPx:function(viewPortPx) {
        var layerPx = null;
        if (viewPortPx != null) {
            var dX = -this.layerContainerOriginPx.x;
            var dY = -this.layerContainerOriginPx.y;
            layerPx = viewPortPx.add(dX, dY);
            if (isNaN(layerPx.x) || isNaN(layerPx.y)) {
                layerPx = null;
            }
        }
        return layerPx;
    },
    
  //
  // TRANSLATION: LonLat <-> LayerPx
  //

    /**
     * Method: getLonLatFromLayerPx
     * 
     * Parameters:
     * px - {<HGIS.Pixel>}
     *
     * Returns:
     * {<HGIS.LonLat>}
     */
    getLonLatFromLayerPx: function (px) {
       //adjust for displacement of layerContainerDiv
       px = this.getViewPortPxFromLayerPx(px);
       return this.getLonLatFromViewPortPx(px);         
    },
    
    /**
     * APIMethod: getLayerPxFromLonLat
     * 
     * Parameters:
     * lonlat - {<HGIS.LonLat>} lonlat
     *
     * Returns:
     * {<HGIS.Pixel>} An HGIS.Pixel which is the passed-in 
     *                      <HGIS.LonLat>, translated into layer pixels 
     *                      by the current base layer
     */
    getLayerPxFromLonLat: function (lonlat) {
       //adjust for displacement of layerContainerDiv
       var px = this.getPixelFromLonLat(lonlat);
       return this.getLayerPxFromViewPortPx(px);         
    },

    /**
     * Method: applyTransform
     * Applies the given transform to the <layerContainerDiv>. This method has
     * a 2-stage fallback from translate3d/scale3d via translate/scale to plain
     * style.left/style.top, in which case no scaling is supported.
     *
     * Parameters:
     * x - {Number} x parameter for the translation. Defaults to the x value of
     *     the map's <layerContainerOriginPx>
     * y - {Number} y parameter for the translation. Defaults to the y value of
     *     the map's <layerContainerOriginPx>
     * scale - {Number} scale. Defaults to 1 if not provided.
     */
     applyTransform: function(x, y, scale) {
         scale = scale || 1;
         var origin = this.layerContainerOriginPx,
             needTransform = scale !== 1;
         x = x || origin.x;
         y = y || origin.y;
            
         var style = this.layerContainerDiv.style,
             transform = this.applyTransform.transform,
             template = this.applyTransform.template;
        
         if (transform === undefined) {
             transform = HGIS.Util.vendorPrefix.style('transform');
             this.applyTransform.transform = transform;
             if (transform) {
                 // Try translate3d, but only if the viewPortDiv has a transform
                 // defined in a stylesheet
                 var computedStyle = HGIS.Element.getStyle(this.viewPortDiv,
                     HGIS.Util.vendorPrefix.css('transform'));
                 if (!computedStyle || computedStyle !== 'none') {
                     template = ['translate3d(', ',0) ', 'scale3d(', ',1)'];
                     style[transform] = [template[0], '0,0', template[1]].join('');
                 }
                 // If no transform is defined in the stylesheet or translate3d
                 // does not stick, use translate and scale
                 if (!template || !~style[transform].indexOf(template[0])) {
                     template = ['translate(', ') ', 'scale(', ')'];
                 }
                 this.applyTransform.template = template;
             }
         }
         
         // If we do 3d transforms, we always want to use them. If we do 2d
         // transforms, we only use them when we need to.
         if (transform !== null && (template[0] === 'translate3d(' || needTransform === true)) {
             // Our 2d transforms are combined with style.left and style.top, so
             // adjust x and y values and set the origin as left and top
             if (needTransform === true && template[0] === 'translate(') {
                 x -= origin.x;
                 y -= origin.y;
                 style.left = origin.x + 'px';
                 style.top = origin.y + 'px';
             }
             style[transform] = [
                 template[0], x, 'px,', y, 'px', template[1],
                 template[2], scale, ',', scale, template[3]
             ].join('');
         } else {
             style.left = x + 'px';
             style.top = y + 'px';
             // We previously might have had needTransform, so remove transform
             if (transform !== null) {
                 style[transform] = '';
             }
         }
     },
    
    CLASS_NAME: "HGIS.Map"
});

/**
 * Constant: TILE_WIDTH
 * {Integer} 256 Default tile width (unless otherwise specified)
 */
HGIS.Map.TILE_WIDTH = 256;
/**
 * Constant: TILE_HEIGHT
 * {Integer} 256 Default tile height (unless otherwise specified)
 */
HGIS.Map.TILE_HEIGHT = 256;
/* ======================================================================
    HGIS/Handler.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Events.js
 */

/**
 * Class: HGIS.Handler
 * Base class to construct a higher-level handler for event sequences.  All
 *     handlers have activate and deactivate methods.  In addition, they have
 *     methods named like browser events.  When a handler is activated, any
 *     additional methods named like a browser event is registered as a
 *     listener for the corresponding event.  When a handler is deactivated,
 *     those same methods are unregistered as event listeners.
 *
 * Handlers also typically have a callbacks object with keys named like
 *     the abstracted events or event sequences that they are in charge of
 *     handling.  The controls that wrap handlers define the methods that
 *     correspond to these abstract events - so instead of listening for
 *     individual browser events, they only listen for the abstract events
 *     defined by the handler.
 *     
 * Handlers are created by controls, which ultimately have the responsibility
 *     of making changes to the the state of the application.  Handlers
 *     themselves may make temporary changes, but in general are expected to
 *     return the application in the same state that they found it.
 */
HGIS.Handler = HGIS.Class({

    /**
     * Property: id
     * {String}
     */
    id: null,
        
    /**
     * APIProperty: control
     * {<HGIS.Control>}. The control that initialized this handler.  The
     *     control is assumed to have a valid map property - that map is used
     *     in the handler's own setMap method.
     */
    control: null,

    /**
     * Property: map
     * {<HGIS.Map>}
     */
    map: null,

    /**
     * APIProperty: keyMask
     * {Integer} Use bitwise operators and one or more of the HGIS.Handler
     *     constants to construct a keyMask.  The keyMask is used by
     *     <checkModifiers>.  If the keyMask matches the combination of keys
     *     down on an event, checkModifiers returns true.
     *
     * Example:
     * (code)
     *     // handler only responds if the Shift key is down
     *     handler.keyMask = HGIS.Handler.MOD_SHIFT;
     *
     *     // handler only responds if Ctrl-Shift is down
     *     handler.keyMask = HGIS.Handler.MOD_SHIFT |
     *                       HGIS.Handler.MOD_CTRL;
     * (end)
     */
    keyMask: null,

    /**
     * Property: active
     * {Boolean}
     */
    active: false,
    
    /**
     * Property: evt
     * {Event} This property references the last event handled by the handler.
     *     Note that this property is not part of the stable API.  Use of the
     *     evt property should be restricted to controls in the library
     *     or other applications that are willing to update with changes to
     *     the HGIS code.
     */
    evt: null,
    
    /**
     * Property: touch
     * {Boolean} Indicates the support of touch events. When touch events are 
     *     started touch will be true and all mouse related listeners will do 
     *     nothing.
     */
    touch: false,

    /**
     * Constructor: HGIS.Handler
     * Construct a handler.
     *
     * Parameters:
     * control - {<HGIS.Control>} The control that initialized this
     *     handler.  The control is assumed to have a valid map property; that
     *     map is used in the handler's own setMap method.  If a map property
     *     is present in the options argument it will be used instead.
     * callbacks - {Object} An object whose properties correspond to abstracted
     *     events or sequences of browser events.  The values for these
     *     properties are functions defined by the control that get called by
     *     the handler.
     * options - {Object} An optional object whose properties will be set on
     *     the handler.
     */
    initialize: function(control, callbacks, options) {
        HGIS.Util.extend(this, options);
        this.control = control;
        this.callbacks = callbacks;

        var map = this.map || control.map;
        if (map) {
            this.setMap(map); 
        }
        
        this.id = HGIS.Util.createUniqueID(this.CLASS_NAME + "_");
    },
    
    /**
     * Method: setMap
     */
    setMap: function (map) {
        this.map = map;
    },

    /**
     * Method: checkModifiers
     * Check the keyMask on the handler.  If no <keyMask> is set, this always
     *     returns true.  If a <keyMask> is set and it matches the combination
     *     of keys down on an event, this returns true.
     *
     * Returns:
     * {Boolean} The keyMask matches the keys down on an event.
     */
    checkModifiers: function (evt) {
        if(this.keyMask == null) {
            return true;
        }
        /* calculate the keyboard modifier mask for this event */
        var keyModifiers =
            (evt.shiftKey ? HGIS.Handler.MOD_SHIFT : 0) |
            (evt.ctrlKey  ? HGIS.Handler.MOD_CTRL  : 0) |
            (evt.altKey   ? HGIS.Handler.MOD_ALT   : 0) |
            (evt.metaKey  ? HGIS.Handler.MOD_META  : 0);
    
        /* if it differs from the handler object's key mask,
           bail out of the event handler */
        return (keyModifiers == this.keyMask);
    },

    /**
     * APIMethod: activate
     * Turn on the handler.  Returns false if the handler was already active.
     * 
     * Returns: 
     * {Boolean} The handler was activated.
     */
    activate: function() {
        if(this.active) {
            return false;
        }
        // register for event handlers defined on this class.
        var events = HGIS.Events.prototype.BROWSER_EVENTS;
        for (var i=0, len=events.length; i<len; i++) {
            if (this[events[i]]) {
                this.register(events[i], this[events[i]]); 
            }
        } 
        this.active = true;
        return true;
    },
    
    /**
     * APIMethod: deactivate
     * Turn off the handler.  Returns false if the handler was already inactive.
     * 
     * Returns:
     * {Boolean} The handler was deactivated.
     */
    deactivate: function() {
        if(!this.active) {
            return false;
        }
        // unregister event handlers defined on this class.
        var events = HGIS.Events.prototype.BROWSER_EVENTS;
        for (var i=0, len=events.length; i<len; i++) {
            if (this[events[i]]) {
                this.unregister(events[i], this[events[i]]); 
            }
        } 
        this.touch = false;
        this.active = false;
        return true;
    },

    /**
     * Method: startTouch
     * Start touch events, this method must be called by subclasses in 
     *     "touchstart" method. When touch events are started <touch> will be
     *     true and all mouse related listeners will do nothing.
     */
    startTouch: function() {
        if (!this.touch) {
            this.touch = true;
            var events = [
                "mousedown", "mouseup", "mousemove", "click", "dblclick",
                "mouseout"
            ];
            for (var i=0, len=events.length; i<len; i++) {
                if (this[events[i]]) {
                    this.unregister(events[i], this[events[i]]); 
                }
            } 
        }
    },

    /**
    * Method: callback
    * Trigger the control's named callback with the given arguments
    *
    * Parameters:
    * name - {String} The key for the callback that is one of the properties
    *     of the handler's callbacks object.
    * args - {Array(*)} An array of arguments (any type) with which to call 
    *     the callback (defined by the control).
    */
    callback: function (name, args) {
        if (name && this.callbacks[name]) {
            this.callbacks[name].apply(this.control, args);
        }
    },

    /**
    * Method: register
    * register an event on the map
    */
    register: function (name, method) {
        // TODO: deal with registerPriority in 3.0
        this.map.events.registerPriority(name, this, method);
        this.map.events.registerPriority(name, this, this.setEvent);
    },

    /**
    * Method: unregister
    * unregister an event from the map
    */
    unregister: function (name, method) {
        this.map.events.unregister(name, this, method);   
        this.map.events.unregister(name, this, this.setEvent);
    },
    
    /**
     * Method: setEvent
     * With each registered browser event, the handler sets its own evt
     *     property.  This property can be accessed by controls if needed
     *     to get more information about the event that the handler is
     *     processing.
     *
     * This allows modifier keys on the event to be checked (alt, shift, ctrl,
     *     and meta cannot be checked with the keyboard handler).  For a
     *     control to determine which modifier keys are associated with the
     *     event that a handler is currently processing, it should access
     *     (code)handler.evt.altKey || handler.evt.shiftKey ||
     *     handler.evt.ctrlKey || handler.evt.metaKey(end).
     *
     * Parameters:
     * evt - {Event} The browser event.
     */
    setEvent: function(evt) {
        this.evt = evt;
        return true;
    },

    /**
     * Method: destroy
     * Deconstruct the handler.
     */
    destroy: function () {
        // unregister event listeners
        this.deactivate();
        // eliminate circular references
        this.control = this.map = null;        
    },

    CLASS_NAME: "HGIS.Handler"
});

/**
 * Constant: HGIS.Handler.MOD_NONE
 * If set as the <keyMask>, <checkModifiers> returns false if any key is down.
 */
HGIS.Handler.MOD_NONE  = 0;

/**
 * Constant: HGIS.Handler.MOD_SHIFT
 * If set as the <keyMask>, <checkModifiers> returns false if Shift is down.
 */
HGIS.Handler.MOD_SHIFT = 1;

/**
 * Constant: HGIS.Handler.MOD_CTRL
 * If set as the <keyMask>, <checkModifiers> returns false if Ctrl is down.
 */
HGIS.Handler.MOD_CTRL  = 2;

/**
 * Constant: HGIS.Handler.MOD_ALT
 * If set as the <keyMask>, <checkModifiers> returns false if Alt is down.
 */
HGIS.Handler.MOD_ALT   = 4;

/**
 * Constant: HGIS.Handler.MOD_META
 * If set as the <keyMask>, <checkModifiers> returns false if Cmd is down.
 */
HGIS.Handler.MOD_META  = 8;


/* ======================================================================
    HGIS/Handler/Click.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Handler.js
 */

/**
 * Class: HGIS.Handler.Click
 * A handler for mouse clicks.  The intention of this handler is to give
 *     controls more flexibility with handling clicks.  Browsers trigger
 *     click events twice for a double-click.  In addition, the mousedown,
 *     mousemove, mouseup sequence fires a click event.  With this handler,
 *     controls can decide whether to ignore clicks associated with a double
 *     click.  By setting a <pixelTolerance>, controls can also ignore clicks
 *     that include a drag.  Create a new instance with the
 *     <HGIS.Handler.Click> constructor.
 * 
 * Inherits from:
 *  - <HGIS.Handler> 
 */
HGIS.Handler.Click = HGIS.Class(HGIS.Handler, {
    /**
     * APIProperty: delay
     * {Number} Number of milliseconds between clicks before the event is
     *     considered a double-click.
     */
    delay: 300,
    
    /**
     * APIProperty: single
     * {Boolean} Handle single clicks.  Default is true.  If false, clicks
     * will not be reported.  If true, single-clicks will be reported.
     */
    single: true,
    
    /**
     * APIProperty: double
     * {Boolean} Handle double-clicks.  Default is false.
     */
    'double': false,
    
    /**
     * APIProperty: pixelTolerance
     * {Number} Maximum number of pixels between mouseup and mousedown for an
     *     event to be considered a click.  Default is 0.  If set to an
     *     integer value, clicks with a drag greater than the value will be
     *     ignored.  This property can only be set when the handler is
     *     constructed.
     */
    pixelTolerance: 0,
        
    /**
     * APIProperty: dblclickTolerance
     * {Number} Maximum distance in pixels between clicks for a sequence of 
     *     events to be considered a double click.  Default is 13.  If the
     *     distance between two clicks is greater than this value, a double-
     *     click will not be fired.
     */
    dblclickTolerance: 13,
        
    /**
     * APIProperty: stopSingle
     * {Boolean} Stop other listeners from being notified of clicks.  Default
     *     is false.  If true, any listeners registered before this one for 
     *     click or rightclick events will not be notified.
     */
    stopSingle: false,
    
    /**
     * APIProperty: stopDouble
     * {Boolean} Stop other listeners from being notified of double-clicks.
     *     Default is false.  If true, any click listeners registered before
     *     this one will not be notified of *any* double-click events.
     * 
     * The one caveat with stopDouble is that given a map with two click
     *     handlers, one with stopDouble true and the other with stopSingle
     *     true, the stopSingle handler should be activated last to get
     *     uniform cross-browser performance.  Since IE triggers one click
     *     with a dblclick and FF triggers two, if a stopSingle handler is
     *     activated first, all it gets in IE is a single click when the
     *     second handler stops propagation on the dblclick.
     */
    stopDouble: false,

    /**
     * Property: timerId
     * {Number} The id of the timeout waiting to clear the <delayedCall>.
     */
    timerId: null,
    
    /**
     * Property: down
     * {Object} Object that store relevant information about the last
     *     mousedown or touchstart. Its 'xy' HGIS.Pixel property gives
     *     the average location of the mouse/touch event. Its 'touches'
     *     property records clientX/clientY of each touches.
     */
    down: null,

    /**
     * Property: last
     * {Object} Object that store relevant information about the last
     *     mousemove or touchmove. Its 'xy' HGIS.Pixel property gives
     *     the average location of the mouse/touch event. Its 'touches'
     *     property records clientX/clientY of each touches.
     */
    last: null,

    /** 
     * Property: first
     * {Object} When waiting for double clicks, this object will store 
     *     information about the first click in a two click sequence.
     */
    first: null,

    /**
     * Property: rightclickTimerId
     * {Number} The id of the right mouse timeout waiting to clear the 
     *     <delayedEvent>.
     */
    rightclickTimerId: null,
    
    /**
     * Constructor: HGIS.Handler.Click
     * Create a new click handler.
     * 
     * Parameters:
     * control - {<HGIS.Control>} The control that is making use of
     *     this handler.  If a handler is being used without a control, the
     *     handler's setMap method must be overridden to deal properly with
     *     the map.
     * callbacks - {Object} An object with keys corresponding to callbacks
     *     that will be called by the handler. The callbacks should
     *     expect to recieve a single argument, the click event.
     *     Callbacks for 'click' and 'dblclick' are supported.
     * options - {Object} Optional object whose properties will be set on the
     *     handler.
     */
    
    /**
     * Method: touchstart
     * Handle touchstart.
     *
     * Returns:
     * {Boolean} Continue propagating this event.
     */
    touchstart: function(evt) {
        this.startTouch();
        this.down = this.getEventInfo(evt);
        this.last = this.getEventInfo(evt);
        return true;
    },
    
    /**
     * Method: touchmove
     *    Store position of last move, because touchend event can have
     *    an empty "touches" property.
     *
     * Returns:
     * {Boolean} Continue propagating this event.
     */
    touchmove: function(evt) {
        this.last = this.getEventInfo(evt);
        return true;
    },

    /**
     * Method: touchend
     *   Correctly set event xy property, and add lastTouches to have
     *   touches property from last touchstart or touchmove
     *
     * Returns:
     * {Boolean} Continue propagating this event.
     */
    touchend: function(evt) {
        // touchstart may not have been allowed to propagate
        if (this.down) {
            evt.xy = this.last.xy;
            evt.lastTouches = this.last.touches;
            this.handleSingle(evt);
            this.down = null;
        }
        return true;
    },

    /**
     * Method: mousedown
     * Handle mousedown.
     *
     * Returns:
     * {Boolean} Continue propagating this event.
     */
    mousedown: function(evt) {
        this.down = this.getEventInfo(evt);
        this.last = this.getEventInfo(evt);
        return true;
    },

    /**
     * Method: mouseup
     * Handle mouseup.  Installed to support collection of right mouse events.
     * 
     * Returns:
     * {Boolean} Continue propagating this event.
     */
    mouseup: function (evt) {
        var propagate = true;

        // Collect right mouse clicks from the mouseup
        //  IE - ignores the second right click in mousedown so using
        //  mouseup instead
        if (this.checkModifiers(evt) && this.control.handleRightClicks &&
           HGIS.Event.isRightClick(evt)) {
            propagate = this.rightclick(evt);
        }

        return propagate;
    },
    
    /**
     * Method: rightclick
     * Handle rightclick.  For a dblrightclick, we get two clicks so we need 
     *     to always register for dblrightclick to properly handle single 
     *     clicks.
     *     
     * Returns:
     * {Boolean} Continue propagating this event.
     */
    rightclick: function(evt) {
        if(this.passesTolerance(evt)) {
           if(this.rightclickTimerId != null) {
                //Second click received before timeout this must be 
                // a double click
                this.clearTimer();
                this.callback('dblrightclick', [evt]);
                return !this.stopDouble;
            } else { 
                //Set the rightclickTimerId, send evt only if double is 
                // true else trigger single
                var clickEvent = this['double'] ?
                    HGIS.Util.extend({}, evt) : 
                    this.callback('rightclick', [evt]);

                var delayedRightCall = HGIS.Function.bind(
                    this.delayedRightCall, 
                    this, 
                    clickEvent
                );
                this.rightclickTimerId = window.setTimeout(
                    delayedRightCall, this.delay
                );
            } 
        }
        return !this.stopSingle;
    },
    
    /**
     * Method: delayedRightCall
     * Sets <rightclickTimerId> to null.  And optionally triggers the 
     *     rightclick callback if evt is set.
     */
    delayedRightCall: function(evt) {
        this.rightclickTimerId = null;
        if (evt) {
           this.callback('rightclick', [evt]);
        }
    },
    
    /**
     * Method: click
     * Handle click events from the browser.  This is registered as a listener
     *     for click events and should not be called from other events in this
     *     handler.
     *
     * Returns:
     * {Boolean} Continue propagating this event.
     */
    click: function(evt) {
        if (!this.last) {
            this.last = this.getEventInfo(evt);
        }
        this.handleSingle(evt);
        return !this.stopSingle;
    },

    /**
     * Method: dblclick
     * Handle dblclick.  For a dblclick, we get two clicks in some browsers
     *     (FF) and one in others (IE).  So we need to always register for
     *     dblclick to properly handle single clicks.  This method is registered
     *     as a listener for the dblclick browser event.  It should *not* be
     *     called by other methods in this handler.
     *     
     * Returns:
     * {Boolean} Continue propagating this event.
     */
    dblclick: function(evt) {
        this.handleDouble(evt);
        return !this.stopDouble;
    },
    
    /** 
     * Method: handleDouble
     * Handle double-click sequence.
     */
    handleDouble: function(evt) {
        if (this.passesDblclickTolerance(evt)) {
            if (this["double"]) {
                this.callback("dblclick", [evt]);
            }
            // to prevent a dblclick from firing the click callback in IE
            this.clearTimer();
        }
    },
    
    /** 
     * Method: handleSingle
     * Handle single click sequence.
     */
    handleSingle: function(evt) {
        if (this.passesTolerance(evt)) {
            if (this.timerId != null) {
                // already received a click
                if (this.last.touches && this.last.touches.length === 1) {
                    // touch device, no dblclick event - this may be a double
                    if (this["double"]) {
                        // on Android don't let the browser zoom on the page
                        HGIS.Event.preventDefault(evt);
                    }
                    this.handleDouble(evt);
                }
                // if we're not in a touch environment we clear the click timer
                // if we've got a second touch, we'll get two touchend events
                if (!this.last.touches || this.last.touches.length !== 2) {
                    this.clearTimer();
                }
            } else {
                // remember the first click info so we can compare to the second
                this.first = this.getEventInfo(evt);
                // set the timer, send evt only if single is true
                //use a clone of the event object because it will no longer 
                //be a valid event object in IE in the timer callback
                var clickEvent = this.single ?
                    HGIS.Util.extend({}, evt) : null;
                this.queuePotentialClick(clickEvent);
            }
        }
    },
    
    /** 
     * Method: queuePotentialClick
     * This method is separated out largely to make testing easier (so we
     *     don't have to override window.setTimeout)
     */
    queuePotentialClick: function(evt) {
        this.timerId = window.setTimeout(
            HGIS.Function.bind(this.delayedCall, this, evt),
            this.delay
        );
    },

    /**
     * Method: passesTolerance
     * Determine whether the event is within the optional pixel tolerance.  Note
     *     that the pixel tolerance check only works if mousedown events get to
     *     the listeners registered here.  If they are stopped by other elements,
     *     the <pixelTolerance> will have no effect here (this method will always
     *     return true).
     *
     * Returns:
     * {Boolean} The click is within the pixel tolerance (if specified).
     */
    passesTolerance: function(evt) {
        var passes = true;
        if (this.pixelTolerance != null && this.down && this.down.xy) {
            passes = this.pixelTolerance >= this.down.xy.distanceTo(evt.xy);
            // for touch environments, we also enforce that all touches
            // start and end within the given tolerance to be considered a click
            if (passes && this.touch && 
                this.down.touches.length === this.last.touches.length) {
                // the touchend event doesn't come with touches, so we check
                // down and last
                for (var i=0, ii=this.down.touches.length; i<ii; ++i) {
                    if (this.getTouchDistance(
                            this.down.touches[i], 
                            this.last.touches[i]
                        ) > this.pixelTolerance) {
                        passes = false;
                        break;
                    }
                }
            }
        }
        return passes;
    },
    
    /** 
     * Method: getTouchDistance
     *
     * Returns:
     * {Boolean} The pixel displacement between two touches.
     */
    getTouchDistance: function(from, to) {
        return Math.sqrt(
            Math.pow(from.clientX - to.clientX, 2) +
            Math.pow(from.clientY - to.clientY, 2)
        );
    },
    
    /**
     * Method: passesDblclickTolerance
     * Determine whether the event is within the optional double-cick pixel 
     *     tolerance.
     *
     * Returns:
     * {Boolean} The click is within the double-click pixel tolerance.
     */
    passesDblclickTolerance: function(evt) {
        var passes = true;
        if (this.down && this.first) {
            passes = this.down.xy.distanceTo(this.first.xy) <= this.dblclickTolerance;
        }
        return passes;
    },

    /**
     * Method: clearTimer
     * Clear the timer and set <timerId> to null.
     */
    clearTimer: function() {
        if (this.timerId != null) {
            window.clearTimeout(this.timerId);
            this.timerId = null;
        }
        if (this.rightclickTimerId != null) {
            window.clearTimeout(this.rightclickTimerId);
            this.rightclickTimerId = null;
        }
    },
    
    /**
     * Method: delayedCall
     * Sets <timerId> to null.  And optionally triggers the click callback if
     *     evt is set.
     */
    delayedCall: function(evt) {
        this.timerId = null;
        if (evt) {
            this.callback("click", [evt]);
        }
    },

    /**
     * Method: getEventInfo
     * This method allows us to store event information without storing the
     *     actual event.  In touch devices (at least), the same event is 
     *     modified between touchstart, touchmove, and touchend.
     *
     * Returns:
     * {Object} An object with event related info.
     */
    getEventInfo: function(evt) {
        var touches;
        if (evt.touches) {
            var len = evt.touches.length;
            touches = new Array(len);
            var touch;
            for (var i=0; i<len; i++) {
                touch = evt.touches[i];
                touches[i] = {
                    clientX: touch.olClientX,
                    clientY: touch.olClientY
                };
            }
        }
        return {
            xy: evt.xy,
            touches: touches
        };
    },

    /**
     * APIMethod: deactivate
     * Deactivate the handler.
     *
     * Returns:
     * {Boolean} The handler was successfully deactivated.
     */
    deactivate: function() {
        var deactivated = false;
        if(HGIS.Handler.prototype.deactivate.apply(this, arguments)) {
            this.clearTimer();
            this.down = null;
            this.first = null;
            this.last = null;
            deactivated = true;
        }
        return deactivated;
    },

    CLASS_NAME: "HGIS.Handler.Click"
});
/* ======================================================================
    HGIS/Handler/Drag.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Handler.js
 */

/**
 * Class: HGIS.Handler.Drag
 * The drag handler is used to deal with sequences of browser events related
 *     to dragging.  The handler is used by controls that want to know when
 *     a drag sequence begins, when a drag is happening, and when it has
 *     finished.
 *
 * Controls that use the drag handler typically construct it with callbacks
 *     for 'down', 'move', and 'done'.  Callbacks for these keys are called
 *     when the drag begins, with each move, and when the drag is done.  In
 *     addition, controls can have callbacks keyed to 'up' and 'out' if they
 *     care to differentiate between the types of events that correspond with
 *     the end of a drag sequence.  If no drag actually occurs (no mouse move)
 *     the 'down' and 'up' callbacks will be called, but not the 'done'
 *     callback.
 *
 * Create a new drag handler with the <HGIS.Handler.Drag> constructor.
 *
 * Inherits from:
 *  - <HGIS.Handler>
 */
HGIS.Handler.Drag = HGIS.Class(HGIS.Handler, {
  
    /** 
     * Property: started
     * {Boolean} When a mousedown or touchstart event is received, we want to
     * record it, but not set 'dragging' until the mouse moves after starting.
     */
    started: false,

    /**
     * Property: stopDown
     * {Boolean} Stop propagation of mousedown events from getting to listeners
     *     on the same element.  Default is true.
     */
    stopDown: true,

    /** 
     * Property: dragging 
     * {Boolean} 
     */
    dragging: false,

    /** 
     * Property: last
     * {<HGIS.Pixel>} The last pixel location of the drag.
     */
    last: null,

    /** 
     * Property: start
     * {<HGIS.Pixel>} The first pixel location of the drag.
     */
    start: null,

    /**
     * Property: lastMoveEvt
     * {Object} The last mousemove event that occurred. Used to
     *     position the map correctly when our "delay drag"
     *     timeout expired.
     */
    lastMoveEvt: null,

    /**
     * Property: oldOnselectstart
     * {Function}
     */
    oldOnselectstart: null,
    
    /**
     * Property: interval
     * {Integer} In order to increase performance, an interval (in 
     *     milliseconds) can be set to reduce the number of drag events 
     *     called. If set, a new drag event will not be set until the 
     *     interval has passed. 
     *     Defaults to 0, meaning no interval. 
     */
    interval: 0,
    
    /**
     * Property: timeoutId
     * {String} The id of the timeout used for the mousedown interval.
     *     This is "private", and should be left alone.
     */
    timeoutId: null,
    
    /**
     * APIProperty: documentDrag
     * {Boolean} If set to true, the handler will also handle mouse moves when
     *     the cursor has moved out of the map viewport. Default is false.
     */
    documentDrag: false,
    
    /**
     * Property: documentEvents
     * {Boolean} Are we currently observing document events?
     */
    documentEvents: null,

    /**
     * Constructor: HGIS.Handler.Drag
     * Returns HGIS.Handler.Drag
     * 
     * Parameters:
     * control - {<HGIS.Control>} The control that is making use of
     *     this handler.  If a handler is being used without a control, the
     *     handlers setMap method must be overridden to deal properly with
     *     the map.
     * callbacks - {Object} An object containing a single function to be
     *     called when the drag operation is finished. The callback should
     *     expect to recieve a single argument, the pixel location of the event.
     *     Callbacks for 'move' and 'done' are supported. You can also speficy
     *     callbacks for 'down', 'up', and 'out' to respond to those events.
     * options - {Object} 
     */
    initialize: function(control, callbacks, options) {
        HGIS.Handler.prototype.initialize.apply(this, arguments);
        
        if (this.documentDrag === true) {
            var me = this;
            this._docMove = function(evt) {
                me.mousemove({
                    xy: {x: evt.clientX, y: evt.clientY},
                    element: document
                });
            };
            this._docUp = function(evt) {
                me.mouseup({xy: {x: evt.clientX, y: evt.clientY}});
            };
        }
    },

    
    /**
     * Method: dragstart
     * This private method is factorized from mousedown and touchstart methods
     *
     * Parameters:
     * evt - {Event} The event
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    dragstart: function (evt) {
        var propagate = true;
        this.dragging = false;
        if (this.checkModifiers(evt) &&
               (HGIS.Event.isLeftClick(evt) ||
                HGIS.Event.isSingleTouch(evt))) {
            this.started = true;
            this.start = evt.xy;
            this.last = evt.xy;
            HGIS.Element.addClass(
                this.map.viewPortDiv, "olDragDown"
            );
            this.down(evt);
            this.callback("down", [evt.xy]);

            // prevent document dragging
            HGIS.Event.preventDefault(evt);

            if(!this.oldOnselectstart) {
                this.oldOnselectstart = document.onselectstart ?
                    document.onselectstart : HGIS.Function.True;
            }
            document.onselectstart = HGIS.Function.False;

            propagate = !this.stopDown;
        } else {
            this.started = false;
            this.start = null;
            this.last = null;
        }
        return propagate;
    },

    /**
     * Method: dragmove
     * This private method is factorized from mousemove and touchmove methods
     *
     * Parameters:
     * evt - {Event} The event
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    dragmove: function (evt) {
        this.lastMoveEvt = evt;
        if (this.started && !this.timeoutId && (evt.xy.x != this.last.x ||
                                                evt.xy.y != this.last.y)) {
            if(this.documentDrag === true && this.documentEvents) {
                if(evt.element === document) {
                    this.adjustXY(evt);
                    // do setEvent manually because the documentEvents are not
                    // registered with the map
                    this.setEvent(evt);
                } else {
                    this.removeDocumentEvents();
                }
            }
            if (this.interval > 0) {
                this.timeoutId = setTimeout(
                    HGIS.Function.bind(this.removeTimeout, this),
                    this.interval);
            }
            this.dragging = true;

            this.move(evt);
            this.callback("move", [evt.xy]);
            if(!this.oldOnselectstart) {
                this.oldOnselectstart = document.onselectstart;
                document.onselectstart = HGIS.Function.False;
            }
            this.last = evt.xy;
        }
        return true;
    },

    /**
     * Method: dragend
     * This private method is factorized from mouseup and touchend methods
     *
     * Parameters:
     * evt - {Event} The event
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    dragend: function (evt) {
        if (this.started) {
            if(this.documentDrag === true && this.documentEvents) {
                this.adjustXY(evt);
                this.removeDocumentEvents();
            }
            var dragged = (this.start != this.last);
            this.started = false;
            this.dragging = false;
            HGIS.Element.removeClass(
                this.map.viewPortDiv, "olDragDown"
            );
            this.up(evt);
            this.callback("up", [evt.xy]);
            if(dragged) {
                this.callback("done", [evt.xy]);
            }
            document.onselectstart = this.oldOnselectstart;
        }
        return true;
    },

    /**
     * The four methods below (down, move, up, and out) are used by subclasses
     *     to do their own processing related to these mouse events.
     */

    /**
     * Method: down
     * This method is called during the handling of the mouse down event.
     *     Subclasses can do their own processing here.
     *
     * Parameters:
     * evt - {Event} The mouse down event
     */
    down: function(evt) {
    },

    /**
     * Method: move
     * This method is called during the handling of the mouse move event.
     *     Subclasses can do their own processing here.
     *
     * Parameters:
     * evt - {Event} The mouse move event
     *
     */
    move: function(evt) {
    },

    /**
     * Method: up
     * This method is called during the handling of the mouse up event.
     *     Subclasses can do their own processing here.
     *
     * Parameters:
     * evt - {Event} The mouse up event
     */
    up: function(evt) {
    },

    /**
     * Method: out
     * This method is called during the handling of the mouse out event.
     *     Subclasses can do their own processing here.
     *
     * Parameters:
     * evt - {Event} The mouse out event
     */
    out: function(evt) {
    },

    /**
     * The methods below are part of the magic of event handling.  Because
     *     they are named like browser events, they are registered as listeners
     *     for the events they represent.
     */

    /**
     * Method: mousedown
     * Handle mousedown events
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    mousedown: function(evt) {
        return this.dragstart(evt);
    },

    /**
     * Method: touchstart
     * Handle touchstart events
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    touchstart: function(evt) {
        this.startTouch();
        return this.dragstart(evt);
    },

    /**
     * Method: mousemove
     * Handle mousemove events
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    mousemove: function(evt) {
        return this.dragmove(evt);
    },

    /**
     * Method: touchmove
     * Handle touchmove events
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    touchmove: function(evt) {
        return this.dragmove(evt);
    },

    /**
     * Method: removeTimeout
     * Private. Called by mousemove() to remove the drag timeout.
     */
    removeTimeout: function() {
        this.timeoutId = null;
        // if timeout expires while we're still dragging (mouseup
        // hasn't occurred) then call mousemove to move to the
        // correct position
        if(this.dragging) {
            this.mousemove(this.lastMoveEvt);
        }
    },

    /**
     * Method: mouseup
     * Handle mouseup events
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    mouseup: function(evt) {
        return this.dragend(evt);
    },

    /**
     * Method: touchend
     * Handle touchend events
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    touchend: function(evt) {
        // override evt.xy with last position since touchend does not have
        // any touch position
        evt.xy = this.last;
        return this.dragend(evt);
    },

    /**
     * Method: mouseout
     * Handle mouseout events
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    mouseout: function (evt) {
        if (this.started && HGIS.Util.mouseLeft(evt, this.map.viewPortDiv)) {
            if(this.documentDrag === true) {
                this.addDocumentEvents();
            } else {
                var dragged = (this.start != this.last);
                this.started = false; 
                this.dragging = false;
                HGIS.Element.removeClass(
                    this.map.viewPortDiv, "olDragDown"
                );
                this.out(evt);
                this.callback("out", []);
                if(dragged) {
                    this.callback("done", [evt.xy]);
                }
                if(document.onselectstart) {
                    document.onselectstart = this.oldOnselectstart;
                }
            }
        }
        return true;
    },

    /**
     * Method: click
     * The drag handler captures the click event.  If something else registers
     *     for clicks on the same element, its listener will not be called 
     *     after a drag.
     * 
     * Parameters: 
     * evt - {Event} 
     * 
     * Returns:
     * {Boolean} Let the event propagate.
     */
    click: function (evt) {
        // let the click event propagate only if the mouse moved
        return (this.start == this.last);
    },

    /**
     * Method: activate
     * Activate the handler.
     * 
     * Returns:
     * {Boolean} The handler was successfully activated.
     */
    activate: function() {
        var activated = false;
        if(HGIS.Handler.prototype.activate.apply(this, arguments)) {
            this.dragging = false;
            activated = true;
        }
        return activated;
    },

    /**
     * Method: deactivate 
     * Deactivate the handler.
     * 
     * Returns:
     * {Boolean} The handler was successfully deactivated.
     */
    deactivate: function() {
        var deactivated = false;
        if(HGIS.Handler.prototype.deactivate.apply(this, arguments)) {
            this.started = false;
            this.dragging = false;
            this.start = null;
            this.last = null;
            deactivated = true;
            HGIS.Element.removeClass(
                this.map.viewPortDiv, "olDragDown"
            );
        }
        return deactivated;
    },
    
    /**
     * Method: adjustXY
     * Converts event coordinates that are relative to the document body to
     * ones that are relative to the map viewport. The latter is the default in
     * HGIS.
     * 
     * Parameters:
     * evt - {Object}
     */
    adjustXY: function(evt) {
        var pos = HGIS.Util.pagePosition(this.map.viewPortDiv);
        evt.xy.x -= pos[0];
        evt.xy.y -= pos[1];
    },
    
    /**
     * Method: addDocumentEvents
     * Start observing document events when documentDrag is true and the mouse
     * cursor leaves the map viewport while dragging.
     */
    addDocumentEvents: function() {
        HGIS.Element.addClass(document.body, "olDragDown");
        this.documentEvents = true;
        HGIS.Event.observe(document, "mousemove", this._docMove);
        HGIS.Event.observe(document, "mouseup", this._docUp);
    },
    
    /**
     * Method: removeDocumentEvents
     * Stops observing document events when documentDrag is true and the mouse
     * cursor re-enters the map viewport while dragging.
     */
    removeDocumentEvents: function() {
        HGIS.Element.removeClass(document.body, "olDragDown");
        this.documentEvents = false;
        HGIS.Event.stopObserving(document, "mousemove", this._docMove);
        HGIS.Event.stopObserving(document, "mouseup", this._docUp);
    },

    CLASS_NAME: "HGIS.Handler.Drag"
});
/* ======================================================================
    HGIS/Control/OverviewMap.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/** 
 * @requires HGIS/Control.js
 * @requires HGIS/BaseTypes.js
 * @requires HGIS/Events/buttonclick.js
 * @requires HGIS/Map.js
 * @requires HGIS/Handler/Click.js
 * @requires HGIS/Handler/Drag.js
 */

/**
 * Class: HGIS.Control.OverviewMap
 * The OverMap control creates a small overview map, useful to display the 
 * extent of a zoomed map and your main map and provide additional 
 * navigation options to the User.  By default the overview map is drawn in
 * the lower right corner of the main map. Create a new overview map with the
 * <HGIS.Control.OverviewMap> constructor.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.OverviewMap = HGIS.Class(HGIS.Control, {

    /**
     * Property: element
     * {DOMElement} The DOM element that contains the overview map
     */
    element: null,
    
    /**
     * APIProperty: ovmap
     * {<HGIS.Map>} A reference to the overview map itself.
     */
    ovmap: null,

    /**
     * APIProperty: size
     * {<HGIS.Size>} The overvew map size in pixels.  Note that this is
     * the size of the map itself - the element that contains the map (default
     * class name olControlOverviewMapElement) may have padding or other style
     * attributes added via CSS.
     */
    size: {w: 180, h: 90},

    /**
     * APIProperty: layers
     * {Array(<HGIS.Layer>)} Ordered list of layers in the overview map.
     * If none are sent at construction, the base layer for the main map is used.
     */
    layers: null,
    
    /**
     * APIProperty: minRectSize
     * {Integer} The minimum width or height (in pixels) of the extent
     *     rectangle on the overview map.  When the extent rectangle reaches
     *     this size, it will be replaced depending on the value of the
     *     <minRectDisplayClass> property.  Default is 15 pixels.
     */
    minRectSize: 15,
    
    /**
     * APIProperty: minRectDisplayClass
     * {String} Replacement style class name for the extent rectangle when
     *     <minRectSize> is reached.  This string will be suffixed on to the
     *     displayClass.  Default is "RectReplacement".
     *
     * Example CSS declaration:
     * (code)
     * .olControlOverviewMapRectReplacement {
     *     overflow: hidden;
     *     cursor: move;
     *     background-image: url("img/overview_replacement.gif");
     *     background-repeat: no-repeat;
     *     background-position: center;
     * }
     * (end)
     */
    minRectDisplayClass: "RectReplacement",

    /**
     * APIProperty: minRatio
     * {Float} The ratio of the overview map resolution to the main map
     *     resolution at which to zoom farther out on the overview map.
     */
    minRatio: 8,

    /**
     * APIProperty: maxRatio
     * {Float} The ratio of the overview map resolution to the main map
     *     resolution at which to zoom farther in on the overview map.
     */
    maxRatio: 32,
    
    /**
     * APIProperty: mapOptions
     * {Object} An object containing any non-default properties to be sent to
     *     the overview map's map constructor.  These should include any
     *     non-default options that the main map was constructed with.
     */
    mapOptions: null,

    /**
     * APIProperty: autoPan
     * {Boolean} Always pan the overview map, so the extent marker remains in
     *     the center.  Default is false.  If true, when you drag the extent
     *     marker, the overview map will update itself so the marker returns
     *     to the center.
     */
    autoPan: false,
    
    /**
     * Property: handlers
     * {Object}
     */
    handlers: null,

    /**
     * Property: resolutionFactor
     * {Object}
     */
    resolutionFactor: 1,

    /**
     * APIProperty: maximized
     * {Boolean} Start as maximized (visible). Defaults to false.
     */
    maximized: false,

    /**
     * APIProperty: maximizeTitle
     * {String}  This property is used for showing a tooltip over the  
     * maximize div. Defaults to "" (no title).
     */ 
    maximizeTitle: "",

    /**
     * APIProperty: minimizeTitle
     * {String}  This property is used for showing a tooltip over the  
     * minimize div. Defaults to "" (no title).
     */ 
    minimizeTitle: "",

    /**
     * Constructor: HGIS.Control.OverviewMap
     * Create a new overview map
     *
     * Parameters:
     * options - {Object} Properties of this object will be set on the overview
     * map object.  Note, to set options on the map object contained in this
     * control, set <mapOptions> as one of the options properties.
     */
    initialize: function(options) {
        this.layers = [];
        this.handlers = {};
        HGIS.Control.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * APIMethod: destroy
     * Deconstruct the control
     */
    destroy: function() {
        if (!this.mapDiv) { // we've already been destroyed
            return;
        }
        if (this.handlers.click) {
            this.handlers.click.destroy();
        }
        if (this.handlers.drag) {
            this.handlers.drag.destroy();
        }

        this.ovmap && this.ovmap.viewPortDiv.removeChild(this.extentRectangle);
        this.extentRectangle = null;

        if (this.rectEvents) {
            this.rectEvents.destroy();
            this.rectEvents = null;
        }

        if (this.ovmap) {
            this.ovmap.destroy();
            this.ovmap = null;
        }
        
        this.element.removeChild(this.mapDiv);
        this.mapDiv = null;

        this.div.removeChild(this.element);
        this.element = null;

        if (this.maximizeDiv) {
            this.div.removeChild(this.maximizeDiv);
            this.maximizeDiv = null;
        }
        
        if (this.minimizeDiv) {
            this.div.removeChild(this.minimizeDiv);
            this.minimizeDiv = null;
        }

        this.map.events.un({
            buttonclick: this.onButtonClick,
            moveend: this.update,
            changebaselayer: this.baseLayerDraw,
            scope: this
        });

        HGIS.Control.prototype.destroy.apply(this, arguments);    
    },

    /**
     * Method: draw
     * Render the control in the browser.
     */    
    draw: function() {
        HGIS.Control.prototype.draw.apply(this, arguments);
        if (this.layers.length === 0) {
            if (this.map.baseLayer) {
                var layer = this.map.baseLayer.clone();
                this.layers = [layer];
            } else {
                this.map.events.register("changebaselayer", this, this.baseLayerDraw);
                return this.div;
            }
        }

        // create overview map DOM elements
        this.element = document.createElement('div');
        this.element.className = this.displayClass + 'Element';
        this.element.style.display = 'none';

        this.mapDiv = document.createElement('div');
        this.mapDiv.style.width = this.size.w + 'px';
        this.mapDiv.style.height = this.size.h + 'px';
        this.mapDiv.style.position = 'relative';
        this.mapDiv.style.overflow = 'hidden';
        this.mapDiv.id = HGIS.Util.createUniqueID('overviewMap');
        
        this.extentRectangle = document.createElement('div');
        this.extentRectangle.style.position = 'absolute';
        this.extentRectangle.style.zIndex = 1000;  //HACK
        this.extentRectangle.className = this.displayClass+'ExtentRectangle';

        this.element.appendChild(this.mapDiv);  

        this.div.appendChild(this.element);

        // Optionally add min/max buttons if the control will go in the
        // map viewport.
        if(!this.outsideViewport) {
            this.div.className += " " + this.displayClass + 'Container';
            // maximize button div
            var img = HGIS.Util.getImageLocation('layer-switcher-maximize.png');
            this.maximizeDiv = HGIS.Util.createAlphaImageDiv(
                                        this.displayClass + 'MaximizeButton', 
                                        null, 
                                        null, 
                                        img, 
                                        'absolute');
            this.maximizeDiv.style.display = 'none';
            this.maximizeDiv.className = this.displayClass + 'MaximizeButton olButton';
            if (this.maximizeTitle) {
                this.maximizeDiv.title = this.maximizeTitle;
            }
            this.div.appendChild(this.maximizeDiv);
    
            // minimize button div
            var img = HGIS.Util.getImageLocation('layer-switcher-minimize.png');
            this.minimizeDiv = HGIS.Util.createAlphaImageDiv(
                                        'HGIS_Control_minimizeDiv', 
                                        null, 
                                        null, 
                                        img, 
                                        'absolute');
            this.minimizeDiv.style.display = 'none';
            this.minimizeDiv.className = this.displayClass + 'MinimizeButton olButton';
            if (this.minimizeTitle) {
                this.minimizeDiv.title = this.minimizeTitle;
            }
            this.div.appendChild(this.minimizeDiv);            
            this.minimizeControl();
        } else {
            // show the overview map
            this.element.style.display = '';
        }
        if(this.map.getExtent()) {
            this.update();
        }
        
        this.map.events.on({
            buttonclick: this.onButtonClick,
            moveend: this.update,
            scope: this
        });
        
        if (this.maximized) {
            this.maximizeControl();
        }
        return this.div;
    },
    
    /**
     * Method: baseLayerDraw
     * Draw the base layer - called if unable to complete in the initial draw
     */
    baseLayerDraw: function() {
        this.draw();
        this.map.events.unregister("changebaselayer", this, this.baseLayerDraw);
    },

    /**
     * Method: rectDrag
     * Handle extent rectangle drag
     *
     * Parameters:
     * px - {<HGIS.Pixel>} The pixel location of the drag.
     */
    rectDrag: function(px) {
        var deltaX = this.handlers.drag.last.x - px.x;
        var deltaY = this.handlers.drag.last.y - px.y;
        if(deltaX != 0 || deltaY != 0) {
            var rectTop = this.rectPxBounds.top;
            var rectLeft = this.rectPxBounds.left;
            var rectHeight = Math.abs(this.rectPxBounds.getHeight());
            var rectWidth = this.rectPxBounds.getWidth();
            // don't allow dragging off of parent element
            var newTop = Math.max(0, (rectTop - deltaY));
            newTop = Math.min(newTop,
                              this.ovmap.size.h - this.hComp - rectHeight);
            var newLeft = Math.max(0, (rectLeft - deltaX));
            newLeft = Math.min(newLeft,
                               this.ovmap.size.w - this.wComp - rectWidth);
            this.setRectPxBounds(new HGIS.Bounds(newLeft,
                                                       newTop + rectHeight,
                                                       newLeft + rectWidth,
                                                       newTop));
        }
    },
    
    /**
     * Method: mapDivClick
     * Handle browser events
     *
     * Parameters:
     * evt - {<HGIS.Event>} evt
     */
    mapDivClick: function(evt) {
        var pxCenter = this.rectPxBounds.getCenterPixel();
        var deltaX = evt.xy.x - pxCenter.x;
        var deltaY = evt.xy.y - pxCenter.y;
        var top = this.rectPxBounds.top;
        var left = this.rectPxBounds.left;
        var height = Math.abs(this.rectPxBounds.getHeight());
        var width = this.rectPxBounds.getWidth();
        var newTop = Math.max(0, (top + deltaY));
        newTop = Math.min(newTop, this.ovmap.size.h - height);
        var newLeft = Math.max(0, (left + deltaX));
        newLeft = Math.min(newLeft, this.ovmap.size.w - width);
        this.setRectPxBounds(new HGIS.Bounds(newLeft,
                                                   newTop + height,
                                                   newLeft + width,
                                                   newTop));
        this.updateMapToRect();
    },
    
    /**
     * Method: onButtonClick
     *
     * Parameters:
     * evt - {Event}
     */
    onButtonClick: function(evt) {
        if (evt.buttonElement === this.minimizeDiv) {
            this.minimizeControl();
        } else if (evt.buttonElement === this.maximizeDiv) {
            this.maximizeControl();
        }
    },

    /**
     * Method: maximizeControl
     * Unhide the control.  Called when the control is in the map viewport.
     *
     * Parameters:
     * e - {<HGIS.Event>}
     */
    maximizeControl: function(e) {
        this.element.style.display = '';
        this.showToggle(false);
        if (e != null) {
            HGIS.Event.stop(e);                                            
        }
    },

    /**
     * Method: minimizeControl
     * Hide all the contents of the control, shrink the size, 
     * add the maximize icon
     * 
     * Parameters:
     * e - {<HGIS.Event>}
     */
    minimizeControl: function(e) {
        this.element.style.display = 'none';
        this.showToggle(true);
        if (e != null) {
            HGIS.Event.stop(e);                                            
        }
    },

    /**
     * Method: showToggle
     * Hide/Show the toggle depending on whether the control is minimized
     *
     * Parameters:
     * minimize - {Boolean} 
     */
    showToggle: function(minimize) {
        if (this.maximizeDiv) {
            this.maximizeDiv.style.display = minimize ? '' : 'none';
        }
        if (this.minimizeDiv) {
            this.minimizeDiv.style.display = minimize ? 'none' : '';
        }
    },

    /**
     * Method: update
     * Update the overview map after layers move.
     */
    update: function() {
        if(this.ovmap == null) {
            this.createMap();
        }
        
        if(this.autoPan || !this.isSuitableOverview()) {
            this.updateOverview();
        }
        
        // update extent rectangle
        this.updateRectToMap();
    },
    
    /**
     * Method: isSuitableOverview
     * Determines if the overview map is suitable given the extent and
     * resolution of the main map.
     */
    isSuitableOverview: function() {
        var mapExtent = this.map.getExtent();
        var maxExtent = this.map.getMaxExtent();
        var testExtent = new HGIS.Bounds(
                                Math.max(mapExtent.left, maxExtent.left),
                                Math.max(mapExtent.bottom, maxExtent.bottom),
                                Math.min(mapExtent.right, maxExtent.right),
                                Math.min(mapExtent.top, maxExtent.top));        

        if (this.ovmap.getProjection() != this.map.getProjection()) {
            testExtent = testExtent.transform(
                this.map.getProjectionObject(),
                this.ovmap.getProjectionObject() );
        }

        var resRatio = this.ovmap.getResolution() / this.map.getResolution();
        return ((resRatio > this.minRatio) &&
                (resRatio <= this.maxRatio) &&
                (this.ovmap.getExtent().containsBounds(testExtent)));
    },
    
    /**
     * Method updateOverview
     * Called by <update> if <isSuitableOverview> returns true
     */
    updateOverview: function() {
        var mapRes = this.map.getResolution();
        var targetRes = this.ovmap.getResolution();
        var resRatio = targetRes / mapRes;
        if(resRatio > this.maxRatio) {
            // zoom in overview map
            targetRes = this.minRatio * mapRes;            
        } else if(resRatio <= this.minRatio) {
            // zoom out overview map
            targetRes = this.maxRatio * mapRes;
        }
        var center;
        if (this.ovmap.getProjection() != this.map.getProjection()) {
            center = this.map.center.clone();
            center.transform(this.map.getProjectionObject(),
                this.ovmap.getProjectionObject() );
        } else {
            center = this.map.center;
        }
        this.ovmap.setCenter(center, this.ovmap.getZoomForResolution(
            targetRes * this.resolutionFactor));
        this.updateRectToMap();
    },
    
    /**
     * Method: createMap
     * Construct the map that this control contains
     */
    createMap: function() {
        // create the overview map
        var options = HGIS.Util.extend(
                        {controls: [], maxResolution: 'auto', 
                         fallThrough: false}, this.mapOptions);
        this.ovmap = new HGIS.Map(this.mapDiv, options);
        this.ovmap.viewPortDiv.appendChild(this.extentRectangle);
        
        // prevent ovmap from being destroyed when the page unloads, because
        // the OverviewMap control has to do this (and does it).
        HGIS.Event.stopObserving(window, 'unload', this.ovmap.unloadDestroy);
        
        this.ovmap.addLayers(this.layers);
        this.ovmap.zoomToMaxExtent();
        // check extent rectangle border width
        this.wComp = parseInt(HGIS.Element.getStyle(this.extentRectangle,
                                               'border-left-width')) +
                     parseInt(HGIS.Element.getStyle(this.extentRectangle,
                                               'border-right-width'));
        this.wComp = (this.wComp) ? this.wComp : 2;
        this.hComp = parseInt(HGIS.Element.getStyle(this.extentRectangle,
                                               'border-top-width')) +
                     parseInt(HGIS.Element.getStyle(this.extentRectangle,
                                               'border-bottom-width'));
        this.hComp = (this.hComp) ? this.hComp : 2;

        this.handlers.drag = new HGIS.Handler.Drag(
            this, {move: this.rectDrag, done: this.updateMapToRect},
            {map: this.ovmap}
        );
        this.handlers.click = new HGIS.Handler.Click(
            this, {
                "click": this.mapDivClick
            },{
                "single": true, "double": false,
                "stopSingle": true, "stopDouble": true,
                "pixelTolerance": 1,
                map: this.ovmap
            }
        );
        this.handlers.click.activate();
        
        this.rectEvents = new HGIS.Events(this, this.extentRectangle,
                                                null, true);
        this.rectEvents.register("mouseover", this, function(e) {
            if(!this.handlers.drag.active && !this.map.dragging) {
                this.handlers.drag.activate();
            }
        });
        this.rectEvents.register("mouseout", this, function(e) {
            if(!this.handlers.drag.dragging) {
                this.handlers.drag.deactivate();
            }
        });

        if (this.ovmap.getProjection() != this.map.getProjection()) {
            var sourceUnits = this.map.getProjectionObject().getUnits() ||
                this.map.units || this.map.baseLayer.units;
            var targetUnits = this.ovmap.getProjectionObject().getUnits() ||
                this.ovmap.units || this.ovmap.baseLayer.units;
            this.resolutionFactor = sourceUnits && targetUnits ?
                HGIS.INCHES_PER_UNIT[sourceUnits] /
                HGIS.INCHES_PER_UNIT[targetUnits] : 1;
        }
    },
        
    /**
     * Method: updateRectToMap
     * Updates the extent rectangle position and size to match the map extent
     */
    updateRectToMap: function() {
        // If the projections differ we need to reproject
        var bounds;
        if (this.ovmap.getProjection() != this.map.getProjection()) {
            bounds = this.map.getExtent().transform(
                this.map.getProjectionObject(), 
                this.ovmap.getProjectionObject() );
        } else {
            bounds = this.map.getExtent();
        }
        var pxBounds = this.getRectBoundsFromMapBounds(bounds);
        if (pxBounds) {
            this.setRectPxBounds(pxBounds);
        }
    },
    
    /**
     * Method: updateMapToRect
     * Updates the map extent to match the extent rectangle position and size
     */
    updateMapToRect: function() {
        var lonLatBounds = this.getMapBoundsFromRectBounds(this.rectPxBounds);
        if (this.ovmap.getProjection() != this.map.getProjection()) {
            lonLatBounds = lonLatBounds.transform(
                this.ovmap.getProjectionObject(),
                this.map.getProjectionObject() );
        }
        this.map.panTo(lonLatBounds.getCenterLonLat());
    },

    /**
     * Method: setRectPxBounds
     * Set extent rectangle pixel bounds.
     *
     * Parameters:
     * pxBounds - {<HGIS.Bounds>}
     */
    setRectPxBounds: function(pxBounds) {
        var top = Math.max(pxBounds.top, 0);
        var left = Math.max(pxBounds.left, 0);
        var bottom = Math.min(pxBounds.top + Math.abs(pxBounds.getHeight()),
                              this.ovmap.size.h - this.hComp);
        var right = Math.min(pxBounds.left + pxBounds.getWidth(),
                             this.ovmap.size.w - this.wComp);
        var width = Math.max(right - left, 0);
        var height = Math.max(bottom - top, 0);
        if(width < this.minRectSize || height < this.minRectSize) {
            this.extentRectangle.className = this.displayClass +
                                             this.minRectDisplayClass;
            var rLeft = left + (width / 2) - (this.minRectSize / 2);
            var rTop = top + (height / 2) - (this.minRectSize / 2);
            this.extentRectangle.style.top = Math.round(rTop) + 'px';
            this.extentRectangle.style.left = Math.round(rLeft) + 'px';
            this.extentRectangle.style.height = this.minRectSize + 'px';
            this.extentRectangle.style.width = this.minRectSize + 'px';
        } else {
            this.extentRectangle.className = this.displayClass +
                                             'ExtentRectangle';
            this.extentRectangle.style.top = Math.round(top) + 'px';
            this.extentRectangle.style.left = Math.round(left) + 'px';
            this.extentRectangle.style.height = Math.round(height) + 'px';
            this.extentRectangle.style.width = Math.round(width) + 'px';
        }
        this.rectPxBounds = new HGIS.Bounds(
            Math.round(left), Math.round(bottom),
            Math.round(right), Math.round(top)
        );
    },

    /**
     * Method: getRectBoundsFromMapBounds
     * Get the rect bounds from the map bounds.
     *
     * Parameters:
     * lonLatBounds - {<HGIS.Bounds>}
     *
     * Returns:
     * {<HGIS.Bounds>}A bounds which is the passed-in map lon/lat extent
     * translated into pixel bounds for the overview map
     */
    getRectBoundsFromMapBounds: function(lonLatBounds) {
        var leftBottomPx = this.getOverviewPxFromLonLat({
            lon: lonLatBounds.left,
            lat: lonLatBounds.bottom
        });
        var rightTopPx = this.getOverviewPxFromLonLat({
            lon: lonLatBounds.right,
            lat: lonLatBounds.top
        });
        var bounds = null;
        if (leftBottomPx && rightTopPx) {
            bounds = new HGIS.Bounds(leftBottomPx.x, leftBottomPx.y,
                                           rightTopPx.x, rightTopPx.y);
        }
        return bounds;
    },

    /**
     * Method: getMapBoundsFromRectBounds
     * Get the map bounds from the rect bounds.
     *
     * Parameters:
     * pxBounds - {<HGIS.Bounds>}
     *
     * Returns:
     * {<HGIS.Bounds>} Bounds which is the passed-in overview rect bounds
     * translated into lon/lat bounds for the overview map
     */
    getMapBoundsFromRectBounds: function(pxBounds) {
        var leftBottomLonLat = this.getLonLatFromOverviewPx({
            x: pxBounds.left,
            y: pxBounds.bottom
        });
        var rightTopLonLat = this.getLonLatFromOverviewPx({
            x: pxBounds.right,
            y: pxBounds.top
        });
        return new HGIS.Bounds(leftBottomLonLat.lon, leftBottomLonLat.lat,
                                     rightTopLonLat.lon, rightTopLonLat.lat);
    },

    /**
     * Method: getLonLatFromOverviewPx
     * Get a map location from a pixel location
     *
     * Parameters:
     * overviewMapPx - {<HGIS.Pixel>|Object} HGIS.Pixel or
     *                                             an object with a
     *                                             'x' and 'y' properties.
     *
     * Returns:
     * {Object} Location which is the passed-in overview map
     * HGIS.Pixel, translated into lon/lat by the overview
     * map. An object with a 'lon' and 'lat' properties.
     */
    getLonLatFromOverviewPx: function(overviewMapPx) {
        var size = this.ovmap.size;
        var res  = this.ovmap.getResolution();
        var center = this.ovmap.getExtent().getCenterLonLat();
    
        var deltaX = overviewMapPx.x - (size.w / 2);
        var deltaY = overviewMapPx.y - (size.h / 2);

        return {
            lon: center.lon + deltaX * res,
            lat: center.lat - deltaY * res
        };
    },

    /**
     * Method: getOverviewPxFromLonLat
     * Get a pixel location from a map location
     *
     * Parameters:
     * lonlat - {<HGIS.LonLat>|Object} HGIS.LonLat or an
     *     object with a 'lon' and 'lat' properties.
     *
     * Returns:
     * {Object} Location which is the passed-in HGIS.LonLat, 
     * translated into overview map pixels
     */
    getOverviewPxFromLonLat: function(lonlat) {
        var res = this.ovmap.getResolution();
        var extent = this.ovmap.getExtent();
        if (extent) {
            return {
                x: Math.round(1/res * (lonlat.lon - extent.left)),
                y: Math.round(1/res * (extent.top - lonlat.lat))
            };
        } 
    },

    CLASS_NAME: 'HGIS.Control.OverviewMap'
});
/* ======================================================================
    HGIS/Layer.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Map.js
 * @requires HGIS/Projection.js
 */

/**
 * Class: HGIS.Layer
 */
HGIS.Layer = HGIS.Class({

    /**
     * APIProperty: id
     * {String}
     */
    id: null,

    /** 
     * APIProperty: name
     * {String}
     */
    name: null,

    /** 
     * APIProperty: div
     * {DOMElement}
     */
    div: null,

    /**
     * APIProperty: opacity
     * {Float} The layer's opacity. Float number between 0.0 and 1.0. Default
     * is 1.
     */
    opacity: 1,

    /**
     * APIProperty: alwaysInRange
     * {Boolean} If a layer's display should not be scale-based, this should 
     *     be set to true. This will cause the layer, as an overlay, to always 
     *     be 'active', by always returning true from the calculateInRange() 
     *     function. 
     * 
     *     If not explicitly specified for a layer, its value will be 
     *     determined on startup in initResolutions() based on whether or not 
     *     any scale-specific properties have been set as options on the 
     *     layer. If no scale-specific options have been set on the layer, we 
     *     assume that it should always be in range.
     * 
     *     See #987 for more info.
     */
    alwaysInRange: null,   

    /**
     * Constant: RESOLUTION_PROPERTIES
     * {Array} The properties that are used for calculating resolutions
     *     information.
     */
    RESOLUTION_PROPERTIES: [
        'scales', 'resolutions',
        'maxScale', 'minScale',
        'maxResolution', 'minResolution',
        'numZoomLevels', 'maxZoomLevel'
    ],

    /**
     * APIProperty: events
     * {<HGIS.Events>}
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * layer.events.register(type, obj, listener);
     * (end)
     *
     * Listeners will be called with a reference to an event object.  The
     *     properties of this event depends on exactly what happened.
     *
     * All event objects have at least the following properties:
     * object - {Object} A reference to layer.events.object.
     * element - {DOMElement} A reference to layer.events.element.
     *
     * Supported map event types:
     * loadstart - Triggered when layer loading starts.  When using a Vector 
     *     layer with a Fixed or BBOX strategy, the event object includes 
     *     a *filter* property holding the HGIS.Filter used when 
     *     calling read on the protocol.
     * loadend - Triggered when layer loading ends.  When using a Vector layer
     *     with a Fixed or BBOX strategy, the event object includes a 
     *     *response* property holding an HGIS.Protocol.Response object.
     * visibilitychanged - Triggered when the layer's visibility property is
     *     changed, e.g. by turning the layer on or off in the layer switcher.
     *     Note that the actual visibility of the layer can also change if it
     *     gets out of range (see <calculateInRange>). If you also want to catch
     *     these cases, register for the map's 'changelayer' event instead.
     * move - Triggered when layer moves (triggered with every mousemove
     *     during a drag).
     * moveend - Triggered when layer is done moving, object passed as
     *     argument has a zoomChanged boolean property which tells that the
     *     zoom has changed.
     * added - Triggered after the layer is added to a map.  Listeners will
     *     receive an object with a *map* property referencing the map and a
     *     *layer* property referencing the layer.
     * removed - Triggered after the layer is removed from the map.  Listeners
     *     will receive an object with a *map* property referencing the map and
     *     a *layer* property referencing the layer.
     */
    events: null,

    /**
     * APIProperty: map
     * {<HGIS.Map>} This variable is set when the layer is added to 
     *     the map, via the accessor function setMap().
     */
    map: null,
    
    /**
     * APIProperty: isBaseLayer
     * {Boolean} Whether or not the layer is a base layer. This should be set 
     *     individually by all subclasses. Default is false
     */
    isBaseLayer: false,
 
    /**
     * Property: alpha
     * {Boolean} The layer's images have an alpha channel.  Default is false.
     */
    alpha: false,

    /** 
     * APIProperty: displayInLayerSwitcher
     * {Boolean} Display the layer's name in the layer switcher.  Default is
     *     true.
     */
    displayInLayerSwitcher: true,

    /**
     * APIProperty: visibility
     * {Boolean} The layer should be displayed in the map.  Default is true.
     */
    visibility: true,

    /**
     * APIProperty: attribution
     * {String} Attribution string, displayed when an 
     *     <HGIS.Control.Attribution> has been added to the map.
     */
    attribution: null, 

    /** 
     * Property: inRange
     * {Boolean} The current map resolution is within the layer's min/max 
     *     range. This is set in <HGIS.Map.setCenter> whenever the zoom 
     *     changes.
     */
    inRange: false,
    
    /**
     * Propery: imageSize
     * {<HGIS.Size>} For layers with a gutter, the image is larger than 
     *     the tile by twice the gutter in each dimension.
     */
    imageSize: null,
    
  // OPTIONS

    /** 
     * Property: options
     * {Object} An optional object whose properties will be set on the layer.
     *     Any of the layer properties can be set as a property of the options
     *     object and sent to the constructor when the layer is created.
     */
    options: null,

    /**
     * APIProperty: eventListeners
     * {Object} If set as an option at construction, the eventListeners
     *     object will be registered with <HGIS.Events.on>.  Object
     *     structure must be a listeners object as shown in the example for
     *     the events.on method.
     */
    eventListeners: null,

    /**
     * APIProperty: gutter
     * {Integer} Determines the width (in pixels) of the gutter around image
     *     tiles to ignore.  By setting this property to a non-zero value,
     *     images will be requested that are wider and taller than the tile
     *     size by a value of 2 x gutter.  This allows artifacts of rendering
     *     at tile edges to be ignored.  Set a gutter value that is equal to
     *     half the size of the widest symbol that needs to be displayed.
     *     Defaults to zero.  Non-tiled layers always have zero gutter.
     */ 
    gutter: 0, 

    /**
     * APIProperty: projection
     * {<HGIS.Projection>} or {<String>} Specifies the projection of the layer.
     *     Can be set in the layer options. If not specified in the layer options,
     *     it is set to the default projection specified in the map,
     *     when the layer is added to the map.
     *     Projection along with default maxExtent and resolutions
     *     are set automatically with commercial baselayers in EPSG:3857,
     *     such as Google, Bing and OpenStreetMap, and do not need to be specified.
     *     Otherwise, if specifying projection, also set maxExtent,
     *     maxResolution or resolutions as appropriate.
     *     When using vector layers with strategies, layer projection should be set
     *     to the projection of the source data if that is different from the map default.
     * 
     *     Can be either a string or an <HGIS.Projection> object;
     *     if a string is passed, will be converted to an object when
     *     the layer is added to the map.
     * 
     */
    projection: null,    
    
    /**
     * APIProperty: units
     * {String} The layer map units.  Defaults to null.  Possible values
     *     are 'degrees' (or 'dd'), 'm', 'ft', 'km', 'mi', 'inches'.
     *     Normally taken from the projection.
     *     Only required if both map and layers do not define a projection,
     *     or if they define a projection which does not define units.
     */
    units: null,

    /**
     * APIProperty: scales
     * {Array}  An array of map scales in descending order.  The values in the
     *     array correspond to the map scale denominator.  Note that these
     *     values only make sense if the display (monitor) resolution of the
     *     client is correctly guessed by whomever is configuring the
     *     application.  In addition, the units property must also be set.
     *     Use <resolutions> instead wherever possible.
     */
    scales: null,

    /**
     * APIProperty: resolutions
     * {Array} A list of map resolutions (map units per pixel) in descending
     *     order.  If this is not set in the layer constructor, it will be set
     *     based on other resolution related properties (maxExtent,
     *     maxResolution, maxScale, etc.).
     */
    resolutions: null,
    
    /**
     * APIProperty: maxExtent
     * {<HGIS.Bounds>|Array} If provided as an array, the array
     *     should consist of four values (left, bottom, right, top).
     *     The maximum extent for the layer.  Defaults to null.
     * 
     *     The center of these bounds will not stray outside
     *     of the viewport extent during panning.  In addition, if
     *     <displayOutsideMaxExtent> is set to false, data will not be
     *     requested that falls completely outside of these bounds.
     */
    maxExtent: null,
    
    /**
     * APIProperty: minExtent
     * {<HGIS.Bounds>|Array} If provided as an array, the array
     *     should consist of four values (left, bottom, right, top).
     *     The minimum extent for the layer.  Defaults to null.
     */
    minExtent: null,
    
    /**
     * APIProperty: maxResolution
     * {Float} Default max is 360 deg / 256 px, which corresponds to
     *     zoom level 0 on gmaps.  Specify a different value in the layer 
     *     options if you are not using the default <HGIS.Map.tileSize>
     *     and displaying the whole world.
     */
    maxResolution: null,

    /**
     * APIProperty: minResolution
     * {Float}
     */
    minResolution: null,

    /**
     * APIProperty: numZoomLevels
     * {Integer}
     */
    numZoomLevels: null,
    
    /**
     * APIProperty: minScale
     * {Float}
     */
    minScale: null,
    
    /**
     * APIProperty: maxScale
     * {Float}
     */
    maxScale: null,

    /**
     * APIProperty: displayOutsideMaxExtent
     * {Boolean} Request map tiles that are completely outside of the max 
     *     extent for this layer. Defaults to false.
     */
    displayOutsideMaxExtent: false,

    /**
     * APIProperty: wrapDateLine
     * {Boolean} Wraps the world at the international dateline, so the map can
     * be panned infinitely in longitudinal direction. Only use this on the
     * base layer, and only if the layer's maxExtent equals the world bounds.
     * #487 for more info.   
     */
    wrapDateLine: false,
    
    /**
     * Property: metadata
     * {Object} This object can be used to store additional information on a
     *     layer object.
     */
    metadata: null,
    
    /**
     * Constructor: HGIS.Layer
     *
     * Parameters:
     * name - {String} The layer name
     * options - {Object} Hashtable of extra options to tag onto the layer
     */
    initialize: function(name, options) {

        this.metadata = {};
        
        options = HGIS.Util.extend({}, options);
        // make sure we respect alwaysInRange if set on the prototype
        if (this.alwaysInRange != null) {
            options.alwaysInRange = this.alwaysInRange;
        }
        this.addOptions(options);

        this.name = name;
        
        if (this.id == null) {

            this.id = HGIS.Util.createUniqueID(this.CLASS_NAME + "_");

            this.div = HGIS.Util.createDiv(this.id);
            this.div.style.width = "100%";
            this.div.style.height = "100%";
            this.div.dir = "ltr";

            this.events = new HGIS.Events(this, this.div);
            if(this.eventListeners instanceof Object) {
                this.events.on(this.eventListeners);
            }

        }
    },
    
    /**
     * Method: destroy
     * Destroy is a destructor: this is to alleviate cyclic references which
     *     the Javascript garbage cleaner can not take care of on its own.
     *
     * Parameters:
     * setNewBaseLayer - {Boolean} Set a new base layer when this layer has
     *     been destroyed.  Default is true.
     */
    destroy: function(setNewBaseLayer) {
        if (setNewBaseLayer == null) {
            setNewBaseLayer = true;
        }
        if (this.map != null) {
            this.map.removeLayer(this, setNewBaseLayer);
        }
        this.projection = null;
        this.map = null;
        this.name = null;
        this.div = null;
        this.options = null;

        if (this.events) {
            if(this.eventListeners) {
                this.events.un(this.eventListeners);
            }
            this.events.destroy();
        }
        this.eventListeners = null;
        this.events = null;
    },
    
   /**
    * Method: clone
    *
    * Parameters:
    * obj - {<HGIS.Layer>} The layer to be cloned
    *
    * Returns:
    * {<HGIS.Layer>} An exact clone of this <HGIS.Layer>
    */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new HGIS.Layer(this.name, this.getOptions());
        }
        
        // catch any randomly tagged-on properties
        HGIS.Util.applyDefaults(obj, this);
        
        // a cloned layer should never have its map property set
        //  because it has not been added to a map yet. 
        obj.map = null;
        
        return obj;
    },
    
    /**
     * Method: getOptions
     * Extracts an object from the layer with the properties that were set as
     *     options, but updates them with the values currently set on the
     *     instance.
     * 
     * Returns:
     * {Object} the <options> of the layer, representing the current state.
     */
    getOptions: function() {
        var options = {};
        for(var o in this.options) {
            options[o] = this[o];
        }
        return options;
    },
    
    /** 
     * APIMethod: setName
     * Sets the new layer name for this layer.  Can trigger a changelayer event
     *     on the map.
     *
     * Parameters:
     * newName - {String} The new name.
     */
    setName: function(newName) {
        if (newName != this.name) {
            this.name = newName;
            if (this.map != null) {
                this.map.events.triggerEvent("changelayer", {
                    layer: this,
                    property: "name"
                });
            }
        }
    },    
    
   /**
    * APIMethod: addOptions
    * 
    * Parameters:
    * newOptions - {Object}
    * reinitialize - {Boolean} If set to true, and if resolution options of the
    *     current baseLayer were changed, the map will be recentered to make
    *     sure that it is displayed with a valid resolution, and a
    *     changebaselayer event will be triggered.
    */
    addOptions: function (newOptions, reinitialize) {

        if (this.options == null) {
            this.options = {};
        }
        
        if (newOptions) {
            // make sure this.projection references a projection object
            if(typeof newOptions.projection == "string") {
                newOptions.projection = new HGIS.Projection(newOptions.projection);
            }
            if (newOptions.projection) {
                // get maxResolution, units and maxExtent from projection defaults if
                // they are not defined already
                HGIS.Util.applyDefaults(newOptions,
                    HGIS.Projection.defaults[newOptions.projection.getCode()]);
            }
            // allow array for extents
            if (newOptions.maxExtent && !(newOptions.maxExtent instanceof HGIS.Bounds)) {
                newOptions.maxExtent = new HGIS.Bounds(newOptions.maxExtent);
            }
            if (newOptions.minExtent && !(newOptions.minExtent instanceof HGIS.Bounds)) {
                newOptions.minExtent = new HGIS.Bounds(newOptions.minExtent);
            }
        }

        // update our copy for clone
        HGIS.Util.extend(this.options, newOptions);

        // add new options to this
        HGIS.Util.extend(this, newOptions);
        
        // get the units from the projection, if we have a projection
        // and it it has units
        if(this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits();
        }

        // re-initialize resolutions if necessary, i.e. if any of the
        // properties of the "properties" array defined below is set
        // in the new options
        if(this.map) {
            // store current resolution so we can try to restore it later
            var resolution = this.map.getResolution();
            var properties = this.RESOLUTION_PROPERTIES.concat(
                ["projection", "units", "minExtent", "maxExtent"]
            );
            for(var o in newOptions) {
                if(newOptions.hasOwnProperty(o) &&
                   HGIS.Util.indexOf(properties, o) >= 0) {

                    this.initResolutions();
                    if (reinitialize && this.map.baseLayer === this) {
                        // update map position, and restore previous resolution
                        this.map.setCenter(this.map.getCenter(),
                            this.map.getZoomForResolution(resolution),
                            false, true
                        );
                        // trigger a changebaselayer event to make sure that
                        // all controls (especially
                        // HGIS.Control.PanZoomBar) get notified of the
                        // new options
                        this.map.events.triggerEvent("changebaselayer", {
                            layer: this
                        });
                    }
                    break;
                }
            }
        }
    },

    /**
     * APIMethod: onMapResize
     * This function can be implemented by subclasses
     */
    onMapResize: function() {
        //this function can be implemented by subclasses  
    },

    /**
     * APIMethod: redraw
     * Redraws the layer.  Returns true if the layer was redrawn, false if not.
     *
     * Returns:
     * {Boolean} The layer was redrawn.
     */
    redraw: function() {
        var redrawn = false;
        if (this.map) {

            // min/max Range may have changed
            this.inRange = this.calculateInRange();

            // map's center might not yet be set
            var extent = this.getExtent();

            if (extent && this.inRange && this.visibility) {
                var zoomChanged = true;
                this.moveTo(extent, zoomChanged, false);
                this.events.triggerEvent("moveend",
                    {"zoomChanged": zoomChanged});
                redrawn = true;
            }
        }
        return redrawn;
    },

    /**
     * Method: moveTo
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     * zoomChanged - {Boolean} Tells when zoom has changed, as layers have to
     *     do some init work in that case.
     * dragging - {Boolean}
     */
    moveTo:function(bounds, zoomChanged, dragging) {
        var display = this.visibility;
        if (!this.isBaseLayer) {
            display = display && this.inRange;
        }
        this.display(display);
    },

    /**
     * Method: moveByPx
     * Move the layer based on pixel vector. To be implemented by subclasses.
     *
     * Parameters:
     * dx - {Number} The x coord of the displacement vector.
     * dy - {Number} The y coord of the displacement vector.
     */
    moveByPx: function(dx, dy) {
    },

    /**
     * Method: setMap
     * Set the map property for the layer. This is done through an accessor
     *     so that subclasses can override this and take special action once 
     *     they have their map variable set. 
     * 
     *     Here we take care to bring over any of the necessary default 
     *     properties from the map. 
     * 
     * Parameters:
     * map - {<HGIS.Map>}
     */
    setMap: function(map) {
        if (this.map == null) {
        
            this.map = map;
            
            // grab some essential layer data from the map if it hasn't already
            //  been set
            this.maxExtent = this.maxExtent || this.map.maxExtent;
            this.minExtent = this.minExtent || this.map.minExtent;

            this.projection = this.projection || this.map.projection;
            if (typeof this.projection == "string") {
                this.projection = new HGIS.Projection(this.projection);
            }

            // Check the projection to see if we can get units -- if not, refer
            // to properties.
            this.units = this.projection.getUnits() ||
                         this.units || this.map.units;
            
            this.initResolutions();
            
            if (!this.isBaseLayer) {
                this.inRange = this.calculateInRange();
                var show = ((this.visibility) && (this.inRange));
                this.div.style.display = show ? "" : "none";
            }
            
            // deal with gutters
            this.setTileSize();
        }
    },
    
    /**
     * Method: afterAdd
     * Called at the end of the map.addLayer sequence.  At this point, the map
     *     will have a base layer.  To be overridden by subclasses.
     */
    afterAdd: function() {
    },
    
    /**
     * APIMethod: removeMap
     * Just as setMap() allows each layer the possibility to take a 
     *     personalized action on being added to the map, removeMap() allows
     *     each layer to take a personalized action on being removed from it. 
     *     For now, this will be mostly unused, except for the EventPane layer,
     *     which needs this hook so that it can remove the special invisible
     *     pane. 
     * 
     * Parameters:
     * map - {<HGIS.Map>}
     */
    removeMap: function(map) {
        //to be overridden by subclasses
    },
    
    /**
     * APIMethod: getImageSize
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>} optional tile bounds, can be used
     *     by subclasses that have to deal with different tile sizes at the
     *     layer extent edges (e.g. Zoomify)
     * 
     * Returns:
     * {<HGIS.Size>} The size that the image should be, taking into 
     *     account gutters.
     */ 
    getImageSize: function(bounds) { 
        return (this.imageSize || this.tileSize); 
    },    
  
    /**
     * APIMethod: setTileSize
     * Set the tile size based on the map size.  This also sets layer.imageSize
     *     or use by Tile.Image.
     * 
     * Parameters:
     * size - {<HGIS.Size>}
     */
    setTileSize: function(size) {
        var tileSize = (size) ? size :
                                ((this.tileSize) ? this.tileSize :
                                                   this.map.getTileSize());
        this.tileSize = tileSize;
        if(this.gutter) {
          // layers with gutters need non-null tile sizes
          //if(tileSize == null) {
          //    HGIS.console.error("Error in layer.setMap() for " +
          //                              this.name + ": layers with " +
          //                              "gutters need non-null tile sizes");
          //}
            this.imageSize = new HGIS.Size(tileSize.w + (2*this.gutter), 
                                                 tileSize.h + (2*this.gutter)); 
        }
    },

    /**
     * APIMethod: getVisibility
     * 
     * Returns:
     * {Boolean} The layer should be displayed (if in range).
     */
    getVisibility: function() {
        return this.visibility;
    },

    /** 
     * APIMethod: setVisibility
     * Set the visibility flag for the layer and hide/show & redraw 
     *     accordingly. Fire event unless otherwise specified
     * 
     * Note that visibility is no longer simply whether or not the layer's
     *     style.display is set to "block". Now we store a 'visibility' state 
     *     property on the layer class, this allows us to remember whether or 
     *     not we *desire* for a layer to be visible. In the case where the 
     *     map's resolution is out of the layer's range, this desire may be 
     *     subverted.
     * 
     * Parameters:
     * visibility - {Boolean} Whether or not to display the layer (if in range)
     */
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
            this.visibility = visibility;
            this.display(visibility);
            this.redraw();
            if (this.map != null) {
                this.map.events.triggerEvent("changelayer", {
                    layer: this,
                    property: "visibility"
                });
            }
            this.events.triggerEvent("visibilitychanged");
        }
    },

    /** 
     * APIMethod: display
     * Hide or show the Layer. This is designed to be used internally, and 
     *     is not generally the way to enable or disable the layer. For that,
     *     use the setVisibility function instead..
     * 
     * Parameters:
     * display - {Boolean}
     */
    display: function(display) {
        if (display != (this.div.style.display != "none")) {
            this.div.style.display = (display && this.calculateInRange()) ? "block" : "none";
        }
    },

    /**
     * APIMethod: calculateInRange
     * 
     * Returns:
     * {Boolean} The layer is displayable at the current map's current
     *     resolution. Note that if 'alwaysInRange' is true for the layer, 
     *     this function will always return true.
     */
    calculateInRange: function() {
        var inRange = false;

        if (this.alwaysInRange) {
            inRange = true;
        } else {
            if (this.map) {
                var resolution = this.map.getResolution();
                inRange = ( (resolution >= this.minResolution) &&
                            (resolution <= this.maxResolution) );
            }
        }
        return inRange;
    },

    /** 
     * APIMethod: setIsBaseLayer
     * 
     * Parameters:
     * isBaseLayer - {Boolean}
     */
    setIsBaseLayer: function(isBaseLayer) {
        if (isBaseLayer != this.isBaseLayer) {
            this.isBaseLayer = isBaseLayer;
            if (this.map != null) {
                this.map.events.triggerEvent("changebaselayer", {
                    layer: this
                });
            }
        }
    },

  /********************************************************/
  /*                                                      */
  /*                 Baselayer Functions                  */
  /*                                                      */
  /********************************************************/
  
    /** 
     * Method: initResolutions
     * This method's responsibility is to set up the 'resolutions' array 
     *     for the layer -- this array is what the layer will use to interface
     *     between the zoom levels of the map and the resolution display 
     *     of the layer.
     * 
     * The user has several options that determine how the array is set up.
     *  
     * For a detailed explanation, see the following wiki from the 
     *     HGIS.org homepage:
     *     http://trac.HGIS.org/wiki/SettingZoomLevels
     */
    initResolutions: function() {

        // ok we want resolutions, here's our strategy:
        //
        // 1. if resolutions are defined in the layer config, use them
        // 2. else, if scales are defined in the layer config then derive
        //    resolutions from these scales
        // 3. else, attempt to calculate resolutions from maxResolution,
        //    minResolution, numZoomLevels, maxZoomLevel set in the
        //    layer config
        // 4. if we still don't have resolutions, and if resolutions
        //    are defined in the same, use them
        // 5. else, if scales are defined in the map then derive
        //    resolutions from these scales
        // 6. else, attempt to calculate resolutions from maxResolution,
        //    minResolution, numZoomLevels, maxZoomLevel set in the
        //    map
        // 7. hope for the best!

        var i, len, p;
        var props = {}, alwaysInRange = true;

        // get resolution data from layer config
        // (we also set alwaysInRange in the layer as appropriate)
        for(i=0, len=this.RESOLUTION_PROPERTIES.length; i<len; i++) {
            p = this.RESOLUTION_PROPERTIES[i];
            props[p] = this.options[p];
            if(alwaysInRange && this.options[p]) {
                alwaysInRange = false;
            }
        }
        if(this.options.alwaysInRange == null) {
            this.alwaysInRange = alwaysInRange;
        }

        // if we don't have resolutions then attempt to derive them from scales
        if(props.resolutions == null) {
            props.resolutions = this.resolutionsFromScales(props.scales);
        }

        // if we still don't have resolutions then attempt to calculate them
        if(props.resolutions == null) {
            props.resolutions = this.calculateResolutions(props);
        }

        // if we couldn't calculate resolutions then we look at we have
        // in the map
        if(props.resolutions == null) {
            for(i=0, len=this.RESOLUTION_PROPERTIES.length; i<len; i++) {
                p = this.RESOLUTION_PROPERTIES[i];
                props[p] = this.options[p] != null ?
                    this.options[p] : this.map[p];
            }
            if(props.resolutions == null) {
                props.resolutions = this.resolutionsFromScales(props.scales);
            }
            if(props.resolutions == null) {
                props.resolutions = this.calculateResolutions(props);
            }
        }

        // ok, we new need to set properties in the instance

        // get maxResolution from the config if it's defined there
        var maxResolution;
        if(this.options.maxResolution &&
           this.options.maxResolution !== "auto") {
            maxResolution = this.options.maxResolution;
        }
        if(this.options.minScale) {
            maxResolution = HGIS.Util.getResolutionFromScale(
                this.options.minScale, this.units);
        }

        // get minResolution from the config if it's defined there
        var minResolution;
        if(this.options.minResolution &&
           this.options.minResolution !== "auto") {
            minResolution = this.options.minResolution;
        }
        if(this.options.maxScale) {
            minResolution = HGIS.Util.getResolutionFromScale(
                this.options.maxScale, this.units);
        }

        if(props.resolutions) {

            //sort resolutions array descendingly
            props.resolutions.sort(function(a, b) {
                return (b - a);
            });

            // if we still don't have a maxResolution get it from the
            // resolutions array
            if(!maxResolution) {
                maxResolution = props.resolutions[0];
            }

            // if we still don't have a minResolution get it from the
            // resolutions array
            if(!minResolution) {
                var lastIdx = props.resolutions.length - 1;
                minResolution = props.resolutions[lastIdx];
            }
        }

        this.resolutions = props.resolutions;
        if(this.resolutions) {
            len = this.resolutions.length;
            this.scales = new Array(len);
            for(i=0; i<len; i++) {
                this.scales[i] = HGIS.Util.getScaleFromResolution(
                    this.resolutions[i], this.units);
            }
            this.numZoomLevels = len;
        }
        this.minResolution = minResolution;
        if(minResolution) {
            this.maxScale = HGIS.Util.getScaleFromResolution(
                minResolution, this.units);
        }
        this.maxResolution = maxResolution;
        if(maxResolution) {
            this.minScale = HGIS.Util.getScaleFromResolution(
                maxResolution, this.units);
        }
    },

    /**
     * Method: resolutionsFromScales
     * Derive resolutions from scales.
     *
     * Parameters:
     * scales - {Array(Number)} Scales
     *
     * Returns
     * {Array(Number)} Resolutions
     */
    resolutionsFromScales: function(scales) {
        if(scales == null) {
            return;
        }
        var resolutions, i, len;
        len = scales.length;
        resolutions = new Array(len);
        for(i=0; i<len; i++) {
            resolutions[i] = HGIS.Util.getResolutionFromScale(
                scales[i], this.units);
        }
        return resolutions;
    },

    /**
     * Method: calculateResolutions
     * Calculate resolutions based on the provided properties.
     *
     * Parameters:
     * props - {Object} Properties
     *
     * Returns:
     * {Array({Number})} Array of resolutions.
     */
    calculateResolutions: function(props) {

        var viewSize, wRes, hRes;

        // determine maxResolution
        var maxResolution = props.maxResolution;
        if(props.minScale != null) {
            maxResolution =
                HGIS.Util.getResolutionFromScale(props.minScale,
                                                       this.units);
        } else if(maxResolution == "auto" && this.maxExtent != null) {
            viewSize = this.map.getSize();
            wRes = this.maxExtent.getWidth() / viewSize.w;
            hRes = this.maxExtent.getHeight() / viewSize.h;
            maxResolution = Math.max(wRes, hRes);
        }

        // determine minResolution
        var minResolution = props.minResolution;
        if(props.maxScale != null) {
            minResolution =
                HGIS.Util.getResolutionFromScale(props.maxScale,
                                                       this.units);
        } else if(props.minResolution == "auto" && this.minExtent != null) {
            viewSize = this.map.getSize();
            wRes = this.minExtent.getWidth() / viewSize.w;
            hRes = this.minExtent.getHeight()/ viewSize.h;
            minResolution = Math.max(wRes, hRes);
        }

        if(typeof maxResolution !== "number" &&
           typeof minResolution !== "number" &&
           this.maxExtent != null) {
            // maxResolution for default grid sets assumes that at zoom
            // level zero, the whole world fits on one tile.
            var tileSize = this.map.getTileSize();
            maxResolution = Math.max(
                this.maxExtent.getWidth() / tileSize.w,
                this.maxExtent.getHeight() / tileSize.h
            );
        }

        // determine numZoomLevels
        var maxZoomLevel = props.maxZoomLevel;
        var numZoomLevels = props.numZoomLevels;
        if(typeof minResolution === "number" &&
           typeof maxResolution === "number" && numZoomLevels === undefined) {
            var ratio = maxResolution / minResolution;
            numZoomLevels = Math.floor(Math.log(ratio) / Math.log(2)) + 1;
        } else if(numZoomLevels === undefined && maxZoomLevel != null) {
            numZoomLevels = maxZoomLevel + 1;
        }

        // are we able to calculate resolutions?
        if(typeof numZoomLevels !== "number" || numZoomLevels <= 0 ||
           (typeof maxResolution !== "number" &&
                typeof minResolution !== "number")) {
            return;
        }

        // now we have numZoomLevels and at least one of maxResolution
        // or minResolution, we can populate the resolutions array

        var resolutions = new Array(numZoomLevels);
        var base = 2;
        if(typeof minResolution == "number" &&
           typeof maxResolution == "number") {
            // if maxResolution and minResolution are set, we calculate
            // the base for exponential scaling that starts at
            // maxResolution and ends at minResolution in numZoomLevels
            // steps.
            base = Math.pow(
                    (maxResolution / minResolution),
                (1 / (numZoomLevels - 1))
            );
        }

        var i;
        if(typeof maxResolution === "number") {
            for(i=0; i<numZoomLevels; i++) {
                resolutions[i] = maxResolution / Math.pow(base, i);
            }
        } else {
            for(i=0; i<numZoomLevels; i++) {
                resolutions[numZoomLevels - 1 - i] =
                    minResolution * Math.pow(base, i);
            }
        }

        return resolutions;
    },

    /**
     * APIMethod: getResolution
     * 
     * Returns:
     * {Float} The currently selected resolution of the map, taken from the
     *     resolutions array, indexed by current zoom level.
     */
    getResolution: function() {
        var zoom = this.map.getZoom();
        return this.getResolutionForZoom(zoom);
    },

    /** 
     * APIMethod: getExtent
     * 
     * Returns:
     * {<HGIS.Bounds>} A Bounds object which represents the lon/lat 
     *     bounds of the current viewPort.
     */
    getExtent: function() {
        // just use stock map calculateBounds function -- passing no arguments
        //  means it will user map's current center & resolution
        //
        return this.map.calculateBounds();
    },

    /**
     * APIMethod: getZoomForExtent
     * 
     * Parameters:
     * extent - {<HGIS.Bounds>}
     * closest - {Boolean} Find the zoom level that most closely fits the 
     *     specified bounds. Note that this may result in a zoom that does 
     *     not exactly contain the entire extent.
     *     Default is false.
     *
     * Returns:
     * {Integer} The index of the zoomLevel (entry in the resolutions array) 
     *     for the passed-in extent. We do this by calculating the ideal 
     *     resolution for the given extent (based on the map size) and then 
     *     calling getZoomForResolution(), passing along the 'closest'
     *     parameter.
     */
    getZoomForExtent: function(extent, closest) {
        var viewSize = this.map.getSize();
        var idealResolution = Math.max( extent.getWidth()  / viewSize.w,
                                        extent.getHeight() / viewSize.h );

        return this.getZoomForResolution(idealResolution, closest);
    },
    
    /** 
     * Method: getDataExtent
     * Calculates the max extent which includes all of the data for the layer.
     *     This function is to be implemented by subclasses.
     * 
     * Returns:
     * {<HGIS.Bounds>}
     */
    getDataExtent: function () {
        //to be implemented by subclasses
    },

    /**
     * APIMethod: getResolutionForZoom
     * 
     * Parameters:
     * zoom - {Float}
     * 
     * Returns:
     * {Float} A suitable resolution for the specified zoom.
     */
    getResolutionForZoom: function(zoom) {
        zoom = Math.max(0, Math.min(zoom, this.resolutions.length - 1));
        var resolution;
        if(this.map.fractionalZoom) {
            var low = Math.floor(zoom);
            var high = Math.ceil(zoom);
            resolution = this.resolutions[low] -
                ((zoom-low) * (this.resolutions[low]-this.resolutions[high]));
        } else {
            resolution = this.resolutions[Math.round(zoom)];
        }
        return resolution;
    },

    /**
     * APIMethod: getZoomForResolution
     * 
     * Parameters:
     * resolution - {Float}
     * closest - {Boolean} Find the zoom level that corresponds to the absolute 
     *     closest resolution, which may result in a zoom whose corresponding
     *     resolution is actually smaller than we would have desired (if this
     *     is being called from a getZoomForExtent() call, then this means that
     *     the returned zoom index might not actually contain the entire 
     *     extent specified... but it'll be close).
     *     Default is false.
     * 
     * Returns:
     * {Integer} The index of the zoomLevel (entry in the resolutions array) 
     *     that corresponds to the best fit resolution given the passed in 
     *     value and the 'closest' specification.
     */
    getZoomForResolution: function(resolution, closest) {
        var zoom, i, len;
        if(this.map.fractionalZoom) {
            var lowZoom = 0;
            var highZoom = this.resolutions.length - 1;
            var highRes = this.resolutions[lowZoom];
            var lowRes = this.resolutions[highZoom];
            var res;
            for(i=0, len=this.resolutions.length; i<len; ++i) {
                res = this.resolutions[i];
                if(res >= resolution) {
                    highRes = res;
                    lowZoom = i;
                }
                if(res <= resolution) {
                    lowRes = res;
                    highZoom = i;
                    break;
                }
            }
            var dRes = highRes - lowRes;
            if(dRes > 0) {
                zoom = lowZoom + ((highRes - resolution) / dRes);
            } else {
                zoom = lowZoom;
            }
        } else {
            var diff;
            var minDiff = Number.POSITIVE_INFINITY;
            for(i=0, len=this.resolutions.length; i<len; i++) {            
                if (closest) {
                    diff = Math.abs(this.resolutions[i] - resolution);
                    if (diff > minDiff) {
                        break;
                    }
                    minDiff = diff;
                } else {
                    if (this.resolutions[i] < resolution) {
                        break;
                    }
                }
            }
            zoom = Math.max(0, i-1);
        }
        return zoom;
    },
    
    /**
     * APIMethod: getLonLatFromViewPortPx
     * 
     * Parameters:
     * viewPortPx - {<HGIS.Pixel>|Object} An HGIS.Pixel or
     *                                          an object with a 'x'
     *                                          and 'y' properties.
     *
     * Returns:
     * {<HGIS.LonLat>} An HGIS.LonLat which is the passed-in 
     *     view port <HGIS.Pixel>, translated into lon/lat by the layer.
     */
    getLonLatFromViewPortPx: function (viewPortPx) {
        var lonlat = null;
        var map = this.map;
        if (viewPortPx != null && map.minPx) {
            var res = map.getResolution();
            var maxExtent = map.getMaxExtent({restricted: true});
            var lon = (viewPortPx.x - map.minPx.x) * res + maxExtent.left;
            var lat = (map.minPx.y - viewPortPx.y) * res + maxExtent.top;
            lonlat = new HGIS.LonLat(lon, lat);

            if (this.wrapDateLine) {
                lonlat = lonlat.wrapDateLine(this.maxExtent);
            }
        }
        return lonlat;
    },

    /**
     * APIMethod: getViewPortPxFromLonLat
     * Returns a pixel location given a map location.  This method will return
     *     fractional pixel values.
     * 
     * Parameters:
     * lonlat - {<HGIS.LonLat>|Object} An HGIS.LonLat or
     *                                       an object with a 'lon'
     *                                       and 'lat' properties.
     *
     * Returns: 
     * {<HGIS.Pixel>} An <HGIS.Pixel> which is the passed-in 
     *     lonlat translated into view port pixels.
     */
    getViewPortPxFromLonLat: function (lonlat, resolution) {
        var px = null; 
        if (lonlat != null) {
            resolution = resolution || this.map.getResolution();
            var extent = this.map.calculateBounds(null, resolution);
            px = new HGIS.Pixel(
                (1/resolution * (lonlat.lon - extent.left)),
                (1/resolution * (extent.top - lonlat.lat))
            );    
        }
        return px;
    },
    
    /**
     * APIMethod: setOpacity
     * Sets the opacity for the entire layer (all images)
     * 
     * Parameters:
     * opacity - {Float}
     */
    setOpacity: function(opacity) {
        if (opacity != this.opacity) {
            this.opacity = opacity;
            var childNodes = this.div.childNodes;
            for(var i = 0, len = childNodes.length; i < len; ++i) {
                var element = childNodes[i].firstChild || childNodes[i];
                var lastChild = childNodes[i].lastChild;
                //TODO de-uglify this
                if (lastChild && lastChild.nodeName.toLowerCase() === "iframe") {
                    element = lastChild.parentNode;
                }
                HGIS.Util.modifyDOMElement(element, null, null, null, 
                                                 null, null, null, opacity);
            }
            if (this.map != null) {
                this.map.events.triggerEvent("changelayer", {
                    layer: this,
                    property: "opacity"
                });
            }
        }
    },

    /**
     * Method: getZIndex
     * 
     * Returns: 
     * {Integer} the z-index of this layer
     */    
    getZIndex: function () {
        return this.div.style.zIndex;
    },

    /**
     * Method: setZIndex
     * 
     * Parameters: 
     * zIndex - {Integer}
     */    
    setZIndex: function (zIndex) {
        this.div.style.zIndex = zIndex;
    },

    /**
     * Method: adjustBounds
     * This function will take a bounds, and if wrapDateLine option is set
     *     on the layer, it will return a bounds which is wrapped around the 
     *     world. We do not wrap for bounds which *cross* the 
     *     maxExtent.left/right, only bounds which are entirely to the left 
     *     or entirely to the right.
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     */
    adjustBounds: function (bounds) {

        if (this.gutter) {
            // Adjust the extent of a bounds in map units by the 
            // layer's gutter in pixels.
            var mapGutter = this.gutter * this.map.getResolution();
            bounds = new HGIS.Bounds(bounds.left - mapGutter,
                                           bounds.bottom - mapGutter,
                                           bounds.right + mapGutter,
                                           bounds.top + mapGutter);
        }

        if (this.wrapDateLine) {
            // wrap around the date line, within the limits of rounding error
            var wrappingOptions = { 
                'rightTolerance':this.getResolution(),
                'leftTolerance':this.getResolution()
            };    
            bounds = bounds.wrapDateLine(this.maxExtent, wrappingOptions);
                              
        }
        return bounds;
    },

    CLASS_NAME: "HGIS.Layer"
});
/* ======================================================================
    HGIS/Layer/SphericalMercator.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer.js
 * @requires HGIS/Projection.js
 */

/**
 * Class: HGIS.Layer.SphericalMercator
 * A mixin for layers that wraps up the pieces neccesary to have a coordinate
 *     conversion for working with commercial APIs which use a spherical
 *     mercator projection.  Using this layer as a base layer, additional
 *     layers can be used as overlays if they are in the same projection.
 *
 * A layer is given properties of this object by setting the sphericalMercator
 *     property to true.
 *
 * More projection information:
 *  - http://spatialreference.org/ref/user/google-projection/
 *
 * Proj4 Text:
 *     +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0
 *     +k=1.0 +units=m +nadgrids=@null +no_defs
 *
 * WKT:
 *     900913=PROJCS["WGS84 / Simple Mercator", GEOGCS["WGS 84",
 *     DATUM["WGS_1984", SPHEROID["WGS_1984", 6378137.0, 298.257223563]], 
 *     PRIMEM["Greenwich", 0.0], UNIT["degree", 0.017453292519943295], 
 *     AXIS["Longitude", EAST], AXIS["Latitude", NORTH]],
 *     PROJECTION["Mercator_1SP_Google"], 
 *     PARAMETER["latitude_of_origin", 0.0], PARAMETER["central_meridian", 0.0], 
 *     PARAMETER["scale_factor", 1.0], PARAMETER["false_easting", 0.0], 
 *     PARAMETER["false_northing", 0.0], UNIT["m", 1.0], AXIS["x", EAST],
 *     AXIS["y", NORTH], AUTHORITY["EPSG","900913"]]
 */
HGIS.Layer.SphericalMercator = {

    /**
     * Method: getExtent
     * Get the map's extent.
     *
     * Returns:
     * {<HGIS.Bounds>} The map extent.
     */
    getExtent: function() {
        var extent = null;
        if (this.sphericalMercator) {
            extent = this.map.calculateBounds();
        } else {
            extent = HGIS.Layer.FixedZoomLevels.prototype.getExtent.apply(this);
        }
        return extent;
    },

    /**
     * Method: getLonLatFromViewPortPx
     * Get a map location from a pixel location
     * 
     * Parameters:
     * viewPortPx - {<HGIS.Pixel>}
     *
     * Returns:
     *  {<HGIS.LonLat>} An HGIS.LonLat which is the passed-in view
     *  port HGIS.Pixel, translated into lon/lat by map lib
     *  If the map lib is not loaded or not centered, returns null
     */
    getLonLatFromViewPortPx: function (viewPortPx) {
        return HGIS.Layer.prototype.getLonLatFromViewPortPx.apply(this, arguments);
    },
    
    /**
     * Method: getViewPortPxFromLonLat
     * Get a pixel location from a map location
     *
     * Parameters:
     * lonlat - {<HGIS.LonLat>}
     *
     * Returns:
     * {<HGIS.Pixel>} An HGIS.Pixel which is the passed-in
     * HGIS.LonLat, translated into view port pixels by map lib
     * If map lib is not loaded or not centered, returns null
     */
    getViewPortPxFromLonLat: function (lonlat) {
        return HGIS.Layer.prototype.getViewPortPxFromLonLat.apply(this, arguments);
    },

    /** 
     * Method: initMercatorParameters 
     * Set up the mercator parameters on the layer: resolutions,
     *     projection, units.
     */
    initMercatorParameters: function() {
        // set up properties for Mercator - assume EPSG:900913
        this.RESOLUTIONS = [];
        var maxResolution = 156543.03390625;
        for(var zoom=0; zoom<=this.MAX_ZOOM_LEVEL; ++zoom) {
            this.RESOLUTIONS[zoom] = maxResolution / Math.pow(2, zoom);
        }
        this.units = "m";
        this.projection = this.projection || "EPSG:900913";
    },

    /**
     * APIMethod: forwardMercator
     * Given a lon,lat in EPSG:4326, return a point in Spherical Mercator.
     *
     * Parameters:
     * lon - {float} 
     * lat - {float}
     * 
     * Returns:
     * {<HGIS.LonLat>} The coordinates transformed to Mercator.
     */
    forwardMercator: (function() {
        var gg = new HGIS.Projection("EPSG:4326");
        var sm = new HGIS.Projection("EPSG:900913");
        return function(lon, lat) {
            var point = HGIS.Projection.transform({x: lon, y: lat}, gg, sm);
            return new HGIS.LonLat(point.x, point.y);
        };
    })(),

    /**
     * APIMethod: inverseMercator
     * Given a x,y in Spherical Mercator, return a point in EPSG:4326.
     *
     * Parameters:
     * x - {float} A map x in Spherical Mercator.
     * y - {float} A map y in Spherical Mercator.
     * 
     * Returns:
     * {<HGIS.LonLat>} The coordinates transformed to EPSG:4326.
     */
    inverseMercator: (function() {
        var gg = new HGIS.Projection("EPSG:4326");
        var sm = new HGIS.Projection("EPSG:900913");
        return function(x, y) {
            var point = HGIS.Projection.transform({x: x, y: y}, sm, gg);
            return new HGIS.LonLat(point.x, point.y);
        };
    })()

};
/* ======================================================================
    HGIS/Layer/EventPane.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer.js
 * @requires HGIS/Util.js
 */

/**
 * Class: HGIS.Layer.EventPane
 * Base class for 3rd party layers, providing a DOM element which isolates
 * the 3rd-party layer from mouse events.
 * Only used by Google layers.
 *
 * Automatically instantiated by the Google constructor, and not usually instantiated directly.
 *
 * Create a new event pane layer with the
 * <HGIS.Layer.EventPane> constructor.
 * 
 * Inherits from:
 *  - <HGIS.Layer>
 */
HGIS.Layer.EventPane = HGIS.Class(HGIS.Layer, {
    
    /**
     * APIProperty: smoothDragPan
     * {Boolean} smoothDragPan determines whether non-public/internal API
     *     methods are used for better performance while dragging EventPane 
     *     layers. When not in sphericalMercator mode, the smoother dragging 
     *     doesn't actually move north/south directly with the number of 
     *     pixels moved, resulting in a slight offset when you drag your mouse 
     *     north south with this option on. If this visual disparity bothers 
     *     you, you should turn this option off, or use spherical mercator. 
     *     Default is on.
     */
    smoothDragPan: true,

    /**
     * Property: isBaseLayer
     * {Boolean} EventPaned layers are always base layers, by necessity.
     */ 
    isBaseLayer: true,

    /**
     * APIProperty: isFixed
     * {Boolean} EventPaned layers are fixed by default.
     */ 
    isFixed: true,

    /**
     * Property: pane
     * {DOMElement} A reference to the element that controls the events.
     */
    pane: null,


    /**
     * Property: mapObject
     * {Object} This is the object which will be used to load the 3rd party library
     * in the case of the google layer, this will be of type GMap, 
     * in the case of the ve layer, this will be of type VEMap
     */ 
    mapObject: null,


    /**
     * Constructor: HGIS.Layer.EventPane
     * Create a new event pane layer
     *
     * Parameters:
     * name - {String}
     * options - {Object} Hashtable of extra options to tag onto the layer
     */
    initialize: function(name, options) {
        HGIS.Layer.prototype.initialize.apply(this, arguments);
        if (this.pane == null) {
            this.pane = HGIS.Util.createDiv(this.div.id + "_EventPane");
        }
    },
    
    /**
     * APIMethod: destroy
     * Deconstruct this layer.
     */
    destroy: function() {
        this.mapObject = null;
        this.pane = null;
        HGIS.Layer.prototype.destroy.apply(this, arguments); 
    },

    
    /**
     * Method: setMap
     * Set the map property for the layer. This is done through an accessor
     * so that subclasses can override this and take special action once 
     * they have their map variable set. 
     *
     * Parameters:
     * map - {<HGIS.Map>}
     */
    setMap: function(map) {
        HGIS.Layer.prototype.setMap.apply(this, arguments);
        
        this.pane.style.zIndex = parseInt(this.div.style.zIndex) + 1;
        this.pane.style.display = this.div.style.display;
        this.pane.style.width="100%";
        this.pane.style.height="100%";
        if (HGIS.BROWSER_NAME == "msie") {
            this.pane.style.background = 
                "url(" + HGIS.Util.getImageLocation("blank.gif") + ")";
        }

        if (this.isFixed) {
            this.map.viewPortDiv.appendChild(this.pane);
        } else {
            this.map.layerContainerDiv.appendChild(this.pane);
        }

        // once our layer has been added to the map, we can load it
        this.loadMapObject();
    
        // if map didn't load, display warning
        if (this.mapObject == null) {
            this.loadWarningMessage();
        }
    },

    /**
     * APIMethod: removeMap
     * On being removed from the map, we'll like to remove the invisible 'pane'
     *     div that we added to it on creation. 
     * 
     * Parameters:
     * map - {<HGIS.Map>}
     */
    removeMap: function(map) {
        if (this.pane && this.pane.parentNode) {
            this.pane.parentNode.removeChild(this.pane);
        }
        HGIS.Layer.prototype.removeMap.apply(this, arguments);
    },
  
    /**
     * Method: loadWarningMessage
     * If we can't load the map lib, then display an error message to the 
     *     user and tell them where to go for help.
     * 
     *     This function sets up the layout for the warning message. Each 3rd
     *     party layer must implement its own getWarningHTML() function to 
     *     provide the actual warning message.
     */
    loadWarningMessage:function() {

        this.div.style.backgroundColor = "darkblue";

        var viewSize = this.map.getSize();
        
        var msgW = Math.min(viewSize.w, 300);
        var msgH = Math.min(viewSize.h, 200);
        var size = new HGIS.Size(msgW, msgH);

        var centerPx = new HGIS.Pixel(viewSize.w/2, viewSize.h/2);

        var topLeft = centerPx.add(-size.w/2, -size.h/2);            

        var div = HGIS.Util.createDiv(this.name + "_warning", 
                                            topLeft, 
                                            size,
                                            null,
                                            null,
                                            null,
                                            "auto");

        div.style.padding = "7px";
        div.style.backgroundColor = "yellow";

        div.innerHTML = this.getWarningHTML();
        this.div.appendChild(div);
    },
  
    /** 
     * Method: getWarningHTML
     * To be implemented by subclasses.
     * 
     * Returns:
     * {String} String with information on why layer is broken, how to get
     *          it working.
     */
    getWarningHTML:function() {
        //should be implemented by subclasses
        return "";
    },
  
    /**
     * Method: display
     * Set the display on the pane
     *
     * Parameters:
     * display - {Boolean}
     */
    display: function(display) {
        HGIS.Layer.prototype.display.apply(this, arguments);
        this.pane.style.display = this.div.style.display;
    },
  
    /**
     * Method: setZIndex
     * Set the z-index order for the pane.
     * 
     * Parameters:
     * zIndex - {int}
     */
    setZIndex: function (zIndex) {
        HGIS.Layer.prototype.setZIndex.apply(this, arguments);
        this.pane.style.zIndex = parseInt(this.div.style.zIndex) + 1;
    },
    
    /**
     * Method: moveByPx
     * Move the layer based on pixel vector. To be implemented by subclasses.
     *
     * Parameters:
     * dx - {Number} The x coord of the displacement vector.
     * dy - {Number} The y coord of the displacement vector.
     */
    moveByPx: function(dx, dy) {
        HGIS.Layer.prototype.moveByPx.apply(this, arguments);
        
        if (this.dragPanMapObject) {
            this.dragPanMapObject(dx, -dy);
        } else {
            this.moveTo(this.map.getCachedCenter());
        }
    },

    /**
     * Method: moveTo
     * Handle calls to move the layer.
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     * zoomChanged - {Boolean}
     * dragging - {Boolean}
     */
    moveTo:function(bounds, zoomChanged, dragging) {
        HGIS.Layer.prototype.moveTo.apply(this, arguments);

        if (this.mapObject != null) {

            var newCenter = this.map.getCenter();
            var newZoom = this.map.getZoom();

            if (newCenter != null) {

                var moOldCenter = this.getMapObjectCenter();
                var oldCenter = this.getOLLonLatFromMapObjectLonLat(moOldCenter);

                var moOldZoom = this.getMapObjectZoom();
                var oldZoom= this.getOLZoomFromMapObjectZoom(moOldZoom);

                if (!(newCenter.equals(oldCenter)) || newZoom != oldZoom) {

                    if (!zoomChanged && oldCenter && this.dragPanMapObject && 
                        this.smoothDragPan) {
                        var oldPx = this.map.getViewPortPxFromLonLat(oldCenter);
                        var newPx = this.map.getViewPortPxFromLonLat(newCenter);
                        this.dragPanMapObject(newPx.x-oldPx.x, oldPx.y-newPx.y);
                    } else {
                        var center = this.getMapObjectLonLatFromOLLonLat(newCenter);
                        var zoom = this.getMapObjectZoomFromOLZoom(newZoom);
                        this.setMapObjectCenter(center, zoom, dragging);
                    }
                }
            }
        }
    },


  /********************************************************/
  /*                                                      */
  /*                 Baselayer Functions                  */
  /*                                                      */
  /********************************************************/

    /**
     * Method: getLonLatFromViewPortPx
     * Get a map location from a pixel location
     * 
     * Parameters:
     * viewPortPx - {<HGIS.Pixel>}
     *
     * Returns:
     *  {<HGIS.LonLat>} An HGIS.LonLat which is the passed-in view
     *  port HGIS.Pixel, translated into lon/lat by map lib
     *  If the map lib is not loaded or not centered, returns null
     */
    getLonLatFromViewPortPx: function (viewPortPx) {
        var lonlat = null;
        if ( (this.mapObject != null) && 
             (this.getMapObjectCenter() != null) ) {
            var moPixel = this.getMapObjectPixelFromOLPixel(viewPortPx);
            var moLonLat = this.getMapObjectLonLatFromMapObjectPixel(moPixel);
            lonlat = this.getOLLonLatFromMapObjectLonLat(moLonLat);
        }
        return lonlat;
    },

 
    /**
     * Method: getViewPortPxFromLonLat
     * Get a pixel location from a map location
     *
     * Parameters:
     * lonlat - {<HGIS.LonLat>}
     *
     * Returns:
     * {<HGIS.Pixel>} An HGIS.Pixel which is the passed-in
     * HGIS.LonLat, translated into view port pixels by map lib
     * If map lib is not loaded or not centered, returns null
     */
    getViewPortPxFromLonLat: function (lonlat) {
        var viewPortPx = null;
        if ( (this.mapObject != null) && 
             (this.getMapObjectCenter() != null) ) {

            var moLonLat = this.getMapObjectLonLatFromOLLonLat(lonlat);
            var moPixel = this.getMapObjectPixelFromMapObjectLonLat(moLonLat);
        
            viewPortPx = this.getOLPixelFromMapObjectPixel(moPixel);
        }
        return viewPortPx;
    },

  /********************************************************/
  /*                                                      */
  /*               Translation Functions                  */
  /*                                                      */
  /*   The following functions translate Map Object and   */
  /*            OL formats for Pixel, LonLat              */
  /*                                                      */
  /********************************************************/

  //
  // TRANSLATION: MapObject LatLng <-> HGIS.LonLat
  //

    /**
     * Method: getOLLonLatFromMapObjectLonLat
     * Get an OL style map location from a 3rd party style map location
     *
     * Parameters
     * moLonLat - {Object}
     * 
     * Returns:
     * {<HGIS.LonLat>} An HGIS.LonLat, translated from the passed in 
     *          MapObject LonLat
     *          Returns null if null value is passed in
     */
    getOLLonLatFromMapObjectLonLat: function(moLonLat) {
        var olLonLat = null;
        if (moLonLat != null) {
            var lon = this.getLongitudeFromMapObjectLonLat(moLonLat);
            var lat = this.getLatitudeFromMapObjectLonLat(moLonLat);
            olLonLat = new HGIS.LonLat(lon, lat);
        }
        return olLonLat;
    },

    /**
     * Method: getMapObjectLonLatFromOLLonLat
     * Get a 3rd party map location from an OL map location.
     *
     * Parameters:
     * olLonLat - {<HGIS.LonLat>}
     * 
     * Returns:
     * {Object} A MapObject LonLat, translated from the passed in 
     *          HGIS.LonLat
     *          Returns null if null value is passed in
     */
    getMapObjectLonLatFromOLLonLat: function(olLonLat) {
        var moLatLng = null;
        if (olLonLat != null) {
            moLatLng = this.getMapObjectLonLatFromLonLat(olLonLat.lon,
                                                         olLonLat.lat);
        }
        return moLatLng;
    },


  //
  // TRANSLATION: MapObject Pixel <-> HGIS.Pixel
  //

    /**
     * Method: getOLPixelFromMapObjectPixel
     * Get an OL pixel location from a 3rd party pixel location.
     *
     * Parameters:
     * moPixel - {Object}
     * 
     * Returns:
     * {<HGIS.Pixel>} An HGIS.Pixel, translated from the passed in 
     *          MapObject Pixel
     *          Returns null if null value is passed in
     */
    getOLPixelFromMapObjectPixel: function(moPixel) {
        var olPixel = null;
        if (moPixel != null) {
            var x = this.getXFromMapObjectPixel(moPixel);
            var y = this.getYFromMapObjectPixel(moPixel);
            olPixel = new HGIS.Pixel(x, y);
        }
        return olPixel;
    },

    /**
     * Method: getMapObjectPixelFromOLPixel
     * Get a 3rd party pixel location from an OL pixel location
     *
     * Parameters:
     * olPixel - {<HGIS.Pixel>}
     * 
     * Returns:
     * {Object} A MapObject Pixel, translated from the passed in 
     *          HGIS.Pixel
     *          Returns null if null value is passed in
     */
    getMapObjectPixelFromOLPixel: function(olPixel) {
        var moPixel = null;
        if (olPixel != null) {
            moPixel = this.getMapObjectPixelFromXY(olPixel.x, olPixel.y);
        }
        return moPixel;
    },

    CLASS_NAME: "HGIS.Layer.EventPane"
});
/* ======================================================================
    HGIS/Layer/FixedZoomLevels.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer.js
 */

/**
 * Class: HGIS.Layer.FixedZoomLevels
 *   Some Layers will already have established zoom levels (like google 
 *    or ve). Instead of trying to determine them and populate a resolutions[]
 *    Array with those values, we will hijack the resolution functionality
 *    here.
 * 
 *   When you subclass FixedZoomLevels: 
 * 
 *   The initResolutions() call gets nullified, meaning no resolutions[] array 
 *    is set up. Which would be a big problem getResolution() in Layer, since 
 *    it merely takes map.zoom and indexes into resolutions[]... but....
 * 
 *   The getResolution() call is also overridden. Instead of using the 
 *    resolutions[] array, we simply calculate the current resolution based
 *    on the current extent and the current map size. But how will we be able
 *    to calculate the current extent without knowing the resolution...?
 *  
 *   The getExtent() function is also overridden. Instead of calculating extent
 *    based on the center point and the current resolution, we instead 
 *    calculate the extent by getting the lonlats at the top-left and 
 *    bottom-right by using the getLonLatFromViewPortPx() translation function,
 *    taken from the pixel locations (0,0) and the size of the map. But how 
 *    will we be able to do lonlat-px translation without resolution....?
 * 
 *   The getZoomForResolution() method is overridden. Instead of indexing into
 *    the resolutions[] array, we call HGIS.Layer.getExent(), passing in
 *    the desired resolution. With this extent, we then call getZoomForExtent() 
 * 
 * 
 *   Whenever you implement a layer using HGIS.Layer.FixedZoomLevels, 
 *    it is your responsibility to provide the following three functions:
 * 
 *   - getLonLatFromViewPortPx
 *   - getViewPortPxFromLonLat
 *   - getZoomForExtent
 * 
 *  ...those three functions should generally be provided by any reasonable 
 *  API that you might be working from.
 *
 */
HGIS.Layer.FixedZoomLevels = HGIS.Class({
      
  /********************************************************/
  /*                                                      */
  /*                 Baselayer Functions                  */
  /*                                                      */
  /*    The following functions must all be implemented   */
  /*                  by all base layers                  */
  /*                                                      */
  /********************************************************/
    
    /**
     * Constructor: HGIS.Layer.FixedZoomLevels
     * Create a new fixed zoom levels layer.
     */
    initialize: function() {
        //this class is only just to add the following functions... 
        // nothing to actually do here... but it is probably a good
        // idea to have layers that use these functions call this 
        // inititalize() anyways, in case at some point we decide we 
        // do want to put some functionality or state in here. 
    },
    
    /**
     * Method: initResolutions
     * Populate the resolutions array
     */
    initResolutions: function() {

        var props = ['minZoomLevel', 'maxZoomLevel', 'numZoomLevels'];
          
        for(var i=0, len=props.length; i<len; i++) {
            var property = props[i];
            this[property] = (this.options[property] != null)  
                                     ? this.options[property] 
                                     : this.map[property];
        }

        if ( (this.minZoomLevel == null) ||
             (this.minZoomLevel < this.MIN_ZOOM_LEVEL) ){
            this.minZoomLevel = this.MIN_ZOOM_LEVEL;
        }        

        //
        // At this point, we know what the minimum desired zoom level is, and
        //  we must calculate the total number of zoom levels. 
        //  
        //  Because we allow for the setting of either the 'numZoomLevels'
        //   or the 'maxZoomLevel' properties... on either the layer or the  
        //   map, we have to define some rules to see which we take into
        //   account first in this calculation. 
        //
        // The following is the precedence list for these properties:
        // 
        // (1) numZoomLevels set on layer
        // (2) maxZoomLevel set on layer
        // (3) numZoomLevels set on map
        // (4) maxZoomLevel set on map*
        // (5) none of the above*
        //
        // *Note that options (4) and (5) are only possible if the user 
        //  _explicitly_ sets the 'numZoomLevels' property on the map to 
        //  null, since it is set by default to 16. 
        //

        //
        // Note to future: In 3.0, I think we should remove the default 
        // value of 16 for map.numZoomLevels. Rather, I think that value 
        // should be set as a default on the Layer.WMS class. If someone
        // creates a 3rd party layer and does not specify any 'minZoomLevel', 
        // 'maxZoomLevel', or 'numZoomLevels', and has not explicitly 
        // specified any of those on the map object either.. then I think
        // it is fair to say that s/he wants all the zoom levels available.
        // 
        // By making map.numZoomLevels *null* by default, that will be the 
        // case. As it is, I don't feel comfortable changing that right now
        // as it would be a glaring API change and actually would probably
        // break many peoples' codes. 
        //

        //the number of zoom levels we'd like to have.
        var desiredZoomLevels;

        //this is the maximum number of zoom levels the layer will allow, 
        // given the specified starting minimum zoom level.
        var limitZoomLevels = this.MAX_ZOOM_LEVEL - this.minZoomLevel + 1;

        if ( ((this.options.numZoomLevels == null) && 
              (this.options.maxZoomLevel != null)) // (2)
              ||
             ((this.numZoomLevels == null) &&
              (this.maxZoomLevel != null)) // (4)
           ) {
            //calculate based on specified maxZoomLevel (on layer or map)
            desiredZoomLevels = this.maxZoomLevel - this.minZoomLevel + 1;
        } else {
            //calculate based on specified numZoomLevels (on layer or map)
            // this covers cases (1) and (3)
            desiredZoomLevels = this.numZoomLevels;
        }

        if (desiredZoomLevels != null) {
            //Now that we know what we would *like* the number of zoom levels
            // to be, based on layer or map options, we have to make sure that
            // it does not conflict with the actual limit, as specified by 
            // the constants on the layer itself (and calculated into the
            // 'limitZoomLevels' variable). 
            this.numZoomLevels = Math.min(desiredZoomLevels, limitZoomLevels);
        } else {
            // case (5) -- neither 'numZoomLevels' not 'maxZoomLevel' was 
            // set on either the layer or the map. So we just use the 
            // maximum limit as calculated by the layer's constants.
            this.numZoomLevels = limitZoomLevels;
        }

        //now that the 'numZoomLevels' is appropriately, safely set, 
        // we go back and re-calculate the 'maxZoomLevel'.
        this.maxZoomLevel = this.minZoomLevel + this.numZoomLevels - 1;

        if (this.RESOLUTIONS != null) {
            var resolutionsIndex = 0;
            this.resolutions = [];
            for(var i= this.minZoomLevel; i <= this.maxZoomLevel; i++) {
                this.resolutions[resolutionsIndex++] = this.RESOLUTIONS[i];            
            }
            this.maxResolution = this.resolutions[0];
            this.minResolution = this.resolutions[this.resolutions.length - 1];
        }       
    },
    
    /**
     * APIMethod: getResolution
     * Get the current map resolution
     * 
     * Returns:
     * {Float} Map units per Pixel
     */
    getResolution: function() {

        if (this.resolutions != null) {
            return HGIS.Layer.prototype.getResolution.apply(this, arguments);
        } else {
            var resolution = null;
            
            var viewSize = this.map.getSize();
            var extent = this.getExtent();
            
            if ((viewSize != null) && (extent != null)) {
                resolution = Math.max( extent.getWidth()  / viewSize.w,
                                       extent.getHeight() / viewSize.h );
            }
            return resolution;
        }
     },

    /**
     * APIMethod: getExtent
     * Calculates using px-> lonlat translation functions on tl and br 
     *     corners of viewport
     * 
     * Returns:
     * {<HGIS.Bounds>} A Bounds object which represents the lon/lat 
     *                       bounds of the current viewPort.
     */
    getExtent: function () {
        var size = this.map.getSize();
        var tl = this.getLonLatFromViewPortPx({
            x: 0, y: 0
        });
        var br = this.getLonLatFromViewPortPx({
            x: size.w, y: size.h
        });
        
        if ((tl != null) && (br != null)) {
            return new HGIS.Bounds(tl.lon, br.lat, br.lon, tl.lat);
        } else {
            return null;
        }
    },

    /**
     * Method: getZoomForResolution
     * Get the zoom level for a given resolution
     *
     * Parameters:
     * resolution - {Float}
     *
     * Returns:
     * {Integer} A suitable zoom level for the specified resolution.
     *           If no baselayer is set, returns null.
     */
    getZoomForResolution: function(resolution) {
      
        if (this.resolutions != null) {
            return HGIS.Layer.prototype.getZoomForResolution.apply(this, arguments);
        } else {
            var extent = HGIS.Layer.prototype.getExtent.apply(this, []);
            return this.getZoomForExtent(extent);
        }
    },



    
    /********************************************************/
    /*                                                      */
    /*             Translation Functions                    */
    /*                                                      */
    /*    The following functions translate GMaps and OL    */ 
    /*     formats for Pixel, LonLat, Bounds, and Zoom      */
    /*                                                      */
    /********************************************************/
    
    
    //
    // TRANSLATION: MapObject Zoom <-> HGIS Zoom
    //
  
    /**
     * Method: getOLZoomFromMapObjectZoom
     * Get the OL zoom index from the map object zoom level
     *
     * Parameters:
     * moZoom - {Integer}
     * 
     * Returns:
     * {Integer} An HGIS Zoom level, translated from the passed in zoom
     *           Returns null if null value is passed in
     */
    getOLZoomFromMapObjectZoom: function(moZoom) {
        var zoom = null;
        if (moZoom != null) {
            zoom = moZoom - this.minZoomLevel;
            if (this.map.baseLayer !== this) {
                zoom = this.map.baseLayer.getZoomForResolution(
                    this.getResolutionForZoom(zoom)
                );
            }
        }
        return zoom;
    },
    
    /**
     * Method: getMapObjectZoomFromOLZoom
     * Get the map object zoom level from the OL zoom level
     *
     * Parameters:
     * olZoom - {Integer}
     * 
     * Returns:
     * {Integer} A MapObject level, translated from the passed in olZoom
     *           Returns null if null value is passed in
     */
    getMapObjectZoomFromOLZoom: function(olZoom) {
        var zoom = null; 
        if (olZoom != null) {
            zoom = olZoom + this.minZoomLevel;
            if (this.map.baseLayer !== this) {
                zoom = this.getZoomForResolution(
                    this.map.baseLayer.getResolutionForZoom(zoom)
                );
            }
        }
        return zoom;
    },

    CLASS_NAME: "HGIS.Layer.FixedZoomLevels"
});

/* ======================================================================
    HGIS/Layer/Google.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer/SphericalMercator.js
 * @requires HGIS/Layer/EventPane.js
 * @requires HGIS/Layer/FixedZoomLevels.js
 * @requires HGIS/Lang.js
 */

/**
 * Class: HGIS.Layer.Google
 * 
 * Provides a wrapper for Google's Maps API
 * Normally the Terms of Use for this API do not allow wrapping, but Google
 * have provided written consent to HGIS for this - see email in 
 * http://osgeo-org.1560.n6.nabble.com/Google-Maps-API-Terms-of-Use-changes-tp4910013p4911981.html
 * 
 * Inherits from:
 *  - <HGIS.Layer.SphericalMercator>
 *  - <HGIS.Layer.EventPane>
 *  - <HGIS.Layer.FixedZoomLevels>
 */
HGIS.Layer.Google = HGIS.Class(
    HGIS.Layer.EventPane, 
    HGIS.Layer.FixedZoomLevels, {
    
    /** 
     * Constant: MIN_ZOOM_LEVEL
     * {Integer} 0 
     */
    MIN_ZOOM_LEVEL: 0,
    
    /** 
     * Constant: MAX_ZOOM_LEVEL
     * {Integer} 21
     */
    MAX_ZOOM_LEVEL: 21,

    /** 
     * Constant: RESOLUTIONS
     * {Array(Float)} Hardcode these resolutions so that they are more closely
     *                tied with the standard wms projection
     */
    RESOLUTIONS: [
        1.40625, 
        0.703125, 
        0.3515625, 
        0.17578125, 
        0.087890625, 
        0.0439453125,
        0.02197265625, 
        0.010986328125, 
        0.0054931640625, 
        0.00274658203125,
        0.001373291015625, 
        0.0006866455078125, 
        0.00034332275390625,
        0.000171661376953125, 
        0.0000858306884765625, 
        0.00004291534423828125,
        0.00002145767211914062, 
        0.00001072883605957031,
        0.00000536441802978515, 
        0.00000268220901489257,
        0.0000013411045074462891,
        0.00000067055225372314453
    ],

    /**
     * APIProperty: type
     * {GMapType}
     */
    type: null,

    /**
     * APIProperty: wrapDateLine
     * {Boolean} Allow user to pan forever east/west.  Default is true.  
     *     Setting this to false only restricts panning if 
     *     <sphericalMercator> is true. 
     */
    wrapDateLine: true,

    /**
     * APIProperty: sphericalMercator
     * {Boolean} Should the map act as a mercator-projected map? This will
     *     cause all interactions with the map to be in the actual map 
     *     projection, which allows support for vector drawing, overlaying 
     *     other maps, etc. 
     */
    sphericalMercator: false, 
    
    /**
     * Property: version
     * {Number} The version of the Google Maps API
     */
    version: null,

    /** 
     * Constructor: HGIS.Layer.Google
     * 
     * Parameters:
     * name - {String} A name for the layer.
     * options - {Object} An optional object whose properties will be set
     *     on the layer.
     */
    initialize: function(name, options) {
        options = options || {};
        if(!options.version) {
            options.version = typeof GMap2 === "function" ? "2" : "3";
        }
        var mixin = HGIS.Layer.Google["v" +
            options.version.replace(/\./g, "_")];
        if (mixin) {
            HGIS.Util.applyDefaults(options, mixin);
        } else {
            throw "Unsupported Google Maps API version: " + options.version;
        }

        HGIS.Util.applyDefaults(options, mixin.DEFAULTS);
        if (options.maxExtent) {
            options.maxExtent = options.maxExtent.clone();
        }

        HGIS.Layer.EventPane.prototype.initialize.apply(this,
            [name, options]);
        HGIS.Layer.FixedZoomLevels.prototype.initialize.apply(this, 
            [name, options]);

        if (this.sphericalMercator) {
            HGIS.Util.extend(this, HGIS.Layer.SphericalMercator);
            this.initMercatorParameters();
        }    
    },

    /**
     * Method: clone
     * Create a clone of this layer
     *
     * Returns:
     * {<HGIS.Layer.Google>} An exact clone of this layer
     */
    clone: function() {
        /**
         * This method isn't intended to be called by a subclass and it
         * doesn't call the same method on the superclass.  We don't call
         * the super's clone because we don't want properties that are set
         * on this layer after initialize (i.e. this.mapObject etc.).
         */
        return new HGIS.Layer.Google(
            this.name, this.getOptions()
        );
    },

    /**
     * APIMethod: setVisibility
     * Set the visibility flag for the layer and hide/show & redraw 
     *     accordingly. Fire event unless otherwise specified
     * 
     * Note that visibility is no longer simply whether or not the layer's
     *     style.display is set to "block". Now we store a 'visibility' state 
     *     property on the layer class, this allows us to remember whether or 
     *     not we *desire* for a layer to be visible. In the case where the 
     *     map's resolution is out of the layer's range, this desire may be 
     *     subverted.
     * 
     * Parameters:
     * visible - {Boolean} Display the layer (if in range)
     */
    setVisibility: function(visible) {
        // sharing a map container, opacity has to be set per layer
        var opacity = this.opacity == null ? 1 : this.opacity;
        HGIS.Layer.EventPane.prototype.setVisibility.apply(this, arguments);
        this.setOpacity(opacity);
    },
    
    /** 
     * APIMethod: display
     * Hide or show the Layer
     * 
     * Parameters:
     * visible - {Boolean}
     */
    display: function(visible) {
        if (!this._dragging) {
            this.setGMapVisibility(visible);
        }
        HGIS.Layer.EventPane.prototype.display.apply(this, arguments);
    },
    
    /**
     * Method: moveTo
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     * zoomChanged - {Boolean} Tells when zoom has changed, as layers have to
     *     do some init work in that case.
     * dragging - {Boolean}
     */
    moveTo: function(bounds, zoomChanged, dragging) {
        this._dragging = dragging;
        HGIS.Layer.EventPane.prototype.moveTo.apply(this, arguments);
        delete this._dragging;
    },
    
    /**
     * APIMethod: setOpacity
     * Sets the opacity for the entire layer (all images)
     * 
     * Parameters:
     * opacity - {Float}
     */
    setOpacity: function(opacity) {
        if (opacity !== this.opacity) {
            if (this.map != null) {
                this.map.events.triggerEvent("changelayer", {
                    layer: this,
                    property: "opacity"
                });
            }
            this.opacity = opacity;
        }
        // Though this layer's opacity may not change, we're sharing a container
        // and need to update the opacity for the entire container.
        if (this.getVisibility()) {
            var container = this.getMapContainer();
            HGIS.Util.modifyDOMElement(
                container, null, null, null, null, null, null, opacity
            );
        }
    },

    /**
     * APIMethod: destroy
     * Clean up this layer.
     */
    destroy: function() {
        /**
         * We have to override this method because the event pane destroy
         * deletes the mapObject reference before removing this layer from
         * the map.
         */
        if (this.map) {
            this.setGMapVisibility(false);
            var cache = HGIS.Layer.Google.cache[this.map.id];
            if (cache && cache.count <= 1) {
                this.removeGMapElements();
            }            
        }
        HGIS.Layer.EventPane.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Method: removeGMapElements
     * Remove all elements added to the dom.  This should only be called if
     * this is the last of the Google layers for the given map.
     */
    removeGMapElements: function() {
        var cache = HGIS.Layer.Google.cache[this.map.id];
        if (cache) {
            // remove shared elements from dom
            var container = this.mapObject && this.getMapContainer();                
            if (container && container.parentNode) {
                container.parentNode.removeChild(container);
            }
            var termsOfUse = cache.termsOfUse;
            if (termsOfUse && termsOfUse.parentNode) {
                termsOfUse.parentNode.removeChild(termsOfUse);
            }
            var poweredBy = cache.poweredBy;
            if (poweredBy && poweredBy.parentNode) {
                poweredBy.parentNode.removeChild(poweredBy);
            }
            if (this.mapObject && window.google && google.maps &&
                    google.maps.event && google.maps.event.clearListeners) {
                google.maps.event.clearListeners(this.mapObject, 'tilesloaded');
            }
        }
    },

    /**
     * APIMethod: removeMap
     * On being removed from the map, also remove termsOfUse and poweredBy divs
     * 
     * Parameters:
     * map - {<HGIS.Map>}
     */
    removeMap: function(map) {
        // hide layer before removing
        if (this.visibility && this.mapObject) {
            this.setGMapVisibility(false);
        }
        // check to see if last Google layer in this map
        var cache = HGIS.Layer.Google.cache[map.id];
        if (cache) {
            if (cache.count <= 1) {
                this.removeGMapElements();
                delete HGIS.Layer.Google.cache[map.id];
            } else {
                // decrement the layer count
                --cache.count;
            }
        }
        // remove references to gmap elements
        delete this.termsOfUse;
        delete this.poweredBy;
        delete this.mapObject;
        delete this.dragObject;
        HGIS.Layer.EventPane.prototype.removeMap.apply(this, arguments);
    },
    
  //
  // TRANSLATION: MapObject Bounds <-> HGIS.Bounds
  //

    /**
     * APIMethod: getOLBoundsFromMapObjectBounds
     * 
     * Parameters:
     * moBounds - {Object}
     * 
     * Returns:
     * {<HGIS.Bounds>} An <HGIS.Bounds>, translated from the 
     *                       passed-in MapObject Bounds.
     *                       Returns null if null value is passed in.
     */
    getOLBoundsFromMapObjectBounds: function(moBounds) {
        var olBounds = null;
        if (moBounds != null) {
            var sw = moBounds.getSouthWest();
            var ne = moBounds.getNorthEast();
            if (this.sphericalMercator) {
                sw = this.forwardMercator(sw.lng(), sw.lat());
                ne = this.forwardMercator(ne.lng(), ne.lat());
            } else {
                sw = new HGIS.LonLat(sw.lng(), sw.lat()); 
                ne = new HGIS.LonLat(ne.lng(), ne.lat()); 
            }    
            olBounds = new HGIS.Bounds(sw.lon, 
                                             sw.lat, 
                                             ne.lon, 
                                             ne.lat );
        }
        return olBounds;
    },

    /** 
     * APIMethod: getWarningHTML
     * 
     * Returns: 
     * {String} String with information on why layer is broken, how to get
     *          it working.
     */
    getWarningHTML:function() {
        return HGIS.i18n("googleWarning");
    },


    /************************************
     *                                  *
     *   MapObject Interface Controls   *
     *                                  *
     ************************************/


  // Get&Set Center, Zoom

    /**
     * APIMethod: getMapObjectCenter
     * 
     * Returns: 
     * {Object} The mapObject's current center in Map Object format
     */
    getMapObjectCenter: function() {
        return this.mapObject.getCenter();
    },

    /** 
     * APIMethod: getMapObjectZoom
     * 
     * Returns:
     * {Integer} The mapObject's current zoom, in Map Object format
     */
    getMapObjectZoom: function() {
        return this.mapObject.getZoom();
    },

  
    /************************************
     *                                  *
     *       MapObject Primitives       *
     *                                  *
     ************************************/


  // LonLat
    
    /**
     * APIMethod: getLongitudeFromMapObjectLonLat
     * 
     * Parameters:
     * moLonLat - {Object} MapObject LonLat format
     * 
     * Returns:
     * {Float} Longitude of the given MapObject LonLat
     */
    getLongitudeFromMapObjectLonLat: function(moLonLat) {
        return this.sphericalMercator ? 
          this.forwardMercator(moLonLat.lng(), moLonLat.lat()).lon :
          moLonLat.lng();  
    },

    /**
     * APIMethod: getLatitudeFromMapObjectLonLat
     * 
     * Parameters:
     * moLonLat - {Object} MapObject LonLat format
     * 
     * Returns:
     * {Float} Latitude of the given MapObject LonLat
     */
    getLatitudeFromMapObjectLonLat: function(moLonLat) {
        var lat = this.sphericalMercator ? 
          this.forwardMercator(moLonLat.lng(), moLonLat.lat()).lat :
          moLonLat.lat(); 
        return lat;  
    },
    
  // Pixel
    
    /**
     * APIMethod: getXFromMapObjectPixel
     * 
     * Parameters:
     * moPixel - {Object} MapObject Pixel format
     * 
     * Returns:
     * {Integer} X value of the MapObject Pixel
     */
    getXFromMapObjectPixel: function(moPixel) {
        return moPixel.x;
    },

    /**
     * APIMethod: getYFromMapObjectPixel
     * 
     * Parameters:
     * moPixel - {Object} MapObject Pixel format
     * 
     * Returns:
     * {Integer} Y value of the MapObject Pixel
     */
    getYFromMapObjectPixel: function(moPixel) {
        return moPixel.y;
    },
    
    CLASS_NAME: "HGIS.Layer.Google"
});

/**
 * Property: HGIS.Layer.Google.cache
 * {Object} Cache for elements that should only be created once per map.
 */
HGIS.Layer.Google.cache = {};


/**
 * Constant: HGIS.Layer.Google.v2
 * 
 * Mixin providing functionality specific to the Google Maps API v2.
 * 
 * This API has been deprecated by Google.
 * Developers are encouraged to migrate to v3 of the API; support for this
 * is provided by <HGIS.Layer.Google.v3>
 */
HGIS.Layer.Google.v2 = {
    
    /**
     * Property: termsOfUse
     * {DOMElement} Div for Google's copyright and terms of use link
     */
    termsOfUse: null, 

    /**
     * Property: poweredBy
     * {DOMElement} Div for Google's powered by logo and link
     */
    poweredBy: null, 

    /**
     * Property: dragObject
     * {GDraggableObject} Since 2.93, Google has exposed the ability to get
     *     the maps GDraggableObject. We can now use this for smooth panning
     */
    dragObject: null, 
    
    /** 
     * Method: loadMapObject
     * Load the GMap and register appropriate event listeners. If we can't 
     *     load GMap2, then display a warning message.
     */
    loadMapObject:function() {
        if (!this.type) {
            this.type = G_NORMAL_MAP;
        }
        var mapObject, termsOfUse, poweredBy;
        var cache = HGIS.Layer.Google.cache[this.map.id];
        if (cache) {
            // there are already Google layers added to this map
            mapObject = cache.mapObject;
            termsOfUse = cache.termsOfUse;
            poweredBy = cache.poweredBy;
            // increment the layer count
            ++cache.count;
        } else {
            // this is the first Google layer for this map

            var container = this.map.viewPortDiv;
            var div = document.createElement("div");
            div.id = this.map.id + "_GMap2Container";
            div.style.position = "absolute";
            div.style.width = "100%";
            div.style.height = "100%";
            container.appendChild(div);

            // create GMap and shuffle elements
            try {
                mapObject = new GMap2(div);
                
                // move the ToS and branding stuff up to the container div
                termsOfUse = div.lastChild;
                container.appendChild(termsOfUse);
                termsOfUse.style.zIndex = "1100";
                termsOfUse.style.right = "";
                termsOfUse.style.bottom = "";
                termsOfUse.className = "olLayerGoogleCopyright";

                poweredBy = div.lastChild;
                container.appendChild(poweredBy);
                poweredBy.style.zIndex = "1100";
                poweredBy.style.right = "";
                poweredBy.style.bottom = "";
                poweredBy.className = "olLayerGooglePoweredBy gmnoprint";
                
            } catch (e) {
                throw(e);
            }
            // cache elements for use by any other google layers added to
            // this same map
            HGIS.Layer.Google.cache[this.map.id] = {
                mapObject: mapObject,
                termsOfUse: termsOfUse,
                poweredBy: poweredBy,
                count: 1
            };
        }

        this.mapObject = mapObject;
        this.termsOfUse = termsOfUse;
        this.poweredBy = poweredBy;
        
        // ensure this layer type is one of the mapObject types
        if (HGIS.Util.indexOf(this.mapObject.getMapTypes(),
                                    this.type) === -1) {
            this.mapObject.addMapType(this.type);
        }

        //since v 2.93 getDragObject is now available.
        if(typeof mapObject.getDragObject == "function") {
            this.dragObject = mapObject.getDragObject();
        } else {
            this.dragPanMapObject = null;
        }
        
        if(this.isBaseLayer === false) {
            this.setGMapVisibility(this.div.style.display !== "none");
        }

    },

    /**
     * APIMethod: onMapResize
     */
    onMapResize: function() {
        // workaround for resizing of invisible or not yet fully loaded layers
        // where GMap2.checkResize() does not work. We need to load the GMap
        // for the old div size, then checkResize(), and then call
        // layer.moveTo() to trigger GMap.setCenter() (which will finish
        // the GMap initialization).
        if(this.visibility && this.mapObject.isLoaded()) {
            this.mapObject.checkResize();
        } else {
            if(!this._resized) {
                var layer = this;
                var handle = GEvent.addListener(this.mapObject, "load", function() {
                    GEvent.removeListener(handle);
                    delete layer._resized;
                    layer.mapObject.checkResize();
                    layer.moveTo(layer.map.getCenter(), layer.map.getZoom());
                });
            }
            this._resized = true;
        }
    },

    /**
     * Method: setGMapVisibility
     * Display the GMap container and associated elements.
     * 
     * Parameters:
     * visible - {Boolean} Display the GMap elements.
     */
    setGMapVisibility: function(visible) {
        var cache = HGIS.Layer.Google.cache[this.map.id];
        if (cache) {
            var container = this.mapObject.getContainer();
            if (visible === true) {
                this.mapObject.setMapType(this.type);
                container.style.display = "";
                this.termsOfUse.style.left = "";
                this.termsOfUse.style.display = "";
                this.poweredBy.style.display = "";            
                cache.displayed = this.id;
            } else {
                if (cache.displayed === this.id) {
                    delete cache.displayed;
                }
                if (!cache.displayed) {
                    container.style.display = "none";
                    this.termsOfUse.style.display = "none";
                    // move ToU far to the left in addition to setting display
                    // to "none", because at the end of the GMap2 load
                    // sequence, display: none will be unset and ToU would be
                    // visible after loading a map with a google layer that is
                    // initially hidden. 
                    this.termsOfUse.style.left = "-9999px";
                    this.poweredBy.style.display = "none";
                }
            }
        }
    },
    
    /**
     * Method: getMapContainer
     * 
     * Returns:
     * {DOMElement} the GMap container's div
     */
    getMapContainer: function() {
        return this.mapObject.getContainer();
    },

  //
  // TRANSLATION: MapObject Bounds <-> HGIS.Bounds
  //

    /**
     * APIMethod: getMapObjectBoundsFromOLBounds
     * 
     * Parameters:
     * olBounds - {<HGIS.Bounds>}
     * 
     * Returns:
     * {Object} A MapObject Bounds, translated from olBounds
     *          Returns null if null value is passed in
     */
    getMapObjectBoundsFromOLBounds: function(olBounds) {
        var moBounds = null;
        if (olBounds != null) {
            var sw = this.sphericalMercator ? 
              this.inverseMercator(olBounds.bottom, olBounds.left) : 
              new HGIS.LonLat(olBounds.bottom, olBounds.left);
            var ne = this.sphericalMercator ? 
              this.inverseMercator(olBounds.top, olBounds.right) : 
              new HGIS.LonLat(olBounds.top, olBounds.right);
            moBounds = new GLatLngBounds(new GLatLng(sw.lat, sw.lon),
                                         new GLatLng(ne.lat, ne.lon));
        }
        return moBounds;
    },


    /************************************
     *                                  *
     *   MapObject Interface Controls   *
     *                                  *
     ************************************/


  // Get&Set Center, Zoom

    /** 
     * APIMethod: setMapObjectCenter
     * Set the mapObject to the specified center and zoom
     * 
     * Parameters:
     * center - {Object} MapObject LonLat format
     * zoom - {int} MapObject zoom format
     */
    setMapObjectCenter: function(center, zoom) {
        this.mapObject.setCenter(center, zoom); 
    },
   
    /**
     * APIMethod: dragPanMapObject
     * 
     * Parameters:
     * dX - {Integer}
     * dY - {Integer}
     */
    dragPanMapObject: function(dX, dY) {
        this.dragObject.moveBy(new GSize(-dX, dY));
    },


  // LonLat - Pixel Translation
  
    /**
     * APIMethod: getMapObjectLonLatFromMapObjectPixel
     * 
     * Parameters:
     * moPixel - {Object} MapObject Pixel format
     * 
     * Returns:
     * {Object} MapObject LonLat translated from MapObject Pixel
     */
    getMapObjectLonLatFromMapObjectPixel: function(moPixel) {
        return this.mapObject.fromContainerPixelToLatLng(moPixel);
    },

    /**
     * APIMethod: getMapObjectPixelFromMapObjectLonLat
     * 
     * Parameters:
     * moLonLat - {Object} MapObject LonLat format
     * 
     * Returns:
     * {Object} MapObject Pixel transtlated from MapObject LonLat
     */
    getMapObjectPixelFromMapObjectLonLat: function(moLonLat) {
        return this.mapObject.fromLatLngToContainerPixel(moLonLat);
    },

  
  // Bounds
  
    /** 
     * APIMethod: getMapObjectZoomFromMapObjectBounds
     * 
     * Parameters:
     * moBounds - {Object} MapObject Bounds format
     * 
     * Returns:
     * {Object} MapObject Zoom for specified MapObject Bounds
     */
    getMapObjectZoomFromMapObjectBounds: function(moBounds) {
        return this.mapObject.getBoundsZoomLevel(moBounds);
    },

    /************************************
     *                                  *
     *       MapObject Primitives       *
     *                                  *
     ************************************/


  // LonLat
    
    /**
     * APIMethod: getMapObjectLonLatFromLonLat
     * 
     * Parameters:
     * lon - {Float}
     * lat - {Float}
     * 
     * Returns:
     * {Object} MapObject LonLat built from lon and lat params
     */
    getMapObjectLonLatFromLonLat: function(lon, lat) {
        var gLatLng;
        if(this.sphericalMercator) {
            var lonlat = this.inverseMercator(lon, lat);
            gLatLng = new GLatLng(lonlat.lat, lonlat.lon);
        } else {
            gLatLng = new GLatLng(lat, lon);
        }
        return gLatLng;
    },

  // Pixel
    
    /**
     * APIMethod: getMapObjectPixelFromXY
     * 
     * Parameters:
     * x - {Integer}
     * y - {Integer}
     * 
     * Returns:
     * {Object} MapObject Pixel from x and y parameters
     */
    getMapObjectPixelFromXY: function(x, y) {
        return new GPoint(x, y);
    }
    
};
/* ======================================================================
    HGIS/Format/XML.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format.js
 */

/**
 * Class: HGIS.Format.XML
 * Read and write XML.  For cross-browser XML generation, use methods on an
 *     instance of the XML format class instead of on <code>document<end>.
 *     The DOM creation and traversing methods exposed here all mimic the
 *     W3C XML DOM methods.  Create a new parser with the
 *     <HGIS.Format.XML> constructor.
 *
 * Inherits from:
 *  - <HGIS.Format>
 */
HGIS.Format.XML = HGIS.Class(HGIS.Format, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.  Properties
     *     of this object should not be set individually.  Read-only.  All
     *     XML subclasses should have their own namespaces object.  Use
     *     <setNamespace> to add or set a namespace alias after construction.
     */
    namespaces: null,
    
    /**
     * Property: namespaceAlias
     * {Object} Mapping of namespace URI to namespace alias.  This object
     *     is read-only.  Use <setNamespace> to add or set a namespace alias.
     */
    namespaceAlias: null,
    
    /**
     * Property: defaultPrefix
     * {String} The default namespace alias for creating element nodes.
     */
    defaultPrefix: null,
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {},
    
    /**
     * Property: writers
     * As a compliment to the <readers> property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {},

    /**
     * Property: xmldom
     * {XMLDom} If this browser uses ActiveX, this will be set to a XMLDOM
     *     object.  It is not intended to be a browser sniffing property.
     *     Instead, the xmldom property is used instead of <code>document<end>
     *     where namespaced node creation methods are not supported. In all
     *     other browsers, this remains null.
     */
    xmldom: null,

    /**
     * Constructor: HGIS.Format.XML
     * Construct an XML parser.  The parser is used to read and write XML.
     *     Reading XML from a string returns a DOM element.  Writing XML from
     *     a DOM element returns a string.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on
     *     the object.
     */
    initialize: function(options) {
        if(window.ActiveXObject) {
            this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
        }
        HGIS.Format.prototype.initialize.apply(this, [options]);
        // clone the namespace object and set all namespace aliases
        this.namespaces = HGIS.Util.extend({}, this.namespaces);
        this.namespaceAlias = {};
        for(var alias in this.namespaces) {
            this.namespaceAlias[this.namespaces[alias]] = alias;
        }
    },
    
    /**
     * APIMethod: destroy
     * Clean up.
     */
    destroy: function() {
        this.xmldom = null;
        HGIS.Format.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Method: setNamespace
     * Set a namespace alias and URI for the format.
     *
     * Parameters:
     * alias - {String} The namespace alias (prefix).
     * uri - {String} The namespace URI.
     */
    setNamespace: function(alias, uri) {
        this.namespaces[alias] = uri;
        this.namespaceAlias[uri] = alias;
    },

    /**
     * APIMethod: read
     * Deserialize a XML string and return a DOM node.
     *
     * Parameters:
     * text - {String} A XML string
     
     * Returns:
     * {DOMElement} A DOM node
     */
    read: function(text) {
        var index = text.indexOf('<');
        if(index > 0) {
            text = text.substring(index);
        }
        var node = HGIS.Util.Try(
            HGIS.Function.bind((
                function() {
                    var xmldom;
                    /**
                     * Since we want to be able to call this method on the prototype
                     * itself, this.xmldom may not exist even if in IE.
                     */
                    if(window.ActiveXObject && !this.xmldom) {
                        xmldom = new ActiveXObject("Microsoft.XMLDOM");
                    } else {
                        xmldom = this.xmldom;
                        
                    }
                    xmldom.loadXML(text);
                    return xmldom;
                }
            ), this),
            function() {
                return new DOMParser().parseFromString(text, 'text/xml');
            },
            function() {
                var req = new XMLHttpRequest();
                req.open("GET", "data:" + "text/xml" +
                         ";charset=utf-8," + encodeURIComponent(text), false);
                if(req.overrideMimeType) {
                    req.overrideMimeType("text/xml");
                }
                req.send(null);
                return req.responseXML;
            }
        );

        if(this.keepData) {
            this.data = node;
        }

        return node;
    },

    /**
     * APIMethod: write
     * Serialize a DOM node into a XML string.
     * 
     * Parameters:
     * node - {DOMElement} A DOM node.
     *
     * Returns:
     * {String} The XML string representation of the input node.
     */
    write: function(node) {
        var data;
        if(this.xmldom) {
            data = node.xml;
        } else {
            var serializer = new XMLSerializer();
            if (node.nodeType == 1) {
                // Add nodes to a document before serializing. Everything else
                // is serialized as is. This may need more work. See #1218 .
                var doc = document.implementation.createDocument("", "", null);
                if (doc.importNode) {
                    node = doc.importNode(node, true);
                }
                doc.appendChild(node);
                data = serializer.serializeToString(doc);
            } else {
                data = serializer.serializeToString(node);
            }
        }
        return data;
    },

    /**
     * APIMethod: createElementNS
     * Create a new element with namespace.  This node can be appended to
     *     another node with the standard node.appendChild method.  For
     *     cross-browser support, this method must be used instead of
     *     document.createElementNS.
     *
     * Parameters:
     * uri - {String} Namespace URI for the element.
     * name - {String} The qualified name of the element (prefix:localname).
     * 
     * Returns:
     * {Element} A DOM element with namespace.
     */
    createElementNS: function(uri, name) {
        var element;
        if(this.xmldom) {
            if(typeof uri == "string") {
                element = this.xmldom.createNode(1, name, uri);
            } else {
                element = this.xmldom.createNode(1, name, "");
            }
        } else {
            element = document.createElementNS(uri, name);
        }
        return element;
    },

    /**
     * APIMethod: createDocumentFragment
     * Create a document fragment node that can be appended to another node
     *     created by createElementNS.  This will call 
     *     document.createDocumentFragment outside of IE.  In IE, the ActiveX
     *     object's createDocumentFragment method is used.
     *
     * Returns:
     * {Element} A document fragment.
     */
    createDocumentFragment: function() {
        var element;
        if (this.xmldom) {
            element = this.xmldom.createDocumentFragment();
        } else {
            element = document.createDocumentFragment();
        }
        return element;
    },

    /**
     * APIMethod: createTextNode
     * Create a text node.  This node can be appended to another node with
     *     the standard node.appendChild method.  For cross-browser support,
     *     this method must be used instead of document.createTextNode.
     * 
     * Parameters:
     * text - {String} The text of the node.
     * 
     * Returns: 
     * {DOMElement} A DOM text node.
     */
    createTextNode: function(text) {
        var node;
        if (typeof text !== "string") {
            text = String(text);
        }
        if(this.xmldom) {
            node = this.xmldom.createTextNode(text);
        } else {
            node = document.createTextNode(text);
        }
        return node;
    },

    /**
     * APIMethod: getElementsByTagNameNS
     * Get a list of elements on a node given the namespace URI and local name.
     *     To return all nodes in a given namespace, use '*' for the name
     *     argument.  To return all nodes of a given (local) name, regardless
     *     of namespace, use '*' for the uri argument.
     * 
     * Parameters:
     * node - {Element} Node on which to search for other nodes.
     * uri - {String} Namespace URI.
     * name - {String} Local name of the tag (without the prefix).
     * 
     * Returns:
     * {NodeList} A node list or array of elements.
     */
    getElementsByTagNameNS: function(node, uri, name) {
        var elements = [];
        if(node.getElementsByTagNameNS) {
            elements = node.getElementsByTagNameNS(uri, name);
        } else {
            // brute force method
            var allNodes = node.getElementsByTagName("*");
            var potentialNode, fullName;
            for(var i=0, len=allNodes.length; i<len; ++i) {
                potentialNode = allNodes[i];
                fullName = (potentialNode.prefix) ?
                           (potentialNode.prefix + ":" + name) : name;
                if((name == "*") || (fullName == potentialNode.nodeName)) {
                    if((uri == "*") || (uri == potentialNode.namespaceURI)) {
                        elements.push(potentialNode);
                    }
                }
            }
        }
        return elements;
    },

    /**
     * APIMethod: getAttributeNodeNS
     * Get an attribute node given the namespace URI and local name.
     * 
     * Parameters:
     * node - {Element} Node on which to search for attribute nodes.
     * uri - {String} Namespace URI.
     * name - {String} Local name of the attribute (without the prefix).
     * 
     * Returns:
     * {DOMElement} An attribute node or null if none found.
     */
    getAttributeNodeNS: function(node, uri, name) {
        var attributeNode = null;
        if(node.getAttributeNodeNS) {
            attributeNode = node.getAttributeNodeNS(uri, name);
        } else {
            var attributes = node.attributes;
            var potentialNode, fullName;
            for(var i=0, len=attributes.length; i<len; ++i) {
                potentialNode = attributes[i];
                if(potentialNode.namespaceURI == uri) {
                    fullName = (potentialNode.prefix) ?
                               (potentialNode.prefix + ":" + name) : name;
                    if(fullName == potentialNode.nodeName) {
                        attributeNode = potentialNode;
                        break;
                    }
                }
            }
        }
        return attributeNode;
    },

    /**
     * APIMethod: getAttributeNS
     * Get an attribute value given the namespace URI and local name.
     * 
     * Parameters:
     * node - {Element} Node on which to search for an attribute.
     * uri - {String} Namespace URI.
     * name - {String} Local name of the attribute (without the prefix).
     * 
     * Returns:
     * {String} An attribute value or and empty string if none found.
     */
    getAttributeNS: function(node, uri, name) {
        var attributeValue = "";
        if(node.getAttributeNS) {
            attributeValue = node.getAttributeNS(uri, name) || "";
        } else {
            var attributeNode = this.getAttributeNodeNS(node, uri, name);
            if(attributeNode) {
                attributeValue = attributeNode.nodeValue;
            }
        }
        return attributeValue;
    },
    
    /**
     * APIMethod: getChildValue
     * Get the textual value of the node if it exists, or return an
     *     optional default string.  Returns an empty string if no first child
     *     exists and no default value is supplied.
     *
     * Parameters:
     * node - {DOMElement} The element used to look for a first child value.
     * def - {String} Optional string to return in the event that no
     *     first child value exists.
     *
     * Returns:
     * {String} The value of the first child of the given node.
     */
    getChildValue: function(node, def) {
        var value = def || "";
        if(node) {
            for(var child=node.firstChild; child; child=child.nextSibling) {
                switch(child.nodeType) {
                    case 3: // text node
                    case 4: // cdata section
                        value += child.nodeValue;
                }
            }
        }
        return value;
    },

    /**
     * APIMethod: isSimpleContent
     * Test if the given node has only simple content (i.e. no child element
     *     nodes).
     *
     * Parameters:
     * node - {DOMElement} An element node.
     *
     * Returns:
     * {Boolean} The node has no child element nodes (nodes of type 1). 
     */
    isSimpleContent: function(node) {
        var simple = true;
        for(var child=node.firstChild; child; child=child.nextSibling) {
            if(child.nodeType === 1) {
                simple = false;
                break;
            }
        }
        return simple;
    },
    
    /**
     * APIMethod: contentType
     * Determine the content type for a given node.
     *
     * Parameters:
     * node - {DOMElement}
     *
     * Returns:
     * {Integer} One of HGIS.Format.XML.CONTENT_TYPE.{EMPTY,SIMPLE,COMPLEX,MIXED}
     *     if the node has no, simple, complex, or mixed content.
     */
    contentType: function(node) {
        var simple = false,
            complex = false;
            
        var type = HGIS.Format.XML.CONTENT_TYPE.EMPTY;

        for(var child=node.firstChild; child; child=child.nextSibling) {
            switch(child.nodeType) {
                case 1: // element
                    complex = true;
                    break;
                case 8: // comment
                    break;
                default:
                    simple = true;
            }
            if(complex && simple) {
                break;
            }
        }
        
        if(complex && simple) {
            type = HGIS.Format.XML.CONTENT_TYPE.MIXED;
        } else if(complex) {
            return HGIS.Format.XML.CONTENT_TYPE.COMPLEX;
        } else if(simple) {
            return HGIS.Format.XML.CONTENT_TYPE.SIMPLE;
        }
        return type;
    },

    /**
     * APIMethod: hasAttributeNS
     * Determine whether a node has a particular attribute matching the given
     *     name and namespace.
     * 
     * Parameters:
     * node - {Element} Node on which to search for an attribute.
     * uri - {String} Namespace URI.
     * name - {String} Local name of the attribute (without the prefix).
     * 
     * Returns:
     * {Boolean} The node has an attribute matching the name and namespace.
     */
    hasAttributeNS: function(node, uri, name) {
        var found = false;
        if(node.hasAttributeNS) {
            found = node.hasAttributeNS(uri, name);
        } else {
            found = !!this.getAttributeNodeNS(node, uri, name);
        }
        return found;
    },
    
    /**
     * APIMethod: setAttributeNS
     * Adds a new attribute or changes the value of an attribute with the given
     *     namespace and name.
     *
     * Parameters:
     * node - {Element} Element node on which to set the attribute.
     * uri - {String} Namespace URI for the attribute.
     * name - {String} Qualified name (prefix:localname) for the attribute.
     * value - {String} Attribute value.
     */
    setAttributeNS: function(node, uri, name, value) {
        if(node.setAttributeNS) {
            node.setAttributeNS(uri, name, value);
        } else {
            if(this.xmldom) {
                if(uri) {
                    var attribute = node.ownerDocument.createNode(
                        2, name, uri
                    );
                    attribute.nodeValue = value;
                    node.setAttributeNode(attribute);
                } else {
                    node.setAttribute(name, value);
                }
            } else {
                throw "setAttributeNS not implemented";
            }
        }
    },

    /**
     * Method: createElementNSPlus
     * Shorthand for creating namespaced elements with optional attributes and
     *     child text nodes.
     *
     * Parameters:
     * name - {String} The qualified node name.
     * options - {Object} Optional object for node configuration.
     *
     * Valid options:
     * uri - {String} Optional namespace uri for the element - supply a prefix
     *     instead if the namespace uri is a property of the format's namespace
     *     object.
     * attributes - {Object} Optional attributes to be set using the
     *     <setAttributes> method.
     * value - {String} Optional text to be appended as a text node.
     *
     * Returns:
     * {Element} An element node.
     */
    createElementNSPlus: function(name, options) {
        options = options || {};
        // order of prefix preference
        // 1. in the uri option
        // 2. in the prefix option
        // 3. in the qualified name
        // 4. from the defaultPrefix
        var uri = options.uri || this.namespaces[options.prefix];
        if(!uri) {
            var loc = name.indexOf(":");
            uri = this.namespaces[name.substring(0, loc)];
        }
        if(!uri) {
            uri = this.namespaces[this.defaultPrefix];
        }
        var node = this.createElementNS(uri, name);
        if(options.attributes) {
            this.setAttributes(node, options.attributes);
        }
        var value = options.value;
        if(value != null) {
            node.appendChild(this.createTextNode(value));
        }
        return node;
    },
    
    /**
     * Method: setAttributes
     * Set multiple attributes given key value pairs from an object.
     *
     * Parameters:
     * node - {Element} An element node.
     * obj - {Object || Array} An object whose properties represent attribute
     *     names and values represent attribute values.  If an attribute name
     *     is a qualified name ("prefix:local"), the prefix will be looked up
     *     in the parsers {namespaces} object.  If the prefix is found,
     *     setAttributeNS will be used instead of setAttribute.
     */
    setAttributes: function(node, obj) {
        var value, uri;
        for(var name in obj) {
            if(obj[name] != null && obj[name].toString) {
                value = obj[name].toString();
                // check for qualified attribute name ("prefix:local")
                uri = this.namespaces[name.substring(0, name.indexOf(":"))] || null;
                this.setAttributeNS(node, uri, name, value);
            }
        }
    },

    /**
     * Method: readNode
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     *
     * Parameters:
     * node - {DOMElement} The node to be read (required).
     * obj - {Object} The object to be modified (optional).
     *
     * Returns:
     * {Object} The input object, modified (or a new one if none was provided).
     */
    readNode: function(node, obj) {
        if(!obj) {
            obj = {};
        }
        var group = this.readers[node.namespaceURI ? this.namespaceAlias[node.namespaceURI]: this.defaultPrefix];
        if(group) {
            var local = node.localName || node.nodeName.split(":").pop();
            var reader = group[local] || group["*"];
            if(reader) {
                reader.apply(this, [node, obj]);
            }
        }
        return obj;
    },

    /**
     * Method: readChildNodes
     * Shorthand for applying the named readers to all children of a node.
     *     For each child of type 1 (element), <readSelf> is called.
     *
     * Parameters:
     * node - {DOMElement} The node to be read (required).
     * obj - {Object} The object to be modified (optional).
     *
     * Returns:
     * {Object} The input object, modified.
     */
    readChildNodes: function(node, obj) {
        if(!obj) {
            obj = {};
        }
        var children = node.childNodes;
        var child;
        for(var i=0, len=children.length; i<len; ++i) {
            child = children[i];
            if(child.nodeType == 1) {
                this.readNode(child, obj);
            }
        }
        return obj;
    },

    /**
     * Method: writeNode
     * Shorthand for applying one of the named writers and appending the
     *     results to a node.  If a qualified name is not provided for the
     *     second argument (and a local name is used instead), the namespace
     *     of the parent node will be assumed.
     *
     * Parameters:
     * name - {String} The name of a node to generate.  If a qualified name
     *     (e.g. "pre:Name") is used, the namespace prefix is assumed to be
     *     in the <writers> group.  If a local name is used (e.g. "Name") then
     *     the namespace of the parent is assumed.  If a local name is used
     *     and no parent is supplied, then the default namespace is assumed.
     * obj - {Object} Structure containing data for the writer.
     * parent - {DOMElement} Result will be appended to this node.  If no parent
     *     is supplied, the node will not be appended to anything.
     *
     * Returns:
     * {DOMElement} The child node.
     */
    writeNode: function(name, obj, parent) {
        var prefix, local;
        var split = name.indexOf(":");
        if(split > 0) {
            prefix = name.substring(0, split);
            local = name.substring(split + 1);
        } else {
            if(parent) {
                prefix = this.namespaceAlias[parent.namespaceURI];
            } else {
                prefix = this.defaultPrefix;
            }
            local = name;
        }
        var child = this.writers[prefix][local].apply(this, [obj]);
        if(parent) {
            parent.appendChild(child);
        }
        return child;
    },

    /**
     * APIMethod: getChildEl
     * Get the first child element.  Optionally only return the first child
     *     if it matches the given name and namespace URI.
     *
     * Parameters:
     * node - {DOMElement} The parent node.
     * name - {String} Optional node name (local) to search for.
     * uri - {String} Optional namespace URI to search for.
     *
     * Returns:
     * {DOMElement} The first child.  Returns null if no element is found, if
     *     something significant besides an element is found, or if the element
     *     found does not match the optional name and uri.
     */
    getChildEl: function(node, name, uri) {
        return node && this.getThisOrNextEl(node.firstChild, name, uri);
    },
    
    /**
     * APIMethod: getNextEl
     * Get the next sibling element.  Optionally get the first sibling only
     *     if it matches the given local name and namespace URI.
     *
     * Parameters:
     * node - {DOMElement} The node.
     * name - {String} Optional local name of the sibling to search for.
     * uri - {String} Optional namespace URI of the sibling to search for.
     *
     * Returns:
     * {DOMElement} The next sibling element.  Returns null if no element is
     *     found, something significant besides an element is found, or the
     *     found element does not match the optional name and uri.
     */
    getNextEl: function(node, name, uri) {
        return node && this.getThisOrNextEl(node.nextSibling, name, uri);
    },
    
    /**
     * Method: getThisOrNextEl
     * Return this node or the next element node.  Optionally get the first
     *     sibling with the given local name or namespace URI.
     *
     * Parameters:
     * node - {DOMElement} The node.
     * name - {String} Optional local name of the sibling to search for.
     * uri - {String} Optional namespace URI of the sibling to search for.
     *
     * Returns:
     * {DOMElement} The next sibling element.  Returns null if no element is
     *     found, something significant besides an element is found, or the
     *     found element does not match the query.
     */
    getThisOrNextEl: function(node, name, uri) {
        outer: for(var sibling=node; sibling; sibling=sibling.nextSibling) {
            switch(sibling.nodeType) {
                case 1: // Element
                    if((!name || name === (sibling.localName || sibling.nodeName.split(":").pop())) &&
                       (!uri || uri === sibling.namespaceURI)) {
                        // matches
                        break outer;
                    }
                    sibling = null;
                    break outer;
                case 3: // Text
                    if(/^\s*$/.test(sibling.nodeValue)) {
                        break;
                    }
                case 4: // CDATA
                case 6: // ENTITY_NODE
                case 12: // NOTATION_NODE
                case 10: // DOCUMENT_TYPE_NODE
                case 11: // DOCUMENT_FRAGMENT_NODE
                    sibling = null;
                    break outer;
            } // ignore comments and processing instructions
        }
        return sibling || null;
    },
    
    /**
     * APIMethod: lookupNamespaceURI
     * Takes a prefix and returns the namespace URI associated with it on the given
     *     node if found (and null if not). Supplying null for the prefix will
     *     return the default namespace.
     *
     * For browsers that support it, this calls the native lookupNamesapceURI
     *     function.  In other browsers, this is an implementation of
     *     http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI.
     *
     * For browsers that don't support the attribute.ownerElement property, this
     *     method cannot be called on attribute nodes.
     *     
     * Parameters:
     * node - {DOMElement} The node from which to start looking.
     * prefix - {String} The prefix to lookup or null to lookup the default namespace.
     * 
     * Returns:
     * {String} The namespace URI for the given prefix.  Returns null if the prefix
     *     cannot be found or the node is the wrong type.
     */
    lookupNamespaceURI: function(node, prefix) {
        var uri = null;
        if(node) {
            if(node.lookupNamespaceURI) {
                uri = node.lookupNamespaceURI(prefix);
            } else {
                outer: switch(node.nodeType) {
                    case 1: // ELEMENT_NODE
                        if(node.namespaceURI !== null && node.prefix === prefix) {
                            uri = node.namespaceURI;
                            break outer;
                        }
                        var len = node.attributes.length;
                        if(len) {
                            var attr;
                            for(var i=0; i<len; ++i) {
                                attr = node.attributes[i];
                                if(attr.prefix === "xmlns" && attr.name === "xmlns:" + prefix) {
                                    uri = attr.value || null;
                                    break outer;
                                } else if(attr.name === "xmlns" && prefix === null) {
                                    uri = attr.value || null;
                                    break outer;
                                }
                            }
                        }
                        uri = this.lookupNamespaceURI(node.parentNode, prefix);
                        break outer;
                    case 2: // ATTRIBUTE_NODE
                        uri = this.lookupNamespaceURI(node.ownerElement, prefix);
                        break outer;
                    case 9: // DOCUMENT_NODE
                        uri = this.lookupNamespaceURI(node.documentElement, prefix);
                        break outer;
                    case 6: // ENTITY_NODE
                    case 12: // NOTATION_NODE
                    case 10: // DOCUMENT_TYPE_NODE
                    case 11: // DOCUMENT_FRAGMENT_NODE
                        break outer;
                    default: 
                        // TEXT_NODE (3), CDATA_SECTION_NODE (4), ENTITY_REFERENCE_NODE (5),
                        // PROCESSING_INSTRUCTION_NODE (7), COMMENT_NODE (8)
                        uri =  this.lookupNamespaceURI(node.parentNode, prefix);
                        break outer;
                }
            }
        }
        return uri;
    },
    
    /**
     * Method: getXMLDoc
     * Get an XML document for nodes that are not supported in HTML (e.g.
     * createCDATASection). On IE, this will either return an existing or
     * create a new <xmldom> on the instance. On other browsers, this will
     * either return an existing or create a new shared document (see
     * <HGIS.Format.XML.document>).
     *
     * Returns:
     * {XMLDocument}
     */
    getXMLDoc: function() {
        if (!HGIS.Format.XML.document && !this.xmldom) {
            if (document.implementation && document.implementation.createDocument) {
                HGIS.Format.XML.document =
                    document.implementation.createDocument("", "", null);
            } else if (!this.xmldom && window.ActiveXObject) {
                this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
            }
        }
        return HGIS.Format.XML.document || this.xmldom;
    },

    CLASS_NAME: "HGIS.Format.XML" 

});     

HGIS.Format.XML.CONTENT_TYPE = {EMPTY: 0, SIMPLE: 1, COMPLEX: 2, MIXED: 3};

/**
 * APIFunction: HGIS.Format.XML.lookupNamespaceURI
 * Takes a prefix and returns the namespace URI associated with it on the given
 *     node if found (and null if not). Supplying null for the prefix will
 *     return the default namespace.
 *
 * For browsers that support it, this calls the native lookupNamesapceURI
 *     function.  In other browsers, this is an implementation of
 *     http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI.
 *
 * For browsers that don't support the attribute.ownerElement property, this
 *     method cannot be called on attribute nodes.
 *     
 * Parameters:
 * node - {DOMElement} The node from which to start looking.
 * prefix - {String} The prefix to lookup or null to lookup the default namespace.
 * 
 * Returns:
 * {String} The namespace URI for the given prefix.  Returns null if the prefix
 *     cannot be found or the node is the wrong type.
 */
HGIS.Format.XML.lookupNamespaceURI = HGIS.Function.bind(
    HGIS.Format.XML.prototype.lookupNamespaceURI,
    HGIS.Format.XML.prototype
);

/**
 * Property: HGIS.Format.XML.document
 * {XMLDocument} XML document to reuse for creating non-HTML compliant nodes,
 * like document.createCDATASection.
 */
HGIS.Format.XML.document = null;
/* ======================================================================
    HGIS/Format/WFST.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format.js
 */

/**
 * Function: HGIS.Format.WFST
 * Used to create a versioned WFS protocol.  Default version is 1.0.0.
 *
 * Returns:
 * {<HGIS.Format>} A WFST format of the given version.
 */
HGIS.Format.WFST = function(options) {
    options = HGIS.Util.applyDefaults(
        options, HGIS.Format.WFST.DEFAULTS
    );
    var cls = HGIS.Format.WFST["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported WFST version: " + options.version;
    }
    return new cls(options);
};

/**
 * Constant: HGIS.Format.WFST.DEFAULTS
 * {Object} Default properties for the WFST format.
 */
HGIS.Format.WFST.DEFAULTS = {
    "version": "1.0.0"
};
/* ======================================================================
    HGIS/Feature.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Util.js
 */

/**
 * Class: HGIS.Feature
 * Features are combinations of geography and attributes. The HGIS.Feature
 *     class specifically combines a marker and a lonlat.
 */
HGIS.Feature = HGIS.Class({

    /** 
     * Property: layer 
     * {<HGIS.Layer>} 
     */
    layer: null,

    /** 
     * Property: id 
     * {String} 
     */
    id: null,
    
    /** 
     * Property: lonlat 
     * {<HGIS.LonLat>} 
     */
    lonlat: null,

    /** 
     * Property: data 
     * {Object} 
     */
    data: null,

    /** 
     * Property: marker 
     * {<HGIS.Marker>} 
     */
    marker: null,

    /**
     * APIProperty: popupClass
     * {<HGIS.Class>} The class which will be used to instantiate
     *     a new Popup. Default is <HGIS.Popup.Anchored>.
     */
    popupClass: null,

    /** 
     * Property: popup 
     * {<HGIS.Popup>} 
     */
    popup: null,

    /** 
     * Constructor: HGIS.Feature
     * Constructor for features.
     *
     * Parameters:
     * layer - {<HGIS.Layer>} 
     * lonlat - {<HGIS.LonLat>} 
     * data - {Object} 
     * 
     * Returns:
     * {<HGIS.Feature>}
     */
    initialize: function(layer, lonlat, data) {
        this.layer = layer;
        this.lonlat = lonlat;
        this.data = (data != null) ? data : {};
        this.id = HGIS.Util.createUniqueID(this.CLASS_NAME + "_"); 
    },

    /** 
     * Method: destroy
     * nullify references to prevent circular references and memory leaks
     */
    destroy: function() {

        //remove the popup from the map
        if ((this.layer != null) && (this.layer.map != null)) {
            if (this.popup != null) {
                this.layer.map.removePopup(this.popup);
            }
        }
        // remove the marker from the layer
        if (this.layer != null && this.marker != null) {
            this.layer.removeMarker(this.marker);
        }

        this.layer = null;
        this.id = null;
        this.lonlat = null;
        this.data = null;
        if (this.marker != null) {
            this.destroyMarker(this.marker);
            this.marker = null;
        }
        if (this.popup != null) {
            this.destroyPopup(this.popup);
            this.popup = null;
        }
    },
    
    /**
     * Method: onScreen
     * 
     * Returns:
     * {Boolean} Whether or not the feature is currently visible on screen
     *           (based on its 'lonlat' property)
     */
    onScreen:function() {
        
        var onScreen = false;
        if ((this.layer != null) && (this.layer.map != null)) {
            var screenBounds = this.layer.map.getExtent();
            onScreen = screenBounds.containsLonLat(this.lonlat);
        }    
        return onScreen;
    },
    

    /**
     * Method: createMarker
     * Based on the data associated with the Feature, create and return a marker object.
     *
     * Returns: 
     * {<HGIS.Marker>} A Marker Object created from the 'lonlat' and 'icon' properties
     *          set in this.data. If no 'lonlat' is set, returns null. If no
     *          'icon' is set, HGIS.Marker() will load the default image.
     *          
     *          Note - this.marker is set to return value
     * 
     */
    createMarker: function() {

        if (this.lonlat != null) {
            this.marker = new HGIS.Marker(this.lonlat, this.data.icon);
        }
        return this.marker;
    },

    /**
     * Method: destroyMarker
     * Destroys marker.
     * If user overrides the createMarker() function, s/he should be able
     *   to also specify an alternative function for destroying it
     */
    destroyMarker: function() {
        this.marker.destroy();  
    },

    /**
     * Method: createPopup
     * Creates a popup object created from the 'lonlat', 'popupSize',
     *     and 'popupContentHTML' properties set in this.data. It uses
     *     this.marker.icon as default anchor. 
     *  
     *  If no 'lonlat' is set, returns null. 
     *  If no this.marker has been created, no anchor is sent.
     *
     *  Note - the returned popup object is 'owned' by the feature, so you
     *      cannot use the popup's destroy method to discard the popup.
     *      Instead, you must use the feature's destroyPopup
     * 
     *  Note - this.popup is set to return value
     * 
     * Parameters: 
     * closeBox - {Boolean} create popup with closebox or not
     * 
     * Returns:
     * {<HGIS.Popup>} Returns the created popup, which is also set
     *     as 'popup' property of this feature. Will be of whatever type
     *     specified by this feature's 'popupClass' property, but must be
     *     of type <HGIS.Popup>.
     * 
     */
    createPopup: function(closeBox) {

        if (this.lonlat != null) {
            if (!this.popup) {
                var anchor = (this.marker) ? this.marker.icon : null;
                var popupClass = this.popupClass ? 
                    this.popupClass : HGIS.Popup.Anchored;
                this.popup = new popupClass(this.id + "_popup", 
                                            this.lonlat,
                                            this.data.popupSize,
                                            this.data.popupContentHTML,
                                            anchor, 
                                            closeBox); 
            }    
            if (this.data.overflow != null) {
                this.popup.contentDiv.style.overflow = this.data.overflow;
            }    
            
            this.popup.feature = this;
        }        
        return this.popup;
    },

    
    /**
     * Method: destroyPopup
     * Destroys the popup created via createPopup.
     *
     * As with the marker, if user overrides the createPopup() function, s/he 
     *   should also be able to override the destruction
     */
    destroyPopup: function() {
        if (this.popup) {
            this.popup.feature = null;
            this.popup.destroy();
            this.popup = null;
        }    
    },

    CLASS_NAME: "HGIS.Feature"
});
/* ======================================================================
    HGIS/Feature/Vector.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

// TRASH THIS
HGIS.State = {
    /** states */
    UNKNOWN: 'Unknown',
    INSERT: 'Insert',
    UPDATE: 'Update',
    DELETE: 'Delete'
};

/**
 * @requires HGIS/Feature.js
 * @requires HGIS/Util.js
 */

/**
 * Class: HGIS.Feature.Vector
 * Vector features use the HGIS.Geometry classes as geometry description.
 * They have an 'attributes' property, which is the data object, and a 'style'
 * property, the default values of which are defined in the 
 * <HGIS.Feature.Vector.style> objects.
 * 
 * Inherits from:
 *  - <HGIS.Feature>
 */
HGIS.Feature.Vector = HGIS.Class(HGIS.Feature, {

    /** 
     * Property: fid 
     * {String} 
     */
    fid: null,
    
    /** 
     * APIProperty: geometry 
     * {<HGIS.Geometry>} 
     */
    geometry: null,

    /** 
     * APIProperty: attributes 
     * {Object} This object holds arbitrary, serializable properties that
     *     describe the feature.
     */
    attributes: null,

    /**
     * Property: bounds
     * {<HGIS.Bounds>} The box bounding that feature's geometry, that
     *     property can be set by an <HGIS.Format> object when
     *     deserializing the feature, so in most cases it represents an
     *     information set by the server. 
     */
    bounds: null,

    /** 
     * Property: state 
     * {String} 
     */
    state: null,
    
    /** 
     * APIProperty: style 
     * {Object} 
     */
    style: null,

    /**
     * APIProperty: url
     * {String} If this property is set it will be taken into account by
     *     {<HGIS.HTTP>} when upadting or deleting the feature.
     */
    url: null,
    
    /**
     * Property: renderIntent
     * {String} rendering intent currently being used
     */
    renderIntent: "default",
    
    /**
     * APIProperty: modified
     * {Object} An object with the originals of the geometry and attributes of
     * the feature, if they were changed. Currently this property is only read
     * by <HGIS.Format.WFST.v1>, and written by
     * <HGIS.Control.ModifyFeature>, which sets the geometry property.
     * Applications can set the originals of modified attributes in the
     * attributes property. Note that applications have to check if this
     * object and the attributes property is already created before using it.
     * After a change made with ModifyFeature, this object could look like
     *
     * (code)
     * {
     *     geometry: >Object
     * }
     * (end)
     *
     * When an application has made changes to feature attributes, it could
     * have set the attributes to something like this:
     *
     * (code)
     * {
     *     attributes: {
     *         myAttribute: "original"
     *     }
     * }
     * (end)
     *
     * Note that <HGIS.Format.WFST.v1> only checks for truthy values in
     * *modified.geometry* and the attribute names in *modified.attributes*,
     * but it is recommended to set the original values (and not just true) as
     * attribute value, so applications could use this information to undo
     * changes.
     */
    modified: null,

    /** 
     * Constructor: HGIS.Feature.Vector
     * Create a vector feature. 
     * 
     * Parameters:
     * geometry - {<HGIS.Geometry>} The geometry that this feature
     *     represents.
     * attributes - {Object} An optional object that will be mapped to the
     *     <attributes> property. 
     * style - {Object} An optional style object.
     */
    initialize: function(geometry, attributes, style) {
        HGIS.Feature.prototype.initialize.apply(this,
                                                      [null, null, attributes]);
        this.lonlat = null;
        this.geometry = geometry ? geometry : null;
        this.state = null;
        this.attributes = {};
        if (attributes) {
            this.attributes = HGIS.Util.extend(this.attributes,
                                                     attributes);
        }
        this.style = style ? style : null; 
    },
    
    /** 
     * Method: destroy
     * nullify references to prevent circular references and memory leaks
     */
    destroy: function() {
        if (this.layer) {
            this.layer.removeFeatures(this);
            this.layer = null;
        }
            
        this.geometry = null;
        this.modified = null;
        HGIS.Feature.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Method: clone
     * Create a clone of this vector feature.  Does not set any non-standard
     *     properties.
     *
     * Returns:
     * {<HGIS.Feature.Vector>} An exact clone of this vector feature.
     */
    clone: function () {
        return new HGIS.Feature.Vector(
            this.geometry ? this.geometry.clone() : null,
            this.attributes,
            this.style);
    },

    /**
     * Method: onScreen
     * Determine whether the feature is within the map viewport.  This method
     *     tests for an intersection between the geometry and the viewport
     *     bounds.  If a more effecient but less precise geometry bounds
     *     intersection is desired, call the method with the boundsOnly
     *     parameter true.
     *
     * Parameters:
     * boundsOnly - {Boolean} Only test whether a feature's bounds intersects
     *     the viewport bounds.  Default is false.  If false, the feature's
     *     geometry must intersect the viewport for onScreen to return true.
     * 
     * Returns:
     * {Boolean} The feature is currently visible on screen (optionally
     *     based on its bounds if boundsOnly is true).
     */
    onScreen:function(boundsOnly) {
        var onScreen = false;
        if(this.layer && this.layer.map) {
            var screenBounds = this.layer.map.getExtent();
            if(boundsOnly) {
                var featureBounds = this.geometry.getBounds();
                onScreen = screenBounds.intersectsBounds(featureBounds);
            } else {
                var screenPoly = screenBounds.toGeometry();
                onScreen = screenPoly.intersects(this.geometry);
            }
        }    
        return onScreen;
    },

    /**
     * Method: getVisibility
     * Determine whether the feature is displayed or not. It may not displayed
     *     because:
     *     - its style display property is set to 'none',
     *     - it doesn't belong to any layer,
     *     - the styleMap creates a symbolizer with display property set to 'none'
     *          for it,
     *     - the layer which it belongs to is not visible.
     * 
     * Returns:
     * {Boolean} The feature is currently displayed.
     */
    getVisibility: function() {
        return !(this.style && this.style.display == 'none' ||
                 !this.layer ||
                 this.layer && this.layer.styleMap &&
                 this.layer.styleMap.createSymbolizer(this, this.renderIntent).display == 'none' ||
                 this.layer && !this.layer.getVisibility());
    },
    
    /**
     * Method: createMarker
     * HACK - we need to decide if all vector features should be able to
     *     create markers
     * 
     * Returns:
     * {<HGIS.Marker>} For now just returns null
     */
    createMarker: function() {
        return null;
    },

    /**
     * Method: destroyMarker
     * HACK - we need to decide if all vector features should be able to
     *     delete markers
     * 
     * If user overrides the createMarker() function, s/he should be able
     *   to also specify an alternative function for destroying it
     */
    destroyMarker: function() {
        // pass
    },

    /**
     * Method: createPopup
     * HACK - we need to decide if all vector features should be able to
     *     create popups
     * 
     * Returns:
     * {<HGIS.Popup>} For now just returns null
     */
    createPopup: function() {
        return null;
    },

    /**
     * Method: atPoint
     * Determins whether the feature intersects with the specified location.
     * 
     * Parameters: 
     * lonlat - {<HGIS.LonLat>|Object} HGIS.LonLat or an
     *     object with a 'lon' and 'lat' properties.
     * toleranceLon - {float} Optional tolerance in Geometric Coords
     * toleranceLat - {float} Optional tolerance in Geographic Coords
     * 
     * Returns:
     * {Boolean} Whether or not the feature is at the specified location
     */
    atPoint: function(lonlat, toleranceLon, toleranceLat) {
        var atPoint = false;
        if(this.geometry) {
            atPoint = this.geometry.atPoint(lonlat, toleranceLon, 
                                                    toleranceLat);
        }
        return atPoint;
    },

    /**
     * Method: destroyPopup
     * HACK - we need to decide if all vector features should be able to
     * delete popups
     */
    destroyPopup: function() {
        // pass
    },

    /**
     * Method: move
     * Moves the feature and redraws it at its new location
     *
     * Parameters:
     * location - {<HGIS.LonLat> or <HGIS.Pixel>} the
     *         location to which to move the feature.
     */
    move: function(location) {

        if(!this.layer || !this.geometry.move){
            //do nothing if no layer or immoveable geometry
            return undefined;
        }

        var pixel;
        if (location.CLASS_NAME == "HGIS.LonLat") {
            pixel = this.layer.getViewPortPxFromLonLat(location);
        } else {
            pixel = location;
        }
        
        var lastPixel = this.layer.getViewPortPxFromLonLat(this.geometry.getBounds().getCenterLonLat());
        var res = this.layer.map.getResolution();
        this.geometry.move(res * (pixel.x - lastPixel.x),
                           res * (lastPixel.y - pixel.y));
        this.layer.drawFeature(this);
        return lastPixel;
    },
    
    /**
     * Method: toState
     * Sets the new state
     *
     * Parameters:
     * state - {String} 
     */
    toState: function(state) {
        if (state == HGIS.State.UPDATE) {
            switch (this.state) {
                case HGIS.State.UNKNOWN:
                case HGIS.State.DELETE:
                    this.state = state;
                    break;
                case HGIS.State.UPDATE:
                case HGIS.State.INSERT:
                    break;
            }
        } else if (state == HGIS.State.INSERT) {
            switch (this.state) {
                case HGIS.State.UNKNOWN:
                    break;
                default:
                    this.state = state;
                    break;
            }
        } else if (state == HGIS.State.DELETE) {
            switch (this.state) {
                case HGIS.State.INSERT:
                    // the feature should be destroyed
                    break;
                case HGIS.State.DELETE:
                    break;
                case HGIS.State.UNKNOWN:
                case HGIS.State.UPDATE:
                    this.state = state;
                    break;
            }
        } else if (state == HGIS.State.UNKNOWN) {
            this.state = state;
        }
    },
    
    CLASS_NAME: "HGIS.Feature.Vector"
});


/**
 * Constant: HGIS.Feature.Vector.style
 * HGIS features can have a number of style attributes. The 'default' 
 *     style will typically be used if no other style is specified. These
 *     styles correspond for the most part, to the styling properties defined
 *     by the SVG standard. 
 *     Information on fill properties: http://www.w3.org/TR/SVG/painting.html#FillProperties
 *     Information on stroke properties: http://www.w3.org/TR/SVG/painting.html#StrokeProperties
 *
 * Symbolizer properties:
 * fill - {Boolean} Set to false if no fill is desired.
 * fillColor - {String} Hex fill color.  Default is "#ee9900".
 * fillOpacity - {Number} Fill opacity (0-1).  Default is 0.4 
 * stroke - {Boolean} Set to false if no stroke is desired.
 * strokeColor - {String} Hex stroke color.  Default is "#ee9900".
 * strokeOpacity - {Number} Stroke opacity (0-1).  Default is 1.
 * strokeWidth - {Number} Pixel stroke width.  Default is 1.
 * strokeLinecap - {String} Stroke cap type.  Default is "round".  [butt | round | square]
 * strokeDashstyle - {String} Stroke dash style.  Default is "solid". [dot | dash | dashdot | longdash | longdashdot | solid]
 * graphic - {Boolean} Set to false if no graphic is desired.
 * pointRadius - {Number} Pixel point radius.  Default is 6.
 * pointerEvents - {String}  Default is "visiblePainted".
 * cursor - {String} Default is "".
 * externalGraphic - {String} Url to an external graphic that will be used for rendering points.
 * graphicWidth - {Number} Pixel width for sizing an external graphic.
 * graphicHeight - {Number} Pixel height for sizing an external graphic.
 * graphicOpacity - {Number} Opacity (0-1) for an external graphic.
 * graphicXOffset - {Number} Pixel offset along the positive x axis for displacing an external graphic.
 * graphicYOffset - {Number} Pixel offset along the positive y axis for displacing an external graphic.
 * rotation - {Number} For point symbolizers, this is the rotation of a graphic in the clockwise direction about its center point (or any point off center as specified by graphicXOffset and graphicYOffset).
 * graphicZIndex - {Number} The integer z-index value to use in rendering.
 * graphicName - {String} Named graphic to use when rendering points.  Supported values include "circle" (default),
 *     "square", "star", "x", "cross", "triangle".
 * graphicTitle - {String} Tooltip when hovering over a feature. *deprecated*, use title instead
 * title - {String} Tooltip when hovering over a feature. Not supported by the canvas renderer.
 * backgroundGraphic - {String} Url to a graphic to be used as the background under an externalGraphic.
 * backgroundGraphicZIndex - {Number} The integer z-index value to use in rendering the background graphic.
 * backgroundXOffset - {Number} The x offset (in pixels) for the background graphic.
 * backgroundYOffset - {Number} The y offset (in pixels) for the background graphic.
 * backgroundHeight - {Number} The height of the background graphic.  If not provided, the graphicHeight will be used.
 * backgroundWidth - {Number} The width of the background width.  If not provided, the graphicWidth will be used.
 * label - {String} The text for an optional label. For browsers that use the canvas renderer, this requires either
 *     fillText or mozDrawText to be available.
 * labelAlign - {String} Label alignment. This specifies the insertion point relative to the text. It is a string
 *     composed of two characters. The first character is for the horizontal alignment, the second for the vertical
 *     alignment. Valid values for horizontal alignment: "l"=left, "c"=center, "r"=right. Valid values for vertical
 *     alignment: "t"=top, "m"=middle, "b"=bottom. Example values: "lt", "cm", "rb". Default is "cm".
 * labelXOffset - {Number} Pixel offset along the positive x axis for displacing the label. Not supported by the canvas renderer.
 * labelYOffset - {Number} Pixel offset along the positive y axis for displacing the label. Not supported by the canvas renderer.
 * labelSelect - {Boolean} If set to true, labels will be selectable using SelectFeature or similar controls.
 *     Default is false.
 * labelOutlineColor - {String} The color of the label outline. Default is 'white'. Only supported by the canvas & SVG renderers.
 * labelOutlineWidth - {Number} The width of the label outline. Default is 3, set to 0 or null to disable. Only supported by the  SVG renderers.
 * labelOutlineOpacity - {Number} The opacity (0-1) of the label outline. Default is fontOpacity. Only supported by the canvas & SVG renderers.
 * fontColor - {String} The font color for the label, to be provided like CSS.
 * fontOpacity - {Number} Opacity (0-1) for the label
 * fontFamily - {String} The font family for the label, to be provided like in CSS.
 * fontSize - {String} The font size for the label, to be provided like in CSS.
 * fontStyle - {String} The font style for the label, to be provided like in CSS.
 * fontWeight - {String} The font weight for the label, to be provided like in CSS.
 * display - {String} Symbolizers will have no effect if display is set to "none".  All other values have no effect.
 */ 
HGIS.Feature.Vector.style = {
    'default': {
        fillColor: "#ee9900",
        fillOpacity: 0.4, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#ee9900",
        strokeOpacity: 1,
        strokeWidth: 1,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3
    },
    'select': {
        fillColor: "blue",
        fillOpacity: 0.4, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "blue",
        strokeOpacity: 1,
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "pointer",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3

    },
    'temporary': {
        fillColor: "#66cccc",
        fillOpacity: 0.2, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#66cccc",
        strokeOpacity: 1,
        strokeLinecap: "round",
        strokeWidth: 2,
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3

    },
    'delete': {
        display: "none"
    }
};    
/* ======================================================================
    HGIS/Style.js
   ====================================================================== */
/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Util.js
 * @requires HGIS/Feature/Vector.js
 */

/**
 * Class: HGIS.Style
 * This class represents a UserStyle obtained
 *     from a SLD, containing styling rules.
 */
HGIS.Style = HGIS.Class({

    /**
     * Property: id
     * {String} A unique id for this session.
     */
    id: null,
    
    /**
     * APIProperty: name
     * {String}
     */
    name: null,
    
    /**
     * Property: title
     * {String} Title of this style (set if included in SLD)
     */
    title: null,
    
    /**
     * Property: description
     * {String} Description of this style (set if abstract is included in SLD)
     */
    description: null,

    /**
     * APIProperty: layerName
     * {<String>} name of the layer that this style belongs to, usually
     * according to the NamedLayer attribute of an SLD document.
     */
    layerName: null,
    
    /**
     * APIProperty: isDefault
     * {Boolean}
     */
    isDefault: false,
     
    /** 
     * Property: rules 
     * {Array(<HGIS.Rule>)}
     */
    rules: null,
    
    /**
     * APIProperty: context
     * {Object} An optional object with properties that symbolizers' property
     * values should be evaluated against. If no context is specified,
     * feature.attributes will be used
     */
    context: null,

    /**
     * Property: defaultStyle
     * {Object} hash of style properties to use as default for merging
     * rule-based style symbolizers onto. If no rules are defined,
     * createSymbolizer will return this style. If <defaultsPerSymbolizer> is set to
     * true, the defaultStyle will only be taken into account if there are
     * rules defined.
     */
    defaultStyle: null,
    
    /**
     * Property: defaultsPerSymbolizer
     * {Boolean} If set to true, the <defaultStyle> will extend the symbolizer
     * of every rule. Properties of the <defaultStyle> will also be used to set
     * missing symbolizer properties if the symbolizer has stroke, fill or
     * graphic set to true. Default is false.
     */
    defaultsPerSymbolizer: false,
    
    /**
     * Property: propertyStyles
     * {Hash of Boolean} cache of style properties that need to be parsed for
     * propertyNames. Property names are keys, values won't be used.
     */
    propertyStyles: null,
    

    /** 
     * Constructor: HGIS.Style
     * Creates a UserStyle.
     *
     * Parameters:
     * style        - {Object} Optional hash of style properties that will be
     *                used as default style for this style object. This style
     *                applies if no rules are specified. Symbolizers defined in
     *                rules will extend this default style.
     * options - {Object} An optional object with properties to set on the
     *     style.
     *
     * Valid options:
     * rules - {Array(<HGIS.Rule>)} List of rules to be added to the
     *     style.
     * 
     * Returns:
     * {<HGIS.Style>}
     */
    initialize: function(style, options) {

        HGIS.Util.extend(this, options);
        this.rules = [];
        if(options && options.rules) {
            this.addRules(options.rules);
        }

        // use the default style from HGIS.Feature.Vector if no style
        // was given in the constructor
        this.setDefaultStyle(style ||
                             HGIS.Feature.Vector.style["default"]);

        this.id = HGIS.Util.createUniqueID(this.CLASS_NAME + "_");
    },

    /** 
     * APIMethod: destroy
     * nullify references to prevent circular references and memory leaks
     */
    destroy: function() {
        for (var i=0, len=this.rules.length; i<len; i++) {
            this.rules[i].destroy();
            this.rules[i] = null;
        }
        this.rules = null;
        this.defaultStyle = null;
    },
    
    /**
     * Method: createSymbolizer
     * creates a style by applying all feature-dependent rules to the base
     * style.
     * 
     * Parameters:
     * feature - {<HGIS.Feature>} feature to evaluate rules for
     * 
     * Returns:
     * {Object} symbolizer hash
     */
    createSymbolizer: function(feature) {
        var style = this.defaultsPerSymbolizer ? {} : this.createLiterals(
            HGIS.Util.extend({}, this.defaultStyle), feature);
        
        var rules = this.rules;

        var rule, context;
        var elseRules = [];
        var appliedRules = false;
        for(var i=0, len=rules.length; i<len; i++) {
            rule = rules[i];
            // does the rule apply?
            var applies = rule.evaluate(feature);
            if(applies) {
                if(rule instanceof HGIS.Rule && rule.elseFilter) {
                    elseRules.push(rule);
                } else {
                    appliedRules = true;
                    this.applySymbolizer(rule, style, feature);
                }
            }
        }
        
        // if no other rules apply, apply the rules with else filters
        if(appliedRules == false && elseRules.length > 0) {
            appliedRules = true;
            for(var i=0, len=elseRules.length; i<len; i++) {
                this.applySymbolizer(elseRules[i], style, feature);
            }
        }

        // don't display if there were rules but none applied
        if(rules.length > 0 && appliedRules == false) {
            style.display = "none";
        }
        
        if (style.label != null && typeof style.label !== "string") {
            style.label = String(style.label);
        }
        if(feature.type == 1 && style.label !== undefined && style.label !== "undefined")
            style.label = this.insertLinebreak(style.label, 8);
        return style;
    },
    insertLinebreak:function(textString,len){
        var length = textString.length;
        if(length > len){
            return textString.substr(0,length/2) + "\n" + textString.substr(length/2,length-1);
        }
        return textString;
    },
    /**
     * Method: applySymbolizer
     *
     * Parameters:
     * rule - {<HGIS.Rule>}
     * style - {Object}
     * feature - {<OpenLayer.Feature.Vector>}
     *
     * Returns:
     * {Object} A style with new symbolizer applied.
     */
    applySymbolizer: function(rule, style, feature) {
        var symbolizerPrefix = HGIS.Style.SYMBOLIZER_PREFIXES[0];//点符号Point
        if(feature.geometry && feature.geometry.CLASS_NAME){
            symbolizerPrefix =  this.getSymbolizerPrefix(feature.geometry);
        }else{ //矢量切片的要素数据
            if(feature.type == 2)//线
                symbolizerPrefix =  HGIS.Style.SYMBOLIZER_PREFIXES[1];//线符号Line
            else if(feature.type == 3)//面
                symbolizerPrefix =  HGIS.Style.SYMBOLIZER_PREFIXES[2];//面符号Polygon
        }

        var symbolizer = rule.symbolizer[symbolizerPrefix] || rule.symbolizer;
        
        if(this.defaultsPerSymbolizer === true) {
            var defaults = this.defaultStyle;
            HGIS.Util.applyDefaults(symbolizer, {
                pointRadius: defaults.pointRadius
            });
            if(symbolizer.stroke === true || symbolizer.graphic === true) {
                HGIS.Util.applyDefaults(symbolizer, {
                    strokeWidth: defaults.strokeWidth,
                    strokeColor: defaults.strokeColor,
                    strokeOpacity: defaults.strokeOpacity,
                    strokeDashstyle: defaults.strokeDashstyle,
                    strokeLinecap: defaults.strokeLinecap
                });
            }
            if(symbolizer.fill === true || symbolizer.graphic === true) {
                HGIS.Util.applyDefaults(symbolizer, {
                    fillColor: defaults.fillColor,
                    fillOpacity: defaults.fillOpacity
                });
            }
            if(symbolizer.graphic === true) {
                HGIS.Util.applyDefaults(symbolizer, {
                    pointRadius: this.defaultStyle.pointRadius,
                    externalGraphic: this.defaultStyle.externalGraphic,
                    graphicName: this.defaultStyle.graphicName,
                    graphicOpacity: this.defaultStyle.graphicOpacity,
                    graphicWidth: this.defaultStyle.graphicWidth,
                    graphicHeight: this.defaultStyle.graphicHeight,
                    graphicXOffset: this.defaultStyle.graphicXOffset,
                    graphicYOffset: this.defaultStyle.graphicYOffset
                });
            }
        }

        // merge the style with the current style
        return this.createLiterals(
                HGIS.Util.extend(style, symbolizer), feature);
    },
    
    /**
     * Method: createLiterals
     * creates literals for all style properties that have an entry in
     * <this.propertyStyles>.
     * 
     * Parameters:
     * style   - {Object} style to create literals for. Will be modified
     *           inline.
     * feature - {Object}
     * 
     * Returns:
     * {Object} the modified style
     */
    createLiterals: function(style, feature) {
        var context = HGIS.Util.extend({}, feature.attributes || feature.data);
        HGIS.Util.extend(context, this.context);
        
        for (var i in this.propertyStyles) {
            style[i] = HGIS.Style.createLiteral(style[i], context, feature, i);
        }
        return style;
    },
    
    /**
     * Method: findPropertyStyles
     * Looks into all rules for this style and the defaultStyle to collect
     * all the style hash property names containing ${...} strings that have
     * to be replaced using the createLiteral method before returning them.
     * 
     * Returns:
     * {Object} hash of property names that need createLiteral parsing. The
     * name of the property is the key, and the value is true;
     */
    findPropertyStyles: function() {
        var propertyStyles = {};

        // check the default style
        var style = this.defaultStyle;
        this.addPropertyStyles(propertyStyles, style);

        // walk through all rules to check for properties in their symbolizer
        var rules = this.rules;
        var symbolizer, value;
        for (var i=0, len=rules.length; i<len; i++) {
            symbolizer = rules[i].symbolizer;
            for (var key in symbolizer) {
                value = symbolizer[key];
                if (typeof value == "object") {
                    // symbolizer key is "Point", "Line" or "Polygon"
                    this.addPropertyStyles(propertyStyles, value);
                } else {
                    // symbolizer is a hash of style properties
                    this.addPropertyStyles(propertyStyles, symbolizer);
                    break;
                }
            }
        }
        return propertyStyles;
    },
    
    /**
     * Method: addPropertyStyles
     * 
     * Parameters:
     * propertyStyles - {Object} hash to add new property styles to. Will be
     *                  modified inline
     * symbolizer     - {Object} search this symbolizer for property styles
     * 
     * Returns:
     * {Object} propertyStyles hash
     */
    addPropertyStyles: function(propertyStyles, symbolizer) {
        var property;
        for (var key in symbolizer) {
            property = symbolizer[key];
            if (typeof property == "string" &&
                    property.match(/\$\{\w+\}/)) {
                propertyStyles[key] = true;
            }
        }
        return propertyStyles;
    },
    
    /**
     * APIMethod: addRules
     * Adds rules to this style.
     * 
     * Parameters:
     * rules - {Array(<HGIS.Rule>)}
     */
    addRules: function(rules) {
        Array.prototype.push.apply(this.rules, rules);
        this.propertyStyles = this.findPropertyStyles();
    },
    
    /**
     * APIMethod: setDefaultStyle
     * Sets the default style for this style object.
     * 
     * Parameters:
     * style - {Object} Hash of style properties
     */
    setDefaultStyle: function(style) {
        this.defaultStyle = style; 
        this.propertyStyles = this.findPropertyStyles();
    },
        
    /**
     * Method: getSymbolizerPrefix
     * Returns the correct symbolizer prefix according to the
     * geometry type of the passed geometry
     * 
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {String} key of the according symbolizer
     */
    getSymbolizerPrefix: function(geometry) {
        var prefixes = HGIS.Style.SYMBOLIZER_PREFIXES;
        for (var i=0, len=prefixes.length; i<len; i++) {
            if (geometry.CLASS_NAME.indexOf(prefixes[i]) != -1) {
                return prefixes[i];
            }
        }
    },
    
    /**
     * APIMethod: clone
     * Clones this style.
     * 
     * Returns:
     * {<HGIS.Style>} Clone of this style.
     */
    clone: function() {
        var options = HGIS.Util.extend({}, this);
        // clone rules
        if(this.rules) {
            options.rules = [];
            for(var i=0, len=this.rules.length; i<len; ++i) {
                options.rules.push(this.rules[i].clone());
            }
        }
        // clone context
        options.context = this.context && HGIS.Util.extend({}, this.context);
        //clone default style
        var defaultStyle = HGIS.Util.extend({}, this.defaultStyle);
        return new HGIS.Style(defaultStyle, options);
    },
    
    CLASS_NAME: "HGIS.Style"
});


/**
 * Function: createLiteral
 * converts a style value holding a combination of PropertyName and Literal
 * into a Literal, taking the property values from the passed features.
 * 
 * Parameters:
 * value - {String} value to parse. If this string contains a construct like
 *         "foo ${bar}", then "foo " will be taken as literal, and "${bar}"
 *         will be replaced by the value of the "bar" attribute of the passed
 *         feature.
 * context - {Object} context to take attribute values from
 * feature - {<HGIS.Feature.Vector>} optional feature to pass to
 *           <HGIS.String.format> for evaluating functions in the
 *           context.
 * property - {String} optional, name of the property for which the literal is
 *            being created for evaluating functions in the context.
 * 
 * Returns:
 * {String} the parsed value. In the example of the value parameter above, the
 * result would be "foo valueOfBar", assuming that the passed feature has an
 * attribute named "bar" with the value "valueOfBar".
 */
HGIS.Style.createLiteral = function(value, context, feature, property) {
    if (typeof value == "string" && value.indexOf("${") != -1) {
        value = HGIS.String.format(value, context, [feature, property]);
        value = (isNaN(value) || !value) ? value : parseFloat(value);
    }
    return value;
};
    
/**
 * Constant: HGIS.Style.SYMBOLIZER_PREFIXES
 * {Array} prefixes of the sld symbolizers. These are the
 * same as the main geometry types
 */
HGIS.Style.SYMBOLIZER_PREFIXES = ['Point', 'Line', 'Polygon', 'Text', 'Raster'];
 
/* ======================================================================
    HGIS/Filter.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Util.js
 * @requires HGIS/Style.js
 */

/**
 * Class: HGIS.Filter
 * This class represents an OGC Filter.
 */
HGIS.Filter = HGIS.Class({
    
    /** 
     * Constructor: HGIS.Filter
     * This class represents a generic filter.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     * 
     * Returns:
     * {<HGIS.Filter>}
     */
    initialize: function(options) {
        HGIS.Util.extend(this, options);
    },

    /** 
     * APIMethod: destroy
     * Remove reference to anything added.
     */
    destroy: function() {
    },

    /**
     * APIMethod: evaluate
     * Evaluates this filter in a specific context.  Instances or subclasses
     * are supposed to override this method.
     * 
     * Parameters:
     * context - {Object} Context to use in evaluating the filter.  If a vector
     *     feature is provided, the feature.attributes will be used as context.
     * 
     * Returns:
     * {Boolean} The filter applies.
     */
    evaluate: function(context) {
        return true;
    },
    
    /**
     * APIMethod: clone
     * Clones this filter. Should be implemented by subclasses.
     * 
     * Returns:
     * {<HGIS.Filter>} Clone of this filter.
     */
    clone: function() {
        return null;
    },
    
    /**
     * APIMethod: toString
     *
     * Returns:
     * {String} Include <HGIS.Format.CQL> in your build to get a CQL
     *     representation of the filter returned. Otherwise "[Object object]"
     *     will be returned.
     */
    toString: function() {
        var string;
        if (HGIS.Format && HGIS.Format.CQL) {
            string = HGIS.Format.CQL.prototype.write(this);
        } else {
            string = Object.prototype.toString.call(this);
        }
        return string;
    },
    
    CLASS_NAME: "HGIS.Filter"
});
/* ======================================================================
    HGIS/Filter/Spatial.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Filter.js
 */

/**
 * Class: HGIS.Filter.Spatial
 * This class represents a spatial filter.
 * Currently implemented: BBOX, DWithin and Intersects
 * 
 * Inherits from:
 * - <HGIS.Filter>
 */
HGIS.Filter.Spatial = HGIS.Class(HGIS.Filter, {

    /**
     * APIProperty: type
     * {String} Type of spatial filter.
     *
     * The type should be one of:
     * - HGIS.Filter.Spatial.BBOX
     * - HGIS.Filter.Spatial.INTERSECTS
     * - HGIS.Filter.Spatial.DWITHIN
     * - HGIS.Filter.Spatial.WITHIN
     * - HGIS.Filter.Spatial.CONTAINS
     */
    type: null,
    
    /**
     * APIProperty: property
     * {String} Name of the context property to compare.
     */
    property: null,
    
    /**
     * APIProperty: value
     * {<HGIS.Bounds> || <HGIS.Geometry>} The bounds or geometry
     *     to be used by the filter.  Use bounds for BBOX filters and geometry
     *     for INTERSECTS or DWITHIN filters.
     */
    value: null,

    /**
     * APIProperty: distance
     * {Number} The distance to use in a DWithin spatial filter.
     */
    distance: null,

    /**
     * APIProperty: distanceUnits
     * {String} The units to use for the distance, e.g. 'm'.
     */
    distanceUnits: null,
    
    /** 
     * Constructor: HGIS.Filter.Spatial
     * Creates a spatial filter.
     *
     * Parameters:
     * options - {Object} An optional object with properties to set on the
     *     filter.
     * 
     * Returns:
     * {<HGIS.Filter.Spatial>}
     */

   /**
    * Method: evaluate
    * Evaluates this filter for a specific feature.
    * 
    * Parameters:
    * feature - {<HGIS.Feature.Vector>} feature to apply the filter to.
    * 
    * Returns:
    * {Boolean} The feature meets filter criteria.
    */
    evaluate: function(feature) {
        var intersect = false;
        switch(this.type) {
            case HGIS.Filter.Spatial.BBOX:
            case HGIS.Filter.Spatial.INTERSECTS:
                if(feature.geometry) {
                    var geom = this.value;
                    if(this.value.CLASS_NAME == "HGIS.Bounds") {
                        geom = this.value.toGeometry();
                    }
                    if(feature.geometry.intersects(geom)) {
                        intersect = true;
                    }
                }
                break;
            default:
                throw new Error('evaluate is not implemented for this filter type.');
        }
        return intersect;
    },

    /**
     * APIMethod: clone
     * Clones this filter.
     * 
     * Returns:
     * {<HGIS.Filter.Spatial>} Clone of this filter.
     */
    clone: function() {
        var options = HGIS.Util.applyDefaults({
            value: this.value && this.value.clone && this.value.clone()
        }, this);
        return new HGIS.Filter.Spatial(options);
    },
    CLASS_NAME: "HGIS.Filter.Spatial"
});

HGIS.Filter.Spatial.BBOX = "BBOX";
HGIS.Filter.Spatial.INTERSECTS = "INTERSECTS";
HGIS.Filter.Spatial.DWITHIN = "DWITHIN";
HGIS.Filter.Spatial.WITHIN = "WITHIN";
HGIS.Filter.Spatial.CONTAINS = "CONTAINS";
/* ======================================================================
    HGIS/Filter/FeatureId.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Filter.js
 */

/**
 * Class: HGIS.Filter.FeatureId
 * This class represents a ogc:FeatureId Filter, as being used for rule-based SLD
 * styling
 * 
 * Inherits from:
 * - <HGIS.Filter>
 */
HGIS.Filter.FeatureId = HGIS.Class(HGIS.Filter, {

    /** 
     * APIProperty: fids
     * {Array(String)} Feature Ids to evaluate this rule against. 
     *     To be passed inside the params object.
     */
    fids: null,
    
    /** 
     * Property: type
     * {String} Type to identify this filter.
     */
    type: "FID",
    
    /** 
     * Constructor: HGIS.Filter.FeatureId
     * Creates an ogc:FeatureId rule.
     *
     * Parameters:
     * options - {Object} An optional object with properties to set on the
     *           rule
     * 
     * Returns:
     * {<HGIS.Filter.FeatureId>}
     */
    initialize: function(options) {
        this.fids = [];
        HGIS.Filter.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: evaluate
     * evaluates this rule for a specific feature
     * 
     * Parameters:
     * feature - {<HGIS.Feature>} feature to apply the rule to.
     *           For vector features, the check is run against the fid,
     *           for plain features against the id.
     * 
     * Returns:
     * {Boolean} true if the rule applies, false if it does not
     */
    evaluate: function(feature) {
        for (var i=0, len=this.fids.length; i<len; i++) {
            var fid = feature.fid || feature.id;
            if (fid == this.fids[i]) {
                return true;
            }
        }
        return false;
    },
    
    /**
     * APIMethod: clone
     * Clones this filter.
     * 
     * Returns:
     * {<HGIS.Filter.FeatureId>} Clone of this filter.
     */
    clone: function() {
        var filter = new HGIS.Filter.FeatureId();
        HGIS.Util.extend(filter, this);
        filter.fids = this.fids.slice();
        return filter;
    },
    
    CLASS_NAME: "HGIS.Filter.FeatureId"
});
/* ======================================================================
    HGIS/Format/WFST/v1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/WFST.js
 * @requires HGIS/Filter/Spatial.js
 * @requires HGIS/Filter/FeatureId.js
 */

/**
 * Class: HGIS.Format.WFST.v1
 * Superclass for WFST parsers.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.WFST.v1 = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs",
        gml: "http://www.opengis.net/gml",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows"
    },
    
    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "wfs",

    /**
     * Property: version
     * {String} WFS version number.
     */
    version: null,

    /**
     * Property: schemaLocation
     * {String} Schema location for a particular minor version.
     */
    schemaLocations: null,
    
    /**
     * APIProperty: srsName
     * {String} URI for spatial reference system.
     */
    srsName: null,

    /**
     * APIProperty: extractAttributes
     * {Boolean} Extract attributes from GML.  Default is true.
     */
    extractAttributes: true,
    
    /**
     * APIProperty: xy
     * {Boolean} Order of the GML coordinate true:(x,y) or false:(y,x)
     * Changing is not recommended, a new Format should be instantiated.
     */ 
    xy: true,

    /**
     * Property: stateName
     * {Object} Maps feature states to node names.
     */
    stateName: null,
    
    /**
     * Constructor: HGIS.Format.WFST.v1
     * Instances of this class are not created directly.  Use the
     *     <HGIS.Format.WFST.v1_0_0> or <HGIS.Format.WFST.v1_1_0>
     *     constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        // set state name mapping
        this.stateName = {};
        this.stateName[HGIS.State.INSERT] = "wfs:Insert";
        this.stateName[HGIS.State.UPDATE] = "wfs:Update";
        this.stateName[HGIS.State.DELETE] = "wfs:Delete";
        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Method: getSrsName
     */
    getSrsName: function(feature, options) {
        var srsName = options && options.srsName;
        if(!srsName) {
            if(feature && feature.layer) {
                srsName = feature.layer.projection.getCode();
            } else {
                srsName = this.srsName;
            }
        }
        return srsName;
    },

    /**
     * APIMethod: read
     * Parse the response from a transaction.  Because WFS is split into
     *     Transaction requests (create, update, and delete) and GetFeature
     *     requests (read), this method handles parsing of both types of
     *     responses.
     *
     * Parameters:
     * data - {String | Document} The WFST document to read
     * options - {Object} Options for the reader
     *
     * Valid options properties:
     * output - {String} either "features" or "object". The default is
     *     "features", which means that the method will return an array of
     *     features. If set to "object", an object with a "features" property
     *     and other properties read by the parser will be returned.
     *
     * Returns:
     * {Array | Object} Output depending on the output option.
     */
    read: function(data, options) {
        options = options || {};
        HGIS.Util.applyDefaults(options, {
            output: "features"
        });
        
        if(typeof data == "string") { 
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var obj = {};
        if(data) {
            this.readNode(data, obj, true);
        }
        if(obj.features && options.output === "features") {
            obj = obj.features;
        }
        return obj;
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wfs": {
            "FeatureCollection": function(node, obj) {
                obj.features = [];
                this.readChildNodes(node, obj);
            }
        }
    },
    
    /**
     * Method: write
     * Given an array of features, write a WFS transaction.  This assumes
     *     the features have a state property that determines the operation
     *     type - insert, update, or delete.
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} A list of features. See
     *     below for a more detailed description of the influence of the
     *     feature's *modified* property.
     * options - {Object}
     *
     * feature.modified rules:
     * If a feature has a modified property set, the following checks will be
     * made before a feature's geometry or attribute is included in an Update
     * transaction:
     * - *modified* is not set at all: The geometry and all attributes will be
     *     included.
     * - *modified.geometry* is set (null or a geometry): The geometry will be
     *     included. If *modified.attributes* is not set, all attributes will
     *     be included.
     * - *modified.attributes* is set: Only the attributes set (i.e. to null or
     *     a value) in *modified.attributes* will be included. 
     *     If *modified.geometry* is not set, the geometry will not be included.
     *
     * Valid options include:
     * - *multi* {Boolean} If set to true, geometries will be casted to
     *   Multi geometries before writing.
     *
     * Returns:
     * {String} A serialized WFS transaction.
     */
    write: function(features, options) {
        var node = this.writeNode("wfs:Transaction", {
            features:features,
            options: options
        });
        var value = this.schemaLocationAttr();
        if(value) {
            this.setAttributeNS(
                node, this.namespaces["xsi"], "xsi:schemaLocation",  value
            );
        }
        return HGIS.Format.XML.prototype.write.apply(this, [node]);
    },
    
    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "wfs": {
            "GetFeature": function(options) {
                var node = this.createElementNSPlus("wfs:GetFeature", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        handle: options && options.handle,
                        outputFormat: options && options.outputFormat,
                        maxFeatures: options && options.maxFeatures,
                        "xsi:schemaLocation": this.schemaLocationAttr(options)
                    }
                });
                if (typeof this.featureType == "string") {
                    this.writeNode("Query", options, node);
                } else {
                    for (var i=0,len = this.featureType.length; i<len; i++) { 
                        options.featureType = this.featureType[i]; 
                        this.writeNode("Query", options, node); 
                    } 
                }
                return node;
            },
            "Transaction": function(obj) {
                obj = obj || {};
                var options = obj.options || {};
                var node = this.createElementNSPlus("wfs:Transaction", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        handle: options.handle
                    }
                });
                var i, len;
                var features = obj.features;
                if(features) {
                    // temporarily re-assigning geometry types
                    if (options.multi === true) {
                        HGIS.Util.extend(this.geometryTypes, {
                            "HGIS.Geometry.Point": "MultiPoint",
                            "HGIS.Geometry.LineString": (this.multiCurve === true) ? "MultiCurve": "MultiLineString",
                            "HGIS.Geometry.Polygon": (this.multiSurface === true) ? "MultiSurface" : "MultiPolygon"
                        });
                    }
                    var name, feature;
                    for(i=0, len=features.length; i<len; ++i) {
                        feature = features[i];
                        name = this.stateName[feature.state];
                        if(name) {
                            this.writeNode(name, {
                                feature: feature, 
                                options: options
                            }, node);
                        }
                    }
                    // switch back to original geometry types assignment
                    if (options.multi === true) {
                        this.setGeometryTypes();
                    }
                }
                if (options.nativeElements) {
                    for (i=0, len=options.nativeElements.length; i<len; ++i) {
                        this.writeNode("wfs:Native", 
                            options.nativeElements[i], node);
                    }
                }
                return node;
            },
            "Native": function(nativeElement) {
                var node = this.createElementNSPlus("wfs:Native", {
                    attributes: {
                        vendorId: nativeElement.vendorId,
                        safeToIgnore: nativeElement.safeToIgnore
                    },
                    value: nativeElement.value
                });
                return node;
            },
            "Insert": function(obj) {
                var feature = obj.feature;
                var options = obj.options;
                var node = this.createElementNSPlus("wfs:Insert", {
                    attributes: {
                        handle: options && options.handle
                    }
                });
                this.srsName = this.getSrsName(feature);
                this.writeNode("feature:_typeName", feature, node);
                return node;
            },
            "Update": function(obj) {
                var feature = obj.feature;
                var options = obj.options;
                var node = this.createElementNSPlus("wfs:Update", {
                    attributes: {
                        handle: options && options.handle,
                        typeName: (this.featureNS ? this.featurePrefix + ":" : "") +
                            this.featureType
                    }
                });
                if(this.featureNS) {
                    node.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);
                }
                
                // add in geometry
                var modified = feature.modified;
                if (this.geometryName !== null && (!modified || modified.geometry !== undefined)) {
                    this.srsName = this.getSrsName(feature);
                    this.writeNode(
                        "Property", {name: this.geometryName, value: feature.geometry}, node
                    );
                }
        
                // add in attributes
                for(var key in feature.attributes) {
                    if(feature.attributes[key] !== undefined &&
                                (!modified || !modified.attributes ||
                                (modified.attributes && modified.attributes[key] !== undefined))) {
                        this.writeNode(
                            "Property", {name: key, value: feature.attributes[key]}, node
                        );
                    }
                }
                
                // add feature id filter
                this.writeNode("ogc:Filter", new HGIS.Filter.FeatureId({
                    fids: [feature.fid]
                }), node);
        
                return node;
            },
            "Property": function(obj) {
                var node = this.createElementNSPlus("wfs:Property");
                this.writeNode("Name", obj.name, node);
                if(obj.value !== null) {
                    this.writeNode("Value", obj.value, node);
                }
                return node;
            },
            "Name": function(name) {
                return this.createElementNSPlus("wfs:Name", {value: name});
            },
            "Value": function(obj) {
                var node;
                if(obj instanceof HGIS.Geometry) {
                    node = this.createElementNSPlus("wfs:Value");
                    var geom = this.writeNode("feature:_geometry", obj).firstChild;
                    node.appendChild(geom);
                } else {
                    node = this.createElementNSPlus("wfs:Value", {value: obj});                
                }
                return node;
            },
            "Delete": function(obj) {
                var feature = obj.feature;
                var options = obj.options;
                var node = this.createElementNSPlus("wfs:Delete", {
                    attributes: {
                        handle: options && options.handle,
                        typeName: (this.featureNS ? this.featurePrefix + ":" : "") +
                            this.featureType
                    }
                });
                if(this.featureNS) {
                    node.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);
                }
                this.writeNode("ogc:Filter", new HGIS.Filter.FeatureId({
                    fids: [feature.fid]
                }), node);
                return node;
            }
        }
    },

    /**
     * Method: schemaLocationAttr
     * Generate the xsi:schemaLocation attribute value.
     *
     * Returns:
     * {String} The xsi:schemaLocation attribute or undefined if none.
     */
    schemaLocationAttr: function(options) {
        options = HGIS.Util.extend({
            featurePrefix: this.featurePrefix,
            schema: this.schema
        }, options);
        var schemaLocations = HGIS.Util.extend({}, this.schemaLocations);
        if(options.schema) {
            schemaLocations[options.featurePrefix] = options.schema;
        }
        var parts = [];
        var uri;
        for(var key in schemaLocations) {
            uri = this.namespaces[key];
            if(uri) {
                parts.push(uri + " " + schemaLocations[key]);
            }
        }
        var value = parts.join(" ") || undefined;
        return value;
    },
    
    /**
     * Method: setFilterProperty
     * Set the property of each spatial filter.
     *
     * Parameters:
     * filter - {<HGIS.Filter>}
     */
    setFilterProperty: function(filter) {
        if(filter.filters) {
            for(var i=0, len=filter.filters.length; i<len; ++i) {
                HGIS.Format.WFST.v1.prototype.setFilterProperty.call(this, filter.filters[i]);
            }
        } else {
            if(filter instanceof HGIS.Filter.Spatial && !filter.property) {
                // got a spatial filter without property, so set it
                filter.property = this.geometryName;
            }
        }
    },

    CLASS_NAME: "HGIS.Format.WFST.v1" 

});
/* ======================================================================
    HGIS/Format/OGCExceptionReport.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 */

/**
 * Class: HGIS.Format.OGCExceptionReport
 * Class to read exception reports for various OGC services and versions.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.OGCExceptionReport = HGIS.Class(HGIS.Format.XML, {

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ogc: "http://www.opengis.net/ogc"
    },

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "ogc",

    /**
     * Constructor: HGIS.Format.OGCExceptionReport
     * Create a new parser for OGC exception reports.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read OGC exception report data from a string, and return an object with
     * information about the exceptions.
     *
     * Parameters:
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Information about the exceptions that occurred.
     */
    read: function(data) {
        var result;
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        var root = data.documentElement;
        var exceptionInfo = {exceptionReport: null}; 
        if (root) {
            this.readChildNodes(data, exceptionInfo);
            if (exceptionInfo.exceptionReport === null) {
                // fall-back to OWSCommon since this is a common output format for exceptions
                // we cannot easily use the ows readers directly since they differ for 1.0 and 1.1
                exceptionInfo = new HGIS.Format.OWSCommon().read(data);
            }
        }
        return exceptionInfo;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ogc": {
            "ServiceExceptionReport": function(node, obj) {
                obj.exceptionReport = {exceptions: []};
                this.readChildNodes(node, obj.exceptionReport);
            },
            "ServiceException": function(node, exceptionReport) {
                var exception = {
                    code: node.getAttribute("code"),
                    locator: node.getAttribute("locator"),
                    text: this.getChildValue(node)
                };
                exceptionReport.exceptions.push(exception);
            }
        }
    },
    
    CLASS_NAME: "HGIS.Format.OGCExceptionReport"
    
});
/* ======================================================================
    HGIS/Format/XML/VersionedOGC.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/OGCExceptionReport.js
 */

/**
 * Class: HGIS.Format.XML.VersionedOGC
 * Base class for versioned formats, i.e. a format which supports multiple
 * versions.
 *
 * To enable checking if parsing succeeded, you will need to define a property
 * called errorProperty on the parser you want to check. The parser will then
 * check the returned object to see if that property is present. If it is, it
 * assumes the parsing was successful. If it is not present (or is null), it will
 * pass the document through an OGCExceptionReport parser.
 * 
 * If errorProperty is undefined for the parser, this error checking mechanism
 * will be disabled.
 *
 *
 * 
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.XML.VersionedOGC = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.
     */
    defaultVersion: null,
    
    /**
     * APIProperty: version
     * {String} Specify a version string if one is known.
     */
    version: null,

    /**
     * APIProperty: profile
     * {String} If provided, use a custom profile.
     */
    profile: null,

    /**
     * APIProperty: allowFallback
     * {Boolean} If a profiled parser cannot be found for the returned version,
     * use a non-profiled parser as the fallback. Application code using this
     * should take into account that the return object structure might be
     * missing the specifics of the profile. Defaults to false.
     */
    allowFallback: false,

    /**
     * Property: name
     * {String} The name of this parser, this is the part of the CLASS_NAME
     * except for "HGIS.Format."
     */
    name: null,

    /**
     * APIProperty: stringifyOutput
     * {Boolean} If true, write will return a string otherwise a DOMElement.
     * Default is false.
     */
    stringifyOutput: false,

    /**
     * Property: parser
     * {Object} Instance of the versioned parser.  Cached for multiple read and
     *     write calls of the same version.
     */
    parser: null,

    /**
     * Constructor: HGIS.Format.XML.VersionedOGC.
     * Constructor.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on
     *     the object.
     */
    initialize: function(options) {
        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
        var className = this.CLASS_NAME;
        this.name = className.substring(className.lastIndexOf(".")+1);
    },

    /**
     * Method: getVersion
     * Returns the version to use. Subclasses can override this function
     * if a different version detection is needed.
     *
     * Parameters:
     * root - {DOMElement}
     * options - {Object} Optional configuration object.
     *
     * Returns:
     * {String} The version to use.
     */
    getVersion: function(root, options) {
        var version;
        // read
        if (root) {
            version = this.version;
            if(!version) {
                version = root.getAttribute("version");
                if(!version) {
                    version = this.defaultVersion;
                }
            }
        } else { // write
            version = (options && options.version) || 
                this.version || this.defaultVersion;
        }
        return version;
    },

    /**
     * Method: getParser
     * Get an instance of the cached parser if available, otherwise create one.
     *
     * Parameters:
     * version - {String}
     *
     * Returns:
     * {<HGIS.Format>}
     */
    getParser: function(version) {
        version = version || this.defaultVersion;
        var profile = this.profile ? "_" + this.profile : "";
        if(!this.parser || this.parser.VERSION != version) {
            var format = HGIS.Format[this.name][
                "v" + version.replace(/\./g, "_") + profile
            ];
            if(!format) {
                if (profile !== "" && this.allowFallback) {
                    // fallback to the non-profiled version of the parser
                    profile = "";
                    format = HGIS.Format[this.name][
                        "v" + version.replace(/\./g, "_")
                    ];
                }
                if (!format) {
                    throw "Can't find a " + this.name + " parser for version " +
                          version + profile;
                }
            }
            this.parser = new format(this.options);
        }
        return this.parser;
    },

    /**
     * APIMethod: write
     * Write a document.
     *
     * Parameters:
     * obj - {Object} An object representing the document.
     * options - {Object} Optional configuration object.
     *
     * Returns:
     * {String} The document as a string
     */
    write: function(obj, options) {
        var version = this.getVersion(null, options);
        this.parser = this.getParser(version);
        var root = this.parser.write(obj, options);
        if (this.stringifyOutput === false) {
            return root;
        } else {
            return HGIS.Format.XML.prototype.write.apply(this, [root]);
        }
    },

    /**
     * APIMethod: read
     * Read a doc and return an object representing the document.
     *
     * Parameters:
     * data - {String | DOMElement} Data to read.
     * options - {Object} Options for the reader.
     *
     * Returns:
     * {Object} An object representing the document.
     */
    read: function(data, options) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        var root = data.documentElement;
        var version = this.getVersion(root);
        this.parser = this.getParser(version);          // Select the parser
        var obj = this.parser.read(data, options);      // Parse the data

        var errorProperty = this.parser.errorProperty || null;
        if (errorProperty !== null && obj[errorProperty] === undefined) {
            // an error must have happened, so parse it and report back
            var format = new HGIS.Format.OGCExceptionReport();
            obj.error = format.read(data);
        }
        obj.version = version;
        return obj;
    },

    CLASS_NAME: "HGIS.Format.XML.VersionedOGC"
});
/* ======================================================================
    HGIS/Filter/Logical.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Filter.js
 */

/**
 * Class: HGIS.Filter.Logical
 * This class represents ogc:And, ogc:Or and ogc:Not rules.
 * 
 * Inherits from:
 * - <HGIS.Filter>
 */
HGIS.Filter.Logical = HGIS.Class(HGIS.Filter, {

    /**
     * APIProperty: filters
     * {Array(<HGIS.Filter>)} Child filters for this filter.
     */
    filters: null, 
     
    /**
     * APIProperty: type
     * {String} type of logical operator. Available types are:
     * - HGIS.Filter.Logical.AND = "&&";
     * - HGIS.Filter.Logical.OR  = "||";
     * - HGIS.Filter.Logical.NOT = "!";
     */
    type: null,

    /** 
     * Constructor: HGIS.Filter.Logical
     * Creates a logical filter (And, Or, Not).
     *
     * Parameters:
     * options - {Object} An optional object with properties to set on the
     *     filter.
     * 
     * Returns:
     * {<HGIS.Filter.Logical>}
     */
    initialize: function(options) {
        this.filters = [];
        HGIS.Filter.prototype.initialize.apply(this, [options]);
    },
    
    /** 
     * APIMethod: destroy
     * Remove reference to child filters.
     */
    destroy: function() {
        this.filters = null;
        HGIS.Filter.prototype.destroy.apply(this);
    },

    /**
     * APIMethod: evaluate
     * Evaluates this filter in a specific context.
     * 
     * Parameters:
     * context - {Object} Context to use in evaluating the filter.  A vector
     *     feature may also be provided to evaluate feature attributes in 
     *     comparison filters or geometries in spatial filters.
     * 
     * Returns:
     * {Boolean} The filter applies.
     */
    evaluate: function(context) {
        var i, len;
        switch(this.type) {
            case HGIS.Filter.Logical.AND:
                for (i=0, len=this.filters.length; i<len; i++) {
                    if (this.filters[i].evaluate(context) == false) {
                        return false;
                    }
                }
                return true;
                
            case HGIS.Filter.Logical.OR:
                for (i=0, len=this.filters.length; i<len; i++) {
                    if (this.filters[i].evaluate(context) == true) {
                        return true;
                    }
                }
                return false;
            
            case HGIS.Filter.Logical.NOT:
                return (!this.filters[0].evaluate(context));
        }
        return undefined;
    },
    
    /**
     * APIMethod: clone
     * Clones this filter.
     * 
     * Returns:
     * {<HGIS.Filter.Logical>} Clone of this filter.
     */
    clone: function() {
        var filters = [];        
        for(var i=0, len=this.filters.length; i<len; ++i) {
            filters.push(this.filters[i].clone());
        }
        return new HGIS.Filter.Logical({
            type: this.type,
            filters: filters
        });
    },
    
    CLASS_NAME: "HGIS.Filter.Logical"
});


HGIS.Filter.Logical.AND = "&&";
HGIS.Filter.Logical.OR  = "||";
HGIS.Filter.Logical.NOT = "!";
/* ======================================================================
    HGIS/Filter/Comparison.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Filter.js
 */

/**
 * Class: HGIS.Filter.Comparison
 * This class represents a comparison filter.
 * 
 * Inherits from:
 * - <HGIS.Filter>
 */
HGIS.Filter.Comparison = HGIS.Class(HGIS.Filter, {

    /**
     * APIProperty: type
     * {String} type: type of the comparison. This is one of
     * - HGIS.Filter.Comparison.EQUAL_TO                 = "==";
     * - HGIS.Filter.Comparison.NOT_EQUAL_TO             = "!=";
     * - HGIS.Filter.Comparison.LESS_THAN                = "<";
     * - HGIS.Filter.Comparison.GREATER_THAN             = ">";
     * - HGIS.Filter.Comparison.LESS_THAN_OR_EQUAL_TO    = "<=";
     * - HGIS.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO = ">=";
     * - HGIS.Filter.Comparison.BETWEEN                  = "..";
     * - HGIS.Filter.Comparison.LIKE                     = "~";
     * - HGIS.Filter.Comparison.IS_NULL                  = "NULL";
     */
    type: null,
    
    /**
     * APIProperty: property
     * {String}
     * name of the context property to compare
     */
    property: null,
    
    /**
     * APIProperty: value
     * {Number} or {String}
     * comparison value for binary comparisons. In the case of a String, this
     * can be a combination of text and propertyNames in the form
     * "literal ${propertyName}"
     */
    value: null,
    
    /**
     * Property: matchCase
     * {Boolean} Force case sensitive searches for EQUAL_TO and NOT_EQUAL_TO
     *     comparisons.  The Filter Encoding 1.1 specification added a matchCase
     *     attribute to ogc:PropertyIsEqualTo and ogc:PropertyIsNotEqualTo
     *     elements.  This property will be serialized with those elements only
     *     if using the v1.1.0 filter format. However, when evaluating filters
     *     here, the matchCase property will always be respected (for EQUAL_TO
     *     and NOT_EQUAL_TO).  Default is true. 
     */
    matchCase: true,
    
    /**
     * APIProperty: lowerBoundary
     * {Number} or {String}
     * lower boundary for between comparisons. In the case of a String, this
     * can be a combination of text and propertyNames in the form
     * "literal ${propertyName}"
     */
    lowerBoundary: null,
    
    /**
     * APIProperty: upperBoundary
     * {Number} or {String}
     * upper boundary for between comparisons. In the case of a String, this
     * can be a combination of text and propertyNames in the form
     * "literal ${propertyName}"
     */
    upperBoundary: null,

    /** 
     * Constructor: HGIS.Filter.Comparison
     * Creates a comparison rule.
     *
     * Parameters:
     * options - {Object} An optional object with properties to set on the
     *           rule
     * 
     * Returns:
     * {<HGIS.Filter.Comparison>}
     */
    initialize: function(options) {
        HGIS.Filter.prototype.initialize.apply(this, [options]);
        // since matchCase on PropertyIsLike is not schema compliant, we only
        // want to use this if explicitly asked for
        if (this.type === HGIS.Filter.Comparison.LIKE 
            && options.matchCase === undefined) {
                this.matchCase = null;
        }
    },

    /**
     * APIMethod: evaluate
     * Evaluates this filter in a specific context.
     * 
     * Parameters:
     * context - {Object} Context to use in evaluating the filter.  If a vector
     *     feature is provided, the feature.attributes will be used as context.
     * 
     * Returns:
     * {Boolean} The filter applies.
     */
    evaluate: function(context) {
        if (context instanceof HGIS.Feature.Vector) {
            context = context.attributes;
        }
        var result = false;
        var got = context[this.property];
        var exp;
        switch(this.type) {
            case HGIS.Filter.Comparison.EQUAL_TO:
                exp = this.value;
                if(!this.matchCase &&
                   typeof got == "string" && typeof exp == "string") {
                    result = (got.toUpperCase() == exp.toUpperCase());
                } else {
                    result = (got == exp);
                }
                break;
            case HGIS.Filter.Comparison.NOT_EQUAL_TO:
                exp = this.value;
                if(!this.matchCase &&
                   typeof got == "string" && typeof exp == "string") {
                    result = (got.toUpperCase() != exp.toUpperCase());
                } else {
                    result = (got != exp);
                }
                break;
            case HGIS.Filter.Comparison.LESS_THAN:
                result = got < this.value;
                break;
            case HGIS.Filter.Comparison.GREATER_THAN:
                result = got > this.value;
                break;
            case HGIS.Filter.Comparison.LESS_THAN_OR_EQUAL_TO:
                result = got <= this.value;
                break;
            case HGIS.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO:
                result = got >= this.value;
                break;
            case HGIS.Filter.Comparison.BETWEEN:
                result = (got >= this.lowerBoundary) &&
                    (got <= this.upperBoundary);
                break;
            case HGIS.Filter.Comparison.LIKE:
                var regexp = new RegExp(this.value, "gi");
                result = regexp.test(got);
                break;
            case HGIS.Filter.Comparison.IS_NULL:
                result = (got === null);
                break;
        }
        return result;
    },
    
    /**
     * APIMethod: value2regex
     * Converts the value of this rule into a regular expression string,
     * according to the wildcard characters specified. This method has to
     * be called after instantiation of this class, if the value is not a
     * regular expression already.
     * 
     * Parameters:
     * wildCard   - {Char} wildcard character in the above value, default
     *              is "*"
     * singleChar - {Char} single-character wildcard in the above value
     *              default is "."
     * escapeChar - {Char} escape character in the above value, default is
     *              "!"
     * 
     * Returns:
     * {String} regular expression string
     */
    value2regex: function(wildCard, singleChar, escapeChar) {
        if (wildCard == ".") {
            throw new Error("'.' is an unsupported wildCard character for " +
                            "HGIS.Filter.Comparison");
        }
        

        // set UMN MapServer defaults for unspecified parameters
        wildCard = wildCard ? wildCard : "*";
        singleChar = singleChar ? singleChar : ".";
        escapeChar = escapeChar ? escapeChar : "!";
        
        this.value = this.value.replace(
                new RegExp("\\"+escapeChar+"(.|$)", "g"), "\\$1");
        this.value = this.value.replace(
                new RegExp("\\"+singleChar, "g"), ".");
        this.value = this.value.replace(
                new RegExp("\\"+wildCard, "g"), ".*");
        this.value = this.value.replace(
                new RegExp("\\\\.\\*", "g"), "\\"+wildCard);
        this.value = this.value.replace(
                new RegExp("\\\\\\.", "g"), "\\"+singleChar);
        
        return this.value;
    },
    
    /**
     * Method: regex2value
     * Convert the value of this rule from a regular expression string into an
     *     ogc literal string using a wildCard of *, a singleChar of ., and an
     *     escape of !.  Leaves the <value> property unmodified.
     * 
     * Returns:
     * {String} A string value.
     */
    regex2value: function() {
        
        var value = this.value;
        
        // replace ! with !!
        value = value.replace(/!/g, "!!");

        // replace \. with !. (watching out for \\.)
        value = value.replace(/(\\)?\\\./g, function($0, $1) {
            return $1 ? $0 : "!.";
        });
        
        // replace \* with #* (watching out for \\*)
        value = value.replace(/(\\)?\\\*/g, function($0, $1) {
            return $1 ? $0 : "!*";
        });
        
        // replace \\ with \
        value = value.replace(/\\\\/g, "\\");

        // convert .* to * (the sequence #.* is not allowed)
        value = value.replace(/\.\*/g, "*");
        
        return value;
    },
    
    /**
     * APIMethod: clone
     * Clones this filter.
     * 
     * Returns:
     * {<HGIS.Filter.Comparison>} Clone of this filter.
     */
    clone: function() {
        return HGIS.Util.extend(new HGIS.Filter.Comparison(), this);
    },
    
    CLASS_NAME: "HGIS.Filter.Comparison"
});


HGIS.Filter.Comparison.EQUAL_TO                 = "==";
HGIS.Filter.Comparison.NOT_EQUAL_TO             = "!=";
HGIS.Filter.Comparison.LESS_THAN                = "<";
HGIS.Filter.Comparison.GREATER_THAN             = ">";
HGIS.Filter.Comparison.LESS_THAN_OR_EQUAL_TO    = "<=";
HGIS.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO = ">=";
HGIS.Filter.Comparison.BETWEEN                  = "..";
HGIS.Filter.Comparison.LIKE                     = "~";
HGIS.Filter.Comparison.IS_NULL                  = "NULL";
/* ======================================================================
    HGIS/Format/Filter.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML/VersionedOGC.js
 * @requires HGIS/Filter/FeatureId.js
 * @requires HGIS/Filter/Logical.js
 * @requires HGIS/Filter/Comparison.js
 */

/**
 * Class: HGIS.Format.Filter
 * Read/Write ogc:Filter. Create a new instance with the <HGIS.Format.Filter>
 *     constructor.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML.VersionedOGC>
 */
HGIS.Format.Filter = HGIS.Class(HGIS.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.0.0".
     */
    defaultVersion: "1.0.0",
    
    /**
     * APIMethod: write
     * Write an ogc:Filter given a filter object.
     *
     * Parameters:
     * filter - {<HGIS.Filter>} An filter.
     * options - {Object} Optional configuration object.
     *
     * Returns:
     * {Elment} An ogc:Filter element node.
     */
    
    /**
     * APIMethod: read
     * Read and Filter doc and return an object representing the Filter.
     *
     * Parameters:
     * data - {String | DOMElement} Data to read.
     *
     * Returns:
     * {<HGIS.Filter>} A filter object.
     */

    CLASS_NAME: "HGIS.Format.Filter" 
});
/* ======================================================================
    HGIS/Filter/Function.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Filter.js
 */

/**
 * Class: HGIS.Filter.Function
 * This class represents a filter function.
 * We are using this class for creation of complex 
 * filters that can contain filter functions as values.
 * Nesting function as other functions parameter is supported.
 * 
 * Inherits from:
 * - <HGIS.Filter>
 */
HGIS.Filter.Function = HGIS.Class(HGIS.Filter, {

    /**
     * APIProperty: name
     * {String} Name of the function.
     */
    name: null,
    
    /**
     * APIProperty: params
     * {Array(<HGIS.Filter.Function> || String || Number)} Function parameters
     * For now support only other Functions, String or Number
     */
    params: null,  
    
    /** 
     * Constructor: HGIS.Filter.Function
     * Creates a filter function.
     *
     * Parameters:
     * options - {Object} An optional object with properties to set on the
     *     function.
     * 
     * Returns:
     * {<HGIS.Filter.Function>}
     */

    CLASS_NAME: "HGIS.Filter.Function"
});

/* ======================================================================
    HGIS/BaseTypes/Date.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/SingleFile.js
 */

/**
 * Namespace: HGIS.Date
 * Contains implementations of Date.parse and date.toISOString that match the
 *     ECMAScript 5 specification for parsing RFC 3339 dates.
 *     http://tools.ietf.org/html/rfc3339
 */
HGIS.Date = {

    /** 
     * APIProperty: dateRegEx
     * The regex to be used for validating dates. You can provide your own
     * regex for instance for adding support for years before BC. Default
     * value is: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/
     */
    dateRegEx: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/,

    /**
     * APIMethod: toISOString
     * Generates a string representing a date.  The format of the string follows
     *     the profile of ISO 8601 for date and time on the Internet (see
     *     http://tools.ietf.org/html/rfc3339).  If the toISOString method is
     *     available on the Date prototype, that is used.  The toISOString
     *     method for Date instances is defined in ECMA-262.
     *
     * Parameters:
     * date - {Date} A date object.
     *
     * Returns:
     * {String} A string representing the date (e.g.
     *     "2010-08-07T16:58:23.123Z").  If the date does not have a valid time
     *     (i.e. isNaN(date.getTime())) this method returns the string "Invalid
     *     Date".  The ECMA standard says the toISOString method should throw
     *     RangeError in this case, but Firefox returns a string instead.  For
     *     best results, use isNaN(date.getTime()) to determine date validity
     *     before generating date strings.
     */
    toISOString: (function() {
        if ("toISOString" in Date.prototype) {
            return function(date) {
                return date.toISOString();
            };
        } else {
            return function(date) {
                var str;
                if (isNaN(date.getTime())) {
                    // ECMA-262 says throw RangeError, Firefox returns
                    // "Invalid Date"
                    str = "Invalid Date";
                } else {
                    str =
                        date.getUTCFullYear() + "-" +
                        HGIS.Number.zeroPad(date.getUTCMonth() + 1, 2) + "-" +
                        HGIS.Number.zeroPad(date.getUTCDate(), 2) + "T" +
                        HGIS.Number.zeroPad(date.getUTCHours(), 2) + ":" +
                        HGIS.Number.zeroPad(date.getUTCMinutes(), 2) + ":" +
                        HGIS.Number.zeroPad(date.getUTCSeconds(), 2) + "." +
                        HGIS.Number.zeroPad(date.getUTCMilliseconds(), 3) + "Z";
                }
                return str;
            };
        }

    })(),

    /**
     * APIMethod: parse
     * Generate a date object from a string.  The format for the string follows
     *     the profile of ISO 8601 for date and time on the Internet (see
     *     http://tools.ietf.org/html/rfc3339).  We don't call the native
     *     Date.parse because of inconsistency between implmentations.  In
     *     Chrome, calling Date.parse with a string that doesn't contain any
     *     indication of the timezone (e.g. "2011"), the date is interpreted
     *     in local time.  On Firefox, the assumption is UTC.
     *
     * Parameters:
     * str - {String} A string representing the date (e.g.
     *     "2010", "2010-08", "2010-08-07", "2010-08-07T16:58:23.123Z",
     *     "2010-08-07T11:58:23.123-06").
     *
     * Returns:
     * {Date} A date object.  If the string could not be parsed, an invalid
     *     date is returned (i.e. isNaN(date.getTime())).
     */
    parse: function(str) {
        var date;
        var match = str.match(this.dateRegEx);
        if (match && (match[1] || match[7])) { // must have at least year or time
            var year = parseInt(match[1], 10) || 0;
            var month = (parseInt(match[2], 10) - 1) || 0;
            var day = parseInt(match[3], 10) || 1;
            date = new Date(Date.UTC(year, month, day));
            // optional time
            var type = match[7];
            if (type) {
                var hours = parseInt(match[4], 10);
                var minutes = parseInt(match[5], 10);
                var secFrac = parseFloat(match[6]);
                var seconds = secFrac | 0;
                var milliseconds = Math.round(1000 * (secFrac - seconds));
                date.setUTCHours(hours, minutes, seconds, milliseconds);
                // check offset
                if (type !== "Z") {
                    var hoursOffset = parseInt(type, 10);
                    var minutesOffset = parseInt(match[8], 10) || 0;
                    var offset = -1000 * (60 * (hoursOffset * 60) + minutesOffset * 60);
                    date = new Date(date.getTime() + offset);
                }
            }
        } else {
            date = new Date("invalid");
        }
        return date;
    }
};
/* ======================================================================
    HGIS/Format/Filter/v1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */
/**
 * @requires HGIS/Format/Filter.js
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Filter/Function.js
 * @requires HGIS/BaseTypes/Date.js
 */

/**
 * Class: HGIS.Format.Filter.v1
 * Superclass for Filter version 1 parsers.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.Filter.v1 = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ogc: "http://www.opengis.net/ogc",
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "ogc",

    /**
     * Property: schemaLocation
     * {String} Schema location for a particular minor version.
     */
    schemaLocation: null,
    
    /**
     * Constructor: HGIS.Format.Filter.v1
     * Instances of this class are not created directly.  Use the
     *     <HGIS.Format.Filter> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Method: read
     *
     * Parameters:
     * data - {DOMElement} A Filter document element.
     *
     * Returns:
     * {<HGIS.Filter>} A filter object.
     */
    read: function(data) {
        var obj = {};
        this.readers.ogc["Filter"].apply(this, [data, obj]);
        return obj.filter;
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ogc": {
            "_expression": function(node) {
                // only the simplest of ogc:expression handled
                // "some text and an <PropertyName>attribute</PropertyName>"}
                var obj, value = "";
                for(var child=node.firstChild; child; child=child.nextSibling) {
                    switch(child.nodeType) {
                        case 1:
                            obj = this.readNode(child);
                            if (obj.property) {
                                value += "${" + obj.property + "}";
                            } else if (obj.value !== undefined) {
                                value += obj.value;
                            }
                            break;
                        case 3: // text node
                        case 4: // cdata section
                            value += child.nodeValue;
                    }
                }
                return value;
            },
            "Filter": function(node, parent) {
                // Filters correspond to subclasses of HGIS.Filter.
                // Since they contain information we don't persist, we
                // create a temporary object and then pass on the filter
                // (ogc:Filter) to the parent obj.
                var obj = {
                    fids: [],
                    filters: []
                };
                this.readChildNodes(node, obj);
                if(obj.fids.length > 0) {
                    parent.filter = new HGIS.Filter.FeatureId({
                        fids: obj.fids
                    });
                } else if(obj.filters.length > 0) {
                    parent.filter = obj.filters[0];
                }
            },
            "FeatureId": function(node, obj) {
                var fid = node.getAttribute("fid");
                if(fid) {
                    obj.fids.push(fid);
                }
            },
            "And": function(node, obj) {
                var filter = new HGIS.Filter.Logical({
                    type: HGIS.Filter.Logical.AND
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "Or": function(node, obj) {
                var filter = new HGIS.Filter.Logical({
                    type: HGIS.Filter.Logical.OR
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "Not": function(node, obj) {
                var filter = new HGIS.Filter.Logical({
                    type: HGIS.Filter.Logical.NOT
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLessThan": function(node, obj) {
                var filter = new HGIS.Filter.Comparison({
                    type: HGIS.Filter.Comparison.LESS_THAN
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsGreaterThan": function(node, obj) {
                var filter = new HGIS.Filter.Comparison({
                    type: HGIS.Filter.Comparison.GREATER_THAN
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLessThanOrEqualTo": function(node, obj) {
                var filter = new HGIS.Filter.Comparison({
                    type: HGIS.Filter.Comparison.LESS_THAN_OR_EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsGreaterThanOrEqualTo": function(node, obj) {
                var filter = new HGIS.Filter.Comparison({
                    type: HGIS.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsBetween": function(node, obj) {
                var filter = new HGIS.Filter.Comparison({
                    type: HGIS.Filter.Comparison.BETWEEN
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "Literal": function(node, obj) {
                obj.value = HGIS.String.numericIf(
                    this.getChildValue(node), true);
            },
            "PropertyName": function(node, filter) {
                filter.property = this.getChildValue(node);
            },
            "LowerBoundary": function(node, filter) {
                filter.lowerBoundary = HGIS.String.numericIf(
                    this.readers.ogc._expression.call(this, node), true);
            },
            "UpperBoundary": function(node, filter) {
                filter.upperBoundary = HGIS.String.numericIf(
                    this.readers.ogc._expression.call(this, node), true);
            },
            "Intersects": function(node, obj) {
                this.readSpatial(node, obj, HGIS.Filter.Spatial.INTERSECTS);
            },
            "Within": function(node, obj) {
                this.readSpatial(node, obj, HGIS.Filter.Spatial.WITHIN);
            },
            "Contains": function(node, obj) {
                this.readSpatial(node, obj, HGIS.Filter.Spatial.CONTAINS);
            },
            "DWithin": function(node, obj) {
                this.readSpatial(node, obj, HGIS.Filter.Spatial.DWITHIN);
            },
            "Distance": function(node, obj) {
                obj.distance = parseInt(this.getChildValue(node));
                obj.distanceUnits = node.getAttribute("units");
            },
            "Function": function(node, obj) {
                //TODO write decoder for it
                return;
            },
            "PropertyIsNull": function(node, obj) {
                var filter = new HGIS.Filter.Comparison({
                    type: HGIS.Filter.Comparison.IS_NULL
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            }
        }
    },
    
    /**
     * Method: readSpatial
     *
     * Read a {<HGIS.Filter.Spatial>} filter.
     * 
     * Parameters:
     * node - {DOMElement} A DOM element that contains an ogc:expression.
     * obj - {Object} The target object.
     * type - {String} One of the HGIS.Filter.Spatial.* constants.
     *
     * Returns:
     * {<HGIS.Filter.Spatial>} The created filter.
     */
    readSpatial: function(node, obj, type) {
        var filter = new HGIS.Filter.Spatial({
            type: type
        });
        this.readChildNodes(node, filter);
        filter.value = filter.components[0];
        delete filter.components;
        obj.filters.push(filter);
    },

    /**
     * APIMethod: encodeLiteral
     * Generates the string representation of a value for use in <Literal> 
     *     elements.  The default encoder writes Date values as ISO 8601 
     *     strings.
     *
     * Parameters:
     * value - {Object} Literal value to encode
     *
     * Returns:
     * {String} String representation of the provided value.
     */
    encodeLiteral: function(value) {
        if (value instanceof Date) {
            value = HGIS.Date.toISOString(value);
        }
        return value;
    },

    /**
     * Method: writeOgcExpression
     * Limited support for writing OGC expressions. Currently it supports
     * (<HGIS.Filter.Function> || String || Number)
     *
     * Parameters:
     * value - (<HGIS.Filter.Function> || String || Number)
     * node - {DOMElement} A parent DOM element 
     *
     * Returns:
     * {DOMElement} Updated node element.
     */
    writeOgcExpression: function(value, node) {
        if (value instanceof HGIS.Filter.Function){
            this.writeNode("Function", value, node);
        } else {
            this.writeNode("Literal", value, node);
        }
        return node;
    },    
    
    /**
     * Method: write
     *
     * Parameters:
     * filter - {<HGIS.Filter>} A filter object.
     *
     * Returns:
     * {DOMElement} An ogc:Filter element.
     */
    write: function(filter) {
        return this.writers.ogc["Filter"].apply(this, [filter]);
    },
    
    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "ogc": {
            "Filter": function(filter) {
                var node = this.createElementNSPlus("ogc:Filter");
                this.writeNode(this.getFilterType(filter), filter, node);
                return node;
            },
            "_featureIds": function(filter) {
                var node = this.createDocumentFragment();
                for (var i=0, ii=filter.fids.length; i<ii; ++i) {
                    this.writeNode("ogc:FeatureId", filter.fids[i], node);
                }
                return node;
            },
            "FeatureId": function(fid) {
                return this.createElementNSPlus("ogc:FeatureId", {
                    attributes: {fid: fid}
                });
            },
            "And": function(filter) {
                var node = this.createElementNSPlus("ogc:And");
                var childFilter;
                for (var i=0, ii=filter.filters.length; i<ii; ++i) {
                    childFilter = filter.filters[i];
                    this.writeNode(
                        this.getFilterType(childFilter), childFilter, node
                    );
                }
                return node;
            },
            "Or": function(filter) {
                var node = this.createElementNSPlus("ogc:Or");
                var childFilter;
                for (var i=0, ii=filter.filters.length; i<ii; ++i) {
                    childFilter = filter.filters[i];
                    this.writeNode(
                        this.getFilterType(childFilter), childFilter, node
                    );
                }
                return node;
            },
            "Not": function(filter) {
                var node = this.createElementNSPlus("ogc:Not");
                var childFilter = filter.filters[0];
                this.writeNode(
                    this.getFilterType(childFilter), childFilter, node
                );
                return node;
            },
            "PropertyIsLessThan": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLessThan");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsGreaterThan": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsGreaterThan");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsLessThanOrEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLessThanOrEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsGreaterThanOrEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsGreaterThanOrEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsBetween": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsBetween");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                this.writeNode("LowerBoundary", filter, node);
                this.writeNode("UpperBoundary", filter, node);
                return node;
            },
            "PropertyName": function(filter) {
                // no ogc:expression handling for now
                return this.createElementNSPlus("ogc:PropertyName", {
                    value: filter.property
                });
            },
            "Literal": function(value) {
                var encode = this.encodeLiteral ||
                    HGIS.Format.Filter.v1.prototype.encodeLiteral;
                return this.createElementNSPlus("ogc:Literal", {
                    value: encode(value)
                });
            },
            "LowerBoundary": function(filter) {
                // handle Literals or Functions for now
                var node = this.createElementNSPlus("ogc:LowerBoundary");
                this.writeOgcExpression(filter.lowerBoundary, node);
                return node;
            },
            "UpperBoundary": function(filter) {
                // handle Literals or Functions for now
                var node = this.createElementNSPlus("ogc:UpperBoundary");
                this.writeNode("Literal", filter.upperBoundary, node);
                return node;
            },
            "INTERSECTS": function(filter) {
                return this.writeSpatial(filter, "Intersects");
            },
            "WITHIN": function(filter) {
                return this.writeSpatial(filter, "Within");
            },
            "CONTAINS": function(filter) {
                return this.writeSpatial(filter, "Contains");
            },
            "DWITHIN": function(filter) {
                var node = this.writeSpatial(filter, "DWithin");
                this.writeNode("Distance", filter, node);
                return node;
            },
            "Distance": function(filter) {
                return this.createElementNSPlus("ogc:Distance", {
                    attributes: {
                        units: filter.distanceUnits
                    },
                    value: filter.distance
                });
            },
            "Function": function(filter) {
                var node = this.createElementNSPlus("ogc:Function", {
                    attributes: {
                        name: filter.name
                    }
                });
                var params = filter.params;
                for(var i=0, len=params.length; i<len; i++){
                    this.writeOgcExpression(params[i], node);
                }
                return node;
            },
            "PropertyIsNull": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsNull");
                this.writeNode("PropertyName", filter, node);
                return node;
            }
        }
    },

    /**
     * Method: getFilterType
     */
    getFilterType: function(filter) {
        var filterType = this.filterMap[filter.type];
        if(!filterType) {
            throw "Filter writing not supported for rule type: " + filter.type;
        }
        return filterType;
    },
    
    /**
     * Property: filterMap
     * {Object} Contains a member for each filter type.  Values are node names
     *     for corresponding OGC Filter child elements.
     */
    filterMap: {
        "&&": "And",
        "||": "Or",
        "!": "Not",
        "==": "PropertyIsEqualTo",
        "!=": "PropertyIsNotEqualTo",
        "<": "PropertyIsLessThan",
        ">": "PropertyIsGreaterThan",
        "<=": "PropertyIsLessThanOrEqualTo",
        ">=": "PropertyIsGreaterThanOrEqualTo",
        "..": "PropertyIsBetween",
        "~": "PropertyIsLike",
        "NULL": "PropertyIsNull",
        "BBOX": "BBOX",
        "DWITHIN": "DWITHIN",
        "WITHIN": "WITHIN",
        "CONTAINS": "CONTAINS",
        "INTERSECTS": "INTERSECTS",
        "FID": "_featureIds"
    },

    CLASS_NAME: "HGIS.Format.Filter.v1" 

});
/* ======================================================================
    HGIS/Geometry.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */
 
/**
 * @requires HGIS/BaseTypes/Class.js
 */

/**
 * Class: HGIS.Geometry
 * A Geometry is a description of a geographic object.  Create an instance of
 * this class with the <HGIS.Geometry> constructor.  This is a base class,
 * typical geometry types are described by subclasses of this class.
 *
 * Note that if you use the <HGIS.Geometry.fromWKT> method, you must
 * explicitly include the HGIS.Format.WKT in your build.
 */
HGIS.Geometry = HGIS.Class({

    /**
     * Property: id
     * {String} A unique identifier for this geometry.
     */
    id: null,

    /**
     * Property: parent
     * {<HGIS.Geometry>}This is set when a Geometry is added as component
     * of another geometry
     */
    parent: null,

    /**
     * Property: bounds 
     * {<HGIS.Bounds>} The bounds of this geometry
     */
    bounds: null,

    /**
     * Constructor: HGIS.Geometry
     * Creates a geometry object.  
     */
    initialize: function() {
        this.id = HGIS.Util.createUniqueID(this.CLASS_NAME+ "_");
    },
    
    /**
     * Method: destroy
     * Destroy this geometry.
     */
    destroy: function() {
        this.id = null;
        this.bounds = null;
    },
    
    /**
     * APIMethod: clone
     * Create a clone of this geometry.  Does not set any non-standard
     *     properties of the cloned geometry.
     * 
     * Returns:
     * {<HGIS.Geometry>} An exact clone of this geometry.
     */
    clone: function() {
        return new HGIS.Geometry();
    },
    
    /**
     * Method: setBounds
     * Set the bounds for this Geometry.
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>} 
     */
    setBounds: function(bounds) {
        if (bounds) {
            this.bounds = bounds.clone();
        }
    },
    
    /**
     * Method: clearBounds
     * Nullify this components bounds and that of its parent as well.
     */
    clearBounds: function() {
        this.bounds = null;
        if (this.parent) {
            this.parent.clearBounds();
        }    
    },
    
    /**
     * Method: extendBounds
     * Extend the existing bounds to include the new bounds. 
     * If geometry's bounds is not yet set, then set a new Bounds.
     * 
     * Parameters:
     * newBounds - {<HGIS.Bounds>} 
     */
    extendBounds: function(newBounds){
        var bounds = this.getBounds();
        if (!bounds) {
            this.setBounds(newBounds);
        } else {
            this.bounds.extend(newBounds);
        }
    },
    
    /**
     * APIMethod: getBounds
     * Get the bounds for this Geometry. If bounds is not set, it 
     * is calculated again, this makes queries faster.
     * 
     * Returns:
     * {<HGIS.Bounds>}
     */
    getBounds: function() {
        if (this.bounds == null) {
            this.calculateBounds();
        }
        return this.bounds;
    },
    
    /** 
     * APIMethod: calculateBounds
     * Recalculate the bounds for the geometry. 
     */
    calculateBounds: function() {
        //
        // This should be overridden by subclasses.
        //
    },
    
    /**
     * APIMethod: distanceTo
     * Calculate the closest distance between two geometries (on the x-y plane).
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>} The target geometry.
     * options - {Object} Optional properties for configuring the distance
     *     calculation.
     *
     * Valid options depend on the specific geometry type.
     * 
     * Returns:
     * {Number | Object} The distance between this geometry and the target.
     *     If details is true, the return will be an object with distance,
     *     x0, y0, x1, and x2 properties.  The x0 and y0 properties represent
     *     the coordinates of the closest point on this geometry. The x1 and y1
     *     properties represent the coordinates of the closest point on the
     *     target geometry.
     */
    distanceTo: function(geometry, options) {
    },
    
    /**
     * APIMethod: getVertices
     * Return a list of all points in this geometry.
     *
     * Parameters:
     * nodes - {Boolean} For lines, only return vertices that are
     *     endpoints.  If false, for lines, only vertices that are not
     *     endpoints will be returned.  If not provided, all vertices will
     *     be returned.
     *
     * Returns:
     * {Array} A list of all vertices in the geometry.
     */
    getVertices: function(nodes) {
    },

    /**
     * Method: atPoint
     * Note - This is only an approximation based on the bounds of the 
     * geometry.
     * 
     * Parameters:
     * lonlat - {<HGIS.LonLat>|Object} HGIS.LonLat or an
     *     object with a 'lon' and 'lat' properties.
     * toleranceLon - {float} Optional tolerance in Geometric Coords
     * toleranceLat - {float} Optional tolerance in Geographic Coords
     * 
     * Returns:
     * {Boolean} Whether or not the geometry is at the specified location
     */
    atPoint: function(lonlat, toleranceLon, toleranceLat) {
        var atPoint = false;
        var bounds = this.getBounds();
        if ((bounds != null) && (lonlat != null)) {

            var dX = (toleranceLon != null) ? toleranceLon : 0;
            var dY = (toleranceLat != null) ? toleranceLat : 0;
    
            var toleranceBounds = 
                new HGIS.Bounds(this.bounds.left - dX,
                                      this.bounds.bottom - dY,
                                      this.bounds.right + dX,
                                      this.bounds.top + dY);

            atPoint = toleranceBounds.containsLonLat(lonlat);
        }
        return atPoint;
    },
    
    /**
     * Method: getLength
     * Calculate the length of this geometry. This method is defined in
     * subclasses.
     * 
     * Returns:
     * {Float} The length of the collection by summing its parts
     */
    getLength: function() {
        //to be overridden by geometries that actually have a length
        //
        return 0.0;
    },

    /**
     * Method: getArea
     * Calculate the area of this geometry. This method is defined in subclasses.
     * 
     * Returns:
     * {Float} The area of the collection by summing its parts
     */
    getArea: function() {
        //to be overridden by geometries that actually have an area
        //
        return 0.0;
    },
    
    /**
     * APIMethod: getCentroid
     * Calculate the centroid of this geometry. This method is defined in subclasses.
     *
     * Returns:
     * {<HGIS.Geometry.Point>} The centroid of the collection
     */
    getCentroid: function() {
        return null;
    },

    /**
     * Method: toString
     * Returns a text representation of the geometry.  If the WKT format is
     *     included in a build, this will be the Well-Known Text 
     *     representation.
     *
     * Returns:
     * {String} String representation of this geometry.
     */
    toString: function() {
        var string;
        if (HGIS.Format && HGIS.Format.WKT) {
            string = HGIS.Format.WKT.prototype.write(
                new HGIS.Feature.Vector(this)
            );
        } else {
            string = Object.prototype.toString.call(this);
        }
        return string;
    },

    CLASS_NAME: "HGIS.Geometry"
});

/**
 * Function: HGIS.Geometry.fromWKT
 * Generate a geometry given a Well-Known Text string.  For this method to
 *     work, you must include the HGIS.Format.WKT in your build 
 *     explicitly.
 *
 * Parameters:
 * wkt - {String} A string representing the geometry in Well-Known Text.
 *
 * Returns:
 * {<HGIS.Geometry>} A geometry of the appropriate class.
 */
HGIS.Geometry.fromWKT = function(wkt) {
    var geom;
    if (HGIS.Format && HGIS.Format.WKT) {
        var format = HGIS.Geometry.fromWKT.format;
        if (!format) {
            format = new HGIS.Format.WKT();
            HGIS.Geometry.fromWKT.format = format;
        }
        var result = format.read(wkt);
        if (result instanceof HGIS.Feature.Vector) {
            geom = result.geometry;
        } else if (HGIS.Util.isArray(result)) {
            var len = result.length;
            var components = new Array(len);
            for (var i=0; i<len; ++i) {
                components[i] = result[i].geometry;
            }
            geom = new HGIS.Geometry.Collection(components);
        }
    }
    return geom;
};
    
/**
 * Method: HGIS.Geometry.segmentsIntersect
 * Determine whether two line segments intersect.  Optionally calculates
 *     and returns the intersection point.  This function is optimized for
 *     cases where seg1.x2 >= seg2.x1 || seg2.x2 >= seg1.x1.  In those
 *     obvious cases where there is no intersection, the function should
 *     not be called.
 *
 * Parameters:
 * seg1 - {Object} Object representing a segment with properties x1, y1, x2,
 *     and y2.  The start point is represented by x1 and y1.  The end point
 *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
 * seg2 - {Object} Object representing a segment with properties x1, y1, x2,
 *     and y2.  The start point is represented by x1 and y1.  The end point
 *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
 * options - {Object} Optional properties for calculating the intersection.
 *
 * Valid options:
 * point - {Boolean} Return the intersection point.  If false, the actual
 *     intersection point will not be calculated.  If true and the segments
 *     intersect, the intersection point will be returned.  If true and
 *     the segments do not intersect, false will be returned.  If true and
 *     the segments are coincident, true will be returned.
 * tolerance - {Number} If a non-null value is provided, if the segments are
 *     within the tolerance distance, this will be considered an intersection.
 *     In addition, if the point option is true and the calculated intersection
 *     is within the tolerance distance of an end point, the endpoint will be
 *     returned instead of the calculated intersection.  Further, if the
 *     intersection is within the tolerance of endpoints on both segments, or
 *     if two segment endpoints are within the tolerance distance of eachother
 *     (but no intersection is otherwise calculated), an endpoint on the
 *     first segment provided will be returned.
 *
 * Returns:
 * {Boolean | <HGIS.Geometry.Point>}  The two segments intersect.
 *     If the point argument is true, the return will be the intersection
 *     point or false if none exists.  If point is true and the segments
 *     are coincident, return will be true (and the instersection is equal
 *     to the shorter segment).
 */
HGIS.Geometry.segmentsIntersect = function(seg1, seg2, options) {
    var point = options && options.point;
    var tolerance = options && options.tolerance;
    var intersection = false;
    var x11_21 = seg1.x1 - seg2.x1;
    var y11_21 = seg1.y1 - seg2.y1;
    var x12_11 = seg1.x2 - seg1.x1;
    var y12_11 = seg1.y2 - seg1.y1;
    var y22_21 = seg2.y2 - seg2.y1;
    var x22_21 = seg2.x2 - seg2.x1;
    var d = (y22_21 * x12_11) - (x22_21 * y12_11);
    var n1 = (x22_21 * y11_21) - (y22_21 * x11_21);
    var n2 = (x12_11 * y11_21) - (y12_11 * x11_21);
    if(d == 0) {
        // parallel
        if(n1 == 0 && n2 == 0) {
            // coincident
            intersection = true;
        }
    } else {
        var along1 = n1 / d;
        var along2 = n2 / d;
        if(along1 >= 0 && along1 <= 1 && along2 >=0 && along2 <= 1) {
            // intersect
            if(!point) {
                intersection = true;
            } else {
                // calculate the intersection point
                var x = seg1.x1 + (along1 * x12_11);
                var y = seg1.y1 + (along1 * y12_11);
                intersection = new HGIS.Geometry.Point(x, y);
            }
        }
    }
    if(tolerance) {
        var dist;
        if(intersection) {
            if(point) {
                var segs = [seg1, seg2];
                var seg, x, y;
                // check segment endpoints for proximity to intersection
                // set intersection to first endpoint within the tolerance
                outer: for(var i=0; i<2; ++i) {
                    seg = segs[i];
                    for(var j=1; j<3; ++j) {
                        x = seg["x" + j];
                        y = seg["y" + j];
                        dist = Math.sqrt(
                            Math.pow(x - intersection.x, 2) +
                            Math.pow(y - intersection.y, 2)
                        );
                        if(dist < tolerance) {
                            intersection.x = x;
                            intersection.y = y;
                            break outer;
                        }
                    }
                }
                
            }
        } else {
            // no calculated intersection, but segments could be within
            // the tolerance of one another
            var segs = [seg1, seg2];
            var source, target, x, y, p, result;
            // check segment endpoints for proximity to intersection
            // set intersection to first endpoint within the tolerance
            outer: for(var i=0; i<2; ++i) {
                source = segs[i];
                target = segs[(i+1)%2];
                for(var j=1; j<3; ++j) {
                    p = {x: source["x"+j], y: source["y"+j]};
                    result = HGIS.Geometry.distanceToSegment(p, target);
                    if(result.distance < tolerance) {
                        if(point) {
                            intersection = new HGIS.Geometry.Point(p.x, p.y);
                        } else {
                            intersection = true;
                        }
                        break outer;
                    }
                }
            }
        }
    }
    return intersection;
};

/**
 * Function: HGIS.Geometry.distanceToSegment
 *
 * Parameters:
 * point - {Object} An object with x and y properties representing the
 *     point coordinates.
 * segment - {Object} An object with x1, y1, x2, and y2 properties
 *     representing endpoint coordinates.
 *
 * Returns:
 * {Object} An object with distance, along, x, and y properties.  The distance
 *     will be the shortest distance between the input point and segment.
 *     The x and y properties represent the coordinates along the segment
 *     where the shortest distance meets the segment. The along attribute
 *     describes how far between the two segment points the given point is.
 */
HGIS.Geometry.distanceToSegment = function(point, segment) {
    var result = HGIS.Geometry.distanceSquaredToSegment(point, segment);
    result.distance = Math.sqrt(result.distance);
    return result;
};

/**
 * Function: HGIS.Geometry.distanceSquaredToSegment
 *
 * Usually the distanceToSegment function should be used. This variant however
 * can be used for comparisons where the exact distance is not important.
 *
 * Parameters:
 * point - {Object} An object with x and y properties representing the
 *     point coordinates.
 * segment - {Object} An object with x1, y1, x2, and y2 properties
 *     representing endpoint coordinates.
 *
 * Returns:
 * {Object} An object with squared distance, along, x, and y properties.
 *     The distance will be the shortest distance between the input point and
 *     segment. The x and y properties represent the coordinates along the
 *     segment where the shortest distance meets the segment. The along
 *     attribute describes how far between the two segment points the given
 *     point is.
 */
HGIS.Geometry.distanceSquaredToSegment = function(point, segment) {
    var x0 = point.x;
    var y0 = point.y;
    var x1 = segment.x1;
    var y1 = segment.y1;
    var x2 = segment.x2;
    var y2 = segment.y2;
    var dx = x2 - x1;
    var dy = y2 - y1;
    var along = ((dx * (x0 - x1)) + (dy * (y0 - y1))) /
                (Math.pow(dx, 2) + Math.pow(dy, 2));
    var x, y;
    if(along <= 0.0) {
        x = x1;
        y = y1;
    } else if(along >= 1.0) {
        x = x2;
        y = y2;
    } else {
        x = x1 + along * dx;
        y = y1 + along * dy;
    }
    return {
        distance: Math.pow(x - x0, 2) + Math.pow(y - y0, 2),
        x: x, y: y,
        along: along
    };
};
/* ======================================================================
    HGIS/Geometry/Point.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Geometry.js
 */

/**
 * Class: HGIS.Geometry.Point
 * Point geometry class. 
 * 
 * Inherits from:
 *  - <HGIS.Geometry> 
 */
HGIS.Geometry.Point = HGIS.Class(HGIS.Geometry, {

    /** 
     * APIProperty: x 
     * {float} 
     */
    x: null,

    /** 
     * APIProperty: y 
     * {float} 
     */
    y: null,

    /**
     * Constructor: HGIS.Geometry.Point
     * Construct a point geometry.
     *
     * Parameters:
     * x - {float} 
     * y - {float}
     * 
     */
    initialize: function(x, y) {
        HGIS.Geometry.prototype.initialize.apply(this, arguments);
        
        this.x = parseFloat(x);
        this.y = parseFloat(y);
    },

    /**
     * APIMethod: clone
     * 
     * Returns:
     * {<HGIS.Geometry.Point>} An exact clone of this HGIS.Geometry.Point
     */
    clone: function(obj) {
        if (obj == null) {
            obj = new HGIS.Geometry.Point(this.x, this.y);
        }

        // catch any randomly tagged-on properties
        HGIS.Util.applyDefaults(obj, this);

        return obj;
    },

    /** 
     * Method: calculateBounds
     * Create a new Bounds based on the lon/lat
     */
    calculateBounds: function () {
        this.bounds = new HGIS.Bounds(this.x, this.y,
                                            this.x, this.y);
    },

    /**
     * APIMethod: distanceTo
     * Calculate the closest distance between two geometries (on the x-y plane).
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>} The target geometry.
     * options - {Object} Optional properties for configuring the distance
     *     calculation.
     *
     * Valid options:
     * details - {Boolean} Return details from the distance calculation.
     *     Default is false.
     * edge - {Boolean} Calculate the distance from this geometry to the
     *     nearest edge of the target geometry.  Default is true.  If true,
     *     calling distanceTo from a geometry that is wholly contained within
     *     the target will result in a non-zero distance.  If false, whenever
     *     geometries intersect, calling distanceTo will return 0.  If false,
     *     details cannot be returned.
     *
     * Returns:
     * {Number | Object} The distance between this geometry and the target.
     *     If details is true, the return will be an object with distance,
     *     x0, y0, x1, and x2 properties.  The x0 and y0 properties represent
     *     the coordinates of the closest point on this geometry. The x1 and y1
     *     properties represent the coordinates of the closest point on the
     *     target geometry.
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var distance, x0, y0, x1, y1, result;
        if(geometry instanceof HGIS.Geometry.Point) {
            x0 = this.x;
            y0 = this.y;
            x1 = geometry.x;
            y1 = geometry.y;
            distance = Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
            result = !details ?
                distance : {x0: x0, y0: y0, x1: x1, y1: y1, distance: distance};
        } else {
            result = geometry.distanceTo(this, options);
            if(details) {
                // switch coord order since this geom is target
                result = {
                    x0: result.x1, y0: result.y1,
                    x1: result.x0, y1: result.y0,
                    distance: result.distance
                };
            }
        }
        return result;
    },
    
    /** 
     * APIMethod: equals
     * Determine whether another geometry is equivalent to this one.  Geometries
     *     are considered equivalent if all components have the same coordinates.
     * 
     * Parameters:
     * geom - {<HGIS.Geometry.Point>} The geometry to test. 
     *
     * Returns:
     * {Boolean} The supplied geometry is equivalent to this geometry.
     */
    equals: function(geom) {
        var equals = false;
        if (geom != null) {
            equals = ((this.x == geom.x && this.y == geom.y) ||
                      (isNaN(this.x) && isNaN(this.y) && isNaN(geom.x) && isNaN(geom.y)));
        }
        return equals;
    },
    
    /**
     * Method: toShortString
     *
     * Returns:
     * {String} Shortened String representation of Point object. 
     *         (ex. <i>"5, 42"</i>)
     */
    toShortString: function() {
        return (this.x + ", " + this.y);
    },
    
    /**
     * APIMethod: move
     * Moves a geometry by the given displacement along positive x and y axes.
     *     This modifies the position of the geometry and clears the cached
     *     bounds.
     *
     * Parameters:
     * x - {Float} Distance to move geometry in positive x direction. 
     * y - {Float} Distance to move geometry in positive y direction.
     */
    move: function(x, y) {
        this.x = this.x + x;
        this.y = this.y + y;
        this.clearBounds();
    },

    /**
     * APIMethod: rotate
     * Rotate a point around another.
     *
     * Parameters:
     * angle - {Float} Rotation angle in degrees (measured counterclockwise
     *                 from the positive x-axis)
     * origin - {<HGIS.Geometry.Point>} Center point for the rotation
     */
    rotate: function(angle, origin) {
        angle *= Math.PI / 180;
        var radius = this.distanceTo(origin);
        var theta = angle + Math.atan2(this.y - origin.y, this.x - origin.x);
        this.x = origin.x + (radius * Math.cos(theta));
        this.y = origin.y + (radius * Math.sin(theta));
        this.clearBounds();
    },
    
    /**
     * APIMethod: getCentroid
     *
     * Returns:
     * {<HGIS.Geometry.Point>} The centroid of the collection
     */
    getCentroid: function() {
        return new HGIS.Geometry.Point(this.x, this.y);
    },

    /**
     * APIMethod: resize
     * Resize a point relative to some origin.  For points, this has the effect
     *     of scaling a vector (from the origin to the point).  This method is
     *     more useful on geometry collection subclasses.
     *
     * Parameters:
     * scale - {Float} Ratio of the new distance from the origin to the old
     *                 distance from the origin.  A scale of 2 doubles the
     *                 distance between the point and origin.
     * origin - {<HGIS.Geometry.Point>} Point of origin for resizing
     * ratio - {Float} Optional x:y ratio for resizing.  Default ratio is 1.
     * 
     * Returns:
     * {<HGIS.Geometry>} - The current geometry. 
     */
    resize: function(scale, origin, ratio) {
        ratio = (ratio == undefined) ? 1 : ratio;
        this.x = origin.x + (scale * ratio * (this.x - origin.x));
        this.y = origin.y + (scale * (this.y - origin.y));
        this.clearBounds();
        return this;
    },
    
    /**
     * APIMethod: intersects
     * Determine if the input geometry intersects this one.
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>} Any type of geometry.
     *
     * Returns:
     * {Boolean} The input geometry intersects this one.
     */
    intersects: function(geometry) {
        var intersect = false;
        if(geometry.CLASS_NAME == "HGIS.Geometry.Point") {
            intersect = this.equals(geometry);
        } else {
            intersect = geometry.intersects(this);
        }
        return intersect;
    },
    
    /**
     * APIMethod: transform
     * Translate the x,y properties of the point from source to dest.
     * 
     * Parameters:
     * source - {<HGIS.Projection>} 
     * dest - {<HGIS.Projection>}
     * 
     * Returns:
     * {<HGIS.Geometry>} 
     */
    transform: function(source, dest) {
        if ((source && dest)) {
            HGIS.Projection.transform(
                this, source, dest); 
            this.bounds = null;
        }       
        return this;
    },

    /**
     * APIMethod: getVertices
     * Return a list of all points in this geometry.
     *
     * Parameters:
     * nodes - {Boolean} For lines, only return vertices that are
     *     endpoints.  If false, for lines, only vertices that are not
     *     endpoints will be returned.  If not provided, all vertices will
     *     be returned.
     *
     * Returns:
     * {Array} A list of all vertices in the geometry.
     */
    getVertices: function(nodes) {
        return [this];
    },

    CLASS_NAME: "HGIS.Geometry.Point"
});
/* ======================================================================
    HGIS/Geometry/Collection.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Geometry.js
 */

/**
 * Class: HGIS.Geometry.Collection
 * A Collection is exactly what it sounds like: A collection of different 
 * Geometries. These are stored in the local parameter <components> (which
 * can be passed as a parameter to the constructor). 
 * 
 * As new geometries are added to the collection, they are NOT cloned. 
 * When removing geometries, they need to be specified by reference (ie you 
 * have to pass in the *exact* geometry to be removed).
 * 
 * The <getArea> and <getLength> functions here merely iterate through
 * the components, summing their respective areas and lengths.
 *
 * Create a new instance with the <HGIS.Geometry.Collection> constructor.
 *
 * Inherits from:
 *  - <HGIS.Geometry> 
 */
HGIS.Geometry.Collection = HGIS.Class(HGIS.Geometry, {

    /**
     * APIProperty: components
     * {Array(<HGIS.Geometry>)} The component parts of this geometry
     */
    components: null,
    
    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     */
    componentTypes: null,

    /**
     * Constructor: HGIS.Geometry.Collection
     * Creates a Geometry Collection -- a list of geoms.
     *
     * Parameters: 
     * components - {Array(<HGIS.Geometry>)} Optional array of geometries
     *
     */
    initialize: function (components) {
        HGIS.Geometry.prototype.initialize.apply(this, arguments);
        this.components = [];
        if (components != null) {
            this.addComponents(components);
        }
    },

    /**
     * APIMethod: destroy
     * Destroy this geometry.
     */
    destroy: function () {
        this.components.length = 0;
        this.components = null;
        HGIS.Geometry.prototype.destroy.apply(this, arguments);
    },

    /**
     * APIMethod: clone
     * Clone this geometry.
     *
     * Returns:
     * {<HGIS.Geometry.Collection>} An exact clone of this collection
     */
    clone: function() {
        var geometry = eval("new " + this.CLASS_NAME + "()");
        for(var i=0, len=this.components.length; i<len; i++) {
            geometry.addComponent(this.components[i].clone());
        }
        
        // catch any randomly tagged-on properties
        HGIS.Util.applyDefaults(geometry, this);
        
        return geometry;
    },

    /**
     * Method: getComponentsString
     * Get a string representing the components for this collection
     * 
     * Returns:
     * {String} A string representation of the components of this geometry
     */
    getComponentsString: function(){
        var strings = [];
        for(var i=0, len=this.components.length; i<len; i++) {
            strings.push(this.components[i].toShortString()); 
        }
        return strings.join(",");
    },

    /**
     * APIMethod: calculateBounds
     * Recalculate the bounds by iterating through the components and 
     * calling calling extendBounds() on each item.
     */
    calculateBounds: function() {
        this.bounds = null;
        var bounds = new HGIS.Bounds();
        var components = this.components;
        if (components) {
            for (var i=0, len=components.length; i<len; i++) {
                bounds.extend(components[i].getBounds());
            }
        }
        // to preserve old behavior, we only set bounds if non-null
        // in the future, we could add bounds.isEmpty()
        if (bounds.left != null && bounds.bottom != null && 
            bounds.right != null && bounds.top != null) {
            this.setBounds(bounds);
        }
    },

    /**
     * APIMethod: addComponents
     * Add components to this geometry.
     *
     * Parameters:
     * components - {Array(<HGIS.Geometry>)} An array of geometries to add
     */
    addComponents: function(components){
        if(!(HGIS.Util.isArray(components))) {
            components = [components];
        }
        for(var i=0, len=components.length; i<len; i++) {
            this.addComponent(components[i]);
        }
    },

    /**
     * Method: addComponent
     * Add a new component (geometry) to the collection.  If this.componentTypes
     * is set, then the component class name must be in the componentTypes array.
     *
     * The bounds cache is reset.
     * 
     * Parameters:
     * component - {<HGIS.Geometry>} A geometry to add
     * index - {int} Optional index into the array to insert the component
     *
     * Returns:
     * {Boolean} The component geometry was successfully added
     */    
    addComponent: function(component, index) {
        var added = false;
        if(component) {
            if(this.componentTypes == null ||
               (HGIS.Util.indexOf(this.componentTypes,
                                        component.CLASS_NAME) > -1)) {

                if(index != null && (index < this.components.length)) {
                    var components1 = this.components.slice(0, index);
                    var components2 = this.components.slice(index, 
                                                           this.components.length);
                    components1.push(component);
                    this.components = components1.concat(components2);
                } else {
                    this.components.push(component);
                }
                component.parent = this;
                this.clearBounds();
                added = true;
            }
        }
        return added;
    },
    
    /**
     * APIMethod: removeComponents
     * Remove components from this geometry.
     *
     * Parameters:
     * components - {Array(<HGIS.Geometry>)} The components to be removed
     *
     * Returns: 
     * {Boolean} A component was removed.
     */
    removeComponents: function(components) {
        var removed = false;

        if(!(HGIS.Util.isArray(components))) {
            components = [components];
        }
        for(var i=components.length-1; i>=0; --i) {
            removed = this.removeComponent(components[i]) || removed;
        }
        return removed;
    },
    
    /**
     * Method: removeComponent
     * Remove a component from this geometry.
     *
     * Parameters:
     * component - {<HGIS.Geometry>} 
     *
     * Returns: 
     * {Boolean} The component was removed.
     */
    removeComponent: function(component) {
        
        HGIS.Util.removeItem(this.components, component);
        
        // clearBounds() so that it gets recalculated on the next call
        // to this.getBounds();
        this.clearBounds();
        return true;
    },

    /**
     * APIMethod: getLength
     * Calculate the length of this geometry
     *
     * Returns:
     * {Float} The length of the geometry
     */
    getLength: function() {
        var length = 0.0;
        for (var i=0, len=this.components.length; i<len; i++) {
            length += this.components[i].getLength();
        }
        return length;
    },
    
    /**
     * APIMethod: getArea
     * Calculate the area of this geometry. Note how this function is overridden
     * in <HGIS.Geometry.Polygon>.
     *
     * Returns:
     * {Float} The area of the collection by summing its parts
     */
    getArea: function() {
        var area = 0.0;
        for (var i=0, len=this.components.length; i<len; i++) {
            area += this.components[i].getArea();
        }
        return area;
    },

    /** 
     * APIMethod: getGeodesicArea
     * Calculate the approximate area of the polygon were it projected onto
     *     the earth.
     *
     * Parameters:
     * projection - {<HGIS.Projection>} The spatial reference system
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
     *     assumed.
     * 
     * Reference:
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
     *
     * Returns:
     * {float} The approximate geodesic area of the geometry in square meters.
     */
    getGeodesicArea: function(projection) {
        var area = 0.0;
        for(var i=0, len=this.components.length; i<len; i++) {
            area += this.components[i].getGeodesicArea(projection);
        }
        return area;
    },
    
    /**
     * APIMethod: getCentroid
     *
     * Compute the centroid for this geometry collection.
     *
     * Parameters:
     * weighted - {Boolean} Perform the getCentroid computation recursively,
     * returning an area weighted average of all geometries in this collection.
     *
     * Returns:
     * {<HGIS.Geometry.Point>} The centroid of the collection
     */
    getCentroid: function(weighted) {
        if (!weighted) {
            return this.components.length && this.components[0].getCentroid();
        }
        var len = this.components.length;
        if (!len) {
            return false;
        }
        
        var areas = [];
        var centroids = [];
        var areaSum = 0;
        var minArea = Number.MAX_VALUE;
        var component;
        for (var i=0; i<len; ++i) {
            component = this.components[i];
            var area = component.getArea();
            var centroid = component.getCentroid(true);
            if (isNaN(area) || isNaN(centroid.x) || isNaN(centroid.y)) {
                continue;
            }
            areas.push(area);
            areaSum += area;
            minArea = (area < minArea && area > 0) ? area : minArea;
            centroids.push(centroid);
        }
        len = areas.length;
        if (areaSum === 0) {
            // all the components in this collection have 0 area
            // probably a collection of points -- weight all the points the same
            for (var i=0; i<len; ++i) {
                areas[i] = 1;
            }
            areaSum = areas.length;
        } else {
            // normalize all the areas where the smallest area will get
            // a value of 1
            for (var i=0; i<len; ++i) {
                areas[i] /= minArea;
            }
            areaSum /= minArea;
        }
        
        var xSum = 0, ySum = 0, centroid, area;
        for (var i=0; i<len; ++i) {
            centroid = centroids[i];
            area = areas[i];
            xSum += centroid.x * area;
            ySum += centroid.y * area;
        }
        
        return new HGIS.Geometry.Point(xSum/areaSum, ySum/areaSum);
    },

    /**
     * APIMethod: getGeodesicLength
     * Calculate the approximate length of the geometry were it projected onto
     *     the earth.
     *
     * projection - {<HGIS.Projection>} The spatial reference system
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
     *     assumed.
     * 
     * Returns:
     * {Float} The appoximate geodesic length of the geometry in meters.
     */
    getGeodesicLength: function(projection) {
        var length = 0.0;
        for(var i=0, len=this.components.length; i<len; i++) {
            length += this.components[i].getGeodesicLength(projection);
        }
        return length;
    },

    /**
     * APIMethod: move
     * Moves a geometry by the given displacement along positive x and y axes.
     *     This modifies the position of the geometry and clears the cached
     *     bounds.
     *
     * Parameters:
     * x - {Float} Distance to move geometry in positive x direction. 
     * y - {Float} Distance to move geometry in positive y direction.
     */
    move: function(x, y) {
        for(var i=0, len=this.components.length; i<len; i++) {
            this.components[i].move(x, y);
        }
    },

    /**
     * APIMethod: rotate
     * Rotate a geometry around some origin
     *
     * Parameters:
     * angle - {Float} Rotation angle in degrees (measured counterclockwise
     *                 from the positive x-axis)
     * origin - {<HGIS.Geometry.Point>} Center point for the rotation
     */
    rotate: function(angle, origin) {
        for(var i=0, len=this.components.length; i<len; ++i) {
            this.components[i].rotate(angle, origin);
        }
    },

    /**
     * APIMethod: resize
     * Resize a geometry relative to some origin.  Use this method to apply
     *     a uniform scaling to a geometry.
     *
     * Parameters:
     * scale - {Float} Factor by which to scale the geometry.  A scale of 2
     *                 doubles the size of the geometry in each dimension
     *                 (lines, for example, will be twice as long, and polygons
     *                 will have four times the area).
     * origin - {<HGIS.Geometry.Point>} Point of origin for resizing
     * ratio - {Float} Optional x:y ratio for resizing.  Default ratio is 1.
     * 
     * Returns:
     * {<HGIS.Geometry>} - The current geometry. 
     */
    resize: function(scale, origin, ratio) {
        for(var i=0; i<this.components.length; ++i) {
            this.components[i].resize(scale, origin, ratio);
        }
        return this;
    },

    /**
     * APIMethod: distanceTo
     * Calculate the closest distance between two geometries (on the x-y plane).
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>} The target geometry.
     * options - {Object} Optional properties for configuring the distance
     *     calculation.
     *
     * Valid options:
     * details - {Boolean} Return details from the distance calculation.
     *     Default is false.
     * edge - {Boolean} Calculate the distance from this geometry to the
     *     nearest edge of the target geometry.  Default is true.  If true,
     *     calling distanceTo from a geometry that is wholly contained within
     *     the target will result in a non-zero distance.  If false, whenever
     *     geometries intersect, calling distanceTo will return 0.  If false,
     *     details cannot be returned.
     *
     * Returns:
     * {Number | Object} The distance between this geometry and the target.
     *     If details is true, the return will be an object with distance,
     *     x0, y0, x1, and y1 properties.  The x0 and y0 properties represent
     *     the coordinates of the closest point on this geometry. The x1 and y1
     *     properties represent the coordinates of the closest point on the
     *     target geometry.
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var result, best, distance;
        var min = Number.POSITIVE_INFINITY;
        for(var i=0, len=this.components.length; i<len; ++i) {
            result = this.components[i].distanceTo(geometry, options);
            distance = details ? result.distance : result;
            if(distance < min) {
                min = distance;
                best = result;
                if(min == 0) {
                    break;
                }
            }
        }
        return best;
    },

    /** 
     * APIMethod: equals
     * Determine whether another geometry is equivalent to this one.  Geometries
     *     are considered equivalent if all components have the same coordinates.
     * 
     * Parameters:
     * geometry - {<HGIS.Geometry>} The geometry to test. 
     *
     * Returns:
     * {Boolean} The supplied geometry is equivalent to this geometry.
     */
    equals: function(geometry) {
        var equivalent = true;
        if(!geometry || !geometry.CLASS_NAME ||
           (this.CLASS_NAME != geometry.CLASS_NAME)) {
            equivalent = false;
        } else if(!(HGIS.Util.isArray(geometry.components)) ||
                  (geometry.components.length != this.components.length)) {
            equivalent = false;
        } else {
            for(var i=0, len=this.components.length; i<len; ++i) {
                if(!this.components[i].equals(geometry.components[i])) {
                    equivalent = false;
                    break;
                }
            }
        }
        return equivalent;
    },

    /**
     * APIMethod: transform
     * Reproject the components geometry from source to dest.
     * 
     * Parameters:
     * source - {<HGIS.Projection>} 
     * dest - {<HGIS.Projection>}
     * 
     * Returns:
     * {<HGIS.Geometry>} 
     */
    transform: function(source, dest) {
        if (source && dest) {
            for (var i=0, len=this.components.length; i<len; i++) {  
                var component = this.components[i];
                component.transform(source, dest);
            }
            this.bounds = null;
        }
        return this;
    },

    /**
     * APIMethod: intersects
     * Determine if the input geometry intersects this one.
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>} Any type of geometry.
     *
     * Returns:
     * {Boolean} The input geometry intersects this one.
     */
    intersects: function(geometry) {
        var intersect = false;
        for(var i=0, len=this.components.length; i<len; ++ i) {
            intersect = geometry.intersects(this.components[i]);
            if(intersect) {
                break;
            }
        }
        return intersect;
    },

    /**
     * APIMethod: getVertices
     * Return a list of all points in this geometry.
     *
     * Parameters:
     * nodes - {Boolean} For lines, only return vertices that are
     *     endpoints.  If false, for lines, only vertices that are not
     *     endpoints will be returned.  If not provided, all vertices will
     *     be returned.
     *
     * Returns:
     * {Array} A list of all vertices in the geometry.
     */
    getVertices: function(nodes) {
        var vertices = [];
        for(var i=0, len=this.components.length; i<len; ++i) {
            Array.prototype.push.apply(
                vertices, this.components[i].getVertices(nodes)
            );
        }
        return vertices;
    },


    CLASS_NAME: "HGIS.Geometry.Collection"
});
/* ======================================================================
    HGIS/Geometry/MultiPoint.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Geometry/Collection.js
 * @requires HGIS/Geometry/Point.js
 */

/**
 * Class: HGIS.Geometry.MultiPoint
 * MultiPoint is a collection of Points.  Create a new instance with the
 * <HGIS.Geometry.MultiPoint> constructor.
 *
 * Inherits from:
 *  - <HGIS.Geometry.Collection>
 *  - <HGIS.Geometry>
 */
HGIS.Geometry.MultiPoint = HGIS.Class(
  HGIS.Geometry.Collection, {

    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     */
    componentTypes: ["HGIS.Geometry.Point"],

    /**
     * Constructor: HGIS.Geometry.MultiPoint
     * Create a new MultiPoint Geometry
     *
     * Parameters:
     * components - {Array(<HGIS.Geometry.Point>)} 
     *
     * Returns:
     * {<HGIS.Geometry.MultiPoint>}
     */

    /**
     * APIMethod: addPoint
     * Wrapper for <HGIS.Geometry.Collection.addComponent>
     *
     * Parameters:
     * point - {<HGIS.Geometry.Point>} Point to be added
     * index - {Integer} Optional index
     */
    addPoint: function(point, index) {
        this.addComponent(point, index);
    },
    
    /**
     * APIMethod: removePoint
     * Wrapper for <HGIS.Geometry.Collection.removeComponent>
     *
     * Parameters:
     * point - {<HGIS.Geometry.Point>} Point to be removed
     */
    removePoint: function(point){
        this.removeComponent(point);
    },

    CLASS_NAME: "HGIS.Geometry.MultiPoint"
});
/* ======================================================================
    HGIS/Geometry/Curve.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Geometry/MultiPoint.js
 */

/**
 * Class: HGIS.Geometry.Curve
 * A Curve is a MultiPoint, whose points are assumed to be connected. To 
 * this end, we provide a "getLength()" function, which iterates through 
 * the points, summing the distances between them. 
 * 
 * Inherits: 
 *  - <HGIS.Geometry.MultiPoint>
 */
HGIS.Geometry.Curve = HGIS.Class(HGIS.Geometry.MultiPoint, {

    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of 
     *                 components that the collection can include.  A null 
     *                 value means the component types are not restricted.
     */
    componentTypes: ["HGIS.Geometry.Point"],

    /**
     * Constructor: HGIS.Geometry.Curve
     * 
     * Parameters:
     * point - {Array(<HGIS.Geometry.Point>)}
     */
    
    /**
     * APIMethod: getLength
     * 
     * Returns:
     * {Float} The length of the curve
     */
    getLength: function() {
        var length = 0.0;
        if ( this.components && (this.components.length > 1)) {
            for(var i=1, len=this.components.length; i<len; i++) {
                length += this.components[i-1].distanceTo(this.components[i]);
            }
        }
        return length;
    },

    /**
     * APIMethod: getGeodesicLength
     * Calculate the approximate length of the geometry were it projected onto
     *     the earth.
     *
     * projection - {<HGIS.Projection>} The spatial reference system
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
     *     assumed.
     * 
     * Returns:
     * {Float} The appoximate geodesic length of the geometry in meters.
     */
    getGeodesicLength: function(projection) {
        var geom = this;  // so we can work with a clone if needed
        if(projection) {
            var gg = new HGIS.Projection("EPSG:4326");
            if(!gg.equals(projection)) {
                geom = this.clone().transform(projection, gg);
            }
        }
        var length = 0.0;
        if(geom.components && (geom.components.length > 1)) {
            var p1, p2;
            for(var i=1, len=geom.components.length; i<len; i++) {
                p1 = geom.components[i-1];
                p2 = geom.components[i];
                // this returns km and requires lon/lat properties
                length += HGIS.Util.distVincenty(
                    {lon: p1.x, lat: p1.y}, {lon: p2.x, lat: p2.y}
                );
            }
        }
        // convert to m
        return length * 1000;
    },

    CLASS_NAME: "HGIS.Geometry.Curve"
});
/* ======================================================================
    HGIS/Geometry/LineString.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Geometry/Curve.js
 */

/**
 * Class: HGIS.Geometry.LineString
 * A LineString is a Curve which, once two points have been added to it, can 
 * never be less than two points long.
 * 
 * Inherits from:
 *  - <HGIS.Geometry.Curve>
 */
HGIS.Geometry.LineString = HGIS.Class(HGIS.Geometry.Curve, {

    /**
     * Constructor: HGIS.Geometry.LineString
     * Create a new LineString geometry
     *
     * Parameters:
     * points - {Array(<HGIS.Geometry.Point>)} An array of points used to
     *          generate the linestring
     *
     */

    /**
     * APIMethod: removeComponent
     * Only allows removal of a point if there are three or more points in 
     * the linestring. (otherwise the result would be just a single point)
     *
     * Parameters: 
     * point - {<HGIS.Geometry.Point>} The point to be removed
     *
     * Returns: 
     * {Boolean} The component was removed.
     */
    removeComponent: function(point) {
        var removed = this.components && (this.components.length > 2);
        if (removed) {
            HGIS.Geometry.Collection.prototype.removeComponent.apply(this, 
                                                                  arguments);
        }
        return removed;
    },
    
    /**
     * APIMethod: intersects
     * Test for instersection between two geometries.  This is a cheapo
     *     implementation of the Bently-Ottmann algorigithm.  It doesn't
     *     really keep track of a sweep line data structure.  It is closer
     *     to the brute force method, except that segments are sorted and
     *     potential intersections are only calculated when bounding boxes
     *     intersect.
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     *
     * Returns:
     * {Boolean} The input geometry intersects this geometry.
     */
    intersects: function(geometry) {
        var intersect = false;
        var type = geometry.CLASS_NAME;
        if(type == "HGIS.Geometry.LineString" ||
           type == "HGIS.Geometry.LinearRing" ||
           type == "HGIS.Geometry.Point") {
            var segs1 = this.getSortedSegments();
            var segs2;
            if(type == "HGIS.Geometry.Point") {
                segs2 = [{
                    x1: geometry.x, y1: geometry.y,
                    x2: geometry.x, y2: geometry.y
                }];
            } else {
                segs2 = geometry.getSortedSegments();
            }
            var seg1, seg1x1, seg1x2, seg1y1, seg1y2,
                seg2, seg2y1, seg2y2;
            // sweep right
            outer: for(var i=0, len=segs1.length; i<len; ++i) {
                seg1 = segs1[i];
                seg1x1 = seg1.x1;
                seg1x2 = seg1.x2;
                seg1y1 = seg1.y1;
                seg1y2 = seg1.y2;
                inner: for(var j=0, jlen=segs2.length; j<jlen; ++j) {
                    seg2 = segs2[j];
                    if(seg2.x1 > seg1x2) {
                        // seg1 still left of seg2
                        break;
                    }
                    if(seg2.x2 < seg1x1) {
                        // seg2 still left of seg1
                        continue;
                    }
                    seg2y1 = seg2.y1;
                    seg2y2 = seg2.y2;
                    if(Math.min(seg2y1, seg2y2) > Math.max(seg1y1, seg1y2)) {
                        // seg2 above seg1
                        continue;
                    }
                    if(Math.max(seg2y1, seg2y2) < Math.min(seg1y1, seg1y2)) {
                        // seg2 below seg1
                        continue;
                    }
                    if(HGIS.Geometry.segmentsIntersect(seg1, seg2)) {
                        intersect = true;
                        break outer;
                    }
                }
            }
        } else {
            intersect = geometry.intersects(this);
        }
        return intersect;
    },
    
    /**
     * Method: getSortedSegments
     *
     * Returns:
     * {Array} An array of segment objects.  Segment objects have properties
     *     x1, y1, x2, and y2.  The start point is represented by x1 and y1.
     *     The end point is represented by x2 and y2.  Start and end are
     *     ordered so that x1 < x2.
     */
    getSortedSegments: function() {
        var numSeg = this.components.length - 1;
        var segments = new Array(numSeg), point1, point2;
        for(var i=0; i<numSeg; ++i) {
            point1 = this.components[i];
            point2 = this.components[i + 1];
            if(point1.x < point2.x) {
                segments[i] = {
                    x1: point1.x,
                    y1: point1.y,
                    x2: point2.x,
                    y2: point2.y
                };
            } else {
                segments[i] = {
                    x1: point2.x,
                    y1: point2.y,
                    x2: point1.x,
                    y2: point1.y
                };
            }
        }
        // more efficient to define this somewhere static
        function byX1(seg1, seg2) {
            return seg1.x1 - seg2.x1;
        }
        return segments.sort(byX1);
    },
    
    /**
     * Method: splitWithSegment
     * Split this geometry with the given segment.
     *
     * Parameters:
     * seg - {Object} An object with x1, y1, x2, and y2 properties referencing
     *     segment endpoint coordinates.
     * options - {Object} Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source segment must be within the
     *     tolerance distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of one of the source segment's
     *     endpoints will be assumed to occur at the endpoint.
     *
     * Returns:
     * {Object} An object with *lines* and *points* properties.  If the given
     *     segment intersects this linestring, the lines array will reference
     *     geometries that result from the split.  The points array will contain
     *     all intersection points.  Intersection points are sorted along the
     *     segment (in order from x1,y1 to x2,y2).
     */
    splitWithSegment: function(seg, options) {
        var edge = !(options && options.edge === false);
        var tolerance = options && options.tolerance;
        var lines = [];
        var verts = this.getVertices();
        var points = [];
        var intersections = [];
        var split = false;
        var vert1, vert2, point;
        var node, vertex, target;
        var interOptions = {point: true, tolerance: tolerance};
        var result = null;
        for(var i=0, stop=verts.length-2; i<=stop; ++i) {
            vert1 = verts[i];
            points.push(vert1.clone());
            vert2 = verts[i+1];
            target = {x1: vert1.x, y1: vert1.y, x2: vert2.x, y2: vert2.y};
            point = HGIS.Geometry.segmentsIntersect(
                seg, target, interOptions
            );
            if(point instanceof HGIS.Geometry.Point) {
                if((point.x === seg.x1 && point.y === seg.y1) ||
                   (point.x === seg.x2 && point.y === seg.y2) ||
                   point.equals(vert1) || point.equals(vert2)) {
                    vertex = true;
                } else {
                    vertex = false;
                }
                if(vertex || edge) {
                    // push intersections different than the previous
                    if(!point.equals(intersections[intersections.length-1])) {
                        intersections.push(point.clone());
                    }
                    if(i === 0) {
                        if(point.equals(vert1)) {
                            continue;
                        }
                    }
                    if(point.equals(vert2)) {
                        continue;
                    }
                    split = true;
                    if(!point.equals(vert1)) {
                        points.push(point);
                    }
                    lines.push(new HGIS.Geometry.LineString(points));
                    points = [point.clone()];
                }
            }
        }
        if(split) {
            points.push(vert2.clone());
            lines.push(new HGIS.Geometry.LineString(points));
        }
        if(intersections.length > 0) {
            // sort intersections along segment
            var xDir = seg.x1 < seg.x2 ? 1 : -1;
            var yDir = seg.y1 < seg.y2 ? 1 : -1;
            result = {
                lines: lines,
                points: intersections.sort(function(p1, p2) {
                    return (xDir * p1.x - xDir * p2.x) || (yDir * p1.y - yDir * p2.y);
                })
            };
        }
        return result;
    },

    /**
     * Method: split
     * Use this geometry (the source) to attempt to split a target geometry.
     * 
     * Parameters:
     * target - {<HGIS.Geometry>} The target geometry.
     * options - {Object} Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * Returns:
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     */
    split: function(target, options) {
        var results = null;
        var mutual = options && options.mutual;
        var sourceSplit, targetSplit, sourceParts, targetParts;
        if(target instanceof HGIS.Geometry.LineString) {
            var verts = this.getVertices();
            var vert1, vert2, seg, splits, lines, point;
            var points = [];
            sourceParts = [];
            for(var i=0, stop=verts.length-2; i<=stop; ++i) {
                vert1 = verts[i];
                vert2 = verts[i+1];
                seg = {
                    x1: vert1.x, y1: vert1.y,
                    x2: vert2.x, y2: vert2.y
                };
                targetParts = targetParts || [target];
                if(mutual) {
                    points.push(vert1.clone());
                }
                for(var j=0; j<targetParts.length; ++j) {
                    splits = targetParts[j].splitWithSegment(seg, options);
                    if(splits) {
                        // splice in new features
                        lines = splits.lines;
                        if(lines.length > 0) {
                            lines.unshift(j, 1);
                            Array.prototype.splice.apply(targetParts, lines);
                            j += lines.length - 2;
                        }
                        if(mutual) {
                            for(var k=0, len=splits.points.length; k<len; ++k) {
                                point = splits.points[k];
                                if(!point.equals(vert1)) {
                                    points.push(point);
                                    sourceParts.push(new HGIS.Geometry.LineString(points));
                                    if(point.equals(vert2)) {
                                        points = [];
                                    } else {
                                        points = [point.clone()];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if(mutual && sourceParts.length > 0 && points.length > 0) {
                points.push(vert2.clone());
                sourceParts.push(new HGIS.Geometry.LineString(points));
            }
        } else {
            results = target.splitWith(this, options);
        }
        if(targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if(sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if(targetSplit || sourceSplit) {
            if(mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },

    /**
     * Method: splitWith
     * Split this geometry (the target) with the given geometry (the source).
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>} A geometry used to split this
     *     geometry (the source).
     * options - {Object} Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * Returns:
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     */
    splitWith: function(geometry, options) {
        return geometry.split(this, options);

    },

    /**
     * APIMethod: getVertices
     * Return a list of all points in this geometry.
     *
     * Parameters:
     * nodes - {Boolean} For lines, only return vertices that are
     *     endpoints.  If false, for lines, only vertices that are not
     *     endpoints will be returned.  If not provided, all vertices will
     *     be returned.
     *
     * Returns:
     * {Array} A list of all vertices in the geometry.
     */
    getVertices: function(nodes) {
        var vertices;
        if(nodes === true) {
            vertices = [
                this.components[0],
                this.components[this.components.length-1]
            ];
        } else if (nodes === false) {
            vertices = this.components.slice(1, this.components.length-1);
        } else {
            vertices = this.components.slice();
        }
        return vertices;
    },

    /**
     * APIMethod: distanceTo
     * Calculate the closest distance between two geometries (on the x-y plane).
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>} The target geometry.
     * options - {Object} Optional properties for configuring the distance
     *     calculation.
     *
     * Valid options:
     * details - {Boolean} Return details from the distance calculation.
     *     Default is false.
     * edge - {Boolean} Calculate the distance from this geometry to the
     *     nearest edge of the target geometry.  Default is true.  If true,
     *     calling distanceTo from a geometry that is wholly contained within
     *     the target will result in a non-zero distance.  If false, whenever
     *     geometries intersect, calling distanceTo will return 0.  If false,
     *     details cannot be returned.
     *
     * Returns:
     * {Number | Object} The distance between this geometry and the target.
     *     If details is true, the return will be an object with distance,
     *     x0, y0, x1, and x2 properties.  The x0 and y0 properties represent
     *     the coordinates of the closest point on this geometry. The x1 and y1
     *     properties represent the coordinates of the closest point on the
     *     target geometry.
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var result, best = {};
        var min = Number.POSITIVE_INFINITY;
        if(geometry instanceof HGIS.Geometry.Point) {
            var segs = this.getSortedSegments();
            var x = geometry.x;
            var y = geometry.y;
            var seg;
            for(var i=0, len=segs.length; i<len; ++i) {
                seg = segs[i];
                result = HGIS.Geometry.distanceToSegment(geometry, seg);
                if(result.distance < min) {
                    min = result.distance;
                    best = result;
                    if(min === 0) {
                        break;
                    }
                } else {
                    // if distance increases and we cross y0 to the right of x0, no need to keep looking.
                    if(seg.x2 > x && ((y > seg.y1 && y < seg.y2) || (y < seg.y1 && y > seg.y2))) {
                        break;
                    }
                }
            }
            if(details) {
                best = {
                    distance: best.distance,
                    x0: best.x, y0: best.y,
                    x1: x, y1: y
                };
            } else {
                best = best.distance;
            }
        } else if(geometry instanceof HGIS.Geometry.LineString) { 
            var segs0 = this.getSortedSegments();
            var segs1 = geometry.getSortedSegments();
            var seg0, seg1, intersection, x0, y0;
            var len1 = segs1.length;
            var interOptions = {point: true};
            outer: for(var i=0, len=segs0.length; i<len; ++i) {
                seg0 = segs0[i];
                x0 = seg0.x1;
                y0 = seg0.y1;
                for(var j=0; j<len1; ++j) {
                    seg1 = segs1[j];
                    intersection = HGIS.Geometry.segmentsIntersect(seg0, seg1, interOptions);
                    if(intersection) {
                        min = 0;
                        best = {
                            distance: 0,
                            x0: intersection.x, y0: intersection.y,
                            x1: intersection.x, y1: intersection.y
                        };
                        break outer;
                    } else {
                        result = HGIS.Geometry.distanceToSegment({x: x0, y: y0}, seg1);
                        if(result.distance < min) {
                            min = result.distance;
                            best = {
                                distance: min,
                                x0: x0, y0: y0,
                                x1: result.x, y1: result.y
                            };
                        }
                    }
                }
            }
            if(!details) {
                best = best.distance;
            }
            if(min !== 0) {
                // check the final vertex in this line's sorted segments
                if(seg0) {
                    result = geometry.distanceTo(
                        new HGIS.Geometry.Point(seg0.x2, seg0.y2),
                        options
                    );
                    var dist = details ? result.distance : result;
                    if(dist < min) {
                        if(details) {
                            best = {
                                distance: min,
                                x0: result.x1, y0: result.y1,
                                x1: result.x0, y1: result.y0
                            };
                        } else {
                            best = dist;
                        }
                    }
                }
            }
        } else {
            best = geometry.distanceTo(this, options);
            // swap since target comes from this line
            if(details) {
                best = {
                    distance: best.distance,
                    x0: best.x1, y0: best.y1,
                    x1: best.x0, y1: best.y0
                };
            }
        }
        return best;
    },
    
    /**
     * APIMethod: simplify
     * This function will return a simplified LineString.
     * Simplification is based on the Douglas-Peucker algorithm.
     *
     *
     * Parameters:
     * tolerance - {number} threshhold for simplification in map units
     *
     * Returns:
     * {HGIS.Geometry.LineString} the simplified LineString
     */
    simplify: function(tolerance){
        if (this && this !== null) {
            var points = this.getVertices();
            if (points.length < 3) {
                return this;
            }
    
            var compareNumbers = function(a, b){
                return (a-b);
            };
    
            /**
             * Private function doing the Douglas-Peucker reduction
             */
            var douglasPeuckerReduction = function(points, firstPoint, lastPoint, tolerance){
                var maxDistance = 0;
                var indexFarthest = 0;
    
                for (var index = firstPoint, distance; index < lastPoint; index++) {
                    distance = perpendicularDistance(points[firstPoint], points[lastPoint], points[index]);
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        indexFarthest = index;
                    }
                }
    
                if (maxDistance > tolerance && indexFarthest != firstPoint) {
                    //Add the largest point that exceeds the tolerance
                    pointIndexsToKeep.push(indexFarthest);
                    douglasPeuckerReduction(points, firstPoint, indexFarthest, tolerance);
                    douglasPeuckerReduction(points, indexFarthest, lastPoint, tolerance);
                }
            };
    
            /**
             * Private function calculating the perpendicular distance
             * TODO: check whether HGIS.Geometry.LineString::distanceTo() is faster or slower
             */
            var perpendicularDistance = function(point1, point2, point){
                //Area = |(1/2)(x1y2 + x2y3 + x3y1 - x2y1 - x3y2 - x1y3)|   *Area of triangle
                //Base = v((x1-x2)²+(x1-x2)²)                               *Base of Triangle*
                //Area = .5*Base*H                                          *Solve for height
                //Height = Area/.5/Base
    
                var area = Math.abs(0.5 * (point1.x * point2.y + point2.x * point.y + point.x * point1.y - point2.x * point1.y - point.x * point2.y - point1.x * point.y));
                var bottom = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
                var height = area / bottom * 2;
    
                return height;
            };
    
            var firstPoint = 0;
            var lastPoint = points.length - 1;
            var pointIndexsToKeep = [];
    
            //Add the first and last index to the keepers
            pointIndexsToKeep.push(firstPoint);
            pointIndexsToKeep.push(lastPoint);
    
            //The first and the last point cannot be the same
            while (points[firstPoint].equals(points[lastPoint])) {
                lastPoint--;
                //Addition: the first point not equal to first point in the LineString is kept as well
                pointIndexsToKeep.push(lastPoint);
            }
    
            douglasPeuckerReduction(points, firstPoint, lastPoint, tolerance);
            var returnPoints = [];
            pointIndexsToKeep.sort(compareNumbers);
            for (var index = 0; index < pointIndexsToKeep.length; index++) {
                returnPoints.push(points[pointIndexsToKeep[index]]);
            }
            return new HGIS.Geometry.LineString(returnPoints);
    
        }
        else {
            return this;
        }
    },

    CLASS_NAME: "HGIS.Geometry.LineString"
});
/* ======================================================================
    HGIS/Geometry/MultiLineString.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Geometry/Collection.js
 * @requires HGIS/Geometry/LineString.js
 */

/**
 * Class: HGIS.Geometry.MultiLineString
 * A MultiLineString is a geometry with multiple <HGIS.Geometry.LineString>
 * components.
 * 
 * Inherits from:
 *  - <HGIS.Geometry.Collection>
 *  - <HGIS.Geometry> 
 */
HGIS.Geometry.MultiLineString = HGIS.Class(
  HGIS.Geometry.Collection, {

    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     */
    componentTypes: ["HGIS.Geometry.LineString"],

    /**
     * Constructor: HGIS.Geometry.MultiLineString
     * Constructor for a MultiLineString Geometry.
     *
     * Parameters: 
     * components - {Array(<HGIS.Geometry.LineString>)} 
     *
     */
    
    /**
     * Method: split
     * Use this geometry (the source) to attempt to split a target geometry.
     * 
     * Parameters:
     * geometry - {<HGIS.Geometry>} The target geometry.
     * options - {Object} Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * Returns:
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     */
    split: function(geometry, options) {
        var results = null;
        var mutual = options && options.mutual;
        var splits, sourceLine, sourceLines, sourceSplit, targetSplit;
        var sourceParts = [];
        var targetParts = [geometry];
        for(var i=0, len=this.components.length; i<len; ++i) {
            sourceLine = this.components[i];
            sourceSplit = false;
            for(var j=0; j < targetParts.length; ++j) { 
                splits = sourceLine.split(targetParts[j], options);
                if(splits) {
                    if(mutual) {
                        sourceLines = splits[0];
                        for(var k=0, klen=sourceLines.length; k<klen; ++k) {
                            if(k===0 && sourceParts.length) {
                                sourceParts[sourceParts.length-1].addComponent(
                                    sourceLines[k]
                                );
                            } else {
                                sourceParts.push(
                                    new HGIS.Geometry.MultiLineString([
                                        sourceLines[k]
                                    ])
                                );
                            }
                        }
                        sourceSplit = true;
                        splits = splits[1];
                    }
                    if(splits.length) {
                        // splice in new target parts
                        splits.unshift(j, 1);
                        Array.prototype.splice.apply(targetParts, splits);
                        break;
                    }
                }
            }
            if(!sourceSplit) {
                // source line was not hit
                if(sourceParts.length) {
                    // add line to existing multi
                    sourceParts[sourceParts.length-1].addComponent(
                        sourceLine.clone()
                    );
                } else {
                    // create a fresh multi
                    sourceParts = [
                        new HGIS.Geometry.MultiLineString(
                            sourceLine.clone()
                        )
                    ];
                }
            }
        }
        if(sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if(targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if(sourceSplit || targetSplit) {
            if(mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },
    
    /**
     * Method: splitWith
     * Split this geometry (the target) with the given geometry (the source).
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>} A geometry used to split this
     *     geometry (the source).
     * options - {Object} Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * Returns:
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     */
    splitWith: function(geometry, options) {
        var results = null;
        var mutual = options && options.mutual;
        var splits, targetLine, sourceLines, sourceSplit, targetSplit, sourceParts, targetParts;
        if(geometry instanceof HGIS.Geometry.LineString) {
            targetParts = [];
            sourceParts = [geometry];
            for(var i=0, len=this.components.length; i<len; ++i) {
                targetSplit = false;
                targetLine = this.components[i];
                for(var j=0; j<sourceParts.length; ++j) {
                    splits = sourceParts[j].split(targetLine, options);
                    if(splits) {
                        if(mutual) {
                            sourceLines = splits[0];
                            if(sourceLines.length) {
                                // splice in new source parts
                                sourceLines.unshift(j, 1);
                                Array.prototype.splice.apply(sourceParts, sourceLines);
                                j += sourceLines.length - 2;
                            }
                            splits = splits[1];
                            if(splits.length === 0) {
                                splits = [targetLine.clone()];
                            }
                        }
                        for(var k=0, klen=splits.length; k<klen; ++k) {
                            if(k===0 && targetParts.length) {
                                targetParts[targetParts.length-1].addComponent(
                                    splits[k]
                                );
                            } else {
                                targetParts.push(
                                    new HGIS.Geometry.MultiLineString([
                                        splits[k]
                                    ])
                                );
                            }
                        }
                        targetSplit = true;                    
                    }
                }
                if(!targetSplit) {
                    // target component was not hit
                    if(targetParts.length) {
                        // add it to any existing multi-line
                        targetParts[targetParts.length-1].addComponent(
                            targetLine.clone()
                        );
                    } else {
                        // or start with a fresh multi-line
                        targetParts = [
                            new HGIS.Geometry.MultiLineString([
                                targetLine.clone()
                            ])
                        ];
                    }
                    
                }
            }
        } else {
            results = geometry.split(this);
        }
        if(sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if(targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if(sourceSplit || targetSplit) {
            if(mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },

    CLASS_NAME: "HGIS.Geometry.MultiLineString"
});
/* ======================================================================
    HGIS/Geometry/LinearRing.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Geometry/LineString.js
 */

/**
 * Class: HGIS.Geometry.LinearRing
 * 
 * A Linear Ring is a special LineString which is closed. It closes itself 
 * automatically on every addPoint/removePoint by adding a copy of the first
 * point as the last point. 
 * 
 * Also, as it is the first in the line family to close itself, a getArea()
 * function is defined to calculate the enclosed area of the linearRing
 * 
 * Inherits:
 *  - <HGIS.Geometry.LineString>
 */
HGIS.Geometry.LinearRing = HGIS.Class(
  HGIS.Geometry.LineString, {

    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of 
     *                 components that the collection can include.  A null 
     *                 value means the component types are not restricted.
     */
    componentTypes: ["HGIS.Geometry.Point"],

    /**
     * Constructor: HGIS.Geometry.LinearRing
     * Linear rings are constructed with an array of points.  This array
     *     can represent a closed or open ring.  If the ring is open (the last
     *     point does not equal the first point), the constructor will close
     *     the ring.  If the ring is already closed (the last point does equal
     *     the first point), it will be left closed.
     * 
     * Parameters:
     * points - {Array(<HGIS.Geometry.Point>)} points
     */

    /**
     * APIMethod: addComponent
     * Adds a point to geometry components.  If the point is to be added to
     *     the end of the components array and it is the same as the last point
     *     already in that array, the duplicate point is not added.  This has 
     *     the effect of closing the ring if it is not already closed, and 
     *     doing the right thing if it is already closed.  This behavior can 
     *     be overridden by calling the method with a non-null index as the 
     *     second argument.
     *
     * Parameters:
     * point - {<HGIS.Geometry.Point>}
     * index - {Integer} Index into the array to insert the component
     * 
     * Returns:
     * {Boolean} Was the Point successfully added?
     */
    addComponent: function(point, index) {
        var added = false;

        //remove last point
        var lastPoint = this.components.pop();

        // given an index, add the point
        // without an index only add non-duplicate points
        if(index != null || !point.equals(lastPoint)) {
            added = HGIS.Geometry.Collection.prototype.addComponent.apply(this, 
                                                                    arguments);
        }

        //append copy of first point
        var firstPoint = this.components[0];
        HGIS.Geometry.Collection.prototype.addComponent.apply(this, 
                                                                [firstPoint]);
        
        return added;
    },
    
    /**
     * APIMethod: removeComponent
     * Removes a point from geometry components.
     *
     * Parameters:
     * point - {<HGIS.Geometry.Point>}
     *
     * Returns: 
     * {Boolean} The component was removed.
     */
    removeComponent: function(point) {
        var removed = this.components && (this.components.length > 3);
        if (removed) {
            //remove last point
            this.components.pop();
            
            //remove our point
            HGIS.Geometry.Collection.prototype.removeComponent.apply(this, 
                                                                    arguments);
            //append copy of first point
            var firstPoint = this.components[0];
            HGIS.Geometry.Collection.prototype.addComponent.apply(this, 
                                                                [firstPoint]);
        }
        return removed;
    },
    
    /**
     * APIMethod: move
     * Moves a geometry by the given displacement along positive x and y axes.
     *     This modifies the position of the geometry and clears the cached
     *     bounds.
     *
     * Parameters:
     * x - {Float} Distance to move geometry in positive x direction. 
     * y - {Float} Distance to move geometry in positive y direction.
     */
    move: function(x, y) {
        for(var i = 0, len=this.components.length; i<len - 1; i++) {
            this.components[i].move(x, y);
        }
    },

    /**
     * APIMethod: rotate
     * Rotate a geometry around some origin
     *
     * Parameters:
     * angle - {Float} Rotation angle in degrees (measured counterclockwise
     *                 from the positive x-axis)
     * origin - {<HGIS.Geometry.Point>} Center point for the rotation
     */
    rotate: function(angle, origin) {
        for(var i=0, len=this.components.length; i<len - 1; ++i) {
            this.components[i].rotate(angle, origin);
        }
    },

    /**
     * APIMethod: resize
     * Resize a geometry relative to some origin.  Use this method to apply
     *     a uniform scaling to a geometry.
     *
     * Parameters:
     * scale - {Float} Factor by which to scale the geometry.  A scale of 2
     *                 doubles the size of the geometry in each dimension
     *                 (lines, for example, will be twice as long, and polygons
     *                 will have four times the area).
     * origin - {<HGIS.Geometry.Point>} Point of origin for resizing
     * ratio - {Float} Optional x:y ratio for resizing.  Default ratio is 1.
     * 
     * Returns:
     * {<HGIS.Geometry>} - The current geometry. 
     */
    resize: function(scale, origin, ratio) {
        for(var i=0, len=this.components.length; i<len - 1; ++i) {
            this.components[i].resize(scale, origin, ratio);
        }
        return this;
    },
    
    /**
     * APIMethod: transform
     * Reproject the components geometry from source to dest.
     *
     * Parameters:
     * source - {<HGIS.Projection>}
     * dest - {<HGIS.Projection>}
     * 
     * Returns:
     * {<HGIS.Geometry>} 
     */
    transform: function(source, dest) {
        if (source && dest) {
            for (var i=0, len=this.components.length; i<len - 1; i++) {
                var component = this.components[i];
                component.transform(source, dest);
            }
            this.bounds = null;
        }
        return this;
    },
    
    /**
     * APIMethod: getCentroid
     *
     * Returns:
     * {<HGIS.Geometry.Point>} The centroid of the collection
     */
    getCentroid: function() {
        if (this.components) {
            var len = this.components.length;
            if (len > 0 && len <= 2) {
                return this.components[0].clone();
            } else if (len > 2) {
                var sumX = 0.0;
                var sumY = 0.0;
                var x0 = this.components[0].x;
                var y0 = this.components[0].y;
                var area = -1 * this.getArea();
                if (area != 0) {
                    for (var i = 0; i < len - 1; i++) {
                        var b = this.components[i];
                        var c = this.components[i+1];
                        sumX += (b.x + c.x - 2 * x0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
                        sumY += (b.y + c.y - 2 * y0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
                    }
                    var x = x0 + sumX / (6 * area);
                    var y = y0 + sumY / (6 * area);
                } else {
                    for (var i = 0; i < len - 1; i++) {
                        sumX += this.components[i].x;
                        sumY += this.components[i].y;
                    }
                    var x = sumX / (len - 1);
                    var y = sumY / (len - 1);
                }
                return new HGIS.Geometry.Point(x, y);
            } else {
                return null;
            }
        }
    },

    /**
     * APIMethod: getArea
     * Note - The area is positive if the ring is oriented CW, otherwise
     *         it will be negative.
     * 
     * Returns:
     * {Float} The signed area for a ring.
     */
    getArea: function() {
        var area = 0.0;
        if ( this.components && (this.components.length > 2)) {
            var sum = 0.0;
            for (var i=0, len=this.components.length; i<len - 1; i++) {
                var b = this.components[i];
                var c = this.components[i+1];
                sum += (b.x + c.x) * (c.y - b.y);
            }
            area = - sum / 2.0;
        }
        return area;
    },
    
    /**
     * APIMethod: getGeodesicArea
     * Calculate the approximate area of the polygon were it projected onto
     *     the earth.  Note that this area will be positive if ring is oriented
     *     clockwise, otherwise it will be negative.
     *
     * Parameters:
     * projection - {<HGIS.Projection>} The spatial reference system
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
     *     assumed.
     * 
     * Reference:
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
     *
     * Returns:
     * {float} The approximate signed geodesic area of the polygon in square
     *     meters.
     */
    getGeodesicArea: function(projection) {
        var ring = this;  // so we can work with a clone if needed
        if(projection) {
            var gg = new HGIS.Projection("EPSG:4326");
            if(!gg.equals(projection)) {
                ring = this.clone().transform(projection, gg);
            }
        }
        var area = 0.0;
        var len = ring.components && ring.components.length;
        if(len > 2) {
            var p1, p2;
            for(var i=0; i<len-1; i++) {
                p1 = ring.components[i];
                p2 = ring.components[i+1];
                area += HGIS.Util.rad(p2.x - p1.x) *
                        (2 + Math.sin(HGIS.Util.rad(p1.y)) +
                        Math.sin(HGIS.Util.rad(p2.y)));
            }
            area = area * 6378137.0 * 6378137.0 / 2.0;
        }
        return area;
    },
    
    /**
     * Method: containsPoint
     * Test if a point is inside a linear ring.  For the case where a point
     *     is coincident with a linear ring edge, returns 1.  Otherwise,
     *     returns boolean.
     *
     * Parameters:
     * point - {<HGIS.Geometry.Point>}
     *
     * Returns:
     * {Boolean | Number} The point is inside the linear ring.  Returns 1 if
     *     the point is coincident with an edge.  Returns boolean otherwise.
     */
    containsPoint: function(point) {
        var approx = HGIS.Number.limitSigDigs;
        var digs = 14;
        var px = approx(point.x, digs);
        var py = approx(point.y, digs);
        function getX(y, x1, y1, x2, y2) {
            return (y - y2) * ((x2 - x1) / (y2 - y1)) + x2;
        }
        var numSeg = this.components.length - 1;
        var start, end, x1, y1, x2, y2, cx, cy;
        var crosses = 0;
        for(var i=0; i<numSeg; ++i) {
            start = this.components[i];
            x1 = approx(start.x, digs);
            y1 = approx(start.y, digs);
            end = this.components[i + 1];
            x2 = approx(end.x, digs);
            y2 = approx(end.y, digs);
            
            /**
             * The following conditions enforce five edge-crossing rules:
             *    1. points coincident with edges are considered contained;
             *    2. an upward edge includes its starting endpoint, and
             *    excludes its final endpoint;
             *    3. a downward edge excludes its starting endpoint, and
             *    includes its final endpoint;
             *    4. horizontal edges are excluded; and
             *    5. the edge-ray intersection point must be strictly right
             *    of the point P.
             */
            if(y1 == y2) {
                // horizontal edge
                if(py == y1) {
                    // point on horizontal line
                    if(x1 <= x2 && (px >= x1 && px <= x2) || // right or vert
                       x1 >= x2 && (px <= x1 && px >= x2)) { // left or vert
                        // point on edge
                        crosses = -1;
                        break;
                    }
                }
                // ignore other horizontal edges
                continue;
            }
            cx = approx(getX(py, x1, y1, x2, y2), digs);
            if(cx == px) {
                // point on line
                if(y1 < y2 && (py >= y1 && py <= y2) || // upward
                   y1 > y2 && (py <= y1 && py >= y2)) { // downward
                    // point on edge
                    crosses = -1;
                    break;
                }
            }
            if(cx <= px) {
                // no crossing to the right
                continue;
            }
            if(x1 != x2 && (cx < Math.min(x1, x2) || cx > Math.max(x1, x2))) {
                // no crossing
                continue;
            }
            if(y1 < y2 && (py >= y1 && py < y2) || // upward
               y1 > y2 && (py < y1 && py >= y2)) { // downward
                ++crosses;
            }
        }
        var contained = (crosses == -1) ?
            // on edge
            1 :
            // even (out) or odd (in)
            !!(crosses & 1);

        return contained;
    },

    /**
     * APIMethod: intersects
     * Determine if the input geometry intersects this one.
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>} Any type of geometry.
     *
     * Returns:
     * {Boolean} The input geometry intersects this one.
     */
    intersects: function(geometry) {
        var intersect = false;
        if(geometry.CLASS_NAME == "HGIS.Geometry.Point") {
            intersect = this.containsPoint(geometry);
        } else if(geometry.CLASS_NAME == "HGIS.Geometry.LineString") {
            intersect = geometry.intersects(this);
        } else if(geometry.CLASS_NAME == "HGIS.Geometry.LinearRing") {
            intersect = HGIS.Geometry.LineString.prototype.intersects.apply(
                this, [geometry]
            );
        } else {
            // check for component intersections
            for(var i=0, len=geometry.components.length; i<len; ++ i) {
                intersect = geometry.components[i].intersects(this);
                if(intersect) {
                    break;
                }
            }
        }
        return intersect;
    },

    /**
     * APIMethod: getVertices
     * Return a list of all points in this geometry.
     *
     * Parameters:
     * nodes - {Boolean} For lines, only return vertices that are
     *     endpoints.  If false, for lines, only vertices that are not
     *     endpoints will be returned.  If not provided, all vertices will
     *     be returned.
     *
     * Returns:
     * {Array} A list of all vertices in the geometry.
     */
    getVertices: function(nodes) {
        return (nodes === true) ? [] : this.components.slice(0, this.components.length-1);
    },

    CLASS_NAME: "HGIS.Geometry.LinearRing"
});
/* ======================================================================
    HGIS/Geometry/Polygon.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Geometry/Collection.js
 * @requires HGIS/Geometry/LinearRing.js
 */

/**
 * Class: HGIS.Geometry.Polygon 
 * Polygon is a collection of Geometry.LinearRings. 
 * 
 * Inherits from:
 *  - <HGIS.Geometry.Collection> 
 *  - <HGIS.Geometry> 
 */
HGIS.Geometry.Polygon = HGIS.Class(
  HGIS.Geometry.Collection, {

    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     */
    componentTypes: ["HGIS.Geometry.LinearRing"],

    /**
     * Constructor: HGIS.Geometry.Polygon
     * Constructor for a Polygon geometry. 
     * The first ring (this.component[0])is the outer bounds of the polygon and 
     * all subsequent rings (this.component[1-n]) are internal holes.
     *
     *
     * Parameters:
     * components - {Array(<HGIS.Geometry.LinearRing>)} 
     */

    /** 
     * APIMethod: getArea
     * Calculated by subtracting the areas of the internal holes from the 
     *   area of the outer hole.
     * 
     * Returns:
     * {float} The area of the geometry
     */
    getArea: function() {
        var area = 0.0;
        if ( this.components && (this.components.length > 0)) {
            area += Math.abs(this.components[0].getArea());
            for (var i=1, len=this.components.length; i<len; i++) {
                area -= Math.abs(this.components[i].getArea());
            }
        }
        return area;
    },

    /** 
     * APIMethod: getGeodesicArea
     * Calculate the approximate area of the polygon were it projected onto
     *     the earth.
     *
     * Parameters:
     * projection - {<HGIS.Projection>} The spatial reference system
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is
     *     assumed.
     * 
     * Reference:
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
     *
     * Returns:
     * {float} The approximate geodesic area of the polygon in square meters.
     */
    getGeodesicArea: function(projection) {
        var area = 0.0;
        if(this.components && (this.components.length > 0)) {
            area += Math.abs(this.components[0].getGeodesicArea(projection));
            for(var i=1, len=this.components.length; i<len; i++) {
                area -= Math.abs(this.components[i].getGeodesicArea(projection));
            }
        }
        return area;
    },

    /**
     * Method: containsPoint
     * Test if a point is inside a polygon.  Points on a polygon edge are
     *     considered inside.
     *
     * Parameters:
     * point - {<HGIS.Geometry.Point>}
     *
     * Returns:
     * {Boolean | Number} The point is inside the polygon.  Returns 1 if the
     *     point is on an edge.  Returns boolean otherwise.
     */
    containsPoint: function(point) {
        var numRings = this.components.length;
        var contained = false;
        if(numRings > 0) {
            // check exterior ring - 1 means on edge, boolean otherwise
            contained = this.components[0].containsPoint(point);
            if(contained !== 1) {
                if(contained && numRings > 1) {
                    // check interior rings
                    var hole;
                    for(var i=1; i<numRings; ++i) {
                        hole = this.components[i].containsPoint(point);
                        if(hole) {
                            if(hole === 1) {
                                // on edge
                                contained = 1;
                            } else {
                                // in hole
                                contained = false;
                            }                            
                            break;
                        }
                    }
                }
            }
        }
        return contained;
    },

    /**
     * APIMethod: intersects
     * Determine if the input geometry intersects this one.
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>} Any type of geometry.
     *
     * Returns:
     * {Boolean} The input geometry intersects this one.
     */
    intersects: function(geometry) {
        var intersect = false;
        var i, len;
        if(geometry.CLASS_NAME == "HGIS.Geometry.Point") {
            intersect = this.containsPoint(geometry);
        } else if(geometry.CLASS_NAME == "HGIS.Geometry.LineString" ||
                  geometry.CLASS_NAME == "HGIS.Geometry.LinearRing") {
            // check if rings/linestrings intersect
            for(i=0, len=this.components.length; i<len; ++i) {
                intersect = geometry.intersects(this.components[i]);
                if(intersect) {
                    break;
                }
            }
            if(!intersect) {
                // check if this poly contains points of the ring/linestring
                for(i=0, len=geometry.components.length; i<len; ++i) {
                    intersect = this.containsPoint(geometry.components[i]);
                    if(intersect) {
                        break;
                    }
                }
            }
        } else {
            for(i=0, len=geometry.components.length; i<len; ++ i) {
                intersect = this.intersects(geometry.components[i]);
                if(intersect) {
                    break;
                }
            }
        }
        // check case where this poly is wholly contained by another
        if(!intersect && geometry.CLASS_NAME == "HGIS.Geometry.Polygon") {
            // exterior ring points will be contained in the other geometry
            var ring = this.components[0];
            for(i=0, len=ring.components.length; i<len; ++i) {
                intersect = geometry.containsPoint(ring.components[i]);
                if(intersect) {
                    break;
                }
            }
        }
        return intersect;
    },

    /**
     * APIMethod: distanceTo
     * Calculate the closest distance between two geometries (on the x-y plane).
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>} The target geometry.
     * options - {Object} Optional properties for configuring the distance
     *     calculation.
     *
     * Valid options:
     * details - {Boolean} Return details from the distance calculation.
     *     Default is false.
     * edge - {Boolean} Calculate the distance from this geometry to the
     *     nearest edge of the target geometry.  Default is true.  If true,
     *     calling distanceTo from a geometry that is wholly contained within
     *     the target will result in a non-zero distance.  If false, whenever
     *     geometries intersect, calling distanceTo will return 0.  If false,
     *     details cannot be returned.
     *
     * Returns:
     * {Number | Object} The distance between this geometry and the target.
     *     If details is true, the return will be an object with distance,
     *     x0, y0, x1, and y1 properties.  The x0 and y0 properties represent
     *     the coordinates of the closest point on this geometry. The x1 and y1
     *     properties represent the coordinates of the closest point on the
     *     target geometry.
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var result;
        // this is the case where we might not be looking for distance to edge
        if(!edge && this.intersects(geometry)) {
            result = 0;
        } else {
            result = HGIS.Geometry.Collection.prototype.distanceTo.apply(
                this, [geometry, options]
            );
        }
        return result;
    },

    CLASS_NAME: "HGIS.Geometry.Polygon"
});

/**
 * APIMethod: createRegularPolygon
 * Create a regular polygon around a radius. Useful for creating circles 
 * and the like.
 *
 * Parameters:
 * origin - {<HGIS.Geometry.Point>} center of polygon.
 * radius - {Float} distance to vertex, in map units.
 * sides - {Integer} Number of sides. 20 approximates a circle.
 * rotation - {Float} original angle of rotation, in degrees.
 */
HGIS.Geometry.Polygon.createRegularPolygon = function(origin, radius, sides, rotation) {  
    var angle = Math.PI * ((1/sides) - (1/2));
    if(rotation) {
        angle += (rotation / 180) * Math.PI;
    }
    var rotatedAngle, x, y;
    var points = [];
    for(var i=0; i<sides; ++i) {
        rotatedAngle = angle + (i * 2 * Math.PI / sides);
        x = origin.x + (radius * Math.cos(rotatedAngle));
        y = origin.y + (radius * Math.sin(rotatedAngle));
        points.push(new HGIS.Geometry.Point(x, y));
    }
    var ring = new HGIS.Geometry.LinearRing(points);
    return new HGIS.Geometry.Polygon([ring]);
};
/* ======================================================================
    HGIS/Geometry/MultiPolygon.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Geometry/Collection.js
 * @requires HGIS/Geometry/Polygon.js
 */

/**
 * Class: HGIS.Geometry.MultiPolygon
 * MultiPolygon is a geometry with multiple <HGIS.Geometry.Polygon>
 * components.  Create a new instance with the <HGIS.Geometry.MultiPolygon>
 * constructor.
 * 
 * Inherits from:
 *  - <HGIS.Geometry.Collection>
 */
HGIS.Geometry.MultiPolygon = HGIS.Class(
  HGIS.Geometry.Collection, {

    /**
     * Property: componentTypes
     * {Array(String)} An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     */
    componentTypes: ["HGIS.Geometry.Polygon"],

    /**
     * Constructor: HGIS.Geometry.MultiPolygon
     * Create a new MultiPolygon geometry
     *
     * Parameters:
     * components - {Array(<HGIS.Geometry.Polygon>)} An array of polygons
     *              used to generate the MultiPolygon
     *
     */

    CLASS_NAME: "HGIS.Geometry.MultiPolygon"
});
/* ======================================================================
    HGIS/Format/GML.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Geometry/Point.js
 * @requires HGIS/Geometry/MultiPoint.js
 * @requires HGIS/Geometry/LineString.js
 * @requires HGIS/Geometry/MultiLineString.js
 * @requires HGIS/Geometry/Polygon.js
 * @requires HGIS/Geometry/MultiPolygon.js
 */

/**
 * Class: HGIS.Format.GML
 * Read/Write GML. Create a new instance with the <HGIS.Format.GML>
 *     constructor.  Supports the GML simple features profile.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.GML = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * APIProperty: featureNS
     * {String} Namespace used for feature attributes.  Default is
     *     "http://mapserver.gis.umn.edu/mapserver".
     */
    featureNS: "http://mapserver.gis.umn.edu/mapserver",
    
    /**
     * APIProperty: featurePrefix
     * {String} Namespace alias (or prefix) for feature nodes.  Default is
     *     "feature".
     */
    featurePrefix: "feature",
    
    /**
     * APIProperty: featureName
     * {String} Element name for features. Default is "featureMember".
     */
    featureName: "featureMember", 
    
    /**
     * APIProperty: layerName
     * {String} Name of data layer. Default is "features".
     */
    layerName: "features",
    
    /**
     * APIProperty: geometryName
     * {String} Name of geometry element.  Defaults to "geometry".
     */
    geometryName: "geometry",
    
    /** 
     * APIProperty: collectionName
     * {String} Name of featureCollection element.
     */
    collectionName: "FeatureCollection",
    
    /**
     * APIProperty: gmlns
     * {String} GML Namespace.
     */
    gmlns: "http://www.opengis.net/gml",

    /**
     * APIProperty: extractAttributes
     * {Boolean} Extract attributes from GML.
     */
    extractAttributes: true,
    
    /**
     * APIProperty: xy
     * {Boolean} Order of the GML coordinate true:(x,y) or false:(y,x)
     * Changing is not recommended, a new Format should be instantiated.
     */ 
    xy: true,
    
    /**
     * Constructor: HGIS.Format.GML
     * Create a new parser for GML.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        // compile regular expressions once instead of every time they are used
        this.regExes = {
            trimSpace: (/^\s*|\s*$/g),
            removeSpace: (/\s*/g),
            splitSpace: (/\s+/),
            trimComma: (/\s*,\s*/g)
        };
        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: read
     * Read data from a string, and return a list of features. 
     * 
     * Parameters:
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array(<HGIS.Feature.Vector>)} An array of features.
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        var featureNodes = this.getElementsByTagNameNS(data.documentElement,
                                                       this.gmlns,
                                                       this.featureName);
        var features = [];
        for(var i=0; i<featureNodes.length; i++) {
            var feature = this.parseFeature(featureNodes[i]);
            if(feature) {
                features.push(feature);
            }
        }
        return features;
    },
    
    /**
     * Method: parseFeature
     * This function is the core of the GML parsing code in HGIS.
     *    It creates the geometries that are then attached to the returned
     *    feature, and calls parseAttributes() to get attribute data out.
     *    
     * Parameters:
     * node - {DOMElement} A GML feature node. 
     */
    parseFeature: function(node) {
        // only accept one geometry per feature - look for highest "order"
        var order = ["MultiPolygon", "Polygon",
                     "MultiLineString", "LineString",
                     "MultiPoint", "Point", "Envelope"];
        // FIXME: In case we parse a feature with no geometry, but boundedBy an Envelope,
        // this code creates a geometry derived from the Envelope. This is not correct.
        var type, nodeList, geometry, parser;
        for(var i=0; i<order.length; ++i) {
            type = order[i];
            nodeList = this.getElementsByTagNameNS(node, this.gmlns, type);
            if(nodeList.length > 0) {
                // only deal with first geometry of this type
                parser = this.parseGeometry[type.toLowerCase()];
                if(parser) {
                    geometry = parser.apply(this, [nodeList[0]]);
                    if (this.internalProjection && this.externalProjection) {
                        geometry.transform(this.externalProjection, 
                                           this.internalProjection); 
                    }                       
                } else {
                    throw new TypeError("Unsupported geometry type: " + type);
                }
                // stop looking for different geometry types
                break;
            }
        }

        var bounds;
        var boxNodes = this.getElementsByTagNameNS(node, this.gmlns, "Box");
        for(i=0; i<boxNodes.length; ++i) {
            var boxNode = boxNodes[i];
            var box = this.parseGeometry["box"].apply(this, [boxNode]);
            var parentNode = boxNode.parentNode;
            var parentName = parentNode.localName ||
                             parentNode.nodeName.split(":").pop();
            if(parentName === "boundedBy") {
                bounds = box;
            } else {
                geometry = box.toGeometry();
            }
        }
        
        // construct feature (optionally with attributes)
        var attributes;
        if(this.extractAttributes) {
            attributes = this.parseAttributes(node);
        }
        var feature = new HGIS.Feature.Vector(geometry, attributes);
        feature.bounds = bounds;
        
        feature.gml = {
            featureType: node.firstChild.nodeName.split(":")[1],
            featureNS: node.firstChild.namespaceURI,
            featureNSPrefix: node.firstChild.prefix
        };
                
        // assign fid - this can come from a "fid" or "id" attribute
        var childNode = node.firstChild;
        var fid;
        while(childNode) {
            if(childNode.nodeType == 1) {
                fid = childNode.getAttribute("fid") ||
                      childNode.getAttribute("id");
                if(fid) {
                    break;
                }
            }
            childNode = childNode.nextSibling;
        }
        feature.fid = fid;
        return feature;
    },
    
    /**
     * Property: parseGeometry
     * Properties of this object are the functions that parse geometries based
     *     on their type.
     */
    parseGeometry: {
        
        /**
         * Method: parseGeometry.point
         * Given a GML node representing a point geometry, create an HGIS
         *     point geometry.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<HGIS.Geometry.Point>} A point geometry.
         */
        point: function(node) {
            /**
             * Three coordinate variations to consider:
             * 1) <gml:pos>x y z</gml:pos>
             * 2) <gml:coordinates>x, y, z</gml:coordinates>
             * 3) <gml:coord><gml:X>x</gml:X><gml:Y>y</gml:Y></gml:coord>
             */
            var nodeList, coordString;
            var coords = [];

            // look for <gml:pos>
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns, "pos");
            if(nodeList.length > 0) {
                coordString = nodeList[0].firstChild.nodeValue;
                coordString = coordString.replace(this.regExes.trimSpace, "");
                coords = coordString.split(this.regExes.splitSpace);
            }

            // look for <gml:coordinates>
            if(coords.length == 0) {
                nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "coordinates");
                if(nodeList.length > 0) {
                    coordString = nodeList[0].firstChild.nodeValue;
                    coordString = coordString.replace(this.regExes.removeSpace,
                                                      "");
                    coords = coordString.split(",");
                }
            }

            // look for <gml:coord>
            if(coords.length == 0) {
                nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "coord");
                if(nodeList.length > 0) {
                    var xList = this.getElementsByTagNameNS(nodeList[0],
                                                            this.gmlns, "X");
                    var yList = this.getElementsByTagNameNS(nodeList[0],
                                                            this.gmlns, "Y");
                    if(xList.length > 0 && yList.length > 0) {
                        coords = [xList[0].firstChild.nodeValue,
                                  yList[0].firstChild.nodeValue];
                    }
                }
            }
                
            // preserve third dimension
            if(coords.length == 2) {
                coords[2] = null;
            }
            
            if (this.xy) {
                return new HGIS.Geometry.Point(coords[0], coords[1],
                                                 coords[2]);
            }
            else{
                return new HGIS.Geometry.Point(coords[1], coords[0],
                                                 coords[2]);
            }
        },
        
        /**
         * Method: parseGeometry.multipoint
         * Given a GML node representing a multipoint geometry, create an
         *     HGIS multipoint geometry.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<HGIS.Geometry.MultiPoint>} A multipoint geometry.
         */
        multipoint: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "Point");
            var components = [];
            if(nodeList.length > 0) {
                var point;
                for(var i=0; i<nodeList.length; ++i) {
                    point = this.parseGeometry.point.apply(this, [nodeList[i]]);
                    if(point) {
                        components.push(point);
                    }
                }
            }
            return new HGIS.Geometry.MultiPoint(components);
        },
        
        /**
         * Method: parseGeometry.linestring
         * Given a GML node representing a linestring geometry, create an
         *     HGIS linestring geometry.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<HGIS.Geometry.LineString>} A linestring geometry.
         */
        linestring: function(node, ring) {
            /**
             * Two coordinate variations to consider:
             * 1) <gml:posList dimension="d">x0 y0 z0 x1 y1 z1</gml:posList>
             * 2) <gml:coordinates>x0, y0, z0 x1, y1, z1</gml:coordinates>
             */
            var nodeList, coordString;
            var coords = [];
            var points = [];

            // look for <gml:posList>
            nodeList = this.getElementsByTagNameNS(node, this.gmlns, "posList");
            if(nodeList.length > 0) {
                coordString = this.getChildValue(nodeList[0]);
                coordString = coordString.replace(this.regExes.trimSpace, "");
                coords = coordString.split(this.regExes.splitSpace);
                var dim = parseInt(nodeList[0].getAttribute("dimension"));
                var j, x, y, z;
                for(var i=0; i<coords.length/dim; ++i) {
                    j = i * dim;
                    x = coords[j];
                    y = coords[j+1];
                    z = (dim == 2) ? null : coords[j+2];
                    if (this.xy) {
                        points.push(new HGIS.Geometry.Point(x, y, z));
                    } else {
                        points.push(new HGIS.Geometry.Point(y, x, z));
                    }
                }
            }

            // look for <gml:coordinates>
            if(coords.length == 0) {
                nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "coordinates");
                if(nodeList.length > 0) {
                    coordString = this.getChildValue(nodeList[0]);
                    coordString = coordString.replace(this.regExes.trimSpace,
                                                      "");
                    coordString = coordString.replace(this.regExes.trimComma,
                                                      ",");
                    var pointList = coordString.split(this.regExes.splitSpace);
                    for(var i=0; i<pointList.length; ++i) {
                        coords = pointList[i].split(",");
                        if(coords.length == 2) {
                            coords[2] = null;
                        }
                        if (this.xy) {
                            points.push(new HGIS.Geometry.Point(coords[0],
                                                                  coords[1],
                                                                  coords[2]));
                        } else {
                            points.push(new HGIS.Geometry.Point(coords[1],
                                                                  coords[0],
                                                                  coords[2]));
                        }
                    }
                }
            }

            var line = null;
            if(points.length != 0) {
                if(ring) {
                    line = new HGIS.Geometry.LinearRing(points);
                } else {
                    line = new HGIS.Geometry.LineString(points);
                }
            }
            return line;
        },
        
        /**
         * Method: parseGeometry.multilinestring
         * Given a GML node representing a multilinestring geometry, create an
         *     HGIS multilinestring geometry.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<HGIS.Geometry.MultiLineString>} A multilinestring geometry.
         */
        multilinestring: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "LineString");
            var components = [];
            if(nodeList.length > 0) {
                var line;
                for(var i=0; i<nodeList.length; ++i) {
                    line = this.parseGeometry.linestring.apply(this,
                                                               [nodeList[i]]);
                    if(line) {
                        components.push(line);
                    }
                }
            }
            return new HGIS.Geometry.MultiLineString(components);
        },
        
        /**
         * Method: parseGeometry.polygon
         * Given a GML node representing a polygon geometry, create an
         *     HGIS polygon geometry.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<HGIS.Geometry.Polygon>} A polygon geometry.
         */
        polygon: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "LinearRing");
            var components = [];
            if(nodeList.length > 0) {
                // this assumes exterior ring first, inner rings after
                var ring;
                for(var i=0; i<nodeList.length; ++i) {
                    ring = this.parseGeometry.linestring.apply(this,
                                                        [nodeList[i], true]);
                    if(ring) {
                        components.push(ring);
                    }
                }
            }
            return new HGIS.Geometry.Polygon(components);
        },
        
        /**
         * Method: parseGeometry.multipolygon
         * Given a GML node representing a multipolygon geometry, create an
         *     HGIS multipolygon geometry.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<HGIS.Geometry.MultiPolygon>} A multipolygon geometry.
         */
        multipolygon: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "Polygon");
            var components = [];
            if(nodeList.length > 0) {
                var polygon;
                for(var i=0; i<nodeList.length; ++i) {
                    polygon = this.parseGeometry.polygon.apply(this,
                                                               [nodeList[i]]);
                    if(polygon) {
                        components.push(polygon);
                    }
                }
            }
            return new HGIS.Geometry.MultiPolygon(components);
        },
        
        envelope: function(node) {
            var components = [];
            var coordString;
            var envelope;
            
            var lpoint = this.getElementsByTagNameNS(node, this.gmlns, "lowerCorner");
            if (lpoint.length > 0) {
                var coords = [];
                
                if(lpoint.length > 0) {
                    coordString = lpoint[0].firstChild.nodeValue;
                    coordString = coordString.replace(this.regExes.trimSpace, "");
                    coords = coordString.split(this.regExes.splitSpace);
                }
                
                if(coords.length == 2) {
                    coords[2] = null;
                }
                if (this.xy) {
                    var lowerPoint = new HGIS.Geometry.Point(coords[0], coords[1],coords[2]);
                } else {
                    var lowerPoint = new HGIS.Geometry.Point(coords[1], coords[0],coords[2]);
                }
            }
            
            var upoint = this.getElementsByTagNameNS(node, this.gmlns, "upperCorner");
            if (upoint.length > 0) {
                var coords = [];
                
                if(upoint.length > 0) {
                    coordString = upoint[0].firstChild.nodeValue;
                    coordString = coordString.replace(this.regExes.trimSpace, "");
                    coords = coordString.split(this.regExes.splitSpace);
                }
                
                if(coords.length == 2) {
                    coords[2] = null;
                }
                if (this.xy) {
                    var upperPoint = new HGIS.Geometry.Point(coords[0], coords[1],coords[2]);
                } else {
                    var upperPoint = new HGIS.Geometry.Point(coords[1], coords[0],coords[2]);
                }
            }
            
            if (lowerPoint && upperPoint) {
                components.push(new HGIS.Geometry.Point(lowerPoint.x, lowerPoint.y));
                components.push(new HGIS.Geometry.Point(upperPoint.x, lowerPoint.y));
                components.push(new HGIS.Geometry.Point(upperPoint.x, upperPoint.y));
                components.push(new HGIS.Geometry.Point(lowerPoint.x, upperPoint.y));
                components.push(new HGIS.Geometry.Point(lowerPoint.x, lowerPoint.y));
                
                var ring = new HGIS.Geometry.LinearRing(components);
                envelope = new HGIS.Geometry.Polygon([ring]);
            }
            return envelope; 
        },

        /**
         * Method: parseGeometry.box
         * Given a GML node representing a box geometry, create an
         *     HGIS.Bounds.
         *
         * Parameters:
         * node - {DOMElement} A GML node.
         *
         * Returns:
         * {<HGIS.Bounds>} A bounds representing the box.
         */
        box: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                   "coordinates");
            var coordString;
            var coords, beginPoint = null, endPoint = null;
            if (nodeList.length > 0) {
                coordString = nodeList[0].firstChild.nodeValue;
                coords = coordString.split(" ");
                if (coords.length == 2) {
                    beginPoint = coords[0].split(",");
                    endPoint = coords[1].split(",");
                }
            }
            if (beginPoint !== null && endPoint !== null) {
                return new HGIS.Bounds(parseFloat(beginPoint[0]),
                    parseFloat(beginPoint[1]),
                    parseFloat(endPoint[0]),
                    parseFloat(endPoint[1]) );
            }
        }
        
    },
    
    /**
     * Method: parseAttributes
     *
     * Parameters:
     * node - {DOMElement}
     *
     * Returns:
     * {Object} An attributes object.
     */
    parseAttributes: function(node) {
        var attributes = {};
        // assume attributes are children of the first type 1 child
        var childNode = node.firstChild;
        var children, i, child, grandchildren, grandchild, name, value;
        while(childNode) {
            if(childNode.nodeType == 1) {
                // attributes are type 1 children with one type 3 child
                children = childNode.childNodes;
                for(i=0; i<children.length; ++i) {
                    child = children[i];
                    if(child.nodeType == 1) {
                        grandchildren = child.childNodes;
                        if(grandchildren.length == 1) {
                            grandchild = grandchildren[0];
                            if(grandchild.nodeType == 3 ||
                               grandchild.nodeType == 4) {
                                name = (child.prefix) ?
                                        child.nodeName.split(":")[1] :
                                        child.nodeName;
                                value = grandchild.nodeValue.replace(
                                                this.regExes.trimSpace, "");
                                attributes[name] = value;
                            }
                        } else {
                            // If child has no childNodes (grandchildren),
                            // set an attribute with null value.
                            // e.g. <prefix:fieldname/> becomes
                            // {fieldname: null}
                            attributes[child.nodeName.split(":").pop()] = null;
                        }
                    }
                }
                break;
            }
            childNode = childNode.nextSibling;
        }
        return attributes;
    },
    
    /**
     * APIMethod: write
     * Generate a GML document string given a list of features. 
     * 
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} List of features to
     *     serialize into a string.
     *
     * Returns:
     * {String} A string representing the GML document.
     */
    write: function(features) {
        if(!(HGIS.Util.isArray(features))) {
            features = [features];
        }
        var gml = this.createElementNS("http://www.opengis.net/wfs",
                                       "wfs:" + this.collectionName);
        for(var i=0; i<features.length; i++) {
            gml.appendChild(this.createFeatureXML(features[i]));
        }
        return HGIS.Format.XML.prototype.write.apply(this, [gml]);
    },

    /** 
     * Method: createFeatureXML
     * Accept an HGIS.Feature.Vector, and build a GML node for it.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} The feature to be built as GML.
     *
     * Returns:
     * {DOMElement} A node reprensting the feature in GML.
     */
    createFeatureXML: function(feature) {
        var geometry = feature.geometry;
        var geometryNode = this.buildGeometryNode(geometry);
        var geomContainer = this.createElementNS(this.featureNS,
                                                 this.featurePrefix + ":" +
                                                 this.geometryName);
        geomContainer.appendChild(geometryNode);
        var featureNode = this.createElementNS(this.gmlns,
                                               "gml:" + this.featureName);
        var featureContainer = this.createElementNS(this.featureNS,
                                                    this.featurePrefix + ":" +
                                                    this.layerName);
        var fid = feature.fid || feature.id;
        featureContainer.setAttribute("fid", fid);
        featureContainer.appendChild(geomContainer);
        for(var attr in feature.attributes) {
            var attrText = this.createTextNode(feature.attributes[attr]); 
            var nodename = attr.substring(attr.lastIndexOf(":") + 1);
            var attrContainer = this.createElementNS(this.featureNS,
                                                     this.featurePrefix + ":" +
                                                     nodename);
            attrContainer.appendChild(attrText);
            featureContainer.appendChild(attrContainer);
        }    
        featureNode.appendChild(featureContainer);
        return featureNode;
    },
    
    /**
     * APIMethod: buildGeometryNode
     */
    buildGeometryNode: function(geometry) {
        if (this.externalProjection && this.internalProjection) {
            geometry = geometry.clone();
            geometry.transform(this.internalProjection, 
                               this.externalProjection);
        }    
        var className = geometry.CLASS_NAME;
        var type = className.substring(className.lastIndexOf(".") + 1);
        var builder = this.buildGeometry[type.toLowerCase()];
        return builder.apply(this, [geometry]);
    },

    /**
     * Property: buildGeometry
     * Object containing methods to do the actual geometry node building
     *     based on geometry type.
     */
    buildGeometry: {
        // TBD retrieve the srs from layer
        // srsName is non-standard, so not including it until it's right.
        // gml.setAttribute("srsName",
        //                  "http://www.opengis.net/gml/srs/epsg.xml#4326");

        /**
         * Method: buildGeometry.point
         * Given an HGIS point geometry, create a GML point.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.Point>} A point geometry.
         *
         * Returns:
         * {DOMElement} A GML point node.
         */
        point: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:Point");
            gml.appendChild(this.buildCoordinatesNode(geometry));
            return gml;
        },
        
        /**
         * Method: buildGeometry.multipoint
         * Given an HGIS multipoint geometry, create a GML multipoint.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.MultiPoint>} A multipoint geometry.
         *
         * Returns:
         * {DOMElement} A GML multipoint node.
         */
        multipoint: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:MultiPoint");
            var points = geometry.components;
            var pointMember, pointGeom;
            for(var i=0; i<points.length; i++) { 
                pointMember = this.createElementNS(this.gmlns,
                                                   "gml:pointMember");
                pointGeom = this.buildGeometry.point.apply(this,
                                                               [points[i]]);
                pointMember.appendChild(pointGeom);
                gml.appendChild(pointMember);
            }
            return gml;            
        },
        
        /**
         * Method: buildGeometry.linestring
         * Given an HGIS linestring geometry, create a GML linestring.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.LineString>} A linestring geometry.
         *
         * Returns:
         * {DOMElement} A GML linestring node.
         */
        linestring: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:LineString");
            gml.appendChild(this.buildCoordinatesNode(geometry));
            return gml;
        },
        
        /**
         * Method: buildGeometry.multilinestring
         * Given an HGIS multilinestring geometry, create a GML
         *     multilinestring.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.MultiLineString>} A multilinestring
         *     geometry.
         *
         * Returns:
         * {DOMElement} A GML multilinestring node.
         */
        multilinestring: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:MultiLineString");
            var lines = geometry.components;
            var lineMember, lineGeom;
            for(var i=0; i<lines.length; ++i) {
                lineMember = this.createElementNS(this.gmlns,
                                                  "gml:lineStringMember");
                lineGeom = this.buildGeometry.linestring.apply(this,
                                                                   [lines[i]]);
                lineMember.appendChild(lineGeom);
                gml.appendChild(lineMember);
            }
            return gml;
        },
        
        /**
         * Method: buildGeometry.linearring
         * Given an HGIS linearring geometry, create a GML linearring.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.LinearRing>} A linearring geometry.
         *
         * Returns:
         * {DOMElement} A GML linearring node.
         */
        linearring: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:LinearRing");
            gml.appendChild(this.buildCoordinatesNode(geometry));
            return gml;
        },
        
        /**
         * Method: buildGeometry.polygon
         * Given an HGIS polygon geometry, create a GML polygon.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.Polygon>} A polygon geometry.
         *
         * Returns:
         * {DOMElement} A GML polygon node.
         */
        polygon: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:Polygon");
            var rings = geometry.components;
            var ringMember, ringGeom, type;
            for(var i=0; i<rings.length; ++i) {
                type = (i==0) ? "outerBoundaryIs" : "innerBoundaryIs";
                ringMember = this.createElementNS(this.gmlns,
                                                  "gml:" + type);
                ringGeom = this.buildGeometry.linearring.apply(this,
                                                                   [rings[i]]);
                ringMember.appendChild(ringGeom);
                gml.appendChild(ringMember);
            }
            return gml;
        },
        
        /**
         * Method: buildGeometry.multipolygon
         * Given an HGIS multipolygon geometry, create a GML multipolygon.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.MultiPolygon>} A multipolygon
         *     geometry.
         *
         * Returns:
         * {DOMElement} A GML multipolygon node.
         */
        multipolygon: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:MultiPolygon");
            var polys = geometry.components;
            var polyMember, polyGeom;
            for(var i=0; i<polys.length; ++i) {
                polyMember = this.createElementNS(this.gmlns,
                                                  "gml:polygonMember");
                polyGeom = this.buildGeometry.polygon.apply(this,
                                                                [polys[i]]);
                polyMember.appendChild(polyGeom);
                gml.appendChild(polyMember);
            }
            return gml;

        },
 
        /**
         * Method: buildGeometry.bounds
         * Given an HGIS bounds, create a GML box.
         *
         * Parameters:
         * bounds - {<HGIS.Geometry.Bounds>} A bounds object.
         *
         * Returns:
         * {DOMElement} A GML box node.
         */
        bounds: function(bounds) {
            var gml = this.createElementNS(this.gmlns, "gml:Box");
            gml.appendChild(this.buildCoordinatesNode(bounds));
            return gml;
        }
    },

    /**
     * Method: buildCoordinates
     * builds the coordinates XmlNode
     * (code)
     * <gml:coordinates decimal="." cs="," ts=" ">...</gml:coordinates>
     * (end)
     *
     * Parameters: 
     * geometry - {<HGIS.Geometry>} 
     *
     * Returns:
     * {XmlNode} created xmlNode
     */
    buildCoordinatesNode: function(geometry) {
        var coordinatesNode = this.createElementNS(this.gmlns,
                                                   "gml:coordinates");
        coordinatesNode.setAttribute("decimal", ".");
        coordinatesNode.setAttribute("cs", ",");
        coordinatesNode.setAttribute("ts", " ");

        var parts = [];

        if(geometry instanceof HGIS.Bounds){
            parts.push(geometry.left + "," + geometry.bottom);
            parts.push(geometry.right + "," + geometry.top);
        } else {
            var points = (geometry.components) ? geometry.components : [geometry];
            for(var i=0; i<points.length; i++) {
                parts.push(points[i].x + "," + points[i].y);                
            }            
        }

        var txtNode = this.createTextNode(parts.join(" "));
        coordinatesNode.appendChild(txtNode);
        
        return coordinatesNode;
    },

    CLASS_NAME: "HGIS.Format.GML" 
});
/* ======================================================================
    HGIS/Format/GML/Base.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/GML.js
 */

/**
 * Though required in the full build, if the GML format is excluded, we set
 * the namespace here.
 */
if(!HGIS.Format.GML) {
    HGIS.Format.GML = {};
}

/**
 * Class: HGIS.Format.GML.Base
 * Superclass for GML parsers.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.GML.Base = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs" // this is a convenience for reading wfs:FeatureCollection
    },
    
    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "gml",

    /**
     * Property: schemaLocation
     * {String} Schema location for a particular minor version.
     */
    schemaLocation: null,
    
    /**
     * APIProperty: featureType
     * {Array(String) or String} The local (without prefix) feature typeName(s).
     */
    featureType: null,
    
    /**
     * APIProperty: featureNS
     * {String} The feature namespace.  Must be set in the options at
     *     construction.
     */
    featureNS: null,

    /**
     * APIProperty: geometry
     * {String} Name of geometry element.  Defaults to "geometry". If null, it
     * will be set on <read> when the first geometry is parsed.
     */
    geometryName: "geometry",

    /**
     * APIProperty: extractAttributes
     * {Boolean} Extract attributes from GML.  Default is true.
     */
    extractAttributes: true,
    
    /**
     * APIProperty: srsName
     * {String} URI for spatial reference system.  This is optional for
     *     single part geometries and mandatory for collections and multis.
     *     If set, the srsName attribute will be written for all geometries.
     *     Default is null.
     */
    srsName: null,

    /**
     * APIProperty: xy
     * {Boolean} Order of the GML coordinate true:(x,y) or false:(y,x)
     * Changing is not recommended, a new Format should be instantiated.
     */ 
    xy: true,

    /**
     * Property: geometryTypes
     * {Object} Maps HGIS geometry class names to GML element names.
     *     Use <setGeometryTypes> before accessing this property.
     */
    geometryTypes: null,

    /**
     * Property: singleFeatureType
     * {Boolean} True if there is only 1 featureType, and not an array
     *     of featuretypes.
     */
    singleFeatureType: null,
    
    /**
     * Property: autoConfig
     * {Boolean} Indicates if the format was configured without a <featureNS>,
     * but auto-configured <featureNS> and <featureType> during read.
     * Subclasses making use of <featureType> auto-configuration should make
     * the first call to the <readNode> method (usually in the read method)
     * with true as 3rd argument, so the auto-configured featureType can be
     * reset and the format can be reused for subsequent reads with data from
     * different featureTypes. Set to false after read if you want to keep the
     * auto-configured values.
     */

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g),
        featureMember: (/^(.*:)?featureMembers?$/)
    },

    /**
     * Constructor: HGIS.Format.GML.Base
     * Instances of this class are not created directly.  Use the
     *     <HGIS.Format.GML.v2> or <HGIS.Format.GML.v3> constructor
     *     instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     *
     * Valid options properties:
     * featureType - {Array(String) or String} Local (without prefix) feature 
     *     typeName(s) (required for write).
     * featureNS - {String} Feature namespace (required for write).
     * geometryName - {String} Geometry element name (required for write).
     */
    initialize: function(options) {
        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
        this.setGeometryTypes();
        if(options && options.featureNS) {
            this.setNamespace("feature", options.featureNS);
        }
        this.singleFeatureType = !options || (typeof options.featureType === "string");
    },
    
    /**
     * Method: read
     *
     * Parameters:
     * data - {DOMElement} A gml:featureMember element, a gml:featureMembers
     *     element, or an element containing either of the above at any level.
     *
     * Returns:
     * {Array(<HGIS.Feature.Vector>)} An array of features.
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var features = [];
        this.readNode(data, {features: features}, true);
        if(features.length == 0) {
            // look for gml:featureMember elements
            var elements = this.getElementsByTagNameNS(
                data, this.namespaces.gml, "featureMember"
            );
            if(elements.length) {
                for(var i=0, len=elements.length; i<len; ++i) {
                    this.readNode(elements[i], {features: features}, true);
                }
            } else {
                // look for gml:featureMembers elements (this is v3, but does no harm here)
                var elements = this.getElementsByTagNameNS(
                    data, this.namespaces.gml, "featureMembers"
                );
                if(elements.length) {
                    // there can be only one
                    this.readNode(elements[0], {features: features}, true);
                }
            }
        }
        return features;
    },
    
    /**
     * Method: readNode
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     *
     * Parameters:
     * node - {DOMElement} The node to be read (required).
     * obj - {Object} The object to be modified (optional).
     * first - {Boolean} Should be set to true for the first node read. This
     *     is usually the readNode call in the read method. Without this being
     *     set, auto-configured properties will stick on subsequent reads.
     *
     * Returns:
     * {Object} The input object, modified (or a new one if none was provided).
     */
    readNode: function(node, obj, first) {
        // on subsequent calls of format.read(), we want to reset auto-
        // configured properties and auto-configure again.
        if (first === true && this.autoConfig === true) {
            this.featureType = null;
            delete this.namespaceAlias[this.featureNS];
            delete this.namespaces["feature"];
            this.featureNS = null;
        }
        // featureType auto-configuration
        if (!this.featureNS && (!(node.prefix in this.namespaces) &&
                node.parentNode.namespaceURI == this.namespaces["gml"] &&
                this.regExes.featureMember.test(node.parentNode.nodeName))) {
            this.featureType = node.nodeName.split(":").pop();
            this.setNamespace("feature", node.namespaceURI);
            this.featureNS = node.namespaceURI;
            this.autoConfig = true;
        }
        return HGIS.Format.XML.prototype.readNode.apply(this, [node, obj]);
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "gml": {
            "_inherit": function(node, obj, container) {
                // To be implemented by version specific parsers
            },
            "featureMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "featureMembers": function(node, obj) {
                this.readChildNodes(node, obj);                
            },
            "name": function(node, obj) {
                obj.name = this.getChildValue(node);
            },
            "boundedBy": function(node, obj) {
                var container = {};
                this.readChildNodes(node, container);
                if(container.components && container.components.length > 0) {
                    obj.bounds = container.components[0];
                }
            },
            "Point": function(node, container) {
                var obj = {points: []};
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(obj.points[0]);
            },
            "coordinates": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, ""
                );
                str = str.replace(this.regExes.trimComma, ",");
                var pointList = str.split(this.regExes.splitSpace);
                var coords;
                var numPoints = pointList.length;
                var points = new Array(numPoints);
                for(var i=0; i<numPoints; ++i) {
                    coords = pointList[i].split(",");
                    if (this.xy) {
                        points[i] = new HGIS.Geometry.Point(
                            coords[0], coords[1], coords[2]
                        );
                    } else {
                        points[i] = new HGIS.Geometry.Point(
                            coords[1], coords[0], coords[2]
                        );
                    }
                }
                obj.points = points;
            },
            "coord": function(node, obj) {
                var coord = {};
                this.readChildNodes(node, coord);
                if(!obj.points) {
                    obj.points = [];
                }
                obj.points.push(new HGIS.Geometry.Point(
                    coord.x, coord.y, coord.z
                ));
            },
            "X": function(node, coord) {
                coord.x = this.getChildValue(node);
            },
            "Y": function(node, coord) {
                coord.y = this.getChildValue(node);
            },
            "Z": function(node, coord) {
                coord.z = this.getChildValue(node);
            },
            "MultiPoint": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new HGIS.Geometry.MultiPoint(obj.components)
                ];
            },
            "pointMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "LineString": function(node, container) {
                var obj = {};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(
                    new HGIS.Geometry.LineString(obj.points)
                );
            },
            "MultiLineString": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new HGIS.Geometry.MultiLineString(obj.components)
                ];
            },
            "lineStringMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Polygon": function(node, container) {
                var obj = {outer: null, inner: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                obj.inner.unshift(obj.outer);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(
                    new HGIS.Geometry.Polygon(obj.inner)
                );
            },
            "LinearRing": function(node, obj) {
                var container = {};
                this.readers.gml._inherit.apply(this, [node, container]);
                this.readChildNodes(node, container);
                obj.components = [new HGIS.Geometry.LinearRing(
                    container.points
                )];
            },
            "MultiPolygon": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new HGIS.Geometry.MultiPolygon(obj.components)
                ];
            },
            "polygonMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "GeometryCollection": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new HGIS.Geometry.Collection(obj.components)
                ];
            },
            "geometryMember": function(node, obj) {
                this.readChildNodes(node, obj);
            }
        },
        "feature": {
            "*": function(node, obj) {
                // The node can either be named like the featureType, or it
                // can be a child of the feature:featureType.  Children can be
                // geometry or attributes.
                var name;
                var local = node.localName || node.nodeName.split(":").pop();
                // Since an attribute can have the same name as the feature type
                // we only want to read the node as a feature if the parent
                // node can have feature nodes as children.  In this case, the
                // obj.features property is set.
                if (obj.features) {
                    if (!this.singleFeatureType &&
                        (HGIS.Util.indexOf(this.featureType, local) !== -1)) {
                        name = "_typeName";
                    } else if(local === this.featureType) {
                        name = "_typeName";
                    }
                } else {
                    // Assume attribute elements have one child node and that the child
                    // is a text node.  Otherwise assume it is a geometry node.
                    if(node.childNodes.length == 0 ||
                       (node.childNodes.length == 1 && node.firstChild.nodeType == 3)) {
                        if(this.extractAttributes) {
                            name = "_attribute";
                        }
                    } else {
                        name = "_geometry";
                    }
                }
                if(name) {
                    this.readers.feature[name].apply(this, [node, obj]);
                }
            },
            "_typeName": function(node, obj) {
                var container = {components: [], attributes: {}};
                this.readChildNodes(node, container);
                // look for common gml namespaced elements
                if(container.name) {
                    container.attributes.name = container.name;
                }
                var feature = new HGIS.Feature.Vector(
                    container.components[0], container.attributes
                );
                if (!this.singleFeatureType) {
                    feature.type = node.nodeName.split(":").pop();
                    feature.namespace = node.namespaceURI;
                }
                var fid = node.getAttribute("fid") ||
                    this.getAttributeNS(node, this.namespaces["gml"], "id");
                if(fid) {
                    feature.fid = fid;
                }
                if(this.internalProjection && this.externalProjection &&
                   feature.geometry) {
                    feature.geometry.transform(
                        this.externalProjection, this.internalProjection
                    );
                }
                if(container.bounds) {
                    feature.bounds = container.bounds;
                }
                obj.features.push(feature);
            },
            "_geometry": function(node, obj) {
                if (!this.geometryName) {
                    this.geometryName = node.nodeName.split(":").pop();
                }
                this.readChildNodes(node, obj);
            },
            "_attribute": function(node, obj) {
                var local = node.localName || node.nodeName.split(":").pop();
                var value = this.getChildValue(node);
                obj.attributes[local] = value;
            }
        },
        "wfs": {
            "FeatureCollection": function(node, obj) {
                this.readChildNodes(node, obj);
            }
        }
    },
    
    /**
     * Method: write
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>) | HGIS.Feature.Vector}
     *     An array of features or a single feature.
     *
     * Returns:
     * {String} Given an array of features, a doc with a gml:featureMembers
     *     element will be returned.  Given a single feature, a doc with a
     *     gml:featureMember element will be returned.
     */
    write: function(features) {
        var name;
        if(HGIS.Util.isArray(features)) {
            name = "featureMembers";
        } else {
            name = "featureMember";
        }
        var root = this.writeNode("gml:" + name, features);
        this.setAttributeNS(
            root, this.namespaces["xsi"],
            "xsi:schemaLocation", this.schemaLocation
        );

        return HGIS.Format.XML.prototype.write.apply(this, [root]);
    },
    
    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "gml": {
            "featureMember": function(feature) {
                var node = this.createElementNSPlus("gml:featureMember");
                this.writeNode("feature:_typeName", feature, node);
                return node;
            },
            "MultiPoint": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiPoint");
                var components = geometry.components || [geometry];
                for(var i=0, ii=components.length; i<ii; ++i) {
                    this.writeNode("pointMember", components[i], node);
                }
                return node;
            },
            "pointMember": function(geometry) {
                var node = this.createElementNSPlus("gml:pointMember");
                this.writeNode("Point", geometry, node);
                return node;
            },
            "MultiLineString": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiLineString");
                var components = geometry.components || [geometry];
                for(var i=0, ii=components.length; i<ii; ++i) {
                    this.writeNode("lineStringMember", components[i], node);
                }
                return node;
            },
            "lineStringMember": function(geometry) {
                var node = this.createElementNSPlus("gml:lineStringMember");
                this.writeNode("LineString", geometry, node);
                return node;
            },
            "MultiPolygon": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiPolygon");
                var components = geometry.components || [geometry];
                for(var i=0, ii=components.length; i<ii; ++i) {
                    this.writeNode(
                        "polygonMember", components[i], node
                    );
                }
                return node;
            },
            "polygonMember": function(geometry) {
                var node = this.createElementNSPlus("gml:polygonMember");
                this.writeNode("Polygon", geometry, node);
                return node;
            },
            "GeometryCollection": function(geometry) {
                var node = this.createElementNSPlus("gml:GeometryCollection");
                for(var i=0, len=geometry.components.length; i<len; ++i) {
                    this.writeNode("geometryMember", geometry.components[i], node);
                }
                return node;
            },
            "geometryMember": function(geometry) {
                var node = this.createElementNSPlus("gml:geometryMember");
                var child = this.writeNode("feature:_geometry", geometry);
                node.appendChild(child.firstChild);
                return node;
            }
        },
        "feature": {
            "_typeName": function(feature) {
                var node = this.createElementNSPlus("feature:" + this.featureType, {
                    attributes: {fid: feature.fid}
                });
                if(feature.geometry) {
                    this.writeNode("feature:_geometry", feature.geometry, node);
                }
                for(var name in feature.attributes) {
                    var value = feature.attributes[name];
                    if(value != null) {
                        this.writeNode(
                            "feature:_attribute",
                            {name: name, value: value}, node
                        );
                    }
                }
                return node;
            },
            "_geometry": function(geometry) {
                if(this.externalProjection && this.internalProjection) {
                    geometry = geometry.clone().transform(
                        this.internalProjection, this.externalProjection
                    );
                }    
                var node = this.createElementNSPlus(
                    "feature:" + this.geometryName
                );
                var type = this.geometryTypes[geometry.CLASS_NAME];
                var child = this.writeNode("gml:" + type, geometry, node);
                if(this.srsName) {
                    child.setAttribute("srsName", this.srsName);
                }
                return node;
            },
            "_attribute": function(obj) {
                return this.createElementNSPlus("feature:" + obj.name, {
                    value: obj.value
                });
            }
        },
        "wfs": {
            "FeatureCollection": function(features) {
                /**
                 * This is only here because GML2 only describes abstract
                 * feature collections.  Typically, you would not be using
                 * the GML format to write wfs elements.  This just provides
                 * some way to write out lists of features.  GML3 defines the
                 * featureMembers element, so that is used by default instead.
                 */
                var node = this.createElementNSPlus("wfs:FeatureCollection");
                for(var i=0, len=features.length; i<len; ++i) {
                    this.writeNode("gml:featureMember", features[i], node);
                }
                return node;
            }
        }
    },
    
    /**
     * Method: setGeometryTypes
     * Sets the <geometryTypes> mapping.
     */
    setGeometryTypes: function() {
        this.geometryTypes = {
            "HGIS.Geometry.Point": "Point",
            "HGIS.Geometry.MultiPoint": "MultiPoint",
            "HGIS.Geometry.LineString": "LineString",
            "HGIS.Geometry.MultiLineString": "MultiLineString",
            "HGIS.Geometry.Polygon": "Polygon",
            "HGIS.Geometry.MultiPolygon": "MultiPolygon",
            "HGIS.Geometry.Collection": "GeometryCollection"
        };
    },

    CLASS_NAME: "HGIS.Format.GML.Base" 

});
/* ======================================================================
    HGIS/Format/GML/v3.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/GML/Base.js
 */

/**
 * Class: HGIS.Format.GML.v3
 * Parses GML version 3.
 *
 * Inherits from:
 *  - <HGIS.Format.GML.Base>
 */
HGIS.Format.GML.v3 = HGIS.Class(HGIS.Format.GML.Base, {
    
    /**
     * Property: schemaLocation
     * {String} Schema location for a particular minor version.  The writers
     *     conform with the Simple Features Profile for GML.
     */
    schemaLocation: "http://www.opengis.net/gml http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd",

    /**
     * Property: curve
     * {Boolean} Write gml:Curve instead of gml:LineString elements.  This also
     *     affects the elements in multi-part geometries.  Default is false.
     *     To write gml:Curve elements instead of gml:LineString, set curve
     *     to true in the options to the contstructor (cannot be changed after
     *     instantiation).
     */
    curve: false,
    
    /**
     * Property: multiCurve
     * {Boolean} Write gml:MultiCurve instead of gml:MultiLineString.  Since
     *     the latter is deprecated in GML 3, the default is true.  To write
     *     gml:MultiLineString instead of gml:MultiCurve, set multiCurve to
     *     false in the options to the constructor (cannot be changed after
     *     instantiation).
     */
    multiCurve: true,
    
    /**
     * Property: surface
     * {Boolean} Write gml:Surface instead of gml:Polygon elements.  This also
     *     affects the elements in multi-part geometries.  Default is false.
     *     To write gml:Surface elements instead of gml:Polygon, set surface
     *     to true in the options to the contstructor (cannot be changed after
     *     instantiation).
     */
    surface: false,

    /**
     * Property: multiSurface
     * {Boolean} Write gml:multiSurface instead of gml:MultiPolygon.  Since
     *     the latter is deprecated in GML 3, the default is true.  To write
     *     gml:MultiPolygon instead of gml:multiSurface, set multiSurface to
     *     false in the options to the constructor (cannot be changed after
     *     instantiation).
     */
    multiSurface: true,

    /**
     * Constructor: HGIS.Format.GML.v3
     * Create a parser for GML v3.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     *
     * Valid options properties:
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (required).
     * geometryName - {String} Geometry element name.
     */
    initialize: function(options) {
        HGIS.Format.GML.Base.prototype.initialize.apply(this, [options]);
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "gml": HGIS.Util.applyDefaults({
            "_inherit": function(node, obj, container) {
                // SRSReferenceGroup attributes
                var dim = parseInt(node.getAttribute("srsDimension"), 10) ||
                    (container && container.srsDimension);
                if (dim) {
                    obj.srsDimension = dim;
                }
            },
            "featureMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Curve": function(node, container) {
                var obj = {points: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(
                    new HGIS.Geometry.LineString(obj.points)
                );
            },
            "segments": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "LineStringSegment": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                if(obj.points) {
                    Array.prototype.push.apply(container.points, obj.points);
                }
            },
            "pos": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, ""
                );
                var coords = str.split(this.regExes.splitSpace);
                var point;
                if(this.xy) {
                    point = new HGIS.Geometry.Point(
                        coords[0], coords[1], coords[2]
                    );
                } else {
                    point = new HGIS.Geometry.Point(
                        coords[1], coords[0], coords[2]
                    );
                }
                obj.points = [point];
            },
            "posList": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, ""
                );
                var coords = str.split(this.regExes.splitSpace);
                // The "dimension" attribute is from the GML 3.0.1 spec.
                var dim = obj.srsDimension ||
                    parseInt(node.getAttribute("srsDimension") || node.getAttribute("dimension"), 10) || 2;
                var j, x, y, z;
                var numPoints = coords.length / dim;
                var points = new Array(numPoints);
                for(var i=0, len=coords.length; i<len; i += dim) {
                    x = coords[i];
                    y = coords[i+1];
                    z = (dim == 2) ? undefined : coords[i+2];
                    if (this.xy) {
                        points[i/dim] = new HGIS.Geometry.Point(x, y, z);
                    } else {
                        points[i/dim] = new HGIS.Geometry.Point(y, x, z);
                    }
                }
                obj.points = points;
            },
            "Surface": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "patches": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "PolygonPatch": function(node, obj) {
                this.readers.gml.Polygon.apply(this, [node, obj]);
            },
            "exterior": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.outer = obj.components[0];
            },
            "interior": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.inner.push(obj.components[0]);
            },
            "MultiCurve": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(obj.components.length > 0) {
                    container.components = [
                        new HGIS.Geometry.MultiLineString(obj.components)
                    ];
                }
            },
            "curveMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "MultiSurface": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(obj.components.length > 0) {
                    container.components = [
                        new HGIS.Geometry.MultiPolygon(obj.components)
                    ];
                }
            },
            "surfaceMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "surfaceMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "pointMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "lineStringMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "polygonMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "geometryMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Envelope": function(node, container) {
                var obj = {points: new Array(2)};
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                var min = obj.points[0];
                var max = obj.points[1];
                container.components.push(
                    new HGIS.Bounds(min.x, min.y, max.x, max.y)
                );
            },
            "lowerCorner": function(node, container) {
                var obj = {};
                this.readers.gml.pos.apply(this, [node, obj]);
                container.points[0] = obj.points[0];
            },
            "upperCorner": function(node, container) {
                var obj = {};
                this.readers.gml.pos.apply(this, [node, obj]);
                container.points[1] = obj.points[0];
            }
        }, HGIS.Format.GML.Base.prototype.readers["gml"]),            
        "feature": HGIS.Format.GML.Base.prototype.readers["feature"],
        "wfs": HGIS.Format.GML.Base.prototype.readers["wfs"]
    },
    
    /**
     * Method: write
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>) | HGIS.Feature.Vector}
     *     An array of features or a single feature.
     *
     * Returns:
     * {String} Given an array of features, a doc with a gml:featureMembers
     *     element will be returned.  Given a single feature, a doc with a
     *     gml:featureMember element will be returned.
     */
    write: function(features) {
        var name;
        if(HGIS.Util.isArray(features)) {
            name = "featureMembers";
        } else {
            name = "featureMember";
        }
        var root = this.writeNode("gml:" + name, features);
        this.setAttributeNS(
            root, this.namespaces["xsi"],
            "xsi:schemaLocation", this.schemaLocation
        );

        return HGIS.Format.XML.prototype.write.apply(this, [root]);
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "gml": HGIS.Util.applyDefaults({
            "featureMembers": function(features) {
                var node = this.createElementNSPlus("gml:featureMembers");
                for(var i=0, len=features.length; i<len; ++i) {
                    this.writeNode("feature:_typeName", features[i], node);
                }
                return node;
            },
            "Point": function(geometry) {
                var node = this.createElementNSPlus("gml:Point");
                this.writeNode("pos", geometry, node);
                return node;
            },
            "pos": function(point) {
                // only 2d for simple features profile
                var pos = (this.xy) ?
                    (point.x + " " + point.y) : (point.y + " " + point.x);
                return this.createElementNSPlus("gml:pos", {
                    value: pos
                });
            },
            "LineString": function(geometry) {
                var node = this.createElementNSPlus("gml:LineString");
                this.writeNode("posList", geometry.components, node);
                return node;
            },
            "Curve": function(geometry) {
                var node = this.createElementNSPlus("gml:Curve");
                this.writeNode("segments", geometry, node);
                return node;
            },
            "segments": function(geometry) {
                var node = this.createElementNSPlus("gml:segments");
                this.writeNode("LineStringSegment", geometry, node);
                return node;
            },
            "LineStringSegment": function(geometry) {
                var node = this.createElementNSPlus("gml:LineStringSegment");
                this.writeNode("posList", geometry.components, node);
                return node;
            },
            "posList": function(points) {
                // only 2d for simple features profile
                var len = points.length;
                var parts = new Array(len);
                var point;
                for(var i=0; i<len; ++i) {
                    point = points[i];
                    if(this.xy) {
                        parts[i] = point.x + " " + point.y;
                    } else {
                        parts[i] = point.y + " " + point.x;
                    }
                }
                return this.createElementNSPlus("gml:posList", {
                    value: parts.join(" ")
                }); 
            },
            "Surface": function(geometry) {
                var node = this.createElementNSPlus("gml:Surface");
                this.writeNode("patches", geometry, node);
                return node;
            },
            "patches": function(geometry) {
                var node = this.createElementNSPlus("gml:patches");
                this.writeNode("PolygonPatch", geometry, node);
                return node;
            },
            "PolygonPatch": function(geometry) {
                var node = this.createElementNSPlus("gml:PolygonPatch", {
                    attributes: {interpolation: "planar"}
                });
                this.writeNode("exterior", geometry.components[0], node);
                for(var i=1, len=geometry.components.length; i<len; ++i) {
                    this.writeNode(
                        "interior", geometry.components[i], node
                    );
                }
                return node;
            },
            "Polygon": function(geometry) {
                var node = this.createElementNSPlus("gml:Polygon");
                this.writeNode("exterior", geometry.components[0], node);
                for(var i=1, len=geometry.components.length; i<len; ++i) {
                    this.writeNode(
                        "interior", geometry.components[i], node
                    );
                }
                return node;
            },
            "exterior": function(ring) {
                var node = this.createElementNSPlus("gml:exterior");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "interior": function(ring) {
                var node = this.createElementNSPlus("gml:interior");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "LinearRing": function(ring) {
                var node = this.createElementNSPlus("gml:LinearRing");
                this.writeNode("posList", ring.components, node);
                return node;
            },
            "MultiCurve": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiCurve");
                var components = geometry.components || [geometry];
                for(var i=0, len=components.length; i<len; ++i) {
                    this.writeNode("curveMember", components[i], node);
                }
                return node;
            },
            "curveMember": function(geometry) {
                var node = this.createElementNSPlus("gml:curveMember");
                if(this.curve) {
                    this.writeNode("Curve", geometry, node);
                } else {
                    this.writeNode("LineString", geometry, node);
                }
                return node;
            },
            "MultiSurface": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiSurface");
                var components = geometry.components || [geometry];
                for(var i=0, len=components.length; i<len; ++i) {
                    this.writeNode("surfaceMember", components[i], node);
                }
                return node;
            },
            "surfaceMember": function(polygon) {
                var node = this.createElementNSPlus("gml:surfaceMember");
                if(this.surface) {
                    this.writeNode("Surface", polygon, node);
                } else {
                    this.writeNode("Polygon", polygon, node);
                }
                return node;
            },
            "Envelope": function(bounds) {
                var node = this.createElementNSPlus("gml:Envelope");
                this.writeNode("lowerCorner", bounds, node);
                this.writeNode("upperCorner", bounds, node);
                // srsName attribute is required for gml:Envelope
                if(this.srsName) {
                    node.setAttribute("srsName", this.srsName);
                }
                return node;
            },
            "lowerCorner": function(bounds) {
                // only 2d for simple features profile
                var pos = (this.xy) ?
                    (bounds.left + " " + bounds.bottom) :
                    (bounds.bottom + " " + bounds.left);
                return this.createElementNSPlus("gml:lowerCorner", {
                    value: pos
                });
            },
            "upperCorner": function(bounds) {
                // only 2d for simple features profile
                var pos = (this.xy) ?
                    (bounds.right + " " + bounds.top) :
                    (bounds.top + " " + bounds.right);
                return this.createElementNSPlus("gml:upperCorner", {
                    value: pos
                });
            }
        }, HGIS.Format.GML.Base.prototype.writers["gml"]),
        "feature": HGIS.Format.GML.Base.prototype.writers["feature"],
        "wfs": HGIS.Format.GML.Base.prototype.writers["wfs"]
    },

    /**
     * Method: setGeometryTypes
     * Sets the <geometryTypes> mapping.
     */
    setGeometryTypes: function() {
        this.geometryTypes = {
            "HGIS.Geometry.Point": "Point",
            "HGIS.Geometry.MultiPoint": "MultiPoint",
            "HGIS.Geometry.LineString": (this.curve === true) ? "Curve": "LineString",
            "HGIS.Geometry.MultiLineString": (this.multiCurve === false) ? "MultiLineString" : "MultiCurve",
            "HGIS.Geometry.Polygon": (this.surface === true) ? "Surface" : "Polygon",
            "HGIS.Geometry.MultiPolygon": (this.multiSurface === false) ? "MultiPolygon" : "MultiSurface",
            "HGIS.Geometry.Collection": "GeometryCollection"
        };
    },
    
    CLASS_NAME: "HGIS.Format.GML.v3" 

});
/* ======================================================================
    HGIS/Format/Filter/v1_1_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/Filter/v1.js
 * @requires HGIS/Format/GML/v3.js
 */

/**
 * Class: HGIS.Format.Filter.v1_1_0
 * Write ogc:Filter version 1.1.0.
 *
 * Differences from the v1.0.0 parser:
 *  - uses GML v3 instead of GML v2
 *  - reads matchCase attribute on ogc:PropertyIsEqual and
 *        ogc:PropertyIsNotEqual elements.
 *  - writes matchCase attribute from comparison filters of type EQUAL_TO,
 *        NOT_EQUAL_TO and LIKE.
 * 
 * Inherits from: 
 *  - <HGIS.Format.GML.v3>
 *  - <HGIS.Format.Filter.v1>
 */
HGIS.Format.Filter.v1_1_0 = HGIS.Class(
    HGIS.Format.GML.v3, HGIS.Format.Filter.v1, {
    
    /**
     * Constant: VERSION
     * {String} 1.1.0
     */
    VERSION: "1.1.0",
    
    /**
     * Property: schemaLocation
     * {String} http://www.opengis.net/ogc/filter/1.1.0/filter.xsd
     */
    schemaLocation: "http://www.opengis.net/ogc/filter/1.1.0/filter.xsd",

    /**
     * Constructor: HGIS.Format.Filter.v1_1_0
     * Instances of this class are not created directly.  Use the
     *     <HGIS.Format.Filter> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        HGIS.Format.GML.v3.prototype.initialize.apply(
            this, [options]
        );
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ogc": HGIS.Util.applyDefaults({
            "PropertyIsEqualTo": function(node, obj) {
                var matchCase = node.getAttribute("matchCase");
                var filter = new HGIS.Filter.Comparison({
                    type: HGIS.Filter.Comparison.EQUAL_TO,
                    matchCase: !(matchCase === "false" || matchCase === "0")
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsNotEqualTo": function(node, obj) {
                var matchCase = node.getAttribute("matchCase");
                var filter = new HGIS.Filter.Comparison({
                    type: HGIS.Filter.Comparison.NOT_EQUAL_TO,
                    matchCase: !(matchCase === "false" || matchCase === "0")
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLike": function(node, obj) {
                var filter = new HGIS.Filter.Comparison({
                    type: HGIS.Filter.Comparison.LIKE
                });
                this.readChildNodes(node, filter);
                var wildCard = node.getAttribute("wildCard");
                var singleChar = node.getAttribute("singleChar");
                var esc = node.getAttribute("escapeChar");
                filter.value2regex(wildCard, singleChar, esc);
                obj.filters.push(filter);
            }
        }, HGIS.Format.Filter.v1.prototype.readers["ogc"]),
        "gml": HGIS.Format.GML.v3.prototype.readers["gml"],
        "feature": HGIS.Format.GML.v3.prototype.readers["feature"]        
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "ogc": HGIS.Util.applyDefaults({
            "PropertyIsEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsEqualTo", {
                    attributes: {matchCase: filter.matchCase}
                });
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsNotEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsNotEqualTo", {
                    attributes: {matchCase: filter.matchCase}
                });
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsLike": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLike", {
                    attributes: {
                        matchCase: filter.matchCase,
                        wildCard: "*", singleChar: ".", escapeChar: "!"
                    }
                });
                // no ogc:expression handling for now
                this.writeNode("PropertyName", filter, node);
                // convert regex string to ogc string
                this.writeNode("Literal", filter.regex2value(), node);
                return node;
            },
            "BBOX": function(filter) {
                var node = this.createElementNSPlus("ogc:BBOX");
                // PropertyName is optional in 1.1.0
                filter.property && this.writeNode("PropertyName", filter, node);
                var box = this.writeNode("gml:Envelope", filter.value);
                if(filter.projection) {
                    box.setAttribute("srsName", filter.projection);
                }
                node.appendChild(box); 
                return node;
            },
            "SortBy": function(sortProperties) {
                var node = this.createElementNSPlus("ogc:SortBy");
                for (var i=0,l=sortProperties.length;i<l;i++) {
                    this.writeNode(
                        "ogc:SortProperty",
                        sortProperties[i],
                        node
                    );
                }
                return node;
            }, 
            "SortProperty": function(sortProperty) {
                var node = this.createElementNSPlus("ogc:SortProperty");
                this.writeNode(
                    "ogc:PropertyName",
                    sortProperty,
                    node
                );
                this.writeNode(
                    "ogc:SortOrder",
                    (sortProperty.order == 'DESC') ? 'DESC' : 'ASC',
                    node
                );
                return node;
            },
            "SortOrder": function(value) {
                var node = this.createElementNSPlus("ogc:SortOrder", {
                    value: value
                });
                return node;
            }
        }, HGIS.Format.Filter.v1.prototype.writers["ogc"]),
        "gml": HGIS.Format.GML.v3.prototype.writers["gml"],
        "feature": HGIS.Format.GML.v3.prototype.writers["feature"]
    },

    /**
     * Method: writeSpatial
     *
     * Read a {<HGIS.Filter.Spatial>} filter and converts it into XML.
     *
     * Parameters:
     * filter - {<HGIS.Filter.Spatial>} The filter.
     * name - {String} Name of the generated XML element.
     *
     * Returns:
     * {DOMElement} The created XML element.
     */
    writeSpatial: function(filter, name) {
        var node = this.createElementNSPlus("ogc:"+name);
        this.writeNode("PropertyName", filter, node);
        if(filter.value instanceof HGIS.Filter.Function) {
            this.writeNode("Function", filter.value, node);
        } else {
        var child;
        if(filter.value instanceof HGIS.Geometry) {
            child = this.writeNode("feature:_geometry", filter.value).firstChild;
        } else {
            child = this.writeNode("gml:Envelope", filter.value);
        }
        if(filter.projection) {
            child.setAttribute("srsName", filter.projection);
        }
        node.appendChild(child);
        }
        return node;
    },

    CLASS_NAME: "HGIS.Format.Filter.v1_1_0" 

});
/* ======================================================================
    HGIS/Format/OWSCommon.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML/VersionedOGC.js
 */

/**
 * Class: HGIS.Format.OWSCommon
 * Read OWSCommon. Create a new instance with the <HGIS.Format.OWSCommon>
 *     constructor.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML.VersionedOGC>
 */
HGIS.Format.OWSCommon = HGIS.Class(HGIS.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.0.0".
     */
    defaultVersion: "1.0.0",
    
    /**
     * Constructor: HGIS.Format.OWSCommon
     * Create a new parser for OWSCommon.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Method: getVersion
     * Returns the version to use. Subclasses can override this function
     * if a different version detection is needed.
     *
     * Parameters:
     * root - {DOMElement}
     * options - {Object} Optional configuration object.
     *
     * Returns:
     * {String} The version to use.
     */
    getVersion: function(root, options) {
        var version = this.version;
        if(!version) {
            // remember version does not correspond to the OWS version
            // it corresponds to the WMS/WFS/WCS etc. request version
            var uri = root.getAttribute("xmlns:ows");
            // the above will fail if the namespace prefix is different than
            // ows and if the namespace is declared on a different element
            if (uri && uri.substring(uri.lastIndexOf("/")+1) === "1.1") {
                version ="1.1.0";
            } 
            if(!version) {
                version = this.defaultVersion;
            }
        }
        return version;
    },

    /**
     * APIMethod: read
     * Read an OWSCommon document and return an object.
     *
     * Parameters:
     * data - {String | DOMElement} Data to read.
     * options - {Object} Options for the reader.
     *
     * Returns:
     * {Object} An object representing the structure of the document.
     */

    CLASS_NAME: "HGIS.Format.OWSCommon" 
});
/* ======================================================================
    HGIS/Format/OWSCommon/v1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/OWSCommon.js
 */

/**
 * Class: HGIS.Format.OWSCommon.v1
 * Common readers and writers for OWSCommon v1.X formats
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.OWSCommon.v1 = HGIS.Class(HGIS.Format.XML, {
   
    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * Method: read
     *
     * Parameters:
     * data - {DOMElement} An OWSCommon document element.
     * options - {Object} Options for the reader.
     *
     * Returns:
     * {Object} An object representing the OWSCommon document.
     */
    read: function(data, options) {
        options = HGIS.Util.applyDefaults(options, this.options);
        var ows = {};
        this.readChildNodes(data, ows);
        return ows;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ows": {
            "Exception": function(node, exceptionReport) {
                var exception = {
                    code: node.getAttribute('exceptionCode'),
                    locator: node.getAttribute('locator'),
                    texts: []
                };
                exceptionReport.exceptions.push(exception);
                this.readChildNodes(node, exception);
            },
            "ExceptionText": function(node, exception) {
                var text = this.getChildValue(node);
                exception.texts.push(text);
            },
            "ServiceIdentification": function(node, obj) {
                obj.serviceIdentification = {};
                this.readChildNodes(node, obj.serviceIdentification);
            },
            "Title": function(node, obj) {
                obj.title = this.getChildValue(node);
            },
            "Abstract": function(node, serviceIdentification) {
                serviceIdentification["abstract"] = this.getChildValue(node);
            },
            "Keywords": function(node, serviceIdentification) {
                serviceIdentification.keywords = {};
                this.readChildNodes(node, serviceIdentification.keywords);
            },
            "Keyword": function(node, keywords) {
                keywords[this.getChildValue(node)] = true;
            },
            "ServiceType": function(node, serviceIdentification) {
                serviceIdentification.serviceType = {
                    codeSpace: node.getAttribute('codeSpace'), 
                    value: this.getChildValue(node)};
            },
            "ServiceTypeVersion": function(node, serviceIdentification) {
                serviceIdentification.serviceTypeVersion = this.getChildValue(node);
            },
            "Fees": function(node, serviceIdentification) {
                serviceIdentification.fees = this.getChildValue(node);
            },
            "AccessConstraints": function(node, serviceIdentification) {
                serviceIdentification.accessConstraints = 
                    this.getChildValue(node);
            },
            "ServiceProvider": function(node, obj) {
                obj.serviceProvider = {};
                this.readChildNodes(node, obj.serviceProvider);
            },
            "ProviderName": function(node, serviceProvider) {
                serviceProvider.providerName = this.getChildValue(node);
            },
            "ProviderSite": function(node, serviceProvider) {
                serviceProvider.providerSite = this.getAttributeNS(node, 
                    this.namespaces.xlink, "href");
            },
            "ServiceContact": function(node, serviceProvider) {
                serviceProvider.serviceContact = {};
                this.readChildNodes(node, serviceProvider.serviceContact);
            },
            "IndividualName": function(node, serviceContact) {
                serviceContact.individualName = this.getChildValue(node);
            },
            "PositionName": function(node, serviceContact) {
                serviceContact.positionName = this.getChildValue(node);
            },
            "ContactInfo": function(node, serviceContact) {
                serviceContact.contactInfo = {};
                this.readChildNodes(node, serviceContact.contactInfo);
            },
            "Phone": function(node, contactInfo) {
                contactInfo.phone = {};
                this.readChildNodes(node, contactInfo.phone);
            },
            "Voice": function(node, phone) {
                phone.voice = this.getChildValue(node);
            },
            "Address": function(node, contactInfo) {
                contactInfo.address = {};
                this.readChildNodes(node, contactInfo.address);
            },
            "DeliveryPoint": function(node, address) {
                address.deliveryPoint = this.getChildValue(node);
            },
            "City": function(node, address) {
                address.city = this.getChildValue(node);
            },
            "AdministrativeArea": function(node, address) {
                address.administrativeArea = this.getChildValue(node);
            },
            "PostalCode": function(node, address) {
                address.postalCode = this.getChildValue(node);
            },
            "Country": function(node, address) {
                address.country = this.getChildValue(node);
            },
            "ElectronicMailAddress": function(node, address) {
                address.electronicMailAddress = this.getChildValue(node);
            },
            "Role": function(node, serviceContact) {
                serviceContact.role = this.getChildValue(node);
            },
            "OperationsMetadata": function(node, obj) {
                obj.operationsMetadata = {};
                this.readChildNodes(node, obj.operationsMetadata);
            },
            "Operation": function(node, operationsMetadata) {
                var name = node.getAttribute("name");
                operationsMetadata[name] = {};
                this.readChildNodes(node, operationsMetadata[name]);
            },
            "DCP": function(node, operation) {
                operation.dcp = {};
                this.readChildNodes(node, operation.dcp);
            },
            "HTTP": function(node, dcp) {
                dcp.http = {};
                this.readChildNodes(node, dcp.http);
            },
            "Get": function(node, http) {
                if (!http.get) {
                    http.get = [];
                }
                var obj = {
                    url: this.getAttributeNS(node, this.namespaces.xlink, "href")
                };
                this.readChildNodes(node, obj);
                http.get.push(obj);
            },
            "Post": function(node, http) {
                if (!http.post) {
                    http.post = [];
                }
                var obj = {
                    url: this.getAttributeNS(node, this.namespaces.xlink, "href")
                };
                this.readChildNodes(node, obj);
                http.post.push(obj);
            },
            "Parameter": function(node, operation) {
                if (!operation.parameters) {
                    operation.parameters = {};
                }
                var name = node.getAttribute("name");
                operation.parameters[name] = {};
                this.readChildNodes(node, operation.parameters[name]);
            },
            "Constraint": function(node, obj) {
                if (!obj.constraints) {
                    obj.constraints = {};
                }
                var name = node.getAttribute("name");
                obj.constraints[name] = {};
                this.readChildNodes(node, obj.constraints[name]);
            },
            "Value": function(node, allowedValues) {
                allowedValues[this.getChildValue(node)] = true;
            },
            "OutputFormat": function(node, obj) {
                obj.formats.push({value: this.getChildValue(node)});
                this.readChildNodes(node, obj);
            },
            "WGS84BoundingBox": function(node, obj) {
                var boundingBox = {};
                boundingBox.crs = node.getAttribute("crs");
                if (obj.BoundingBox) {
                    obj.BoundingBox.push(boundingBox);
                } else {
                    obj.projection = boundingBox.crs;
                    boundingBox = obj;
               }
               this.readChildNodes(node, boundingBox);
            },
            "BoundingBox": function(node, obj) {
                // FIXME: We consider that BoundingBox is the same as WGS84BoundingBox
                // LowerCorner = "min_x min_y"
                // UpperCorner = "max_x max_y"
                // It should normally depend on the projection
                this.readers['ows']['WGS84BoundingBox'].apply(this, [node, obj]);
            },
            "LowerCorner": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, "");
                str = str.replace(this.regExes.trimComma, ",");
                var pointList = str.split(this.regExes.splitSpace);
                obj.left = pointList[0];
                obj.bottom = pointList[1];
            },
            "UpperCorner": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, "");
                str = str.replace(this.regExes.trimComma, ",");
                var pointList = str.split(this.regExes.splitSpace);
                obj.right = pointList[0];
                obj.top = pointList[1];
                obj.bounds = new HGIS.Bounds(obj.left, obj.bottom,
                    obj.right, obj.top);
                delete obj.left;
                delete obj.bottom;
                delete obj.right;
                delete obj.top;
            },
            "Language": function(node, obj) {
                obj.language = this.getChildValue(node);
            }
        }
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "ows": {
            "BoundingBox": function(options, nodeName) {
                var node = this.createElementNSPlus(nodeName || "ows:BoundingBox", {
                    attributes: {
                        crs: options.projection
                    }
                });
                this.writeNode("ows:LowerCorner", options, node);
                this.writeNode("ows:UpperCorner", options, node);
                return node;
            },
            "LowerCorner": function(options) {
                var node = this.createElementNSPlus("ows:LowerCorner", {
                    value: options.bounds.left + " " + options.bounds.bottom });
                return node;
            },
            "UpperCorner": function(options) {
                var node = this.createElementNSPlus("ows:UpperCorner", {
                    value: options.bounds.right + " " + options.bounds.top });
                return node;
            },
            "Identifier": function(identifier) {
                var node = this.createElementNSPlus("ows:Identifier", {
                    value: identifier });
                return node;
            },
            "Title": function(title) {
                var node = this.createElementNSPlus("ows:Title", {
                    value: title });
                return node;
            },
            "Abstract": function(abstractValue) {
                var node = this.createElementNSPlus("ows:Abstract", {
                    value: abstractValue });
                return node;
            },
            "OutputFormat": function(format) {
                var node = this.createElementNSPlus("ows:OutputFormat", {
                    value: format });
                return node;
            }
        }
    },

    CLASS_NAME: "HGIS.Format.OWSCommon.v1"

});
/* ======================================================================
    HGIS/Format/OWSCommon/v1_0_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/OWSCommon/v1.js
 */

/**
 * Class: HGIS.Format.OWSCommon.v1_0_0
 * Parser for OWS Common version 1.0.0.
 *
 * Inherits from:
 *  - <HGIS.Format.OWSCommon.v1>
 */
HGIS.Format.OWSCommon.v1_0_0 = HGIS.Class(HGIS.Format.OWSCommon.v1, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ows": HGIS.Util.applyDefaults({
            "ExceptionReport": function(node, obj) {
                obj.success = false;
                obj.exceptionReport = {
                    version: node.getAttribute('version'),
                    language: node.getAttribute('language'),
                    exceptions: []
                };
                this.readChildNodes(node, obj.exceptionReport);
            } 
        }, HGIS.Format.OWSCommon.v1.prototype.readers.ows)
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "ows": HGIS.Format.OWSCommon.v1.prototype.writers.ows
    },
    
    CLASS_NAME: "HGIS.Format.OWSCommon.v1_0_0"

});
/* ======================================================================
    HGIS/Format/WFST/v1_1_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WFST/v1.js
 * @requires HGIS/Format/Filter/v1_1_0.js
 * @requires HGIS/Format/OWSCommon/v1_0_0.js
 */

/**
 * Class: HGIS.Format.WFST.v1_1_0
 * A format for creating WFS v1.1.0 transactions.  Create a new instance with the
 *     <HGIS.Format.WFST.v1_1_0> constructor.
 *
 * Inherits from:
 *  - <HGIS.Format.Filter.v1_1_0>
 *  - <HGIS.Format.WFST.v1>
 */
HGIS.Format.WFST.v1_1_0 = HGIS.Class(
    HGIS.Format.Filter.v1_1_0, HGIS.Format.WFST.v1, {
    
    /**
     * Property: version
     * {String} WFS version number.
     */
    version: "1.1.0",
    
    /**
     * Property: schemaLocations
     * {Object} Properties are namespace aliases, values are schema locations.
     */
    schemaLocations: {
        "wfs": "http://schemas.opengis.net/wfs/1.1.0/wfs.xsd"
    },
    
    /**
     * Constructor: HGIS.Format.WFST.v1_1_0
     * A class for parsing and generating WFS v1.1.0 transactions.
     *
     * To read additional information like hit count (numberOfFeatures) from
     * the  FeatureCollection, call the <HGIS.Format.WFST.v1.read> method
     * with {output: "object"} as 2nd argument. Note that it is possible to
     * just request the hit count from a WFS 1.1.0 server with the
     * resultType="hits" request parameter.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties:
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (optional).
     * featurePrefix - {String} Feature namespace alias (optional - only used
     *     if featureNS is provided).  Default is 'feature'.
     * geometryName - {String} Name of geometry attribute.  Default is 'the_geom'.
     */
    initialize: function(options) {
        HGIS.Format.Filter.v1_1_0.prototype.initialize.apply(this, [options]);
        HGIS.Format.WFST.v1.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Method: readNode
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     *
     * Parameters:
     * node - {DOMElement} The node to be read (required).
     * obj - {Object} The object to be modified (optional).
     * first - {Boolean} Should be set to true for the first node read. This
     *     is usually the readNode call in the read method. Without this being
     *     set, auto-configured properties will stick on subsequent reads.
     *
     * Returns:
     * {Object} The input object, modified (or a new one if none was provided).
     */
    readNode: function(node, obj, first) {
        // Not the superclass, only the mixin classes inherit from
        // Format.GML.v3. We need this because we don't want to get readNode
        // from the superclass's superclass, which is HGIS.Format.XML.
        return HGIS.Format.GML.v3.prototype.readNode.apply(this, arguments);
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wfs": HGIS.Util.applyDefaults({
            "FeatureCollection": function(node, obj) {
                obj.numberOfFeatures = parseInt(node.getAttribute(
                    "numberOfFeatures"));
                HGIS.Format.WFST.v1.prototype.readers["wfs"]["FeatureCollection"].apply(
                    this, arguments);
            },
            "TransactionResponse": function(node, obj) {
                obj.insertIds = [];
                obj.success = false;
                this.readChildNodes(node, obj);
            },
            "TransactionSummary": function(node, obj) {
                // this is a limited test of success
                obj.success = true;
            },
            "InsertResults": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Feature": function(node, container) {
                var obj = {fids: []};
                this.readChildNodes(node, obj);
                container.insertIds.push(obj.fids[0]);
            }
        }, HGIS.Format.WFST.v1.prototype.readers["wfs"]),
        "gml": HGIS.Format.GML.v3.prototype.readers["gml"],
        "feature": HGIS.Format.GML.v3.prototype.readers["feature"],
        "ogc": HGIS.Format.Filter.v1_1_0.prototype.readers["ogc"],
        "ows": HGIS.Format.OWSCommon.v1_0_0.prototype.readers["ows"]
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "wfs": HGIS.Util.applyDefaults({
            "GetFeature": function(options) {
                var node = HGIS.Format.WFST.v1.prototype.writers["wfs"]["GetFeature"].apply(this, arguments);
                options && this.setAttributes(node, {
                    resultType: options.resultType,
                    startIndex: options.startIndex,
                    count: options.count
                });
                return node;
            },
            "Query": function(options) {
                options = HGIS.Util.extend({
                    featureNS: this.featureNS,
                    featurePrefix: this.featurePrefix,
                    featureType: this.featureType,
                    srsName: this.srsName
                }, options);
                var prefix = options.featurePrefix;
                var node = this.createElementNSPlus("wfs:Query", {
                    attributes: {
                        typeName: (prefix ? prefix + ":" : "") +
                            options.featureType,
                        srsName: options.srsName
                    }
                });
                if(options.featureNS) {
                    node.setAttribute("xmlns:" + prefix, options.featureNS);
                }
                if(options.propertyNames) {
                    for(var i=0,len = options.propertyNames.length; i<len; i++) {
                        this.writeNode(
                            "wfs:PropertyName", 
                            {property: options.propertyNames[i]},
                            node
                        );
                    }
                }
                if(options.filter) {
                    HGIS.Format.WFST.v1_1_0.prototype.setFilterProperty.call(this, options.filter);
                    this.writeNode("ogc:Filter", options.filter, node);
                }
                return node;
            },
            "PropertyName": function(obj) {
                return this.createElementNSPlus("wfs:PropertyName", {
                    value: obj.property
                });
            }            
        }, HGIS.Format.WFST.v1.prototype.writers["wfs"]),
        "gml": HGIS.Format.GML.v3.prototype.writers["gml"],
        "feature": HGIS.Format.GML.v3.prototype.writers["feature"],
        "ogc": HGIS.Format.Filter.v1_1_0.prototype.writers["ogc"]
    },

    CLASS_NAME: "HGIS.Format.WFST.v1_1_0" 
});
/* ======================================================================
    HGIS/Protocol.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 */

/**
 * Class: HGIS.Protocol
 * Abstract vector layer protocol class.  Not to be instantiated directly.  Use
 *     one of the protocol subclasses instead.
 */
HGIS.Protocol = HGIS.Class({
    
    /**
     * Property: format
     * {<HGIS.Format>} The format used by this protocol.
     */
    format: null,
    
    /**
     * Property: options
     * {Object} Any options sent to the constructor.
     */
    options: null,

    /**
     * Property: autoDestroy
     * {Boolean} The creator of the protocol can set autoDestroy to false
     *      to fully control when the protocol is destroyed. Defaults to
     *      true.
     */
    autoDestroy: true,
   
    /**
     * Property: defaultFilter
     * {<HGIS.Filter>} Optional default filter to read requests
     */
    defaultFilter: null,
    
    /**
     * Constructor: HGIS.Protocol
     * Abstract class for vector protocols.  Create instances of a subclass.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
    initialize: function(options) {
        options = options || {};
        HGIS.Util.extend(this, options);
        this.options = options;
    },

    /**
     * Method: mergeWithDefaultFilter
     * Merge filter passed to the read method with the default one
     *
     * Parameters:
     * filter - {<HGIS.Filter>}
     */
    mergeWithDefaultFilter: function(filter) {
        var merged;
        if (filter && this.defaultFilter) {
            merged = new HGIS.Filter.Logical({
                type: HGIS.Filter.Logical.AND,
                filters: [this.defaultFilter, filter]
            });
        } else {
            merged = filter || this.defaultFilter || undefined;
        }
        return merged;
    },

    /**
     * APIMethod: destroy
     * Clean up the protocol.
     */
    destroy: function() {
        this.options = null;
        this.format = null;
    },
    
    /**
     * APIMethod: read
     * Construct a request for reading new features.
     *
     * Parameters:
     * options - {Object} Optional object for configuring the request.
     *
     * Returns:
     * {<HGIS.Protocol.Response>} An <HGIS.Protocol.Response>
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    read: function(options) {
        options = options || {};
        options.filter = this.mergeWithDefaultFilter(options.filter);
    },
    
    
    /**
     * APIMethod: create
     * Construct a request for writing newly created features.
     *
     * Parameters:
     * features - {Array({<HGIS.Feature.Vector>})} or
     *            {<HGIS.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *
     * Returns:
     * {<HGIS.Protocol.Response>} An <HGIS.Protocol.Response>
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    create: function() {
    },
    
    /**
     * APIMethod: update
     * Construct a request updating modified features.
     *
     * Parameters:
     * features - {Array({<HGIS.Feature.Vector>})} or
     *            {<HGIS.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *
     * Returns:
     * {<HGIS.Protocol.Response>} An <HGIS.Protocol.Response>
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    update: function() {
    },
    
    /**
     * APIMethod: delete
     * Construct a request deleting a removed feature.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *
     * Returns:
     * {<HGIS.Protocol.Response>} An <HGIS.Protocol.Response>
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    "delete": function() {
    },

    /**
     * APIMethod: commit
     * Go over the features and for each take action
     * based on the feature state. Possible actions are create,
     * update and delete.
     *
     * Parameters:
     * features - {Array({<HGIS.Feature.Vector>})}
     * options - {Object} Object whose possible keys are "create", "update",
     *      "delete", "callback" and "scope", the values referenced by the
     *      first three are objects as passed to the "create", "update", and
     *      "delete" methods, the value referenced by the "callback" key is
     *      a function which is called when the commit operation is complete
     *      using the scope referenced by the "scope" key.
     *
     * Returns:
     * {Array({<HGIS.Protocol.Response>})} An array of
     * <HGIS.Protocol.Response> objects.
     */
    commit: function() {
    },

    /**
     * Method: abort
     * Abort an ongoing request.
     *
     * Parameters:
     * response - {<HGIS.Protocol.Response>}
     */
    abort: function(response) {
    },
   
    /**
     * Method: createCallback
     * Returns a function that applies the given public method with resp and
     *     options arguments.
     *
     * Parameters:
     * method - {Function} The method to be applied by the callback.
     * response - {<HGIS.Protocol.Response>} The protocol response object.
     * options - {Object} Options sent to the protocol method
     */
    createCallback: function(method, response, options) {
        return HGIS.Function.bind(function() {
            method.apply(this, [response, options]);
        }, this);
    },
   
    CLASS_NAME: "HGIS.Protocol" 
});

/**
 * Class: HGIS.Protocol.Response
 * Protocols return Response objects to their users.
 */
HGIS.Protocol.Response = HGIS.Class({
    /**
     * Property: code
     * {Number} - HGIS.Protocol.Response.SUCCESS or
     *            HGIS.Protocol.Response.FAILURE
     */
    code: null,

    /**
     * Property: requestType
     * {String} The type of request this response corresponds to. Either
     *      "create", "read", "update" or "delete".
     */
    requestType: null,

    /**
     * Property: last
     * {Boolean} - true if this is the last response expected in a commit,
     * false otherwise, defaults to true.
     */
    last: true,

    /**
     * Property: features
     * {Array({<HGIS.Feature.Vector>})} or {<HGIS.Feature.Vector>}
     * The features returned in the response by the server. Depending on the 
     * protocol's read payload, either features or data will be populated.
     */
    features: null,

    /**
     * Property: data
     * {Object}
     * The data returned in the response by the server. Depending on the 
     * protocol's read payload, either features or data will be populated.
     */
    data: null,

    /**
     * Property: reqFeatures
     * {Array({<HGIS.Feature.Vector>})} or {<HGIS.Feature.Vector>}
     * The features provided by the user and placed in the request by the
     *      protocol.
     */
    reqFeatures: null,

    /**
     * Property: priv
     */
    priv: null,

    /**
     * Property: error
     * {Object} The error object in case a service exception was encountered.
     */
    error: null,

    /**
     * Constructor: HGIS.Protocol.Response
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
    initialize: function(options) {
        HGIS.Util.extend(this, options);
    },

    /**
     * Method: success
     *
     * Returns:
     * {Boolean} - true on success, false otherwise
     */
    success: function() {
        return this.code > 0;
    },

    CLASS_NAME: "HGIS.Protocol.Response"
});

HGIS.Protocol.Response.SUCCESS = 1;
HGIS.Protocol.Response.FAILURE = 0;
/* ======================================================================
    HGIS/Format/JSON.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * Note:
 * This work draws heavily from the public domain JSON serializer/deserializer
 *     at http://www.json.org/json.js. Rewritten so that it doesn't modify
 *     basic data prototypes.
 */

/**
 * @requires HGIS/Format.js
 */

/**
 * Class: HGIS.Format.JSON
 * A parser to read/write JSON safely.  Create a new instance with the
 *     <HGIS.Format.JSON> constructor.
 *
 * Inherits from:
 *  - <HGIS.Format>
 */
HGIS.Format.JSON = HGIS.Class(HGIS.Format, {
    
    /**
     * APIProperty: indent
     * {String} For "pretty" printing, the indent string will be used once for
     *     each indentation level.
     */
    indent: "    ",
    
    /**
     * APIProperty: space
     * {String} For "pretty" printing, the space string will be used after
     *     the ":" separating a name/value pair.
     */
    space: " ",
    
    /**
     * APIProperty: newline
     * {String} For "pretty" printing, the newline string will be used at the
     *     end of each name/value pair or array item.
     */
    newline: "\n",
    
    /**
     * Property: level
     * {Integer} For "pretty" printing, this is incremented/decremented during
     *     serialization.
     */
    level: 0,

    /**
     * Property: pretty
     * {Boolean} Serialize with extra whitespace for structure.  This is set
     *     by the <write> method.
     */
    pretty: false,

    /**
     * Property: nativeJSON
     * {Boolean} Does the browser support native json?
     */
    nativeJSON: (function() {
        return !!(window.JSON && typeof JSON.parse == "function" && typeof JSON.stringify == "function");
    })(),

    /**
     * Constructor: HGIS.Format.JSON
     * Create a new parser for JSON.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Deserialize a json string.
     *
     * Parameters:
     * json - {String} A JSON string
     * filter - {Function} A function which will be called for every key and
     *     value at every level of the final result. Each value will be
     *     replaced by the result of the filter function. This can be used to
     *     reform generic objects into instances of classes, or to transform
     *     date strings into Date objects.
     *     
     * Returns:
     * {Object} An object, array, string, or number .
     */
    read: function(json, filter) {
        var object;
        if (this.nativeJSON) {
            object = JSON.parse(json, filter);
        } else try {
            /**
             * Parsing happens in three stages. In the first stage, we run the
             *     text against a regular expression which looks for non-JSON
             *     characters. We are especially concerned with '()' and 'new'
             *     because they can cause invocation, and '=' because it can
             *     cause mutation. But just to be safe, we will reject all
             *     unexpected characters.
             */
            if (/^[\],:{}\s]*$/.test(json.replace(/\\["\\\/bfnrtu]/g, '@').
                                replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
                                replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

                /**
                 * In the second stage we use the eval function to compile the
                 *     text into a JavaScript structure. The '{' operator is
                 *     subject to a syntactic ambiguity in JavaScript - it can
                 *     begin a block or an object literal. We wrap the text in
                 *     parens to eliminate the ambiguity.
                 */
                object = eval('(' + json + ')');

                /**
                 * In the optional third stage, we recursively walk the new
                 *     structure, passing each name/value pair to a filter
                 *     function for possible transformation.
                 */
                if(typeof filter === 'function') {
                    function walk(k, v) {
                        if(v && typeof v === 'object') {
                            for(var i in v) {
                                if(v.hasOwnProperty(i)) {
                                    v[i] = walk(i, v[i]);
                                }
                            }
                        }
                        return filter(k, v);
                    }
                    object = walk('', object);
                }
            }
        } catch(e) {
            // Fall through if the regexp test fails.
        }

        if(this.keepData) {
            this.data = object;
        }

        return object;
    },

    /**
     * APIMethod: write
     * Serialize an object into a JSON string.
     *
     * Parameters:
     * value - {String} The object, array, string, number, boolean or date
     *     to be serialized.
     * pretty - {Boolean} Structure the output with newlines and indentation.
     *     Default is false.
     *
     * Returns:
     * {String} The JSON string representation of the input value.
     */
    write: function(value, pretty) {
        this.pretty = !!pretty;
        var json = null;
        var type = typeof value;
        if(this.serialize[type]) {
            try {
                json = (!this.pretty && this.nativeJSON) ?
                    JSON.stringify(value) :
                    this.serialize[type].apply(this, [value]);
            } catch(err) {
                HGIS.Console.error("Trouble serializing: " + err);
            }
        }
        return json;
    },
    
    /**
     * Method: writeIndent
     * Output an indentation string depending on the indentation level.
     *
     * Returns:
     * {String} An appropriate indentation string.
     */
    writeIndent: function() {
        var pieces = [];
        if(this.pretty) {
            for(var i=0; i<this.level; ++i) {
                pieces.push(this.indent);
            }
        }
        return pieces.join('');
    },
    
    /**
     * Method: writeNewline
     * Output a string representing a newline if in pretty printing mode.
     *
     * Returns:
     * {String} A string representing a new line.
     */
    writeNewline: function() {
        return (this.pretty) ? this.newline : '';
    },
    
    /**
     * Method: writeSpace
     * Output a string representing a space if in pretty printing mode.
     *
     * Returns:
     * {String} A space.
     */
    writeSpace: function() {
        return (this.pretty) ? this.space : '';
    },

    /**
     * Property: serialize
     * Object with properties corresponding to the serializable data types.
     *     Property values are functions that do the actual serializing.
     */
    serialize: {
        /**
         * Method: serialize.object
         * Transform an object into a JSON string.
         *
         * Parameters:
         * object - {Object} The object to be serialized.
         * 
         * Returns:
         * {String} A JSON string representing the object.
         */
        'object': function(object) {
            // three special objects that we want to treat differently
            if(object == null) {
                return "null";
            }
            if(object.constructor == Date) {
                return this.serialize.date.apply(this, [object]);
            }
            if(object.constructor == Array) {
                return this.serialize.array.apply(this, [object]);
            }
            var pieces = ['{'];
            this.level += 1;
            var key, keyJSON, valueJSON;
            
            var addComma = false;
            for(key in object) {
                if(object.hasOwnProperty(key)) {
                    // recursive calls need to allow for sub-classing
                    keyJSON = HGIS.Format.JSON.prototype.write.apply(this,
                                                    [key, this.pretty]);
                    valueJSON = HGIS.Format.JSON.prototype.write.apply(this,
                                                    [object[key], this.pretty]);
                    if(keyJSON != null && valueJSON != null) {
                        if(addComma) {
                            pieces.push(',');
                        }
                        pieces.push(this.writeNewline(), this.writeIndent(),
                                    keyJSON, ':', this.writeSpace(), valueJSON);
                        addComma = true;
                    }
                }
            }
            
            this.level -= 1;
            pieces.push(this.writeNewline(), this.writeIndent(), '}');
            return pieces.join('');
        },
        
        /**
         * Method: serialize.array
         * Transform an array into a JSON string.
         *
         * Parameters:
         * array - {Array} The array to be serialized
         * 
         * Returns:
         * {String} A JSON string representing the array.
         */
        'array': function(array) {
            var json;
            var pieces = ['['];
            this.level += 1;
    
            for(var i=0, len=array.length; i<len; ++i) {
                // recursive calls need to allow for sub-classing
                json = HGIS.Format.JSON.prototype.write.apply(this,
                                                    [array[i], this.pretty]);
                if(json != null) {
                    if(i > 0) {
                        pieces.push(',');
                    }
                    pieces.push(this.writeNewline(), this.writeIndent(), json);
                }
            }

            this.level -= 1;    
            pieces.push(this.writeNewline(), this.writeIndent(), ']');
            return pieces.join('');
        },
        
        /**
         * Method: serialize.string
         * Transform a string into a JSON string.
         *
         * Parameters:
         * string - {String} The string to be serialized
         * 
         * Returns:
         * {String} A JSON string representing the string.
         */
        'string': function(string) {
            // If the string contains no control characters, no quote characters, and no
            // backslash characters, then we can simply slap some quotes around it.
            // Otherwise we must also replace the offending characters with safe
            // sequences.    
            var m = {
                '\b': '\\b',
                '\t': '\\t',
                '\n': '\\n',
                '\f': '\\f',
                '\r': '\\r',
                '"' : '\\"',
                '\\': '\\\\'
            };
            if(/["\\\x00-\x1f]/.test(string)) {
                return '"' + string.replace(/([\x00-\x1f\\"])/g, function(a, b) {
                    var c = m[b];
                    if(c) {
                        return c;
                    }
                    c = b.charCodeAt();
                    return '\\u00' +
                        Math.floor(c / 16).toString(16) +
                        (c % 16).toString(16);
                }) + '"';
            }
            return '"' + string + '"';
        },

        /**
         * Method: serialize.number
         * Transform a number into a JSON string.
         *
         * Parameters:
         * number - {Number} The number to be serialized.
         *
         * Returns:
         * {String} A JSON string representing the number.
         */
        'number': function(number) {
            return isFinite(number) ? String(number) : "null";
        },
        
        /**
         * Method: serialize.boolean
         * Transform a boolean into a JSON string.
         *
         * Parameters:
         * bool - {Boolean} The boolean to be serialized.
         * 
         * Returns:
         * {String} A JSON string representing the boolean.
         */
        'boolean': function(bool) {
            return String(bool);
        },
        
        /**
         * Method: serialize.object
         * Transform a date into a JSON string.
         *
         * Parameters:
         * date - {Date} The date to be serialized.
         * 
         * Returns:
         * {String} A JSON string representing the date.
         */
        'date': function(date) {    
            function format(number) {
                // Format integers to have at least two digits.
                return (number < 10) ? '0' + number : number;
            }
            return '"' + date.getFullYear() + '-' +
                    format(date.getMonth() + 1) + '-' +
                    format(date.getDate()) + 'T' +
                    format(date.getHours()) + ':' +
                    format(date.getMinutes()) + ':' +
                    format(date.getSeconds()) + '"';
        }
    },

    CLASS_NAME: "HGIS.Format.JSON" 

});     
/* ======================================================================
    HGIS/Format/GeoJSON.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/JSON.js
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Geometry/Point.js
 * @requires HGIS/Geometry/MultiPoint.js
 * @requires HGIS/Geometry/LineString.js
 * @requires HGIS/Geometry/MultiLineString.js
 * @requires HGIS/Geometry/Polygon.js
 * @requires HGIS/Geometry/MultiPolygon.js
 * @requires HGIS/Console.js
 */

/**
 * Class: HGIS.Format.GeoJSON
 * Read and write GeoJSON. Create a new parser with the
 *     <HGIS.Format.GeoJSON> constructor.
 *
 * Inherits from:
 *  - <HGIS.Format.JSON>
 */
HGIS.Format.GeoJSON = HGIS.Class(HGIS.Format.JSON, {

    /**
     * APIProperty: ignoreExtraDims
     * {Boolean} Ignore dimensions higher than 2 when reading geometry
     * coordinates.
     */ 
    ignoreExtraDims: false,
    
    /**
     * Constructor: HGIS.Format.GeoJSON
     * Create a new parser for GeoJSON.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Deserialize a GeoJSON string.
     *
     * Parameters:
     * json - {String} A GeoJSON string
     * type - {String} Optional string that determines the structure of
     *     the output.  Supported values are "Geometry", "Feature", and
     *     "FeatureCollection".  If absent or null, a default of
     *     "FeatureCollection" is assumed.
     * filter - {Function} A function which will be called for every key and
     *     value at every level of the final result. Each value will be
     *     replaced by the result of the filter function. This can be used to
     *     reform generic objects into instances of classes, or to transform
     *     date strings into Date objects.
     *
     * Returns: 
     * {Object} The return depends on the value of the type argument. If type
     *     is "FeatureCollection" (the default), the return will be an array
     *     of <HGIS.Feature.Vector>. If type is "Geometry", the input json
     *     must represent a single geometry, and the return will be an
     *     <HGIS.Geometry>.  If type is "Feature", the input json must
     *     represent a single feature, and the return will be an
     *     <HGIS.Feature.Vector>.
     */
    read: function(json, type, filter) {
        type = (type) ? type : "FeatureCollection";
        var results = null;
        var obj = null;
        if (typeof json == "string") {
            obj = HGIS.Format.JSON.prototype.read.apply(this,
                                                              [json, filter]);
        } else { 
            obj = json;
        }    
        if(!obj) {
            HGIS.Console.error("Bad JSON: " + json);
        } else if(typeof(obj.type) != "string") {
            HGIS.Console.error("Bad GeoJSON - no type: " + json);
        } else if(this.isValidType(obj, type)) {
            switch(type) {
                case "Geometry":
                    try {
                        results = this.parseGeometry(obj);
                    } catch(err) {
                        HGIS.Console.error(err);
                    }
                    break;
                case "Feature":
                    try {
                        results = this.parseFeature(obj);
                        results.type = "Feature";
                    } catch(err) {
                        HGIS.Console.error(err);
                    }
                    break;
                case "FeatureCollection":
                    // for type FeatureCollection, we allow input to be any type
                    results = [];
                    switch(obj.type) {
                        case "Feature":
                            try {
                                results.push(this.parseFeature(obj));
                            } catch(err) {
                                results = null;
                                HGIS.Console.error(err);
                            }
                            break;
                        case "FeatureCollection":
                            for(var i=0, len=obj.features.length; i<len; ++i) {
                                try {
                                    results.push(this.parseFeature(obj.features[i]));
                                } catch(err) {
                                    results = null;
                                    HGIS.Console.error(err);
                                }
                            }
                            break;
                        default:
                            try {
                                var geom = this.parseGeometry(obj);
                                results.push(new HGIS.Feature.Vector(geom));
                            } catch(err) {
                                results = null;
                                HGIS.Console.error(err);
                            }
                    }
                break;
            }
        }
        return results;
    },
    
    /**
     * Method: isValidType
     * Check if a GeoJSON object is a valid representative of the given type.
     *
     * Returns:
     * {Boolean} The object is valid GeoJSON object of the given type.
     */
    isValidType: function(obj, type) {
        var valid = false;
        switch(type) {
            case "Geometry":
                if(HGIS.Util.indexOf(
                    ["Point", "MultiPoint", "LineString", "MultiLineString",
                     "Polygon", "MultiPolygon", "Box", "GeometryCollection"],
                    obj.type) == -1) {
                    // unsupported geometry type
                    HGIS.Console.error("Unsupported geometry type: " +
                                              obj.type);
                } else {
                    valid = true;
                }
                break;
            case "FeatureCollection":
                // allow for any type to be converted to a feature collection
                valid = true;
                break;
            default:
                // for Feature types must match
                if(obj.type == type) {
                    valid = true;
                } else {
                    HGIS.Console.error("Cannot convert types from " +
                                              obj.type + " to " + type);
                }
        }
        return valid;
    },
    
    /**
     * Method: parseFeature
     * Convert a feature object from GeoJSON into an
     *     <HGIS.Feature.Vector>.
     *
     * Parameters:
     * obj - {Object} An object created from a GeoJSON object
     *
     * Returns:
     * {<HGIS.Feature.Vector>} A feature.
     */
    parseFeature: function(obj) {
        var feature, geometry, attributes, bbox;
        attributes = (obj.properties) ? obj.properties : {};
        bbox = (obj.geometry && obj.geometry.bbox) || obj.bbox;
        try {
            geometry = this.parseGeometry(obj.geometry);
        } catch(err) {
            // deal with bad geometries
            throw err;
        }
        feature = new HGIS.Feature.Vector(geometry, attributes);
        if(bbox) {
            feature.bounds = HGIS.Bounds.fromArray(bbox);
        }
        if(obj.id) {
            feature.fid = obj.id;
        }
        return feature;
    },
    
    /**
     * Method: parseGeometry
     * Convert a geometry object from GeoJSON into an <HGIS.Geometry>.
     *
     * Parameters:
     * obj - {Object} An object created from a GeoJSON object
     *
     * Returns: 
     * {<HGIS.Geometry>} A geometry.
     */
    parseGeometry: function(obj) {
        if (obj == null) {
            return null;
        }
        var geometry, collection = false;
        if(obj.type == "GeometryCollection") {
            if(!(HGIS.Util.isArray(obj.geometries))) {
                throw "GeometryCollection must have geometries array: " + obj;
            }
            var numGeom = obj.geometries.length;
            var components = new Array(numGeom);
            for(var i=0; i<numGeom; ++i) {
                components[i] = this.parseGeometry.apply(
                    this, [obj.geometries[i]]
                );
            }
            geometry = new HGIS.Geometry.Collection(components);
            collection = true;
        } else {
            if(!(HGIS.Util.isArray(obj.coordinates))) {
                throw "Geometry must have coordinates array: " + obj;
            }
            if(!this.parseCoords[obj.type.toLowerCase()]) {
                throw "Unsupported geometry type: " + obj.type;
            }
            try {
                geometry = this.parseCoords[obj.type.toLowerCase()].apply(
                    this, [obj.coordinates]
                );
            } catch(err) {
                // deal with bad coordinates
                throw err;
            }
        }
        // We don't reproject collections because the children are reprojected
        // for us when they are created.
        if (this.internalProjection && this.externalProjection && !collection) {
            geometry.transform(this.externalProjection, 
                               this.internalProjection); 
        }                       
        return geometry;
    },
    
    /**
     * Property: parseCoords
     * Object with properties corresponding to the GeoJSON geometry types.
     *     Property values are functions that do the actual parsing.
     */
    parseCoords: {
        /**
         * Method: parseCoords.point
         * Convert a coordinate array from GeoJSON into an
         *     <HGIS.Geometry>.
         *
         * Parameters:
         * array - {Object} The coordinates array from the GeoJSON fragment.
         *
         * Returns:
         * {<HGIS.Geometry>} A geometry.
         */
        "point": function(array) {
            if (this.ignoreExtraDims == false && 
                  array.length != 2) {
                    throw "Only 2D points are supported: " + array;
            }
            return new HGIS.Geometry.Point(array[0], array[1]);
        },
        
        /**
         * Method: parseCoords.multipoint
         * Convert a coordinate array from GeoJSON into an
         *     <HGIS.Geometry>.
         *
         * Parameters:
         * array - {Object} The coordinates array from the GeoJSON fragment.
         *
         * Returns:
         * {<HGIS.Geometry>} A geometry.
         */
        "multipoint": function(array) {
            var points = [];
            var p = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    p = this.parseCoords["point"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                points.push(p);
            }
            return new HGIS.Geometry.MultiPoint(points);
        },

        /**
         * Method: parseCoords.linestring
         * Convert a coordinate array from GeoJSON into an
         *     <HGIS.Geometry>.
         *
         * Parameters:
         * array - {Object} The coordinates array from the GeoJSON fragment.
         *
         * Returns:
         * {<HGIS.Geometry>} A geometry.
         */
        "linestring": function(array) {
            var points = [];
            var p = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    p = this.parseCoords["point"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                points.push(p);
            }
            return new HGIS.Geometry.LineString(points);
        },
        
        /**
         * Method: parseCoords.multilinestring
         * Convert a coordinate array from GeoJSON into an
         *     <HGIS.Geometry>.
         *
         * Parameters:
         * array - {Object} The coordinates array from the GeoJSON fragment.
         *
         * Returns:
         * {<HGIS.Geometry>} A geometry.
         */
        "multilinestring": function(array) {
            var lines = [];
            var l = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    l = this.parseCoords["linestring"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                lines.push(l);
            }
            return new HGIS.Geometry.MultiLineString(lines);
        },
        
        /**
         * Method: parseCoords.polygon
         * Convert a coordinate array from GeoJSON into an
         *     <HGIS.Geometry>.
         *
         * Returns:
         * {<HGIS.Geometry>} A geometry.
         */
        "polygon": function(array) {
            var rings = [];
            var r, l;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    l = this.parseCoords["linestring"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                r = new HGIS.Geometry.LinearRing(l.components);
                rings.push(r);
            }
            return new HGIS.Geometry.Polygon(rings);
        },

        /**
         * Method: parseCoords.multipolygon
         * Convert a coordinate array from GeoJSON into an
         *     <HGIS.Geometry>.
         *
         * Parameters:
         * array - {Object} The coordinates array from the GeoJSON fragment.
         *
         * Returns:
         * {<HGIS.Geometry>} A geometry.
         */
        "multipolygon": function(array) {
            var polys = [];
            var p = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    p = this.parseCoords["polygon"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                polys.push(p);
            }
            return new HGIS.Geometry.MultiPolygon(polys);
        },

        /**
         * Method: parseCoords.box
         * Convert a coordinate array from GeoJSON into an
         *     <HGIS.Geometry>.
         *
         * Parameters:
         * array - {Object} The coordinates array from the GeoJSON fragment.
         *
         * Returns:
         * {<HGIS.Geometry>} A geometry.
         */
        "box": function(array) {
            if(array.length != 2) {
                throw "GeoJSON box coordinates must have 2 elements";
            }
            return new HGIS.Geometry.Polygon([
                new HGIS.Geometry.LinearRing([
                    new HGIS.Geometry.Point(array[0][0], array[0][1]),
                    new HGIS.Geometry.Point(array[1][0], array[0][1]),
                    new HGIS.Geometry.Point(array[1][0], array[1][1]),
                    new HGIS.Geometry.Point(array[0][0], array[1][1]),
                    new HGIS.Geometry.Point(array[0][0], array[0][1])
                ])
            ]);
        }

    },

    /**
     * APIMethod: write
     * Serialize a feature, geometry, array of features into a GeoJSON string.
     *
     * Parameters:
     * obj - {Object} An <HGIS.Feature.Vector>, <HGIS.Geometry>,
     *     or an array of features.
     * pretty - {Boolean} Structure the output with newlines and indentation.
     *     Default is false.
     *
     * Returns:
     * {String} The GeoJSON string representation of the input geometry,
     *     features, or array of features.
     */
    write: function(obj, pretty) {
        var geojson = {
            "type": null
        };
        if(HGIS.Util.isArray(obj)) {
            geojson.type = "FeatureCollection";
            var numFeatures = obj.length;
            geojson.features = new Array(numFeatures);
            for(var i=0; i<numFeatures; ++i) {
                var element = obj[i];
                if(!element instanceof HGIS.Feature.Vector) {
                    var msg = "FeatureCollection only supports collections " +
                              "of features: " + element;
                    throw msg;
                }
                geojson.features[i] = this.extract.feature.apply(
                    this, [element]
                );
            }
        } else if (obj.CLASS_NAME.indexOf("HGIS.Geometry") == 0) {
            geojson = this.extract.geometry.apply(this, [obj]);
        } else if (obj instanceof HGIS.Feature.Vector) {
            geojson = this.extract.feature.apply(this, [obj]);
            if(obj.layer && obj.layer.projection) {
                geojson.crs = this.createCRSObject(obj);
            }
        }
        return HGIS.Format.JSON.prototype.write.apply(this,
                                                            [geojson, pretty]);
    },

    /**
     * Method: createCRSObject
     * Create the CRS object for an object.
     *
     * Parameters:
     * object - {<HGIS.Feature.Vector>} 
     *
     * Returns:
     * {Object} An object which can be assigned to the crs property
     * of a GeoJSON object.
     */
    createCRSObject: function(object) {
       var proj = object.layer.projection.toString();
       var crs = {};
       if (proj.match(/epsg:/i)) {
           var code = parseInt(proj.substring(proj.indexOf(":") + 1));
           if (code == 4326) {
               crs = {
                   "type": "name",
                   "properties": {
                       "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
                   }
               };
           } else {    
               crs = {
                   "type": "name",
                   "properties": {
                       "name": "EPSG:" + code
                   }
               };
           }    
       }
       return crs;
    },
    
    /**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: {
        /**
         * Method: extract.feature
         * Return a partial GeoJSON object representing a single feature.
         *
         * Parameters:
         * feature - {<HGIS.Feature.Vector>}
         *
         * Returns:
         * {Object} An object representing the point.
         */
        'feature': function(feature) {
            var geom = this.extract.geometry.apply(this, [feature.geometry]);
            var json = {
                "type": "Feature",
                "properties": feature.attributes,
                "geometry": geom
            };
            if (feature.fid != null) {
                json.id = feature.fid;
            }
            return json;
        },
        
        /**
         * Method: extract.geometry
         * Return a GeoJSON object representing a single geometry.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry>}
         *
         * Returns:
         * {Object} An object representing the geometry.
         */
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }
            if (this.internalProjection && this.externalProjection) {
                geometry = geometry.clone();
                geometry.transform(this.internalProjection, 
                                   this.externalProjection);
            }                       
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            if(geometryType == "Collection") {
                json = {
                    "type": "GeometryCollection",
                    "geometries": data
                };
            } else {
                json = {
                    "type": geometryType,
                    "coordinates": data
                };
            }
            
            return json;
        },

        /**
         * Method: extract.point
         * Return an array of coordinates from a point.
         *
         * Parameters:
         * point - {<HGIS.Geometry.Point>}
         *
         * Returns: 
         * {Array} An array of coordinates representing the point.
         */
        'point': function(point) {
            return [point.x, point.y];
        },

        /**
         * Method: extract.multipoint
         * Return an array of point coordinates from a multipoint.
         *
         * Parameters:
         * multipoint - {<HGIS.Geometry.MultiPoint>}
         *
         * Returns:
         * {Array} An array of point coordinate arrays representing
         *     the multipoint.
         */
        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.linestring
         * Return an array of coordinate arrays from a linestring.
         *
         * Parameters:
         * linestring - {<HGIS.Geometry.LineString>}
         *
         * Returns:
         * {Array} An array of coordinate arrays representing
         *     the linestring.
         */
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        /**
         * Method: extract.multilinestring
         * Return an array of linestring arrays from a linestring.
         * 
         * Parameters:
         * multilinestring - {<HGIS.Geometry.MultiLineString>}
         * 
         * Returns:
         * {Array} An array of linestring arrays representing
         *     the multilinestring.
         */
        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.polygon
         * Return an array of linear ring arrays from a polygon.
         *
         * Parameters:
         * polygon - {<HGIS.Geometry.Polygon>}
         * 
         * Returns:
         * {Array} An array of linear ring arrays representing the polygon.
         */
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        },

        /**
         * Method: extract.multipolygon
         * Return an array of polygon arrays from a multipolygon.
         * 
         * Parameters:
         * multipolygon - {<HGIS.Geometry.MultiPolygon>}
         * 
         * Returns:
         * {Array} An array of polygon arrays representing
         *     the multipolygon
         */
        'multipolygon': function(multipolygon) {
            var array = [];
            for(var i=0, len=multipolygon.components.length; i<len; ++i) {
                array.push(this.extract.polygon.apply(this, [multipolygon.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.collection
         * Return an array of geometries from a geometry collection.
         * 
         * Parameters:
         * collection - {<HGIS.Geometry.Collection>}
         * 
         * Returns:
         * {Array} An array of geometry objects representing the geometry
         *     collection.
         */
        'collection': function(collection) {
            var len = collection.components.length;
            var array = new Array(len);
            for(var i=0; i<len; ++i) {
                array[i] = this.extract.geometry.apply(
                    this, [collection.components[i]]
                );
            }
            return array;
        }
        

    },

    CLASS_NAME: "HGIS.Format.GeoJSON" 

});     
/* ======================================================================
    HGIS/Protocol/Script.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Protocol.js
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Format/GeoJSON.js
 */

/**
 * if application uses the query string, for example, for BBOX parameters,
 * HGIS/Format/QueryStringFilter.js should be included in the build config file
 */

/**
 * Class: HGIS.Protocol.Script
 * A basic Script protocol for vector layers.  Create a new instance with the
 *     <HGIS.Protocol.Script> constructor.  A script protocol is used to
 *     get around the same origin policy.  It works with services that return
 *     JSONP - that is, JSON wrapped in a client-specified callback.  The
 *     protocol handles fetching and parsing of feature data and sends parsed
 *     features to the <callback> configured with the protocol.  The protocol
 *     expects features serialized as GeoJSON by default, but can be configured
 *     to work with other formats by setting the <format> property.
 *
 * Inherits from:
 *  - <HGIS.Protocol>
 */
HGIS.Protocol.Script = HGIS.Class(HGIS.Protocol, {

    /**
     * APIProperty: url
     * {String} Service URL.  The service is expected to return serialized 
     *     features wrapped in a named callback (where the callback name is
     *     generated by this protocol).
     *     Read-only, set through the options passed to the constructor.
     */
    url: null,

    /**
     * APIProperty: params
     * {Object} Query string parameters to be appended to the URL.
     *     Read-only, set through the options passed to the constructor.
     *     Example: {maxFeatures: 50}
     */
    params: null,
    
    /**
     * APIProperty: callback
     * {Object} Function to be called when the <read> operation completes.
     */
    callback: null,

    /**
     * APIProperty: callbackTemplate
     * {String} Template for creating a unique callback function name
     * for the registry. Should include ${id}.  The ${id} variable will be
     * replaced with a string identifier prefixed with a "c" (e.g. c1, c2).
     * Default is "HGIS.Protocol.Script.registry.${id}".
     */
    callbackTemplate: "HGIS.Protocol.Script.registry.${id}",

    /**
     * APIProperty: callbackKey
     * {String} The name of the query string parameter that the service 
     *     recognizes as the callback identifier.  Default is "callback".
     *     This key is used to generate the URL for the script.  For example
     *     setting <callbackKey> to "myCallback" would result in a URL like 
     *     http://example.com/?myCallback=...
     */
    callbackKey: "callback",

    /**
     * APIProperty: callbackPrefix
     * {String} Where a service requires that the callback query string 
     *     parameter value is prefixed by some string, this value may be set.
     *     For example, setting <callbackPrefix> to "foo:" would result in a
     *     URL like http://example.com/?callback=foo:...  Default is "".
     */
    callbackPrefix: "",

    /**
     * APIProperty: scope
     * {Object} Optional ``this`` object for the callback. Read-only, set 
     *     through the options passed to the constructor.
     */
    scope: null,

    /**
     * APIProperty: format
     * {<HGIS.Format>} Format for parsing features.  Default is an 
     *     <HGIS.Format.GeoJSON> format.  If an alternative is provided,
     *     the format's read method must take an object and return an array
     *     of features.
     */
    format: null,

    /**
     * Property: pendingRequests
     * {Object} References all pending requests.  Property names are script 
     *     identifiers and property values are script elements.
     */
    pendingRequests: null,

    /**
     * APIProperty: srsInBBOX
     * {Boolean} Include the SRS identifier in BBOX query string parameter.
     *     Setting this property has no effect if a custom filterToParams method
     *     is provided.   Default is false.  If true and the layer has a 
     *     projection object set, any BBOX filter will be serialized with a 
     *     fifth item identifying the projection.  
     *     E.g. bbox=-1000,-1000,1000,1000,EPSG:900913
     */
    srsInBBOX: false,

    /**
     * Constructor: HGIS.Protocol.Script
     * A class for giving layers generic Script protocol.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options include:
     * url - {String}
     * params - {Object}
     * callback - {Function}
     * scope - {Object}
     */
    initialize: function(options) {
        options = options || {};
        this.params = {};
        this.pendingRequests = {};
        HGIS.Protocol.prototype.initialize.apply(this, arguments);
        if (!this.format) {
            this.format = new HGIS.Format.GeoJSON();
        }

        if (!this.filterToParams && HGIS.Format.QueryStringFilter) {
            var format = new HGIS.Format.QueryStringFilter({
                srsInBBOX: this.srsInBBOX
            });
            this.filterToParams = function(filter, params) {
                return format.write(filter, params);
            };
        }
    },
    
    /**
     * APIMethod: read
     * Construct a request for reading new features.
     *
     * Parameters:
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Valid options:
     * url - {String} Url for the request.
     * params - {Object} Parameters to get serialized as a query string.
     * filter - {<HGIS.Filter>} Filter to get serialized as a
     *     query string.
     *
     * Returns:
     * {<HGIS.Protocol.Response>} A response object, whose "priv" property
     *     references the injected script.  This object is also passed to the
     *     callback function when the request completes, its "features" property
     *     is then populated with the features received from the server.
     */
    read: function(options) {
        HGIS.Protocol.prototype.read.apply(this, arguments);
        options = HGIS.Util.applyDefaults(options, this.options);
        options.params = HGIS.Util.applyDefaults(
            options.params, this.options.params
        );
        if (options.filter && this.filterToParams) {
            options.params = this.filterToParams(
                options.filter, options.params
            );
        }
        var response = new HGIS.Protocol.Response({requestType: "read"});
        var request = this.createRequest(
            options.url, 
            options.params, 
            HGIS.Function.bind(function(data) {
                response.data = data;
                this.handleRead(response, options);
            }, this)
        );
        response.priv = request;
        return response;
    },

    /** 
     * APIMethod: filterToParams 
     * Optional method to translate an <HGIS.Filter> object into an object 
     *     that can be serialized as request query string provided.  If a custom 
     *     method is not provided, any filter will not be serialized. 
     * 
     * Parameters: 
     * filter - {<HGIS.Filter>} filter to convert. 
     * params - {Object} The parameters object. 
     * 
     * Returns: 
     * {Object} The resulting parameters object. 
     */

    /** 
     * Method: createRequest
     * Issues a request for features by creating injecting a script in the 
     *     document head.
     *
     * Parameters:
     * url - {String} Service URL.
     * params - {Object} Query string parameters.
     * callback - {Function} Callback to be called with resulting data.
     *
     * Returns:
     * {HTMLScriptElement} The script pending execution.
     */
    createRequest: function(url, params, callback) {
        var id = HGIS.Protocol.Script.register(callback);
        var name = HGIS.String.format(this.callbackTemplate, {id: id});
        params = HGIS.Util.extend({}, params);
        params[this.callbackKey] = this.callbackPrefix + name;
        url = HGIS.Util.urlAppend(
            url, HGIS.Util.getParameterString(params)
        );
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = url;
        script.id = "HGIS_Protocol_Script_" + id;
        this.pendingRequests[script.id] = script;
        var head = document.getElementsByTagName("head")[0];
        head.appendChild(script);
        return script;
    },
    
    /** 
     * Method: destroyRequest
     * Remove a script node associated with a response from the document.  Also
     *     unregisters the callback and removes the script from the 
     *     <pendingRequests> object.
     *
     * Parameters:
     * script - {HTMLScriptElement}
     */
    destroyRequest: function(script) {
        HGIS.Protocol.Script.unregister(script.id.split("_").pop());
        delete this.pendingRequests[script.id];
        if (script.parentNode) {
            script.parentNode.removeChild(script);
        }
    },

    /**
     * Method: handleRead
     * Individual callbacks are created for read, create and update, should
     *     a subclass need to override each one separately.
     *
     * Parameters:
     * response - {<HGIS.Protocol.Response>} The response object to pass to
     *     the user callback.
     * options - {Object} The user options passed to the read call.
     */
    handleRead: function(response, options) {
        this.handleResponse(response, options);
    },

    /**
     * Method: handleResponse
     * Called by CRUD specific handlers.
     *
     * Parameters:
     * response - {<HGIS.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the create, read, update,
     *     or delete call.
     */
    handleResponse: function(response, options) {
        if (options.callback) {
            if (response.data) {
                response.features = this.parseFeatures(response.data);
                response.code = HGIS.Protocol.Response.SUCCESS;
            } else {
                response.code = HGIS.Protocol.Response.FAILURE;
            }
            this.destroyRequest(response.priv);
            options.callback.call(options.scope, response);
        }
    },

    /**
     * Method: parseFeatures
     * Read Script response body and return features.
     *
     * Parameters:
     * data - {Object} The data sent to the callback function by the server.
     *
     * Returns:
     * {Array({<HGIS.Feature.Vector>})} or
     *     {<HGIS.Feature.Vector>} Array of features or a single feature.
     */
    parseFeatures: function(data) {
        return this.format.read(data);
    },

    /**
     * APIMethod: abort
     * Abort an ongoing request.  If no response is provided, all pending 
     *     requests will be aborted.
     *
     * Parameters:
     * response - {<HGIS.Protocol.Response>} The response object returned
     *     from a <read> request.
     */
    abort: function(response) {
        if (response) {
            this.destroyRequest(response.priv);
        } else {
            for (var key in this.pendingRequests) {
                this.destroyRequest(this.pendingRequests[key]);
            }
        }
    },
    
    /**
     * APIMethod: destroy
     * Clean up the protocol.
     */
    destroy: function() {
        this.abort();
        delete this.params;
        delete this.format;
        HGIS.Protocol.prototype.destroy.apply(this);
    },

    CLASS_NAME: "HGIS.Protocol.Script" 
});

(function() {
    var o = HGIS.Protocol.Script;
    var counter = 0;
    o.registry = {};
    
    /**
     * Function: HGIS.Protocol.Script.register
     * Register a callback for a newly created script.
     *
     * Parameters:
     * callback - {Function} The callback to be executed when the newly added
     *     script loads.  This callback will be called with a single argument
     *     that is the JSON returned by the service.
     *
     * Returns:
     * {Number} An identifier for retrieving the registered callback.
     */
    o.register = function(callback) {
        var id = "c"+(++counter);
        o.registry[id] = function() {
            callback.apply(this, arguments);
        };
        return id;
    };
    
    /**
     * Function: HGIS.Protocol.Script.unregister
     * Unregister a callback previously registered with the register function.
     *
     * Parameters:
     * id - {Number} The identifer returned by the register function.
     */
    o.unregister = function(id) {
        delete o.registry[id];
    };
})();
/* ======================================================================
    HGIS/Format/EncodedPolyline.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format.js
 * @requires HGIS/Feature/Vector.js
 */

/**
 * Class: HGIS.Format.EncodedPolyline
 * Class for reading and writing encoded polylines.  Create a new instance
 * with the <HGIS.Format.EncodedPolyline> constructor.
 *
 * Inherits from:
 *  - <HGIS.Format>
 */
HGIS.Format.EncodedPolyline = HGIS.Class(HGIS.Format, {

    /**
     * APIProperty: geometryType
     * {String} Geometry type to output. One of: linestring (default),
     *     linearring, point, multipoint or polygon. If the geometryType is
     *     point, only the first point of the string is returned.
     */
    geometryType: "linestring",

    /**
     * Constructor: HGIS.Format.EncodedPolyline
     * Create a new parser for encoded polylines
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *           this instance
     *
     * Returns:
     * {<HGIS.Format.EncodedPolyline>} A new encoded polylines parser.
     */
    initialize: function(options) {
        HGIS.Format.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: read
     * Deserialize an encoded polyline string and return a vector feature.
     *
     * Parameters:
     * encoded - {String} An encoded polyline string
     *
     * Returns:
     * {<HGIS.Feature.Vector>} A vector feature with a linestring.
     */
    read: function(encoded) {
        var geomType;
        if (this.geometryType == "linestring")
            geomType = HGIS.Geometry.LineString;
        else if (this.geometryType == "linearring")
            geomType = HGIS.Geometry.LinearRing;
        else if (this.geometryType == "multipoint")
            geomType = HGIS.Geometry.MultiPoint;
        else if (this.geometryType != "point" && this.geometryType != "polygon")
            return null;

        var flatPoints = this.decodeDeltas(encoded, 2);
        var flatPointsLength = flatPoints.length;

        var pointGeometries = [];
        for (var i = 0; i + 1 < flatPointsLength;) {
            var y = flatPoints[i++], x = flatPoints[i++];
            pointGeometries.push(new HGIS.Geometry.Point(x, y));
        }


        if (this.geometryType == "point")
            return new HGIS.Feature.Vector(
                pointGeometries[0]
            );

        if (this.geometryType == "polygon")
            return new HGIS.Feature.Vector(
                new HGIS.Geometry.Polygon([
                    new HGIS.Geometry.LinearRing(pointGeometries)
                ])
            );

        return new HGIS.Feature.Vector(
            new geomType(pointGeometries)
        );
    },

    /**
     * APIMethod: decode
     * Deserialize an encoded string and return an array of n-dimensional
     * points.
     *
     * Parameters:
     * encoded - {String} An encoded string
     * dims - {int} The dimension of the points that are returned
     *
     * Returns:
     * {Array(Array(int))} An array containing n-dimensional arrays of
     *     coordinates.
     */
    decode: function(encoded, dims, opt_factor) {
        var factor = opt_factor || 1e5;
        var flatPoints = this.decodeDeltas(encoded, dims, factor);
        var flatPointsLength = flatPoints.length;

        var points = [];
        for (var i = 0; i + (dims - 1) < flatPointsLength;) {
            var point = [];

            for (var dim = 0; dim < dims; ++dim) {
                point.push(flatPoints[i++])
            }

            points.push(point);
        }

        return points;
    },

    /**
     * APIMethod: write
     * Serialize a feature or array of features into a WKT string.
     *
     * Parameters:
     * features - {<HGIS.Feature.Vector>|Array} A feature or array of
     *            features
     *
     * Returns:
     * {String} The WKT string representation of the input geometries
     */
    write: function(features) {
        var feature;
        if (features.constructor == Array)
            feature = features[0];
        else
            feature = features;

        var geometry = feature.geometry;
        var type = geometry.CLASS_NAME.split('.')[2].toLowerCase();

        var pointGeometries;
        if (type == "point")
            pointGeometries = new Array(geometry);
        else if (type == "linestring" ||
                 type == "linearring" ||
                 type == "multipoint")
            pointGeometries = geometry.components;
        else if (type == "polygon")
            pointGeometries = geometry.components[0].components;
        else
            return null;

        var flatPoints = [];

        var pointGeometriesLength = pointGeometries.length;
        for (var i = 0; i < pointGeometriesLength; ++i) {
            var pointGeometry = pointGeometries[i];
            flatPoints.push(pointGeometry.y);
            flatPoints.push(pointGeometry.x);
        }

        return this.encodeDeltas(flatPoints, 2);
    },

    /**
     * APIMethod: encode
     * Serialize an array of n-dimensional points and return an encoded string
     *
     * Parameters:
     * points - {Array(Array(int))} An array containing n-dimensional
     *          arrays of coordinates
     * dims - {int} The dimension of the points that should be read
     *
     * Returns:
     * {String} An encoded string
     */
    encode: function (points, dims, opt_factor) {
        var factor = opt_factor || 1e5;
        var flatPoints = [];

        var pointsLength = points.length;
        for (var i = 0; i < pointsLength; ++i) {
            var point = points[i];

            for (var dim = 0; dim < dims; ++dim) {
                flatPoints.push(point[dim]);
            }
        }

        return this.encodeDeltas(flatPoints, dims, factor);
    },

    /**
     * APIMethod: encodeDeltas
     * Encode a list of n-dimensional points and return an encoded string
     *
     * Attention: This function will modify the passed array!
     *
     * Parameters:
     * numbers - {Array.<number>} A list of n-dimensional points.
     * dimension - {number} The dimension of the points in the list.
     * opt_factor - {number=} The factor by which the numbers will be
     * multiplied. The remaining decimal places will get rounded away.
     *
     * Returns:
     * {string} The encoded string.
     */
    encodeDeltas: function(numbers, dimension, opt_factor) {
      var factor = opt_factor || 1e5;
      var d;

      var lastNumbers = new Array(dimension);
      for (d = 0; d < dimension; ++d) {
        lastNumbers[d] = 0;
      }

      var numbersLength = numbers.length;
      for (var i = 0; i < numbersLength;) {
        for (d = 0; d < dimension; ++d, ++i) {
          var num = numbers[i];
          var delta = num - lastNumbers[d];
          lastNumbers[d] = num;

          numbers[i] = delta;
        }
      }

      return this.encodeFloats(numbers, factor);
    },


    /**
     * APIMethod: decodeDeltas
     * Decode a list of n-dimensional points from an encoded string
     *
     * Parameters:
     * encoded - {string} An encoded string.
     * dimension - {number} The dimension of the points in the encoded string.
     * opt_factor - {number=} The factor by which the resulting numbers will
     * be divided.
     *
     * Returns:
     * {Array.<number>} A list of n-dimensional points.
     */
    decodeDeltas: function(encoded, dimension, opt_factor) {
      var factor = opt_factor || 1e5;
      var d;

      var lastNumbers = new Array(dimension);
      for (d = 0; d < dimension; ++d) {
        lastNumbers[d] = 0;
      }

      var numbers = this.decodeFloats(encoded, factor);

      var numbersLength = numbers.length;
      for (var i = 0; i < numbersLength;) {
        for (d = 0; d < dimension; ++d, ++i) {
          lastNumbers[d] += numbers[i];

          numbers[i] = lastNumbers[d];
        }
      }

      return numbers;
    },


    /**
     * APIMethod: encodeFloats
     * Encode a list of floating point numbers and return an encoded string
     *
     * Attention: This function will modify the passed array!
     *
     * Parameters:
     * numbers - {Array.<number>} A list of floating point numbers.
     * opt_factor - {number=} The factor by which the numbers will be
     * multiplied. The remaining decimal places will get rounded away.
     *
     * Returns:
     * {string} The encoded string.
     */
    encodeFloats: function(numbers, opt_factor) {
      var factor = opt_factor || 1e5;

      var numbersLength = numbers.length;
      for (var i = 0; i < numbersLength; ++i) {
        numbers[i] = Math.round(numbers[i] * factor);
      }

      return this.encodeSignedIntegers(numbers);
    },


    /**
     * APIMethod: decodeFloats
     * Decode a list of floating point numbers from an encoded string
     *
     * Parameters:
     * encoded - {string} An encoded string.
     * opt_factor - {number=} The factor by which the result will be divided.
     *
     * Returns:
     * {Array.<number>} A list of floating point numbers.
     */
    decodeFloats: function(encoded, opt_factor) {
      var factor = opt_factor || 1e5;

      var numbers = this.decodeSignedIntegers(encoded);

      var numbersLength = numbers.length;
      for (var i = 0; i < numbersLength; ++i) {
        numbers[i] /= factor;
      }

      return numbers;
    },


    /**
     * APIMethod: encodeSignedIntegers
     * Encode a list of signed integers and return an encoded string
     *
     * Attention: This function will modify the passed array!
     *
     * Parameters:
     * numbers - {Array.<number>} A list of signed integers.
     *
     * Returns:
     * {string} The encoded string.
     */
    encodeSignedIntegers: function(numbers) {
      var numbersLength = numbers.length;
      for (var i = 0; i < numbersLength; ++i) {
        var num = numbers[i];

        var signedNum = num << 1;
        if (num < 0) {
          signedNum = ~(signedNum);
        }

        numbers[i] = signedNum;
      }

      return this.encodeUnsignedIntegers(numbers);
    },


    /**
     * APIMethod: decodeSignedIntegers
     * Decode a list of signed integers from an encoded string
     *
     * Parameters:
     * encoded - {string} An encoded string.
     *
     * Returns:
     * {Array.<number>} A list of signed integers.
     */
    decodeSignedIntegers: function(encoded) {
      var numbers = this.decodeUnsignedIntegers(encoded);

      var numbersLength = numbers.length;
      for (var i = 0; i < numbersLength; ++i) {
        var num = numbers[i];
        numbers[i] = (num & 1) ? ~(num >> 1) : (num >> 1);
      }

      return numbers;
    },


    /**
     * APIMethod: encodeUnsignedIntegers
     * Encode a list of unsigned integers and return an encoded string
     *
     * Parameters:
     * numbers - {Array.<number>} A list of unsigned integers.
     *
     * Returns:
     * {string} The encoded string.
     */
    encodeUnsignedIntegers: function(numbers) {
      var encoded = '';

      var numbersLength = numbers.length;
      for (var i = 0; i < numbersLength; ++i) {
        encoded += this.encodeUnsignedInteger(numbers[i]);
      }

      return encoded;
    },


    /**
     * APIMethod: decodeUnsignedIntegers
     * Decode a list of unsigned integers from an encoded string
     *
     * Parameters:
     * encoded - {string} An encoded string.
     *
     * Returns:
     * {Array.<number>} A list of unsigned integers.
     */
    decodeUnsignedIntegers: function(encoded) {
      var numbers = [];

      var current = 0;
      var shift = 0;

      var encodedLength = encoded.length;
      for (var i = 0; i < encodedLength; ++i) {
        var b = encoded.charCodeAt(i) - 63;

        current |= (b & 0x1f) << shift;

        if (b < 0x20) {
          numbers.push(current);
          current = 0;
          shift = 0;
        } else {
          shift += 5;
        }
      }

      return numbers;
    },


    /**
     * Method: encodeFloat
     * Encode one single floating point number and return an encoded string
     *
     * Parameters:
     * num - {number} Floating point number that should be encoded.
     * opt_factor - {number=} The factor by which num will be multiplied.
     * The remaining decimal places will get rounded away.
     *
     * Returns:
     * {string} The encoded string.
     */
    encodeFloat: function(num, opt_factor) {
      num = Math.round(num * (opt_factor || 1e5));
      return this.encodeSignedInteger(num);
    },


    /**
     * Method: decodeFloat
     * Decode one single floating point number from an encoded string
     *
     * Parameters:
     * encoded - {string} An encoded string.
     * opt_factor - {number=} The factor by which the result will be divided.
     *
     * Returns:
     * {number} The decoded floating point number.
     */
    decodeFloat: function(encoded, opt_factor) {
      var result = this.decodeSignedInteger(encoded);
      return result / (opt_factor || 1e5);
    },


    /**
     * Method: encodeSignedInteger
     * Encode one single signed integer and return an encoded string
     *
     * Parameters:
     * num - {number} Signed integer that should be encoded.
     *
     * Returns:
     * {string} The encoded string.
     */
    encodeSignedInteger: function(num) {
      var signedNum = num << 1;
      if (num < 0) {
        signedNum = ~(signedNum);
      }

      return this.encodeUnsignedInteger(signedNum);
    },


    /**
     * Method: decodeSignedInteger
     * Decode one single signed integer from an encoded string
     *
     * Parameters:
     * encoded - {string} An encoded string.
     *
     * Returns:
     * {number} The decoded signed integer.
     */
    decodeSignedInteger: function(encoded) {
      var result = this.decodeUnsignedInteger(encoded);
      return ((result & 1) ? ~(result >> 1) : (result >> 1));
    },


    /**
     * Method: encodeUnsignedInteger
     * Encode one single unsigned integer and return an encoded string
     *
     * Parameters:
     * num - {number} Unsigned integer that should be encoded.
     *
     * Returns:
     * {string} The encoded string.
     */
    encodeUnsignedInteger: function(num) {
      var value, encoded = '';
      while (num >= 0x20) {
        value = (0x20 | (num & 0x1f)) + 63;
        encoded += (String.fromCharCode(value));
        num >>= 5;
      }
      value = num + 63;
      encoded += (String.fromCharCode(value));
      return encoded;
    },


    /**
     * Method: decodeUnsignedInteger
     * Decode one single unsigned integer from an encoded string
     *
     * Parameters:
     * encoded - {string} An encoded string.
     *
     * Returns:
     * {number} The decoded unsigned integer.
     */
    decodeUnsignedInteger: function(encoded) {
      var result = 0;
      var shift = 0;

      var encodedLength = encoded.length;
      for (var i = 0; i < encodedLength; ++i) {
        var b = encoded.charCodeAt(i) - 63;

        result |= (b & 0x1f) << shift;

        if (b < 0x20)
          break;

        shift += 5;
      }

      return result;
    },

    CLASS_NAME: "HGIS.Format.EncodedPolyline"
});
/* ======================================================================
    HGIS/Control/Panel.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Events/buttonclick.js
 */

/**
 * Class: HGIS.Control.Panel
 * The Panel control is a container for other controls. With it toolbars
 * may be composed.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.Panel = HGIS.Class(HGIS.Control, {
    /**
     * Property: controls
     * {Array(<HGIS.Control>)}
     */
    controls: null,    
    
    /**
     * APIProperty: autoActivate
     * {Boolean} Activate the control when it is added to a map.  Default is
     *     true.
     */
    autoActivate: true,

    /** 
     * APIProperty: defaultControl
     * {<HGIS.Control>} The control which is activated when the control is
     * activated (turned on), which also happens at instantiation.
     * If <saveState> is true, <defaultControl> will be nullified after the
     * first activation of the panel.
     */
    defaultControl: null,
    
    /**
     * APIProperty: saveState
     * {Boolean} If set to true, the active state of this panel's controls will
     * be stored on panel deactivation, and restored on reactivation. Default
     * is false.
     */
    saveState: false,
      
    /**
     * APIProperty: allowDepress
     * {Boolean} If is true the <HGIS.Control.TYPE_TOOL> controls can 
     *     be deactivated by clicking the icon that represents them.  Default 
     *     is false.
     */
    allowDepress: false,
    
    /**
     * Property: activeState
     * {Object} stores the active state of this panel's controls.
     */
    activeState: null,

    /**
     * Constructor: HGIS.Control.Panel
     * Create a new control panel.
     *
     * Each control in the panel is represented by an icon. When clicking 
     *     on an icon, the <activateControl> method is called.
     *
     * Specific properties for controls on a panel:
     * type - {Number} One of <HGIS.Control.TYPE_TOOL>,
     *     <HGIS.Control.TYPE_TOGGLE>, <HGIS.Control.TYPE_BUTTON>.
     *     If not provided, <HGIS.Control.TYPE_TOOL> is assumed.
     * title - {string} Text displayed when mouse is over the icon that 
     *     represents the control.     
     *
     * The <HGIS.Control.type> of a control determines the behavior when
     * clicking its icon:
     * <HGIS.Control.TYPE_TOOL> - The control is activated and other
     *     controls of this type in the same panel are deactivated. This is
     *     the default type.
     * <HGIS.Control.TYPE_TOGGLE> - The active state of the control is
     *     toggled.
     * <HGIS.Control.TYPE_BUTTON> - The
     *     <HGIS.Control.Button.trigger> method of the control is called,
     *     but its active state is not changed.
     *
     * If a control is <HGIS.Control.active>, it will be drawn with the
     * olControl[Name]ItemActive class, otherwise with the
     * olControl[Name]ItemInactive class.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be used
     *     to extend the control.
     */
    initialize: function(options) {
        HGIS.Control.prototype.initialize.apply(this, [options]);
        this.controls = [];
        this.activeState = {};
    },

    /**
     * APIMethod: destroy
     */
    destroy: function() {
        if (this.map) {
            this.map.events.unregister("buttonclick", this, this.onButtonClick);
        }
        HGIS.Control.prototype.destroy.apply(this, arguments);
        for (var ctl, i = this.controls.length - 1; i >= 0; i--) {
            ctl = this.controls[i];
            if (ctl.events) {
                ctl.events.un({
                    activate: this.iconOn,
                    deactivate: this.iconOff
                });
            }
            ctl.panel_div = null;
        }
        this.activeState = null;
    },

    /**
     * APIMethod: activate
     */
    activate: function() {
        if (HGIS.Control.prototype.activate.apply(this, arguments)) {
            var control;
            for (var i=0, len=this.controls.length; i<len; i++) {
                control = this.controls[i];
                if (control === this.defaultControl ||
                            (this.saveState && this.activeState[control.id])) {
                    control.activate();
                }
            }    
            if (this.saveState === true) {
                this.defaultControl = null;
            }
            this.redraw();
            return true;
        } else {
            return false;
        }
    },
    
    /**
     * APIMethod: deactivate
     */
    deactivate: function() {
        if (HGIS.Control.prototype.deactivate.apply(this, arguments)) {
            var control;
            for (var i=0, len=this.controls.length; i<len; i++) {
                control = this.controls[i];
                this.activeState[control.id] = control.deactivate();
            }    
            this.redraw();
            return true;
        } else {
            return false;
        }
    },
    
    /**
     * Method: draw
     *
     * Returns:
     * {DOMElement}
     */    
    draw: function() {
        HGIS.Control.prototype.draw.apply(this, arguments);
        if (this.outsideViewport) {
            this.events.attachToElement(this.div);
            this.events.register("buttonclick", this, this.onButtonClick);
        } else {
            this.map.events.register("buttonclick", this, this.onButtonClick);
        }
        this.addControlsToMap(this.controls);
        return this.div;
    },

    /**
     * Method: redraw
     */
    redraw: function() {
        for (var l=this.div.childNodes.length, i=l-1; i>=0; i--) {
            this.div.removeChild(this.div.childNodes[i]);
        }
        this.div.innerHTML = "";
        if (this.active) {
            for (var i=0, len=this.controls.length; i<len; i++) {
                this.div.appendChild(this.controls[i].panel_div);
            }
        }
    },
    
    /**
     * APIMethod: activateControl
     * This method is called when the user click on the icon representing a 
     *     control in the panel.
     *
     * Parameters:
     * control - {<HGIS.Control>}
     */
    activateControl: function (control) {
        if (!this.active) { return false; }
        if (control.type == HGIS.Control.TYPE_BUTTON) {
            control.trigger();
            return;
        }
        if (control.type == HGIS.Control.TYPE_TOGGLE) {
            if (control.active) {
                control.deactivate();
            } else {
                control.activate();
            }
            return;
        }
        if (this.allowDepress && control.active) {
            control.deactivate();
        } else {
            var c;
            for (var i=0, len=this.controls.length; i<len; i++) {
                c = this.controls[i];
                if (c != control &&
                   (c.type === HGIS.Control.TYPE_TOOL || c.type == null)) {
                    c.deactivate();
                }
            }
            control.activate();
        }
    },

    /**
     * APIMethod: addControls
     * To build a toolbar, you add a set of controls to it. addControls
     * lets you add a single control or a list of controls to the 
     * Control Panel.
     *
     * Parameters:
     * controls - {<HGIS.Control>} Controls to add in the panel.
     */    
    addControls: function(controls) {
        if (!(HGIS.Util.isArray(controls))) {
            controls = [controls];
        }
        this.controls = this.controls.concat(controls);

        for (var i=0, len=controls.length; i<len; i++) {
            var control = controls[i],
                element = this.createControlMarkup(control);
            HGIS.Element.addClass(element, 
                                        control.displayClass + "ItemInactive");
            HGIS.Element.addClass(element, "olButton");
            if (control.title != ""  && !element.title) {
                element.title = control.title;
            }
            control.panel_div = element;
        }

        if (this.map) { // map.addControl() has already been called on the panel
            this.addControlsToMap(controls);
            this.redraw();
        }
    },

    /**
     * APIMethod: createControlMarkup
     * This function just creates a div for the control. If specific HTML
     * markup is needed this function can be overridden in specific classes,
     * or at panel instantiation time:
     *
     * Example:
     * (code)
     * var panel = new HGIS.Control.Panel({
     *     defaultControl: control,
     *     // ovverride createControlMarkup to create actual buttons
     *     // including texts wrapped into span elements.
     *     createControlMarkup: function(control) {
     *         var button = document.createElement('button'),
     *             span = document.createElement('span');
     *         if (control.text) {
     *             span.innerHTML = control.text;
     *         }
     *         return button;
     *     }
     *  });
     * (end)
     *
     * Parameters:
     * control - {<HGIS.Control>} The control to create the HTML
     *     markup for.
     *
     * Returns:
     * {DOMElement} The markup.
     */
    createControlMarkup: function(control) {
        return document.createElement("div");
    },
   
    /**
     * Method: addControlsToMap
     * Only for internal use in draw() and addControls() methods.
     *
     * Parameters:
     * controls - {Array(<HGIS.Control>)} Controls to add into map.
     */         
    addControlsToMap: function (controls) {
        var control;
        for (var i=0, len=controls.length; i<len; i++) {
            control = controls[i];
            if (control.autoActivate === true) {
                control.autoActivate = false;
                this.map.addControl(control);
                control.autoActivate = true;
            } else {
                this.map.addControl(control);
                control.deactivate();
            }
            control.events.on({
                activate: this.iconOn,
                deactivate: this.iconOff
            });
        }  
    },

    /**
     * Method: iconOn
     * Internal use, for use only with "controls[i].events.on/un".
     */
     iconOn: function() {
        var d = this.panel_div; // "this" refers to a control on panel!
        var re = new RegExp("\\b(" + this.displayClass + "Item)Inactive\\b");
        d.className = d.className.replace(re, "$1Active");
    },

    /**
     * Method: iconOff
     * Internal use, for use only with "controls[i].events.on/un".
     */
     iconOff: function() {
        var d = this.panel_div; // "this" refers to a control on panel!
        var re = new RegExp("\\b(" + this.displayClass + "Item)Active\\b");
        d.className = d.className.replace(re, "$1Inactive");
    },
    
    /**
     * Method: onButtonClick
     *
     * Parameters:
     * evt - {Event}
     */
    onButtonClick: function (evt) {
        var controls = this.controls,
            button = evt.buttonElement;
        for (var i=controls.length-1; i>=0; --i) {
            if (controls[i].panel_div === button) {
                this.activateControl(controls[i]);
                break;
            }
        }
    },

    /**
     * APIMethod: getControlsBy
     * Get a list of controls with properties matching the given criteria.
     *
     * Parameters:
     * property - {String} A control property to be matched.
     * match - {String | Object} A string to match.  Can also be a regular
     *     expression literal or object.  In addition, it can be any object
     *     with a method named test.  For reqular expressions or other, if
     *     match.test(control[property]) evaluates to true, the control will be
     *     included in the array returned.  If no controls are found, an empty
     *     array is returned.
     *
     * Returns:
     * {Array(<HGIS.Control>)} A list of controls matching the given criteria.
     *     An empty array is returned if no matches are found.
     */
    getControlsBy: function(property, match) {
        var test = (typeof match.test == "function");
        var found = HGIS.Array.filter(this.controls, function(item) {
            return item[property] == match || (test && match.test(item[property]));
        });
        return found;
    },

    /**
     * APIMethod: getControlsByName
     * Get a list of contorls with names matching the given name.
     *
     * Parameters:
     * match - {String | Object} A control name.  The name can also be a regular
     *     expression literal or object.  In addition, it can be any object
     *     with a method named test.  For reqular expressions or other, if
     *     name.test(control.name) evaluates to true, the control will be included
     *     in the list of controls returned.  If no controls are found, an empty
     *     array is returned.
     *
     * Returns:
     * {Array(<HGIS.Control>)} A list of controls matching the given name.
     *     An empty array is returned if no matches are found.
     */
    getControlsByName: function(match) {
        return this.getControlsBy("name", match);
    },

    /**
     * APIMethod: getControlsByClass
     * Get a list of controls of a given type (CLASS_NAME).
     *
     * Parameters:
     * match - {String | Object} A control class name.  The type can also be a
     *     regular expression literal or object.  In addition, it can be any
     *     object with a method named test.  For reqular expressions or other,
     *     if type.test(control.CLASS_NAME) evaluates to true, the control will
     *     be included in the list of controls returned.  If no controls are
     *     found, an empty array is returned.
     *
     * Returns:
     * {Array(<HGIS.Control>)} A list of controls matching the given type.
     *     An empty array is returned if no matches are found.
     */
    getControlsByClass: function(match) {
        return this.getControlsBy("CLASS_NAME", match);
    },

    CLASS_NAME: "HGIS.Control.Panel"
});

/* ======================================================================
    HGIS/Control/Button.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 */

/**
 * Class: HGIS.Control.Button 
 * The Button control is a very simple push-button, for use with 
 * <HGIS.Control.Panel>.
 * When clicked, the function trigger() is executed.
 * 
 * Inherits from:
 *  - <HGIS.Control>
 *
 * Use:
 * (code)
 * var button = new HGIS.Control.Button({
 *     displayClass: "MyButton", trigger: myFunction
 * });
 * panel.addControls([button]);
 * (end)
 * 
 * Will create a button with CSS class MyButtonItemInactive, that
 *     will call the function MyFunction() when clicked.
 */
HGIS.Control.Button = HGIS.Class(HGIS.Control, {
    /**
     * Property: type
     * {Integer} HGIS.Control.TYPE_BUTTON.
     */
    type: HGIS.Control.TYPE_BUTTON,
    
    /**
     * Method: trigger
     * Called by a control panel when the button is clicked.
     */
    trigger: function() {},

    CLASS_NAME: "HGIS.Control.Button"
});
/* ======================================================================
    HGIS/Control/ZoomIn.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control/Button.js
 */

/**
 * Class: HGIS.Control.ZoomIn
 * The ZoomIn control is a button to increase the zoom level of a map.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.ZoomIn = HGIS.Class(HGIS.Control.Button, {

    /**
     * Method: trigger
     */
    trigger: function(){
        if (this.map) {
            this.map.zoomIn();
        }
    },

    CLASS_NAME: "HGIS.Control.ZoomIn"
});
/* ======================================================================
    HGIS/Control/ZoomOut.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control/Button.js
 */

/**
 * Class: HGIS.Control.ZoomOut
 * The ZoomOut control is a button to decrease the zoom level of a map.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.ZoomOut = HGIS.Class(HGIS.Control.Button, {

    /**
     * Method: trigger
     */
    trigger: function(){
        if (this.map) {
            this.map.zoomOut();
        }
    },

    CLASS_NAME: "HGIS.Control.ZoomOut"
});
/* ======================================================================
    HGIS/Control/ZoomToMaxExtent.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control/Button.js
 */

/**
 * Class: HGIS.Control.ZoomToMaxExtent 
 * The ZoomToMaxExtent control is a button that zooms out to the maximum
 * extent of the map. It is designed to be used with a 
 * <HGIS.Control.Panel>.
 * 
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.ZoomToMaxExtent = HGIS.Class(HGIS.Control.Button, {

    /**
     * Method: trigger
     * 
     * Called whenever this control is being rendered inside of a panel and a 
     *     click occurs on this controls element. Actually zooms to the maximum
     *     extent of this controls map.
     */
    trigger: function() {
        if (this.map) {
            this.map.zoomToMaxExtent();
        }    
    },

    CLASS_NAME: "HGIS.Control.ZoomToMaxExtent"
});
/* ======================================================================
    HGIS/Control/ZoomPanel.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control/Panel.js
 * @requires HGIS/Control/ZoomIn.js
 * @requires HGIS/Control/ZoomOut.js
 * @requires HGIS/Control/ZoomToMaxExtent.js
 */

/**
 * Class: HGIS.Control.ZoomPanel
 * The ZoomPanel control is a compact collecton of 3 zoom controls: a 
 * <HGIS.Control.ZoomIn>, a <HGIS.Control.ZoomToMaxExtent>, and a
 * <HGIS.Control.ZoomOut>. By default it is drawn in the upper left 
 * corner of the map.
 *
 * Note: 
 * If you wish to use this class with the default images and you want 
 *       it to look nice in ie6, you should add the following, conditionally
 *       added css stylesheet to your HTML file:
 * 
 * (code)
 * <!--[if lte IE 6]>
 *   <link rel="stylesheet" href="../theme/default/ie6-style.css" type="text/css" />
 * <![endif]-->
 * (end)
 * 
 * Inherits from:
 *  - <HGIS.Control.Panel>
 */
HGIS.Control.ZoomPanel = HGIS.Class(HGIS.Control.Panel, {

    /**
     * Constructor: HGIS.Control.ZoomPanel 
     * Add the three zooming controls.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be used
     *     to extend the control.
     */
    initialize: function(options) {
        HGIS.Control.Panel.prototype.initialize.apply(this, [options]);
        this.addControls([
            new HGIS.Control.ZoomIn(),
            new HGIS.Control.ZoomToMaxExtent(),
            new HGIS.Control.ZoomOut()
        ]);
    },

    CLASS_NAME: "HGIS.Control.ZoomPanel"
});
/* ======================================================================
    HGIS/Layer/HTTPRequest.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer.js
 */

/**
 * Class: HGIS.Layer.HTTPRequest
 * 
 * Inherits from: 
 *  - <HGIS.Layer>
 */
HGIS.Layer.HTTPRequest = HGIS.Class(HGIS.Layer, {

    /** 
     * Constant: URL_HASH_FACTOR
     * {Float} Used to hash URL param strings for multi-WMS server selection.
     *         Set to the Golden Ratio per Knuth's recommendation.
     */
    URL_HASH_FACTOR: (Math.sqrt(5) - 1) / 2,

    /** 
     * Property: url
     * {Array(String) or String} This is either an array of url strings or 
     *                           a single url string. 
     */
    url: null,

    /** 
     * Property: params
     * {Object} Hashtable of key/value parameters
     */
    params: null,
    
    /** 
     * APIProperty: reproject
     * *Deprecated*. See http://docs.HGIS.org/library/spherical_mercator.html
     * for information on the replacement for this functionality. 
     * {Boolean} Whether layer should reproject itself based on base layer 
     *           locations. This allows reprojection onto commercial layers. 
     *           Default is false: Most layers can't reproject, but layers 
     *           which can create non-square geographic pixels can, like WMS.
     *           
     */
    reproject: false,

    /**
     * Constructor: HGIS.Layer.HTTPRequest
     * 
     * Parameters:
     * name - {String}
     * url - {Array(String) or String}
     * params - {Object}
     * options - {Object} Hashtable of extra options to tag onto the layer
     */
    initialize: function(name, url, params, options) {
        HGIS.Layer.prototype.initialize.apply(this, [name, options]);
        this.url = url;
        if (!this.params) {
            this.params = HGIS.Util.extend({}, params);
        }
    },

    /**
     * APIMethod: destroy
     */
    destroy: function() {
        this.url = null;
        this.params = null;
        HGIS.Layer.prototype.destroy.apply(this, arguments); 
    },
    
    /**
     * APIMethod: clone
     * 
     * Parameters:
     * obj - {Object}
     * 
     * Returns:
     * {<HGIS.Layer.HTTPRequest>} An exact clone of this 
     *                                  <HGIS.Layer.HTTPRequest>
     */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new HGIS.Layer.HTTPRequest(this.name,
                                                   this.url,
                                                   this.params,
                                                   this.getOptions());
        }
        
        //get all additions from superclasses
        obj = HGIS.Layer.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here
        
        return obj;
    },

    /** 
     * APIMethod: setUrl
     * 
     * Parameters:
     * newUrl - {String}
     */
    setUrl: function(newUrl) {
        this.url = newUrl;
    },

    /**
     * APIMethod: mergeNewParams
     * 
     * Parameters:
     * newParams - {Object}
     *
     * Returns:
     * redrawn: {Boolean} whether the layer was actually redrawn.
     */
    mergeNewParams:function(newParams) {
        this.params = HGIS.Util.extend(this.params, newParams);
        var ret = this.redraw();
        if(this.map != null) {
            this.map.events.triggerEvent("changelayer", {
                layer: this,
                property: "params"
            });
        }
        return ret;
    },

    /**
     * APIMethod: redraw
     * Redraws the layer.  Returns true if the layer was redrawn, false if not.
     *
     * Parameters:
     * force - {Boolean} Force redraw by adding random parameter.
     *
     * Returns:
     * {Boolean} The layer was redrawn.
     */
    redraw: function(force) { 
        if (force) {
            return this.mergeNewParams({"_olSalt": Math.random()});
        } else {
            return HGIS.Layer.prototype.redraw.apply(this, []);
        }
    },
    
    /**
     * Method: selectUrl
     * selectUrl() implements the standard floating-point multiplicative
     *     hash function described by Knuth, and hashes the contents of the 
     *     given param string into a float between 0 and 1. This float is then
     *     scaled to the size of the provided urls array, and used to select
     *     a URL.
     *
     * Parameters:
     * paramString - {String}
     * urls - {Array(String)}
     * 
     * Returns:
     * {String} An entry from the urls array, deterministically selected based
     *          on the paramString.
     */
    selectUrl: function(paramString, urls) {
        var product = 1;
        for (var i=0, len=paramString.length; i<len; i++) { 
            product *= paramString.charCodeAt(i) * this.URL_HASH_FACTOR; 
            product -= Math.floor(product); 
        }
        return urls[Math.floor(product * urls.length)];
    },

    /** 
     * Method: getFullRequestString
     * Combine url with layer's params and these newParams. 
     *   
     *    does checking on the serverPath variable, allowing for cases when it 
     *     is supplied with trailing ? or &, as well as cases where not. 
     *
     *    return in formatted string like this:
     *        "server?key1=value1&key2=value2&key3=value3"
     * 
     * WARNING: The altUrl parameter is deprecated and will be removed in 3.0.
     *
     * Parameters:
     * newParams - {Object}
     * altUrl - {String} Use this as the url instead of the layer's url
     *   
     * Returns: 
     * {String}
     */
    getFullRequestString:function(newParams, altUrl) {

        // if not altUrl passed in, use layer's url
        var url = altUrl || this.url;
        
        // create a new params hashtable with all the layer params and the 
        // new params together. then convert to string
        var allParams = HGIS.Util.extend({}, this.params);
        allParams = HGIS.Util.extend(allParams, newParams);
        var paramsString = HGIS.Util.getParameterString(allParams);
        
        // if url is not a string, it should be an array of strings, 
        // in which case we will deterministically select one of them in 
        // order to evenly distribute requests to different urls.
        //
        if (HGIS.Util.isArray(url)) {
            url = this.selectUrl(paramsString, url);
        }   
 
        // ignore parameters that are already in the url search string
        var urlParams = 
            HGIS.Util.upperCaseObject(HGIS.Util.getParameters(url));
        for(var key in allParams) {
            if(key.toUpperCase() in urlParams) {
                delete allParams[key];
            }
        }
        paramsString = HGIS.Util.getParameterString(allParams);
        
        return HGIS.Util.urlAppend(url, paramsString);
    },

    CLASS_NAME: "HGIS.Layer.HTTPRequest"
});
/* ======================================================================
    HGIS/Tile.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Util.js
 */

/**
 * Class: HGIS.Tile 
 * This is a class designed to designate a single tile, however
 *     it is explicitly designed to do relatively little. Tiles store 
 *     information about themselves -- such as the URL that they are related
 *     to, and their size - but do not add themselves to the layer div 
 *     automatically, for example. Create a new tile with the 
 *     <HGIS.Tile> constructor, or a subclass. 
 * 
 * TBD 3.0 - remove reference to url in above paragraph
 * 
 */
HGIS.Tile = HGIS.Class({
    
    /**
     * APIProperty: events
     * {<HGIS.Events>} An events object that handles all 
     *     events on the tile.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * tile.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types:
     * beforedraw - Triggered before the tile is drawn. Used to defer
     *     drawing to an animation queue. To defer drawing, listeners need
     *     to return false, which will abort drawing. The queue handler needs
     *     to call <draw>(true) to actually draw the tile.
     * loadstart - Triggered when tile loading starts.
     * loadend - Triggered when tile loading ends.
     * loaderror - Triggered before the loadend event (i.e. when the tile is
     *     still hidden) if the tile could not be loaded.
     * reload - Triggered when an already loading tile is reloaded.
     * unload - Triggered before a tile is unloaded.
     */
    events: null,

    /**
     * APIProperty: eventListeners
     * {Object} If set as an option at construction, the eventListeners
     *     object will be registered with <HGIS.Events.on>.  Object
     *     structure must be a listeners object as shown in the example for
     *     the events.on method.
     *
     * This options can be set in the ``tileOptions`` option from
     * <HGIS.Layer.Grid>. For example, to be notified of the
     * ``loadend`` event of each tiles:
     * (code)
     * new HGIS.Layer.OSM('osm', 'http://tile.openstreetmap.org/${z}/${x}/${y}.png', {
     *     tileOptions: {
     *         eventListeners: {
     *             'loadend': function(evt) {
     *                 // do something on loadend
     *             }
     *         }
     *     }
     * });
     * (end)
     */
    eventListeners: null,

    /**
     * Property: id 
     * {String} null
     */
    id: null,
    
    /** 
     * Property: layer 
     * {<HGIS.Layer>} layer the tile is attached to 
     */
    layer: null,
    
    /**
     * Property: url
     * {String} url of the request.
     *
     * TBD 3.0 
     * Deprecated. The base tile class does not need an url. This should be 
     * handled in subclasses. Does not belong here.
     */
    url: null,

    /** 
     * APIProperty: bounds 
     * {<HGIS.Bounds>} null
     */
    bounds: null,
    
    /** 
     * Property: size 
     * {<HGIS.Size>} null
     */
    size: null,
    
    /** 
     * Property: position 
     * {<HGIS.Pixel>} Top Left pixel of the tile
     */    
    position: null,
    
    /**
     * Property: isLoading
     * {Boolean} Is the tile loading?
     */
    isLoading: false,
    
    /** TBD 3.0 -- remove 'url' from the list of parameters to the constructor.
     *             there is no need for the base tile class to have a url.
     */

    /** 
     * Constructor: HGIS.Tile
     * Constructor for a new <HGIS.Tile> instance.
     * 
     * Parameters:
     * layer - {<HGIS.Layer>} layer that the tile will go in.
     * position - {<HGIS.Pixel>}
     * bounds - {<HGIS.Bounds>}
     * url - {<String>}
     * size - {<HGIS.Size>}
     * options - {Object}
     */   
    initialize: function(layer, position, bounds, url, size, options) {
        this.layer = layer;
        this.position = position.clone();
        this.setBounds(bounds);
        this.url = url;
        if (size) {
            this.size = size.clone();
        }

        //give the tile a unique id based on its BBOX.
        this.id = HGIS.Util.createUniqueID("Tile_");

        HGIS.Util.extend(this, options);

        this.events = new HGIS.Events(this);
        if (this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
    },

    /**
     * Method: unload
     * Call immediately before destroying if you are listening to tile
     * events, so that counters are properly handled if tile is still
     * loading at destroy-time. Will only fire an event if the tile is
     * still loading.
     */
    unload: function() {
       if (this.isLoading) { 
           this.isLoading = false; 
           this.events.triggerEvent("unload"); 
       }
    },
    
    /** 
     * APIMethod: destroy
     * Nullify references to prevent circular references and memory leaks.
     */
    destroy:function() {
        this.layer  = null;
        this.bounds = null;
        this.size = null;
        this.position = null;
        
        if (this.eventListeners) {
            this.events.un(this.eventListeners);
        }
        this.events.destroy();
        this.eventListeners = null;
        this.events = null;
    },
    
    /**
     * Method: draw
     * Clear whatever is currently in the tile, then return whether or not 
     *     it should actually be re-drawn. This is an example implementation
     *     that can be overridden by subclasses. The minimum thing to do here
     *     is to call <clear> and return the result from <shouldDraw>.
     *
     * Parameters:
     * force - {Boolean} If true, the tile will not be cleared and no beforedraw
     *     event will be fired. This is used for drawing tiles asynchronously
     *     after drawing has been cancelled by returning false from a beforedraw
     *     listener.
     * 
     * Returns:
     * {Boolean} Whether or not the tile should actually be drawn. Returns null
     *     if a beforedraw listener returned false.
     */
    draw: function(force) {
        if (!force) {
            //clear tile's contents and mark as not drawn
            this.clear();
        }
        var draw = this.shouldDraw();
        if (draw && !force && this.events.triggerEvent("beforedraw") === false) {
            draw = null;
        }
        return draw;
    },
    
    /**
     * Method: shouldDraw
     * Return whether or not the tile should actually be (re-)drawn. The only
     * case where we *wouldn't* want to draw the tile is if the tile is outside
     * its layer's maxExtent
     * 
     * Returns:
     * {Boolean} Whether or not the tile should actually be drawn.
     */
    shouldDraw: function() {        
        var withinMaxExtent = false,
            maxExtent = this.layer.maxExtent;
        if (maxExtent) {
            var map = this.layer.map;
            var worldBounds = map.baseLayer.wrapDateLine && map.getMaxExtent();
            if (this.bounds.intersectsBounds(maxExtent, {inclusive: false, worldBounds: worldBounds})) {
                withinMaxExtent = true;
            }
        }
        
        return withinMaxExtent || this.layer.displayOutsideMaxExtent;
    },
    
    /**
     * Method: setBounds
     * Sets the bounds on this instance
     *
     * Parameters:
     * bounds {<HGIS.Bounds>}
     */
    setBounds: function(bounds) {
        bounds = bounds.clone();
        if (this.layer.map.baseLayer.wrapDateLine) {
            var worldExtent = this.layer.map.getMaxExtent(),
                tolerance = this.layer.map.getResolution();
            bounds = bounds.wrapDateLine(worldExtent, {
                leftTolerance: tolerance,
                rightTolerance: tolerance
            });
        }
        this.bounds = bounds;
    },
    
    /** 
     * Method: moveTo
     * Reposition the tile.
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     * position - {<HGIS.Pixel>}
     * redraw - {Boolean} Call draw method on tile after moving.
     *     Default is true
     */
    moveTo: function (bounds, position, redraw) {
        if (redraw == null) {
            redraw = true;
        }

        this.setBounds(bounds);
        this.position = position.clone();
        if (redraw) {
            this.draw();
        }
    },

    /** 
     * Method: clear
     * Clear the tile of any bounds/position-related data so that it can 
     *     be reused in a new location.
     */
    clear: function(draw) {
        // to be extended by subclasses
    },
    
    CLASS_NAME: "HGIS.Tile"
});
/* ======================================================================
    HGIS/Tile/Image.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Tile.js
 * @requires HGIS/Animation.js
 * @requires HGIS/Util.js
 */

/**
 * Class: HGIS.Tile.Image
 * Instances of HGIS.Tile.Image are used to manage the image tiles
 * used by various layers.  Create a new image tile with the
 * <HGIS.Tile.Image> constructor.
 *
 * Inherits from:
 *  - <HGIS.Tile>
 */
HGIS.Tile.Image = HGIS.Class(HGIS.Tile, {

    /**
     * APIProperty: events
     * {<HGIS.Events>} An events object that handles all 
     *     events on the tile.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * tile.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types (in addition to the <HGIS.Tile> events):
     * beforeload - Triggered before an image is prepared for loading, when the
     *     url for the image is known already. Listeners may call <setImage> on
     *     the tile instance. If they do so, that image will be used and no new
     *     one will be created.
     */

    /** 
     * APIProperty: url
     * {String} The URL of the image being requested. No default. Filled in by
     * layer.getURL() function. May be modified by loadstart listeners.
     */
    url: null,
    
    /** 
     * Property: imgDiv
     * {HTMLImageElement} The image for this tile.
     */
    imgDiv: null,
    
    /**
     * Property: frame
     * {DOMElement} The image element is appended to the frame.  Any gutter on
     * the image will be hidden behind the frame. If no gutter is set,
     * this will be null.
     */ 
    frame: null, 

    /** 
     * Property: imageReloadAttempts
     * {Integer} Attempts to load the image.
     */
    imageReloadAttempts: null,
    
    /**
     * Property: layerAlphaHack
     * {Boolean} True if the png alpha hack needs to be applied on the layer's div.
     */
    layerAlphaHack: null,
    
    /**
     * Property: asyncRequestId
     * {Integer} ID of an request to see if request is still valid. This is a
     * number which increments by 1 for each asynchronous request.
     */
    asyncRequestId: null,
    
    /**
     * APIProperty: maxGetUrlLength
     * {Number} If set, requests that would result in GET urls with more
     * characters than the number provided will be made using form-encoded
     * HTTP POST. It is good practice to avoid urls that are longer than 2048
     * characters.
     *
     * Caution:
     * Older versions of Gecko based browsers (e.g. Firefox < 3.5) and most
     * Opera versions do not fully support this option. On all browsers,
     * transition effects are not supported if POST requests are used.
     */
    maxGetUrlLength: null,

    /**
     * Property: canvasContext
     * {CanvasRenderingContext2D} A canvas context associated with
     * the tile image.
     */
    canvasContext: null,
    
    /**
     * APIProperty: crossOriginKeyword
     * The value of the crossorigin keyword to use when loading images. This is
     * only relevant when using <getCanvasContext> for tiles from remote
     * origins and should be set to either 'anonymous' or 'use-credentials'
     * for servers that send Access-Control-Allow-Origin headers with their
     * tiles.
     */
    crossOriginKeyword: null,

    /** TBD 3.0 - reorder the parameters to the init function to remove 
     *             URL. the getUrl() function on the layer gets called on 
     *             each draw(), so no need to specify it here.
     */

    /** 
     * Constructor: HGIS.Tile.Image
     * Constructor for a new <HGIS.Tile.Image> instance.
     * 
     * Parameters:
     * layer - {<HGIS.Layer>} layer that the tile will go in.
     * position - {<HGIS.Pixel>}
     * bounds - {<HGIS.Bounds>}
     * url - {<String>} Deprecated. Remove me in 3.0.
     * size - {<HGIS.Size>}
     * options - {Object}
     */   
    initialize: function(layer, position, bounds, url, size, options) {
        HGIS.Tile.prototype.initialize.apply(this, arguments);

        this.url = url; //deprecated remove me
        
        this.layerAlphaHack = this.layer.alpha && HGIS.Util.alphaHack();

        if (this.maxGetUrlLength != null || this.layer.gutter || this.layerAlphaHack) {
            // only create frame if it's needed
            this.frame = document.createElement("div");
            this.frame.style.position = "absolute";
            this.frame.style.overflow = "hidden";
        }
        if (this.maxGetUrlLength != null) {
            HGIS.Util.extend(this, HGIS.Tile.Image.IFrame);
        }
    },
    
    /** 
     * APIMethod: destroy
     * nullify references to prevent circular references and memory leaks
     */
    destroy: function() {
        if (this.imgDiv)  {
            this.clear();
            this.imgDiv = null;
            this.frame = null;
        }
        // don't handle async requests any more
        this.asyncRequestId = null;
        HGIS.Tile.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Method: draw
     * Check that a tile should be drawn, and draw it.
     * 
     * Returns:
     * {Boolean} Was a tile drawn? Or null if a beforedraw listener returned
     *     false.
     */
    draw: function() {
        var shouldDraw = HGIS.Tile.prototype.draw.apply(this, arguments);
        if (shouldDraw) {
            // The layer's reproject option is deprecated.
            if (this.layer != this.layer.map.baseLayer && this.layer.reproject) {
                // getBoundsFromBaseLayer is defined in deprecated.js.
                this.bounds = this.getBoundsFromBaseLayer(this.position);
            }
            if (this.isLoading) {
                //if we're already loading, send 'reload' instead of 'loadstart'.
                this._loadEvent = "reload";
            } else {
                this.isLoading = true;
                this._loadEvent = "loadstart";
            }
            this.renderTile();
            this.positionTile();
        } else if (shouldDraw === false) {
            this.unload();
        }
        return shouldDraw;
    },
    
    /**
     * Method: renderTile
     * Internal function to actually initialize the image tile,
     *     position it correctly, and set its url.
     */
    renderTile: function() {
        if (this.layer.async) {
            // Asynchronous image requests call the asynchronous getURL method
            // on the layer to fetch an image that covers 'this.bounds'.
            var id = this.asyncRequestId = (this.asyncRequestId || 0) + 1;
            this.layer.getURLasync(this.bounds, function(url) {
                if (id == this.asyncRequestId) {
                    this.url = url;
                    this.initImage();
                }
            }, this);
        } else {
            // synchronous image requests get the url immediately.
            this.url = this.layer.getURL(this.bounds);
            this.initImage();
        }
    },

    /**
     * Method: positionTile
     * Using the properties currenty set on the layer, position the tile correctly.
     * This method is used both by the async and non-async versions of the Tile.Image
     * code.
     */
    positionTile: function() {
        var style = this.getTile().style,
            size = this.frame ? this.size :
                this.layer.getImageSize(this.bounds),
            ratio = 1;
        if (this.layer instanceof HGIS.Layer.Grid) {
            ratio = this.layer.getServerResolution() / this.layer.map.getResolution();
        }
        style.left = this.position.x + "px";
        style.top = this.position.y + "px";
        style.width = Math.round(ratio * size.w) + "px";
        style.height = Math.round(ratio * size.h) + "px";
    },

    /** 
     * Method: clear
     * Remove the tile from the DOM, clear it of any image related data so that
     * it can be reused in a new location.
     */
    clear: function() {
        HGIS.Tile.prototype.clear.apply(this, arguments);
        var img = this.imgDiv;
        if (img) {
            var tile = this.getTile();
            if (tile.parentNode === this.layer.div) {
                this.layer.div.removeChild(tile);
            }
            this.setImgSrc();
            if (this.layerAlphaHack === true) {
                img.style.filter = "";
            }
            HGIS.Element.removeClass(img, "olImageLoadError");
        }
        this.canvasContext = null;
    },
    
    /**
     * Method: getImage
     * Returns or creates and returns the tile image.
     */
    getImage: function() {
        if (!this.imgDiv) {
            this.imgDiv = HGIS.Tile.Image.IMAGE.cloneNode(false);

            var style = this.imgDiv.style;
            if (this.frame) {
                var left = 0, top = 0;
                if (this.layer.gutter) {
                    left = this.layer.gutter / this.layer.tileSize.w * 100;
                    top = this.layer.gutter / this.layer.tileSize.h * 100;
                }
                style.left = -left + "%";
                style.top = -top + "%";
                style.width = (2 * left + 100) + "%";
                style.height = (2 * top + 100) + "%";
            }
            style.visibility = "hidden";
            style.opacity = 0;
            if (this.layer.opacity < 1) {
                style.filter = 'alpha(opacity=' +
                               (this.layer.opacity * 100) +
                               ')';
            }
            style.position = "absolute";
            if (this.layerAlphaHack) {
                // move the image out of sight
                style.paddingTop = style.height;
                style.height = "0";
                style.width = "100%";
            }
            if (this.frame) {
                this.frame.appendChild(this.imgDiv);
            }
        }

        return this.imgDiv;
    },
    
    /**
     * APIMethod: setImage
     * Sets the image element for this tile. This method should only be called
     * from beforeload listeners.
     *
     * Parameters
     * img - {HTMLImageElement} The image to use for this tile.
     */
    setImage: function(img) {
        this.imgDiv = img;
    },

    /**
     * Method: initImage
     * Creates the content for the frame on the tile.
     */
    initImage: function() {
        this.events.triggerEvent('beforeload');
        this.layer.div.appendChild(this.getTile());
        this.events.triggerEvent(this._loadEvent);
        var img = this.getImage();
        //判断传来的时url还是promise
        if( (typeof (this.url))=="string"){//不使用indexedDB
            if (this.url && HGIS.Util.isEquivalentUrl(img.src, this.url)) {
                this._loadTimeout = window.setTimeout(
                    HGIS.Function.bind(this.onImageLoad, this), 0
                );
            } else {
                this.stopLoading();
                if (this.crossOriginKeyword) {
                    img.removeAttribute("crossorigin");
                }
                HGIS.Event.observe(img, "load",
                    HGIS.Function.bind(this.onImageLoad, this)
                );
                HGIS.Event.observe(img, "error",
                    HGIS.Function.bind(this.onImageError, this)
                );
                this.imageReloadAttempts = 0;
                this.setImgSrc(this.url);
            }

        }else{//使用indexedDB,此时this.url是一个promise对象
            var img = this.imgDiv;
            if(img.src){
                this._loadTimeout = window.setTimeout(
                    HGIS.Function.bind(this.onImageLoad, this), 0
                );
            }else{
                if (this.crossOriginKeyword) {
                    img.removeAttribute("crossorigin");
                }
                HGIS.Event.observe(img, "load",
                    HGIS.Function.bind(this.onImageLoad, this)
                );
                HGIS.Event.observe(img, "error",
                    HGIS.Function.bind(this.onImageError, this)
                );
                this.imageReloadAttempts = 0;
                this.setImgAsyn(this.url);

            }
        }

    },
    /**
     * 获取异步对象Promise中传来的url
     * @param promise
     */
    setImgAsyn:function (promise) {
        var img = this.imgDiv;
        this.url.then(
            function (iurl) {
                img.src=iurl;
            }
        );
    },
    /**
     * Method: setImgSrc
     * Sets the source for the tile image
     *
     * Parameters:
     * url - {String} or undefined to hide the image
     */
    setImgSrc: function(url) {
        var img = this.imgDiv;
        if (url) {
            img.style.visibility = 'hidden';
            img.style.opacity = 0;
            // don't set crossOrigin if the url is a data URL
            if (this.crossOriginKeyword) {
                if (url.substr(0, 5) !== 'data:') {
                    img.setAttribute("crossorigin", this.crossOriginKeyword);
                } else {
                    img.removeAttribute("crossorigin");
                }
            }
            img.src = url;
        } else {
            // Remove reference to the image, and leave it to the browser's
            // caching and garbage collection.
            this.stopLoading();
            this.imgDiv = null;
            if (img.parentNode) {
                img.parentNode.removeChild(img);
            }
        }
    },
    
    /**
     * Method: getTile
     * Get the tile's markup.
     *
     * Returns:
     * {DOMElement} The tile's markup
     */
    getTile: function() {
        return this.frame ? this.frame : this.getImage();
    },

    /**
     * Method: createBackBuffer
     * Create a backbuffer for this tile. A backbuffer isn't exactly a clone
     * of the tile's markup, because we want to avoid the reloading of the
     * image. So we clone the frame, and steal the image from the tile.
     *
     * Returns:
     * {DOMElement} The markup, or undefined if the tile has no image
     * or if it's currently loading.
     */
    createBackBuffer: function() {
        if (!this.imgDiv || this.isLoading) {
            return;
        }
        var backBuffer;
        if (this.frame) {
            backBuffer = this.frame.cloneNode(false);
            backBuffer.appendChild(this.imgDiv);
        } else {
            backBuffer = this.imgDiv;
        }
        this.imgDiv = null;
        return backBuffer;
    },

    /**
     * Method: onImageLoad
     * Handler for the image onload event
     */
    onImageLoad: function() {
        var img = this.imgDiv;
        this.stopLoading();
        img.style.visibility = 'inherit';
        img.style.opacity = this.layer.opacity;
        this.isLoading = false;
        this.canvasContext = null;
        this.events.triggerEvent("loadend");

        if (this.layerAlphaHack === true) {
            img.style.filter =
                "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" +
                img.src + "', sizingMethod='scale')";
        }
    },
    
    /**
     * Method: onImageError
     * Handler for the image onerror event
     */
    onImageError: function() {
        var img = this.imgDiv;
        if (img.src != null) {
            this.imageReloadAttempts++;
            if (this.imageReloadAttempts <= HGIS.IMAGE_RELOAD_ATTEMPTS) {
                this.setImgSrc(this.layer.getURL(this.bounds));
            } else {
                HGIS.Element.addClass(img, "olImageLoadError");
                this.events.triggerEvent("loaderror");
                this.onImageLoad();
            }
        }
    },
    
    /**
     * Method: stopLoading
     * Stops a loading sequence so <onImageLoad> won't be executed.
     */
    stopLoading: function() {
        HGIS.Event.stopObservingElement(this.imgDiv);
        window.clearTimeout(this._loadTimeout);
        delete this._loadTimeout;
    },

    /**
     * APIMethod: getCanvasContext
     * Returns a canvas context associated with the tile image (with
     * the image drawn on it).
     * Returns undefined if the browser does not support canvas, if
     * the tile has no image or if it's currently loading.
     *
     * The function returns a canvas context instance but the
     * underlying canvas is still available in the 'canvas' property:
     * (code)
     * var context = tile.getCanvasContext();
     * if (context) {
     *     var data = context.canvas.toDataURL('image/jpeg');
     * }
     * (end)
     *
     * Returns:
     * {Boolean}
     */
    getCanvasContext: function() {
        if (HGIS.CANVAS_SUPPORTED && this.imgDiv && !this.isLoading) {
            if (!this.canvasContext) {
                var canvas = document.createElement("canvas");
                canvas.width = this.size.w;
                canvas.height = this.size.h;
                this.canvasContext = canvas.getContext("2d");
                this.canvasContext.drawImage(this.imgDiv, 0, 0);
            }
            return this.canvasContext;
        }
    },

    CLASS_NAME: "HGIS.Tile.Image"

});

/** 
 * Constant: HGIS.Tile.Image.IMAGE
 * {HTMLImageElement} The image for a tile.
 */
HGIS.Tile.Image.IMAGE = (function() {
    var img = new Image();
    img.className = "olTileImage";
    // avoid image gallery menu in IE6
    img.galleryImg = "no";
    return img;
}());

/* ======================================================================
    HGIS/Layer/Grid.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer/HTTPRequest.js
 * @requires HGIS/Tile/Image.js
 */

/**
 * Class: HGIS.Layer.Grid
 * Base class for layers that use a lattice of tiles.  Create a new grid
 * layer with the <HGIS.Layer.Grid> constructor.
 *
 * Inherits from:
 *  - <HGIS.Layer.HTTPRequest>
 */
HGIS.Layer.Grid = HGIS.Class(HGIS.Layer.HTTPRequest, {
    
    /**
     * APIProperty: tileSize
     * {<HGIS.Size>}
     */
    tileSize: null,

    /**
     * Property: tileOriginCorner
     * {String} If the <tileOrigin> property is not provided, the tile origin 
     *     will be derived from the layer's <maxExtent>.  The corner of the 
     *     <maxExtent> used is determined by this property.  Acceptable values
     *     are "tl" (top left), "tr" (top right), "bl" (bottom left), and "br"
     *     (bottom right).  Default is "bl".
     */
    tileOriginCorner: "bl",
    
    /**
     * APIProperty: tileOrigin
     * {<HGIS.LonLat>} Optional origin for aligning the grid of tiles.
     *     If provided, requests for tiles at all resolutions will be aligned
     *     with this location (no tiles shall overlap this location).  If
     *     not provided, the grid of tiles will be aligned with the layer's
     *     <maxExtent>.  Default is ``null``.
     */
    tileOrigin: null,
    
    /** APIProperty: tileOptions
     *  {Object} optional configuration options for <HGIS.Tile> instances
     *  created by this Layer, if supported by the tile class.
     */
    tileOptions: null,

    /**
     * APIProperty: tileClass
     * {<HGIS.Tile>} The tile class to use for this layer.
     *     Defaults is HGIS.Tile.Image.
     */
    tileClass: HGIS.Tile.Image,
    
    /**
     * Property: grid
     * {Array(Array(<HGIS.Tile>))} This is an array of rows, each row is 
     *     an array of tiles.
     */
    grid: null,

    /**
     * APIProperty: singleTile
     * {Boolean} Moves the layer into single-tile mode, meaning that one tile 
     *     will be loaded. The tile's size will be determined by the 'ratio'
     *     property. When the tile is dragged such that it does not cover the 
     *     entire viewport, it is reloaded.
     */
    singleTile: false,

    /** APIProperty: ratio
     *  {Float} Used only when in single-tile mode, this specifies the 
     *          ratio of the size of the single tile to the size of the map.
     *          Default value is 1.5.
     */
    ratio: 1.5,

    /**
     * APIProperty: buffer
     * {Integer} Used only when in gridded mode, this specifies the number of 
     *           extra rows and colums of tiles on each side which will
     *           surround the minimum grid tiles to cover the map.
     *           For very slow loading layers, a larger value may increase
     *           performance somewhat when dragging, but will increase bandwidth
     *           use significantly. 
     */
    buffer: 0,

    /**
     * APIProperty: transitionEffect
     * {String} The transition effect to use when the map is zoomed.
     * Two posible values:
     *
     * "resize" - Existing tiles are resized on zoom to provide a visual
     *     effect of the zoom having taken place immediately.  As the
     *     new tiles become available, they are drawn on top of the
     *     resized tiles (this is the default setting).
     * "map-resize" - Existing tiles are resized on zoom and placed below the
     *     base layer.  New tiles for the base layer will cover existing tiles.
     *     This setting is recommended when having an overlay duplicated during
     *     the transition is undesirable (e.g. street labels or big transparent
     *     fills). 
     * null - No transition effect.
     *
     * Using "resize" on non-opaque layers can cause undesired visual
     * effects.  Set transitionEffect to null in this case.
     */
    transitionEffect: "resize",

    /**
     * APIProperty: numLoadingTiles
     * {Integer} How many tiles are still loading?
     */
    numLoadingTiles: 0,

    /**
     * Property: serverResolutions
     * {Array(Number}} This property is documented in subclasses as
     *     an API property.
     */
    serverResolutions: null,

    /**
     * Property: loading
     * {Boolean} Indicates if tiles are being loaded.
     */
    loading: false,
    
    /**
     * Property: backBuffer
     * {DOMElement} The back buffer.
     */
    backBuffer: null,

    /**
     * Property: gridResolution
     * {Number} The resolution of the current grid. Used for backbuffer and
     *     client zoom. This property is updated every time the grid is
     *     initialized.
     */
    gridResolution: null,

    /**
     * Property: backBufferResolution
     * {Number} The resolution of the current back buffer. This property is
     *     updated each time a back buffer is created.
     */
    backBufferResolution: null,

    /**
     * Property: backBufferLonLat
     * {Object} The top-left corner of the current back buffer. Includes lon
     *     and lat properties. This object is updated each time a back buffer
     *     is created.
     */
    backBufferLonLat: null,

    /**
     * Property: backBufferTimerId
     * {Number} The id of the back buffer timer. This timer is used to
     *     delay the removal of the back buffer, thereby preventing
     *     flash effects caused by tile animation.
     */
    backBufferTimerId: null,

    /**
     * APIProperty: removeBackBufferDelay
     * {Number} Delay for removing the backbuffer when all tiles have finished
     *     loading. Can be set to 0 when no css opacity transitions for the
     *     olTileImage class are used. Default is 0 for <singleTile> layers,
     *     2500 for tiled layers. See <className> for more information on
     *     tile animation.
     */
    removeBackBufferDelay: null,

    /**
     * APIProperty: className
     * {String} Name of the class added to the layer div. If not set in the
     *     options passed to the constructor then className defaults to
     *     "olLayerGridSingleTile" for single tile layers (see <singleTile>),
     *     and "olLayerGrid" for non single tile layers.
     *
     * Note:
     *
     * The displaying of tiles is not animated by default for single tile
     *     layers - HGIS' default theme (style.css) includes this:
     * (code)
     * .olLayerGrid .olTileImage {
     *     -webkit-transition: opacity 0.2s linear;
     *     -moz-transition: opacity 0.2s linear;
     *     -o-transition: opacity 0.2s linear;
     *     transition: opacity 0.2s linear;
     *  }
     * (end)
     * To animate tile displaying for any grid layer the following
     *     CSS rule can be used:
     * (code)
     * .olTileImage {
     *     -webkit-transition: opacity 0.2s linear;
     *     -moz-transition: opacity 0.2s linear;
     *     -o-transition: opacity 0.2s linear;
     *     transition: opacity 0.2s linear;
     * }
     * (end)
     * In that case, to avoid flash effects, <removeBackBufferDelay>
     *     should not be zero.
     */
    className: null,
    
    /**
     * Register a listener for a particular event with the following syntax:
     * (code)
     * layer.events.register(type, obj, listener);
     * (end)
     *
     * Listeners will be called with a reference to an event object.  The
     *     properties of this event depends on exactly what happened.
     *
     * All event objects have at least the following properties:
     * object - {Object} A reference to layer.events.object.
     * element - {DOMElement} A reference to layer.events.element.
     *
     * Supported event types:
     * addtile - Triggered when a tile is added to this layer. Listeners receive
     *     an object as first argument, which has a tile property that
     *     references the tile that has been added.
     * tileloadstart - Triggered when a tile starts loading. Listeners receive
     *     an object as first argument, which has a tile property that
     *     references the tile that starts loading.
     * tileloaded - Triggered when each new tile is
     *     loaded, as a means of progress update to listeners.
     *     listeners can access 'numLoadingTiles' if they wish to keep
     *     track of the loading progress. Listeners are called with an object
     *     with a 'tile' property as first argument, making the loaded tile
     *     available to the listener, and an 'aborted' property, which will be
     *     true when loading was aborted and no tile data is available.
     * tileerror - Triggered before the tileloaded event (i.e. when the tile is
     *     still hidden) if a tile failed to load. Listeners receive an object
     *     as first argument, which has a tile property that references the
     *     tile that could not be loaded.
     * retile - Triggered when the layer recreates its tile grid.
     */

    /**
     * Property: gridLayout
     * {Object} Object containing properties tilelon, tilelat, startcol,
     * startrow
     */
    gridLayout: null,
    
    /**
     * Property: rowSign
     * {Number} 1 for grids starting at the top, -1 for grids starting at the
     * bottom. This is used for several grid index and offset calculations.
     */
    rowSign: null,

    /**
     * Property: transitionendEvents
     * {Array} Event names for transitionend
     */
    transitionendEvents: [
        'transitionend', 'webkitTransitionEnd', 'otransitionend',
        'oTransitionEnd'
    ],

    /**
     * Constructor: HGIS.Layer.Grid
     * Create a new grid layer
     *
     * Parameters:
     * name - {String}
     * url - {String}
     * params - {Object}
     * options - {Object} Hashtable of extra options to tag onto the layer
     */
    initialize: function(name, url, params, options) {
        HGIS.Layer.HTTPRequest.prototype.initialize.apply(this, 
                                                                arguments);
        this.grid = [];
        this._removeBackBuffer = HGIS.Function.bind(this.removeBackBuffer, this);

        this.initProperties();

        this.rowSign = this.tileOriginCorner.substr(0, 1) === "t" ? 1 : -1;
    },

    /**
     * Method: initProperties
     * Set any properties that depend on the value of singleTile.
     * Currently sets removeBackBufferDelay and className
     */
    initProperties: function() {
        if (this.options.removeBackBufferDelay === undefined) {
            this.removeBackBufferDelay = this.singleTile ? 0 : 2500;
        }

        if (this.options.className === undefined) {
            this.className = this.singleTile ? 'olLayerGridSingleTile' :
                                               'olLayerGrid';
        }
    },

    /**
     * Method: setMap
     *
     * Parameters:
     * map - {<HGIS.Map>} The map.
     */
    setMap: function(map) {
        HGIS.Layer.HTTPRequest.prototype.setMap.call(this, map);
        HGIS.Element.addClass(this.div, this.className);
    },

    /**
     * Method: removeMap
     * Called when the layer is removed from the map.
     *
     * Parameters:
     * map - {<HGIS.Map>} The map.
     */
    removeMap: function(map) {
        this.removeBackBuffer();
    },

    /**
     * APIMethod: destroy
     * Deconstruct the layer and clear the grid.
     */
    destroy: function() {
        this.removeBackBuffer();
        this.clearGrid();

        this.grid = null;
        this.tileSize = null;
        HGIS.Layer.HTTPRequest.prototype.destroy.apply(this, arguments); 
    },

    /**
     * APIMethod: mergeNewParams
     * Refetches tiles with new params merged, keeping a backbuffer. Each
     * loading new tile will have a css class of '.olTileReplacing'. If a
     * stylesheet applies a 'display: none' style to that class, any fade-in
     * transition will not apply, and backbuffers for each tile will be removed
     * as soon as the tile is loaded.
     * 
     * Parameters:
     * newParams - {Object}
     *
     * Returns:
     * redrawn: {Boolean} whether the layer was actually redrawn.
     */

    /**
     * Method: clearGrid
     * Go through and remove all tiles from the grid, calling
     *    destroy() on each of them to kill circular references
     */
    clearGrid:function() {
        if (this.grid) {
            for(var iRow=0, len=this.grid.length; iRow<len; iRow++) {
                var row = this.grid[iRow];
                for(var iCol=0, clen=row.length; iCol<clen; iCol++) {
                    var tile = row[iCol];
                    this.destroyTile(tile);
                }
            }
            this.grid = [];
            this.gridResolution = null;
            this.gridLayout = null;
        }
    },

   /**
    * APIMethod: addOptions
    * 
    * Parameters:
    * newOptions - {Object}
    * reinitialize - {Boolean} If set to true, and if resolution options of the
    *     current baseLayer were changed, the map will be recentered to make
    *     sure that it is displayed with a valid resolution, and a
    *     changebaselayer event will be triggered.
    */
    addOptions: function (newOptions, reinitialize) {
        var singleTileChanged = newOptions.singleTile !== undefined && 
            newOptions.singleTile !== this.singleTile;
        HGIS.Layer.HTTPRequest.prototype.addOptions.apply(this, arguments);
        if (this.map && singleTileChanged) {
            this.initProperties();
            this.clearGrid();
            this.tileSize = this.options.tileSize;
            this.setTileSize();
            this.moveTo(null, true);
        }
    },
    
    /**
     * APIMethod: clone
     * Create a clone of this layer
     *
     * Parameters:
     * obj - {Object} Is this ever used?
     * 
     * Returns:
     * {<HGIS.Layer.Grid>} An exact clone of this HGIS.Layer.Grid
     */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new HGIS.Layer.Grid(this.name,
                                            this.url,
                                            this.params,
                                            this.getOptions());
        }

        //get all additions from superclasses
        obj = HGIS.Layer.HTTPRequest.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here
        if (this.tileSize != null) {
            obj.tileSize = this.tileSize.clone();
        }
        
        // we do not want to copy reference to grid, so we make a new array
        obj.grid = [];
        obj.gridResolution = null;
        // same for backbuffer
        obj.backBuffer = null;
        obj.backBufferTimerId = null;
        obj.loading = false;
        obj.numLoadingTiles = 0;

        return obj;
    },    

    /**
     * Method: moveTo
     * This function is called whenever the map is moved. All the moving
     * of actual 'tiles' is done by the map, but moveTo's role is to accept
     * a bounds and make sure the data that that bounds requires is pre-loaded.
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     * zoomChanged - {Boolean}
     * dragging - {Boolean}
     */
    moveTo:function(bounds, zoomChanged, dragging) {

        HGIS.Layer.HTTPRequest.prototype.moveTo.apply(this, arguments);

        bounds = bounds || this.map.getExtent();

        if (bounds != null) {
             
            // if grid is empty or zoom has changed, we *must* re-tile
            var forceReTile = !this.grid.length || zoomChanged;
            
            // total bounds of the tiles
            var tilesBounds = this.getTilesBounds();            

            // the new map resolution
            var resolution = this.map.getResolution();

            // the server-supported resolution for the new map resolution
            var serverResolution = this.getServerResolution(resolution);

            if (this.singleTile) {
                
                // We want to redraw whenever even the slightest part of the 
                //  current bounds is not contained by our tile.
                //  (thus, we do not specify partial -- its default is false)

                if ( forceReTile ||
                     (!dragging && !tilesBounds.containsBounds(bounds))) {

                    // In single tile mode with no transition effect, we insert
                    // a non-scaled backbuffer when the layer is moved. But if
                    // a zoom occurs right after a move, i.e. before the new
                    // image is received, we need to remove the backbuffer, or
                    // an ill-positioned image will be visible during the zoom
                    // transition.

                    if(zoomChanged && this.transitionEffect !== 'resize') {
                        this.removeBackBuffer();
                    }

                    if(!zoomChanged || this.transitionEffect === 'resize') {
                        this.applyBackBuffer(resolution);
                    }

                    this.initSingleTile(bounds);
                }
            } else {

                // if the bounds have changed such that they are not even 
                // *partially* contained by our tiles (e.g. when user has 
                // programmatically panned to the other side of the earth on
                // zoom level 18), then moveGriddedTiles could potentially have
                // to run through thousands of cycles, so we want to reTile
                // instead (thus, partial true).  
                forceReTile = forceReTile ||
                    !tilesBounds.intersectsBounds(bounds, {
                        worldBounds: this.map.baseLayer.wrapDateLine &&
                            this.map.getMaxExtent()
                    });

                if(forceReTile) {
                    if(zoomChanged && (this.transitionEffect === 'resize' ||
                                          this.gridResolution === resolution)) {
                        this.applyBackBuffer(resolution);
                    }
                    this.initGriddedTiles(bounds);
                } else {
                    this.moveGriddedTiles();
                }
            }
        }
    },

    /**
     * Method: getTileData
     * Given a map location, retrieve a tile and the pixel offset within that
     *     tile corresponding to the location.  If there is not an existing 
     *     tile in the grid that covers the given location, null will be 
     *     returned.
     *
     * Parameters:
     * loc - {<HGIS.LonLat>} map location
     *
     * Returns:
     * {Object} Object with the following properties: tile ({<HGIS.Tile>}),
     *     i ({Number} x-pixel offset from top left), and j ({Integer} y-pixel
     *     offset from top left).
     */
    getTileData: function(loc) {
        var data = null,
            x = loc.lon,
            y = loc.lat,
            numRows = this.grid.length;

        if (this.map && numRows) {
            var res = this.map.getResolution(),
                tileWidth = this.tileSize.w,
                tileHeight = this.tileSize.h,
                bounds = this.grid[0][0].bounds,
                left = bounds.left,
                top = bounds.top;

            if (x < left) {
                // deal with multiple worlds
                if (this.map.baseLayer.wrapDateLine) {
                    var worldWidth = this.map.getMaxExtent().getWidth();
                    var worldsAway = Math.ceil((left - x) / worldWidth);
                    x += worldWidth * worldsAway;
                }
            }
            // tile distance to location (fractional number of tiles);
            var dtx = (x - left) / (res * tileWidth);
            var dty = (top - y) / (res * tileHeight);
            // index of tile in grid
            var col = Math.floor(dtx);
            var row = Math.floor(dty);
            if (row >= 0 && row < numRows) {
                var tile = this.grid[row][col];
                if (tile) {
                    data = {
                        tile: tile,
                        // pixel index within tile
                        i: Math.floor((dtx - col) * tileWidth),
                        j: Math.floor((dty - row) * tileHeight)
                    };                    
                }
            }
        }
        return data;
    },
    
    /**
     * Method: destroyTile
     *
     * Parameters:
     * tile - {<HGIS.Tile>}
     */
    destroyTile: function(tile) {
        this.removeTileMonitoringHooks(tile);
        tile.destroy();
    },

    /**
     * Method: getServerResolution
     * Return the closest server-supported resolution.
     *
     * Parameters:
     * resolution - {Number} The base resolution. If undefined the
     *     map resolution is used.
     *
     * Returns:
     * {Number} The closest server resolution value.
     */
    getServerResolution: function(resolution) {
        var distance = Number.POSITIVE_INFINITY;
        resolution = resolution || this.map.getResolution();
        if(this.serverResolutions &&
           HGIS.Util.indexOf(this.serverResolutions, resolution) === -1) {
            var i, newDistance, newResolution, serverResolution;
            for(i=this.serverResolutions.length-1; i>= 0; i--) {
                newResolution = this.serverResolutions[i];
                newDistance = Math.abs(newResolution - resolution);
                if (newDistance > distance) {
                    break;
                }
                distance = newDistance;
                serverResolution = newResolution;
            }
            resolution = serverResolution;
        }
        return resolution;
    },

    /**
     * Method: getServerZoom
     * Return the zoom value corresponding to the best matching server
     * resolution, taking into account <serverResolutions> and <zoomOffset>.
     *
     * Returns:
     * {Number} The closest server supported zoom. This is not the map zoom
     *     level, but an index of the server's resolutions array.
     */
    getServerZoom: function() {
        var resolution = this.getServerResolution();
        return this.serverResolutions ?
            HGIS.Util.indexOf(this.serverResolutions, resolution) :
            this.map.getZoomForResolution(resolution) + (this.zoomOffset || 0);
    },

    /**
     * Method: applyBackBuffer
     * Create, insert, scale and position a back buffer for the layer.
     *
     * Parameters:
     * resolution - {Number} The resolution to transition to.
     */
    applyBackBuffer: function(resolution) {
        if(this.backBufferTimerId !== null) {
            this.removeBackBuffer();
        }
        var backBuffer = this.backBuffer;
        if(!backBuffer) {
            backBuffer = this.createBackBuffer();
            if(!backBuffer) {
                return;
            }
            if (resolution === this.gridResolution) {
                this.div.insertBefore(backBuffer, this.div.firstChild);
            } else {
                this.map.baseLayer.div.parentNode.insertBefore(backBuffer, this.map.baseLayer.div);
            }
            this.backBuffer = backBuffer;

            // set some information in the instance for subsequent
            // calls to applyBackBuffer where the same back buffer
            // is reused
            var topLeftTileBounds = this.grid[0][0].bounds;
            this.backBufferLonLat = {
                lon: topLeftTileBounds.left,
                lat: topLeftTileBounds.top
            };
            this.backBufferResolution = this.gridResolution;
        }
        
        var ratio = this.backBufferResolution / resolution;

        // scale the tiles inside the back buffer
        var tiles = backBuffer.childNodes, tile;
        for (var i=tiles.length-1; i>=0; --i) {
            tile = tiles[i];
            tile.style.top = ((ratio * tile._i * tile._h) | 0) + 'px';
            tile.style.left = ((ratio * tile._j * tile._w) | 0) + 'px';
            tile.style.width = Math.round(ratio * tile._w) + 'px';
            tile.style.height = Math.round(ratio * tile._h) + 'px';
        }

        // and position it (based on the grid's top-left corner)
        var position = this.getViewPortPxFromLonLat(
                this.backBufferLonLat, resolution);
        var leftOffset = this.map.layerContainerOriginPx.x;
        var topOffset = this.map.layerContainerOriginPx.y;
        backBuffer.style.left = Math.round(position.x - leftOffset) + 'px';
        backBuffer.style.top = Math.round(position.y - topOffset) + 'px';
    },

    /**
     * Method: createBackBuffer
     * Create a back buffer.
     *
     * Returns:
     * {DOMElement} The DOM element for the back buffer, undefined if the
     * grid isn't initialized yet.
     */
    createBackBuffer: function() {
        var backBuffer;
        if(this.grid.length > 0) {
            backBuffer = document.createElement('div');
            backBuffer.id = this.div.id + '_bb';
            backBuffer.className = 'olBackBuffer';
            backBuffer.style.position = 'absolute';
            var map = this.map;
            backBuffer.style.zIndex = this.transitionEffect === 'resize' ?
                    this.getZIndex() - 1 :
                    // 'map-resize':
                    map.Z_INDEX_BASE.BaseLayer -
                            (map.getNumLayers() - map.getLayerIndex(this));
            for(var i=0, lenI=this.grid.length; i<lenI; i++) {
                for(var j=0, lenJ=this.grid[i].length; j<lenJ; j++) {
                    var tile = this.grid[i][j],
                        markup = this.grid[i][j].createBackBuffer();
                    if (markup) {
                        markup._i = i;
                        markup._j = j;
                        markup._w = tile.size.w;
                        markup._h = tile.size.h;
                        markup.id = tile.id + '_bb';
                        backBuffer.appendChild(markup);
                    }
                }
            }
        }
        return backBuffer;
    },

    /**
     * Method: removeBackBuffer
     * Remove back buffer from DOM.
     */
    removeBackBuffer: function() {
        if (this._transitionElement) {
            for (var i=this.transitionendEvents.length-1; i>=0; --i) {
                HGIS.Event.stopObserving(this._transitionElement,
                    this.transitionendEvents[i], this._removeBackBuffer);
            }
            delete this._transitionElement;
        }
        if(this.backBuffer) {
            if (this.backBuffer.parentNode) {
                this.backBuffer.parentNode.removeChild(this.backBuffer);
            }
            this.backBuffer = null;
            this.backBufferResolution = null;
            if(this.backBufferTimerId !== null) {
                window.clearTimeout(this.backBufferTimerId);
                this.backBufferTimerId = null;
            }
        }
    },

    /**
     * Method: moveByPx
     * Move the layer based on pixel vector.
     *
     * Parameters:
     * dx - {Number}
     * dy - {Number}
     */
    moveByPx: function(dx, dy) {
        if (!this.singleTile) {
            this.moveGriddedTiles();
        }
    },

    /**
     * APIMethod: setTileSize
     * Check if we are in singleTile mode and if so, set the size as a ratio
     *     of the map size (as specified by the layer's 'ratio' property).
     * 
     * Parameters:
     * size - {<HGIS.Size>}
     */
    setTileSize: function(size) { 
        if (this.singleTile) {
            size = this.map.getSize();
            size.h = parseInt(size.h * this.ratio, 10);
            size.w = parseInt(size.w * this.ratio, 10);
        } 
        HGIS.Layer.HTTPRequest.prototype.setTileSize.apply(this, [size]);
    },

    /**
     * APIMethod: getTilesBounds
     * Return the bounds of the tile grid.
     *
     * Returns:
     * {<HGIS.Bounds>} A Bounds object representing the bounds of all the
     *     currently loaded tiles (including those partially or not at all seen 
     *     onscreen).
     */
    getTilesBounds: function() {    
        var bounds = null; 
        
        var length = this.grid.length;
        if (length) {
            var bottomLeftTileBounds = this.grid[length - 1][0].bounds,
                width = this.grid[0].length * bottomLeftTileBounds.getWidth(),
                height = this.grid.length * bottomLeftTileBounds.getHeight();
            
            bounds = new HGIS.Bounds(bottomLeftTileBounds.left, 
                                           bottomLeftTileBounds.bottom,
                                           bottomLeftTileBounds.left + width, 
                                           bottomLeftTileBounds.bottom + height);
        }   
        return bounds;
    },

    /**
     * Method: initSingleTile
     * 
     * Parameters: 
     * bounds - {<HGIS.Bounds>}
     */
    initSingleTile: function(bounds) {
        this.events.triggerEvent("retile");

        //determine new tile bounds
        var center = bounds.getCenterLonLat();
        var tileWidth = bounds.getWidth() * this.ratio;
        var tileHeight = bounds.getHeight() * this.ratio;
                                       
        var tileBounds = 
            new HGIS.Bounds(center.lon - (tileWidth/2),
                                  center.lat - (tileHeight/2),
                                  center.lon + (tileWidth/2),
                                  center.lat + (tileHeight/2));
  
        var px = this.map.getLayerPxFromLonLat({
            lon: tileBounds.left,
            lat: tileBounds.top
        });

        if (!this.grid.length) {
            this.grid[0] = [];
        }

        var tile = this.grid[0][0];
        if (!tile) {
            tile = this.addTile(tileBounds, px);
            
            this.addTileMonitoringHooks(tile);
            tile.draw();
            this.grid[0][0] = tile;
        } else {
            tile.moveTo(tileBounds, px);
        }           
        
        //remove all but our single tile
        this.removeExcessTiles(1,1);

        // store the resolution of the grid
        this.gridResolution = this.getServerResolution();
    },

    /** 
     * Method: calculateGridLayout
     * Generate parameters for the grid layout.
     *
     * Parameters:
     * bounds - {<HGIS.Bound>|Object} HGIS.Bounds or an
     *     object with a 'left' and 'top' properties.
     * origin - {<HGIS.LonLat>|Object} HGIS.LonLat or an
     *     object with a 'lon' and 'lat' properties.
     * resolution - {Number}
     *
     * Returns:
     * {Object} Object containing properties tilelon, tilelat, startcol,
     * startrow
     */
    calculateGridLayout: function(bounds, origin, resolution) {
        var tilelon = resolution * this.tileSize.w;
        var tilelat = resolution * this.tileSize.h;
        
        var offsetlon = bounds.left - origin.lon;
        var tilecol = Math.floor(offsetlon/tilelon) - this.buffer;
        
        var rowSign = this.rowSign;

        var offsetlat = rowSign * (origin.lat - bounds.top + tilelat);  
        var tilerow = Math[~rowSign ? 'floor' : 'ceil'](offsetlat/tilelat) - this.buffer * rowSign;
        
        return { 
          tilelon: tilelon, tilelat: tilelat,
          startcol: tilecol, startrow: tilerow
        };

    },
    
    /**
     * Method: getTileOrigin
     * Determine the origin for aligning the grid of tiles.  If a <tileOrigin>
     *     property is supplied, that will be returned.  Otherwise, the origin
     *     will be derived from the layer's <maxExtent> property.  In this case,
     *     the tile origin will be the corner of the <maxExtent> given by the 
     *     <tileOriginCorner> property.
     *
     * Returns:
     * {<HGIS.LonLat>} The tile origin.
     */
    getTileOrigin: function() {
        var origin = this.tileOrigin;
        if (!origin) {
            var extent = this.getMaxExtent();
            var edges = ({
                "tl": ["left", "top"],
                "tr": ["right", "top"],
                "bl": ["left", "bottom"],
                "br": ["right", "bottom"]
            })[this.tileOriginCorner];
            origin = new HGIS.LonLat(extent[edges[0]], extent[edges[1]]);
        }
        return origin;
    },

    /**
     * Method: getTileBoundsForGridIndex
     *
     * Parameters:
     * row - {Number} The row of the grid
     * col - {Number} The column of the grid
     *
     * Returns:
     * {<HGIS.Bounds>} The bounds for the tile at (row, col)
     */
    getTileBoundsForGridIndex: function(row, col) {
        var origin = this.getTileOrigin();
        var tileLayout = this.gridLayout;
        var tilelon = tileLayout.tilelon;
        var tilelat = tileLayout.tilelat;
        var startcol = tileLayout.startcol;
        var startrow = tileLayout.startrow;
        var rowSign = this.rowSign;
        return new HGIS.Bounds(
            origin.lon + (startcol + col) * tilelon,
            origin.lat - (startrow + row * rowSign) * tilelat * rowSign,
            origin.lon + (startcol + col + 1) * tilelon,
            origin.lat - (startrow + (row - 1) * rowSign) * tilelat * rowSign
        );
    },

    /**
     * Method: initGriddedTiles
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     */
    initGriddedTiles:function(bounds) {
        this.events.triggerEvent("retile");

        // work out mininum number of rows and columns; this is the number of
        // tiles required to cover the viewport plus at least one for panning

        var viewSize = this.map.getSize();
        
        var origin = this.getTileOrigin();
        var resolution = this.map.getResolution(),
            serverResolution = this.getServerResolution(),
            ratio = resolution / serverResolution,
            tileSize = {
                w: this.tileSize.w / ratio,
                h: this.tileSize.h / ratio
            };

        var minRows = Math.ceil(viewSize.h/tileSize.h) + 
                      2 * this.buffer + 1;
        var minCols = Math.ceil(viewSize.w/tileSize.w) +
                      2 * this.buffer + 1;

        var tileLayout = this.calculateGridLayout(bounds, origin, serverResolution);
        this.gridLayout = tileLayout;
        
        var tilelon = tileLayout.tilelon;
        var tilelat = tileLayout.tilelat;
        
        var layerContainerDivLeft = this.map.layerContainerOriginPx.x;
        var layerContainerDivTop = this.map.layerContainerOriginPx.y;

        var tileBounds = this.getTileBoundsForGridIndex(0, 0);
        var startPx = this.map.getViewPortPxFromLonLat(
            new HGIS.LonLat(tileBounds.left, tileBounds.top)
        );
        startPx.x = Math.round(startPx.x) - layerContainerDivLeft;
        startPx.y = Math.round(startPx.y) - layerContainerDivTop;

        var tileData = [], center = this.map.getCenter();

        var rowidx = 0;
        do {
            var row = this.grid[rowidx];
            if (!row) {
                row = [];
                this.grid.push(row);
            }
            
            var colidx = 0;
            do {
                tileBounds = this.getTileBoundsForGridIndex(rowidx, colidx);
                var px = startPx.clone();
                px.x = px.x + colidx * Math.round(tileSize.w);
                px.y = px.y + rowidx * Math.round(tileSize.h);
                var tile = row[colidx];
                if (!tile) {
                    tile = this.addTile(tileBounds, px);
                    this.addTileMonitoringHooks(tile);
                    row.push(tile);
                } else {
                    tile.moveTo(tileBounds, px, false);
                }
                var tileCenter = tileBounds.getCenterLonLat();
                tileData.push({
                    tile: tile,
                    distance: Math.pow(tileCenter.lon - center.lon, 2) +
                        Math.pow(tileCenter.lat - center.lat, 2)
                });
     
                colidx += 1;
            } while ((tileBounds.right <= bounds.right + tilelon * this.buffer)
                     || colidx < minCols);
             
            rowidx += 1;
        } while((tileBounds.bottom >= bounds.bottom - tilelat * this.buffer)
                || rowidx < minRows);
        
        //shave off exceess rows and colums
        this.removeExcessTiles(rowidx, colidx);

        var resolution = this.getServerResolution();
        // store the resolution of the grid
        this.gridResolution = resolution;

        //now actually draw the tiles
        tileData.sort(function(a, b) {
            return a.distance - b.distance; 
        });
        for (var i=0, ii=tileData.length; i<ii; ++i) {
            tileData[i].tile.draw();
        }
    },

    /**
     * Method: getMaxExtent
     * Get this layer's maximum extent. (Implemented as a getter for
     *     potential specific implementations in sub-classes.)
     *
     * Returns:
     * {<HGIS.Bounds>}
     */
    getMaxExtent: function() {
        return this.maxExtent;
    },
    
    /**
     * APIMethod: addTile
     * Create a tile, initialize it, and add it to the layer div. 
     *
     * Parameters
     * bounds - {<HGIS.Bounds>}
     * position - {<HGIS.Pixel>}
     *
     * Returns:
     * {<HGIS.Tile>} The added HGIS.Tile
     */
    addTile: function(bounds, position) {
        var tile = new this.tileClass(
            this, position, bounds, null, this.tileSize, this.tileOptions
        );
        this.events.triggerEvent("addtile", {tile: tile});
        return tile;
    },
    
    /** 
     * Method: addTileMonitoringHooks
     * This function takes a tile as input and adds the appropriate hooks to 
     *     the tile so that the layer can keep track of the loading tiles.
     * 
     * Parameters: 
     * tile - {<HGIS.Tile>}
     */
    addTileMonitoringHooks: function(tile) {
        
        var replacingCls = 'olTileReplacing';

        tile.onLoadStart = function() {
            //if that was first tile then trigger a 'loadstart' on the layer
            if (this.loading === false) {
                this.loading = true;
                this.events.triggerEvent("loadstart");
            }
            this.events.triggerEvent("tileloadstart", {tile: tile});
            this.numLoadingTiles++;
            if (!this.singleTile && this.backBuffer && this.gridResolution === this.backBufferResolution) {
                HGIS.Element.addClass(tile.getTile(), replacingCls);
            }
        };
      
        tile.onLoadEnd = function(evt) {
            this.numLoadingTiles--;
            var aborted = evt.type === 'unload';
            this.events.triggerEvent("tileloaded", {
                tile: tile,
                aborted: aborted
            });
            if (!this.singleTile && !aborted && this.backBuffer && this.gridResolution === this.backBufferResolution) {
                var tileDiv = tile.getTile();
                if (HGIS.Element.getStyle(tileDiv, 'display') === 'none') {
                    var bufferTile = document.getElementById(tile.id + '_bb');
                    if (bufferTile) {
                        bufferTile.parentNode.removeChild(bufferTile);
                    }
                }
                HGIS.Element.removeClass(tileDiv, replacingCls);
            }
            //if that was the last tile, then trigger a 'loadend' on the layer
            if (this.numLoadingTiles === 0) {
                if (this.backBuffer) {
                    if (this.backBuffer.childNodes.length === 0) {
                        // no tiles transitioning, remove immediately
                        this.removeBackBuffer();
                    } else {
                        // wait until transition has ended or delay has passed
                        this._transitionElement = aborted ?
                            this.div.lastChild : tile.imgDiv;
                        var transitionendEvents = this.transitionendEvents;
                        for (var i=transitionendEvents.length-1; i>=0; --i) {
                            HGIS.Event.observe(this._transitionElement,
                                transitionendEvents[i],
                                this._removeBackBuffer);
                        }
                        // the removal of the back buffer is delayed to prevent
                        // flash effects due to the animation of tile displaying
                        this.backBufferTimerId = window.setTimeout(
                            this._removeBackBuffer, this.removeBackBufferDelay
                        );
                    }
                }
                this.loading = false;
                this.events.triggerEvent("loadend");
            }
        };
        
        tile.onLoadError = function() {
            this.events.triggerEvent("tileerror", {tile: tile});
        };
        
        tile.events.on({
            "loadstart": tile.onLoadStart,
            "loadend": tile.onLoadEnd,
            "unload": tile.onLoadEnd,
            "loaderror": tile.onLoadError,
            scope: this
        });
    },

    /** 
     * Method: removeTileMonitoringHooks
     * This function takes a tile as input and removes the tile hooks 
     *     that were added in addTileMonitoringHooks()
     * 
     * Parameters: 
     * tile - {<HGIS.Tile>}
     */
    removeTileMonitoringHooks: function(tile) {
        tile.unload();
        tile.events.un({
            "loadstart": tile.onLoadStart,
            "loadend": tile.onLoadEnd,
            "unload": tile.onLoadEnd,
            "loaderror": tile.onLoadError,
            scope: this
        });
    },
    
    /**
     * Method: moveGriddedTiles
     */
    moveGriddedTiles: function() {
        var buffer = this.buffer + 1;
        while(true) {
            var tlTile = this.grid[0][0];
            var tlViewPort = {
                x: tlTile.position.x +
                    this.map.layerContainerOriginPx.x,
                y: tlTile.position.y +
                    this.map.layerContainerOriginPx.y
            };
            var ratio = this.getServerResolution() / this.map.getResolution();
            var tileSize = {
                w: Math.round(this.tileSize.w * ratio),
                h: Math.round(this.tileSize.h * ratio)
            };
            if (tlViewPort.x > -tileSize.w * (buffer - 1)) {
                this.shiftColumn(true, tileSize);
            } else if (tlViewPort.x < -tileSize.w * buffer) {
                this.shiftColumn(false, tileSize);
            } else if (tlViewPort.y > -tileSize.h * (buffer - 1)) {
                this.shiftRow(true, tileSize);
            } else if (tlViewPort.y < -tileSize.h * buffer) {
                this.shiftRow(false, tileSize);
            } else {
                break;
            }
        }
    },

    /**
     * Method: shiftRow
     * Shifty grid work
     *
     * Parameters:
     * prepend - {Boolean} if true, prepend to beginning.
     *                          if false, then append to end
     * tileSize - {Object} rendered tile size; object with w and h properties
     */
    shiftRow: function(prepend, tileSize) {
        var grid = this.grid;
        var rowIndex = prepend ? 0 : (grid.length - 1);
        var sign = prepend ? -1 : 1;
        var rowSign = this.rowSign;
        var tileLayout = this.gridLayout;
        tileLayout.startrow += sign * rowSign;

        var modelRow = grid[rowIndex];
        var row = grid[prepend ? 'pop' : 'shift']();
        for (var i=0, len=row.length; i<len; i++) {
            var tile = row[i];
            var position = modelRow[i].position.clone();
            position.y += tileSize.h * sign;
            tile.moveTo(this.getTileBoundsForGridIndex(rowIndex, i), position);
        }
        grid[prepend ? 'unshift' : 'push'](row);
    },

    /**
     * Method: shiftColumn
     * Shift grid work in the other dimension
     *
     * Parameters:
     * prepend - {Boolean} if true, prepend to beginning.
     *                          if false, then append to end
     * tileSize - {Object} rendered tile size; object with w and h properties
     */
    shiftColumn: function(prepend, tileSize) {
        var grid = this.grid;
        var colIndex = prepend ? 0 : (grid[0].length - 1);
        var sign = prepend ? -1 : 1;
        var tileLayout = this.gridLayout;
        tileLayout.startcol += sign;

        for (var i=0, len=grid.length; i<len; i++) {
            var row = grid[i];
            var position = row[colIndex].position.clone();
            var tile = row[prepend ? 'pop' : 'shift']();            
            position.x += tileSize.w * sign;
            tile.moveTo(this.getTileBoundsForGridIndex(i, colIndex), position);
            row[prepend ? 'unshift' : 'push'](tile);
        }
    },

    /**
     * Method: removeExcessTiles
     * When the size of the map or the buffer changes, we may need to
     *     remove some excess rows and columns.
     * 
     * Parameters:
     * rows - {Integer} Maximum number of rows we want our grid to have.
     * columns - {Integer} Maximum number of columns we want our grid to have.
     */
    removeExcessTiles: function(rows, columns) {
        var i, l;
        
        // remove extra rows
        while (this.grid.length > rows) {
            var row = this.grid.pop();
            for (i=0, l=row.length; i<l; i++) {
                var tile = row[i];
                this.destroyTile(tile);
            }
        }
        
        // remove extra columns
        for (i=0, l=this.grid.length; i<l; i++) {
            while (this.grid[i].length > columns) {
                var row = this.grid[i];
                var tile = row.pop();
                this.destroyTile(tile);
            }
        }
    },

    /**
     * Method: onMapResize
     * For singleTile layers, this will set a new tile size according to the
     * dimensions of the map pane.
     */
    onMapResize: function() {
        if (this.singleTile) {
            this.clearGrid();
            this.setTileSize();
        }
    },
    
    /**
     * APIMethod: getTileBounds
     * Returns The tile bounds for a layer given a pixel location.
     *
     * Parameters:
     * viewPortPx - {<HGIS.Pixel>} The location in the viewport.
     *
     * Returns:
     * {<HGIS.Bounds>} Bounds of the tile at the given pixel location.
     */
    getTileBounds: function(viewPortPx) {
        var maxExtent = this.maxExtent;
        var resolution = this.getResolution();
        var tileMapWidth = resolution * this.tileSize.w;
        var tileMapHeight = resolution * this.tileSize.h;
        var mapPoint = this.getLonLatFromViewPortPx(viewPortPx);
        var tileLeft = maxExtent.left + (tileMapWidth *
                                         Math.floor((mapPoint.lon -
                                                     maxExtent.left) /
                                                    tileMapWidth));
        var tileBottom = maxExtent.bottom + (tileMapHeight *
                                             Math.floor((mapPoint.lat -
                                                         maxExtent.bottom) /
                                                        tileMapHeight));
        return new HGIS.Bounds(tileLeft, tileBottom,
                                     tileLeft + tileMapWidth,
                                     tileBottom + tileMapHeight);
    },

    CLASS_NAME: "HGIS.Layer.Grid"
});
/* ======================================================================
    HGIS/Format/ArcXML.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Geometry/Polygon.js
 * @requires HGIS/Geometry/Point.js
 * @requires HGIS/Geometry/MultiPolygon.js
 * @requires HGIS/Geometry/LinearRing.js
 */

/**
 * Class: HGIS.Format.ArcXML
 * Read/Write ArcXML. Create a new instance with the <HGIS.Format.ArcXML>
 *     constructor.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.ArcXML = HGIS.Class(HGIS.Format.XML, {

    /**
     * Property: fontStyleKeys
     * {Array} List of keys used in font styling.
     */
    fontStyleKeys: [
        'antialiasing', 'blockout', 'font', 'fontcolor','fontsize', 'fontstyle',
        'glowing', 'interval', 'outline', 'printmode', 'shadow', 'transparency'
    ],

    /**
     * Property: request
     * A get_image request destined for an ArcIMS server.
     */
    request: null,
    
    /**
     * Property: response
     * A parsed response from an ArcIMS server.
     */
    response: null,

    /**
     * Constructor: HGIS.Format.ArcXML
     * Create a new parser/writer for ArcXML.  Create an instance of this class
     *    to begin authoring a request to an ArcIMS service.  This is used
     *    primarily by the ArcIMS layer, but could be used to do other wild
     *    stuff, like geocoding.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        this.request = new HGIS.Format.ArcXML.Request();
        this.response = new HGIS.Format.ArcXML.Response();

        if (options) {
            if (options.requesttype == "feature") {
                this.request.get_image = null;
            
                var qry = this.request.get_feature.query;
                this.addCoordSys(qry.featurecoordsys, options.featureCoordSys);
                this.addCoordSys(qry.filtercoordsys, options.filterCoordSys);
            
                if (options.polygon) {
                    qry.isspatial = true;
                    qry.spatialfilter.polygon = options.polygon;
                } else if (options.envelope) {
                    qry.isspatial = true;
                    qry.spatialfilter.envelope = {minx:0, miny:0, maxx:0, maxy:0};
                    this.parseEnvelope(qry.spatialfilter.envelope, options.envelope);
                }
            } else if (options.requesttype == "image") {
                this.request.get_feature = null;
            
                var props = this.request.get_image.properties;
                this.parseEnvelope(props.envelope, options.envelope);
            
                this.addLayers(props.layerlist, options.layers);
                this.addImageSize(props.imagesize, options.tileSize);
                this.addCoordSys(props.featurecoordsys, options.featureCoordSys);
                this.addCoordSys(props.filtercoordsys, options.filterCoordSys);
            } else {
                // if an arcxml object is being created with no request type, it is
                // probably going to consume a response, so do not throw an error if
                // the requesttype is not defined
                this.request = null;
            }
        }
        
        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Method: parseEnvelope
     * Parse an array of coordinates into an ArcXML envelope structure.
     *
     * Parameters:
     * env - {Object} An envelope object that will contain the parsed coordinates.
     * arr - {Array(double)} An array of coordinates in the order: [ minx, miny, maxx, maxy ]
     */
    parseEnvelope: function(env, arr) {
        if (arr && arr.length == 4) {          
            env.minx = arr[0];
            env.miny = arr[1];
            env.maxx = arr[2];
            env.maxy = arr[3];
        }
    },
    
    /** 
     * Method: addLayers
     * Add a collection of layers to another collection of layers. Each layer in the list is tuple of
     * { id, visible }.  These layer collections represent the 
     * /ARCXML/REQUEST/get_image/PROPERTIES/LAYERLIST/LAYERDEF items in ArcXML
     *
     * TODO: Add support for dynamic layer rendering.
     *
     * Parameters:
     * ll - {Array({id,visible})} A list of layer definitions.
     * lyrs - {Array({id,visible})} A list of layer definitions.
     */
    addLayers: function(ll, lyrs) {
        for(var lind = 0, len=lyrs.length; lind < len; lind++) {
            ll.push(lyrs[lind]);
        }
    },
    
    /**
     * Method: addImageSize
     * Set the size of the requested image.
     *
     * Parameters:
     * imsize - {Object} An ArcXML imagesize object.
     * olsize - {<HGIS.Size>} The image size to set.
     */
    addImageSize: function(imsize, olsize) {
        if (olsize !== null) {
            imsize.width = olsize.w;
            imsize.height = olsize.h;
            imsize.printwidth = olsize.w;
            imsize.printheight = olsize.h;
        }
    },

    /**
     * Method: addCoordSys
     * Add the coordinate system information to an object. The object may be 
     *
     * Parameters:
     * featOrFilt - {Object} A featurecoordsys or filtercoordsys ArcXML structure.
     * fsys - {String} or {<HGIS.Projection>} or {filtercoordsys} or 
     * {featurecoordsys} A projection representation. If it's a {String}, 
     * the value is assumed to be the SRID.  If it's a {HGIS.Projection} 
     * AND Proj4js is available, the projection number and name are extracted 
     * from there.  If it's a filter or feature ArcXML structure, it is copied.
     */
    addCoordSys: function(featOrFilt, fsys) {
        if (typeof fsys == "string") {
            featOrFilt.id = parseInt(fsys);
            featOrFilt.string = fsys;
        }
        // is this a proj4js instance?
        else if (typeof fsys == "object" && fsys.proj !== null){
            featOrFilt.id = fsys.proj.srsProjNumber;
            featOrFilt.string = fsys.proj.srsCode;
        } else {
            featOrFilt = fsys;
        }
    },

    /**
     * APIMethod: iserror
     * Check to see if the response from the server was an error.
     *
     * Parameters:
     * data - {String} or {DOMElement} data to read/parse. If nothing is supplied,
     * the current response is examined.
     *
     * Returns:
     * {Boolean} true if the response was an error.
     */
    iserror: function(data) {
        var ret = null; 
        
        if (!data) {
            ret = (this.response.error !== '');
        } else {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
            var errorNodes = data.documentElement.getElementsByTagName("ERROR");
            ret = (errorNodes !== null && errorNodes.length > 0);
        }

        return ret;
    },

    /**
     * APIMethod: read
     * Read data from a string, and return an response. 
     * 
     * Parameters:
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {<HGIS.Format.ArcXML.Response>} An ArcXML response. Note that this response
     *     data may change in the future. 
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        
        var arcNode = null;
        if (data && data.documentElement) {
            if(data.documentElement.nodeName == "ARCXML") {
                arcNode = data.documentElement;
            } else {
                arcNode = data.documentElement.getElementsByTagName("ARCXML")[0];
            }
        }
          
        // in Safari, arcNode will be there but will have a child named 
        // parsererror
        if (!arcNode || arcNode.firstChild.nodeName === 'parsererror') {
            var error, source;
            try {
                error = data.firstChild.nodeValue;
                source = data.firstChild.childNodes[1].firstChild.nodeValue;
            } catch (err) {
                // pass
            }
            throw {
                message: "Error parsing the ArcXML request", 
                error: error,
                source: source
            };
        }
        
        var response = this.parseResponse(arcNode);
        return response;
    },
    
    /**
     * APIMethod: write
     * Generate an ArcXml document string for sending to an ArcIMS server. 
     * 
     * Returns:
     * {String} A string representing the ArcXML document request.
     */
    write: function(request) {       
        if (!request) {
            request = this.request;
        }    
        var root = this.createElementNS("", "ARCXML");
        root.setAttribute("version","1.1");

        var reqElem = this.createElementNS("", "REQUEST");
        
        if (request.get_image != null) {
            var getElem = this.createElementNS("", "GET_IMAGE");
            reqElem.appendChild(getElem);

            var propElem = this.createElementNS("", "PROPERTIES");
            getElem.appendChild(propElem);

            var props = request.get_image.properties;
            if (props.featurecoordsys != null) {
                var feat = this.createElementNS("", "FEATURECOORDSYS");
                propElem.appendChild(feat);
                
                if (props.featurecoordsys.id === 0) {
                    feat.setAttribute("string", props.featurecoordsys['string']);
                }
                else {
                    feat.setAttribute("id", props.featurecoordsys.id);
                }
            }
          
            if (props.filtercoordsys != null) {
                var filt = this.createElementNS("", "FILTERCOORDSYS");
                propElem.appendChild(filt);

                if (props.filtercoordsys.id === 0) {
                    filt.setAttribute("string", props.filtercoordsys.string);
                }
                else {
                    filt.setAttribute("id", props.filtercoordsys.id);
                }
            }
          
            if (props.envelope != null) {
                var env = this.createElementNS("", "ENVELOPE");
                propElem.appendChild(env);

                env.setAttribute("minx", props.envelope.minx);
                env.setAttribute("miny", props.envelope.miny);
                env.setAttribute("maxx", props.envelope.maxx);
                env.setAttribute("maxy", props.envelope.maxy);
            }        
          
            var imagesz = this.createElementNS("", "IMAGESIZE");
            propElem.appendChild(imagesz);
          
            imagesz.setAttribute("height", props.imagesize.height);
            imagesz.setAttribute("width", props.imagesize.width);
          
            if (props.imagesize.height != props.imagesize.printheight ||
                 props.imagesize.width != props.imagesize.printwidth) {
                imagesz.setAttribute("printheight", props.imagesize.printheight);
                imagesz.setArrtibute("printwidth", props.imagesize.printwidth);
            }
          
            if (props.background != null) {
                var backgrnd = this.createElementNS("", "BACKGROUND");
                propElem.appendChild(backgrnd);
            
                backgrnd.setAttribute("color", 
                    props.background.color.r + "," + 
                    props.background.color.g + "," + 
                    props.background.color.b);
              
                if (props.background.transcolor !== null) {
                    backgrnd.setAttribute("transcolor", 
                        props.background.transcolor.r + "," + 
                        props.background.transcolor.g + "," + 
                        props.background.transcolor.b);
                }
            }
          
            if (props.layerlist != null && props.layerlist.length > 0) {
                var layerlst = this.createElementNS("", "LAYERLIST");
                propElem.appendChild(layerlst);
            
                for (var ld = 0; ld < props.layerlist.length; ld++) {
                    var ldef = this.createElementNS("", "LAYERDEF");
                    layerlst.appendChild(ldef);
              
                    ldef.setAttribute("id", props.layerlist[ld].id);
                    ldef.setAttribute("visible", props.layerlist[ld].visible);
              
                    if (typeof props.layerlist[ld].query == "object") {
                        var query = props.layerlist[ld].query;

                        if (query.where.length < 0) {
                            continue;
                        }
                  
                        var queryElem = null;
                        if (typeof query.spatialfilter == "boolean" && query.spatialfilter) {
                            // handle spatial filter madness
                            queryElem = this.createElementNS("", "SPATIALQUERY");
                        }
                        else {
                            queryElem = this.createElementNS("", "QUERY");
                        }
                
                        queryElem.setAttribute("where", query.where);
                
                        if (typeof query.accuracy == "number" && query.accuracy > 0) {
                            queryElem.setAttribute("accuracy", query.accuracy);
                        }
                        if (typeof query.featurelimit == "number" && query.featurelimit < 2000) {
                            queryElem.setAttribute("featurelimit", query.featurelimit);
                        }
                        if (typeof query.subfields == "string" && query.subfields != "#ALL#") {
                            queryElem.setAttribute("subfields", query.subfields);
                        }
                        if (typeof query.joinexpression == "string" && query.joinexpression.length > 0) {
                            queryElem.setAttribute("joinexpression", query.joinexpression);
                        }
                        if (typeof query.jointables == "string" && query.jointables.length > 0) {
                            queryElem.setAttribute("jointables", query.jointables);
                        }

                        ldef.appendChild(queryElem);
                    }
              
                    if (typeof props.layerlist[ld].renderer == "object") {
                        this.addRenderer(ldef, props.layerlist[ld].renderer);                  
                    }
                }
            }
        } else if (request.get_feature != null) {
            var getElem = this.createElementNS("", "GET_FEATURES");
            getElem.setAttribute("outputmode", "newxml");
            getElem.setAttribute("checkesc", "true");
          
            if (request.get_feature.geometry) {
                getElem.setAttribute("geometry", request.get_feature.geometry);
            }
            else {
                getElem.setAttribute("geometry", "false");
            }
          
            if (request.get_feature.compact) {
                getElem.setAttribute("compact", request.get_feature.compact);
            }
          
            if (request.get_feature.featurelimit == "number") {
                getElem.setAttribute("featurelimit", request.get_feature.featurelimit);
            }
          
            getElem.setAttribute("globalenvelope", "true");
            reqElem.appendChild(getElem);
          
            if (request.get_feature.layer != null && request.get_feature.layer.length > 0) {
                var lyrElem = this.createElementNS("", "LAYER");
                lyrElem.setAttribute("id", request.get_feature.layer);
                getElem.appendChild(lyrElem);
            }
          
            var fquery = request.get_feature.query;
            if (fquery != null) {
                var qElem = null;
                if (fquery.isspatial) {
                    qElem = this.createElementNS("", "SPATIALQUERY");
                } else {
                    qElem = this.createElementNS("", "QUERY");
                }
                getElem.appendChild(qElem);
                
                if (typeof fquery.accuracy == "number") {
                    qElem.setAttribute("accuracy", fquery.accuracy);
                }
                //qElem.setAttribute("featurelimit", "5");
            
                if (fquery.featurecoordsys != null) {
                    var fcsElem1 = this.createElementNS("", "FEATURECOORDSYS");
              
                    if (fquery.featurecoordsys.id == 0) {
                        fcsElem1.setAttribute("string", fquery.featurecoordsys.string);
                    } else {
                        fcsElem1.setAttribute("id", fquery.featurecoordsys.id);
                    }
                    qElem.appendChild(fcsElem1);
                }
            
                if (fquery.filtercoordsys != null) {
                    var fcsElem2 = this.createElementNS("", "FILTERCOORDSYS");
              
                    if (fquery.filtercoordsys.id === 0) {
                        fcsElem2.setAttribute("string", fquery.filtercoordsys.string);
                    } else {
                        fcsElem2.setAttribute("id", fquery.filtercoordsys.id);
                    }
                    qElem.appendChild(fcsElem2);
                }
            
                if (fquery.buffer > 0) {   
                    var bufElem = this.createElementNS("", "BUFFER");
                    bufElem.setAttribute("distance", fquery.buffer);
                    qElem.appendChild(bufElem);
                }
            
                if (fquery.isspatial) {
                    var spfElem = this.createElementNS("", "SPATIALFILTER");
                    spfElem.setAttribute("relation", fquery.spatialfilter.relation);
                    qElem.appendChild(spfElem);
              
                    if (fquery.spatialfilter.envelope) {
                        var envElem = this.createElementNS("", "ENVELOPE"); 
                        envElem.setAttribute("minx", fquery.spatialfilter.envelope.minx);
                        envElem.setAttribute("miny", fquery.spatialfilter.envelope.miny);
                        envElem.setAttribute("maxx", fquery.spatialfilter.envelope.maxx);
                        envElem.setAttribute("maxy", fquery.spatialfilter.envelope.maxy);
                        spfElem.appendChild(envElem);
                    } else if(typeof fquery.spatialfilter.polygon == "object") {
                        spfElem.appendChild(this.writePolygonGeometry(fquery.spatialfilter.polygon));                
                    }
                }
            
                if (fquery.where != null && fquery.where.length > 0) {
                    qElem.setAttribute("where", fquery.where);
                }
            }
        }

        root.appendChild(reqElem);

        return HGIS.Format.XML.prototype.write.apply(this, [root]);
    },
    
    
    addGroupRenderer: function(ldef, toprenderer) {
        var topRelem = this.createElementNS("", "GROUPRENDERER");
        ldef.appendChild(topRelem);
      
        for (var rind = 0; rind < toprenderer.length; rind++) {
            var renderer = toprenderer[rind];
            this.addRenderer(topRelem, renderer);
        }
    },
    
    
    addRenderer: function(topRelem, renderer) {
        if (HGIS.Util.isArray(renderer)) {
            this.addGroupRenderer(topRelem, renderer);
        } else {
            var renderElem = this.createElementNS("", renderer.type.toUpperCase() + "RENDERER");
            topRelem.appendChild(renderElem);
          
            if (renderElem.tagName == "VALUEMAPRENDERER") {
                this.addValueMapRenderer(renderElem, renderer);
            } else if (renderElem.tagName == "VALUEMAPLABELRENDERER") {
                this.addValueMapLabelRenderer(renderElem, renderer);
            } else if (renderElem.tagName == "SIMPLELABELRENDERER") {
                this.addSimpleLabelRenderer(renderElem, renderer);
            } else if (renderElem.tagName == "SCALEDEPENDENTRENDERER") {
                this.addScaleDependentRenderer(renderElem, renderer);
            }
        }             
    },
    
    
    addScaleDependentRenderer: function(renderElem, renderer) {
        if (typeof renderer.lower == "string" || typeof renderer.lower == "number") {
            renderElem.setAttribute("lower", renderer.lower);
        }
        if (typeof renderer.upper == "string" || typeof renderer.upper == "number") {
            renderElem.setAttribute("upper", renderer.upper);
        }
        
        this.addRenderer(renderElem, renderer.renderer);
    },
    
    
    addValueMapLabelRenderer: function(renderElem, renderer) {
        renderElem.setAttribute("lookupfield", renderer.lookupfield);
        renderElem.setAttribute("labelfield", renderer.labelfield);
      
        if (typeof renderer.exacts == "object") {
            for (var ext=0, extlen=renderer.exacts.length; ext<extlen; ext++) {
                var exact = renderer.exacts[ext];
          
                var eelem = this.createElementNS("", "EXACT");
          
                if (typeof exact.value == "string") {
                    eelem.setAttribute("value", exact.value);
                }
                if (typeof exact.label == "string") {
                    eelem.setAttribute("label", exact.label);
                }
                if (typeof exact.method == "string") {
                    eelem.setAttribute("method", exact.method);
                }

                renderElem.appendChild(eelem);
            
                if (typeof exact.symbol == "object") {
                    var selem = null;
                
                    if (exact.symbol.type == "text") {
                        selem = this.createElementNS("", "TEXTSYMBOL");
                    }
                
                    if (selem != null) {
                        var keys = this.fontStyleKeys;
                        for (var i = 0, len = keys.length; i < len; i++) {
                            var key = keys[i];
                            if (exact.symbol[key]) {
                                selem.setAttribute(key, exact.symbol[key]);
                            }
                        }    
                        eelem.appendChild(selem);
                    }
                }
            } // for each exact
        }      
    },
    
    addValueMapRenderer: function(renderElem, renderer) {
        renderElem.setAttribute("lookupfield", renderer.lookupfield);
        
        if (typeof renderer.ranges == "object") {
            for(var rng=0, rnglen=renderer.ranges.length; rng<rnglen; rng++) {
                var range = renderer.ranges[rng];
                
                var relem = this.createElementNS("", "RANGE");
                relem.setAttribute("lower", range.lower);
                relem.setAttribute("upper", range.upper);
                
                renderElem.appendChild(relem);
                
                if (typeof range.symbol == "object") {
                    var selem = null;
              
                    if (range.symbol.type == "simplepolygon") {
                        selem = this.createElementNS("", "SIMPLEPOLYGONSYMBOL");
                    }
              
                    if (selem != null) {
                        if (typeof range.symbol.boundarycolor == "string") {
                            selem.setAttribute("boundarycolor", range.symbol.boundarycolor);
                        }
                        if (typeof range.symbol.fillcolor == "string") {
                            selem.setAttribute("fillcolor", range.symbol.fillcolor);
                        }
                        if (typeof range.symbol.filltransparency == "number") {
                            selem.setAttribute("filltransparency", range.symbol.filltransparency);
                        }
                        relem.appendChild(selem);
                    }   
                }
            } // for each range
        } else if (typeof renderer.exacts == "object") {
            for (var ext=0, extlen=renderer.exacts.length; ext<extlen; ext++) {
                var exact = renderer.exacts[ext];
          
                var eelem = this.createElementNS("", "EXACT");
                if (typeof exact.value == "string") {
                    eelem.setAttribute("value", exact.value);
                }
                if (typeof exact.label == "string") {
                    eelem.setAttribute("label", exact.label);
                }
                if (typeof exact.method == "string") {
                    eelem.setAttribute("method", exact.method);
                }
            
                renderElem.appendChild(eelem);
            
                if (typeof exact.symbol == "object") {
                    var selem = null;
            
                    if (exact.symbol.type == "simplemarker") {
                        selem = this.createElementNS("", "SIMPLEMARKERSYMBOL");
                    }
            
                    if (selem != null) {
                        if (typeof exact.symbol.antialiasing == "string") {
                            selem.setAttribute("antialiasing", exact.symbol.antialiasing);
                        }
                        if (typeof exact.symbol.color == "string") {
                            selem.setAttribute("color", exact.symbol.color);
                        }
                        if (typeof exact.symbol.outline == "string") {
                            selem.setAttribute("outline", exact.symbol.outline);
                        }
                        if (typeof exact.symbol.overlap == "string") {
                            selem.setAttribute("overlap", exact.symbol.overlap);
                        }
                        if (typeof exact.symbol.shadow == "string") {
                            selem.setAttribute("shadow", exact.symbol.shadow);
                        }
                        if (typeof exact.symbol.transparency == "number") {
                            selem.setAttribute("transparency", exact.symbol.transparency);
                        }
                        //if (typeof exact.symbol.type == "string")
                        //    selem.setAttribute("type", exact.symbol.type);
                        if (typeof exact.symbol.usecentroid == "string") {
                            selem.setAttribute("usecentroid", exact.symbol.usecentroid);
                        }
                        if (typeof exact.symbol.width == "number") {
                            selem.setAttribute("width", exact.symbol.width);
                        }
                
                        eelem.appendChild(selem);
                    }
                }
            } // for each exact
        }
    },
    
    
    addSimpleLabelRenderer: function(renderElem, renderer) {
        renderElem.setAttribute("field", renderer.field);
        var keys = ['featureweight', 'howmanylabels', 'labelbufferratio', 
                    'labelpriorities', 'labelweight', 'linelabelposition',
                    'rotationalangles'];
        for (var i=0, len=keys.length; i<len; i++) {
            var key = keys[i];
            if (renderer[key]) {
                renderElem.setAttribute(key, renderer[key]);
            }
        }     
           
        if (renderer.symbol.type == "text") {
            var symbol = renderer.symbol;
            var selem = this.createElementNS("", "TEXTSYMBOL");
            renderElem.appendChild(selem);
          
            var keys = this.fontStyleKeys;
            for (var i=0, len=keys.length; i<len; i++) {
                var key = keys[i];
                if (symbol[key]) {
                    selem.setAttribute(key, renderer[key]);
                }
            }    
        }    
    },
    
    writePolygonGeometry: function(polygon) {
        if (!(polygon instanceof HGIS.Geometry.Polygon)) {
            throw { 
                message:'Cannot write polygon geometry to ArcXML with an ' +
                    polygon.CLASS_NAME + ' object.',
                geometry: polygon
            };
        }
        
        var polyElem = this.createElementNS("", "POLYGON");
      
        for (var ln=0, lnlen=polygon.components.length; ln<lnlen; ln++) {
            var ring = polygon.components[ln];
            var ringElem = this.createElementNS("", "RING");
        
            for (var rn=0, rnlen=ring.components.length; rn<rnlen; rn++) {
                var point = ring.components[rn];
                var pointElem = this.createElementNS("", "POINT");
            
                pointElem.setAttribute("x", point.x);
                pointElem.setAttribute("y", point.y);
            
                ringElem.appendChild(pointElem);
            }
        
            polyElem.appendChild(ringElem);
        }
      
        return polyElem;
    },
    
    /**
     * Method: parseResponse
     * Take an ArcXML response, and parse in into this object's internal properties.
     *
     * Parameters:
     * data - {String} or {DOMElement} The ArcXML response, as either a string or the
     * top level DOMElement of the response.
     */
    parseResponse: function(data) {
        if(typeof data == "string") { 
            var newData = new HGIS.Format.XML();
            data = newData.read(data);
        }
        var response = new HGIS.Format.ArcXML.Response();
        
        var errorNode = data.getElementsByTagName("ERROR");
        
        if (errorNode != null && errorNode.length > 0) {
            response.error = this.getChildValue(errorNode, "Unknown error.");
        } else {
            var responseNode = data.getElementsByTagName("RESPONSE");
          
            if (responseNode == null || responseNode.length == 0) {
                response.error = "No RESPONSE tag found in ArcXML response.";
                return response;
            }
          
            var rtype = responseNode[0].firstChild.nodeName;
            if (rtype == "#text") {
                rtype = responseNode[0].firstChild.nextSibling.nodeName;
            }
          
            if (rtype == "IMAGE") {
                var envelopeNode = data.getElementsByTagName("ENVELOPE");
                var outputNode = data.getElementsByTagName("OUTPUT");
                
                if (envelopeNode == null || envelopeNode.length == 0) {
                    response.error = "No ENVELOPE tag found in ArcXML response.";
                } else if (outputNode == null || outputNode.length == 0) {
                    response.error = "No OUTPUT tag found in ArcXML response.";
                } else {
                    var envAttr = this.parseAttributes(envelopeNode[0]);            
                    var outputAttr = this.parseAttributes(outputNode[0]);
                  
                    if (typeof outputAttr.type == "string") {
                        response.image = { 
                            envelope: envAttr, 
                            output: { 
                                type: outputAttr.type, 
                                data: this.getChildValue(outputNode[0])
                            }
                        };
                    } else {
                        response.image = { envelope: envAttr, output: outputAttr };
                    }
                }
            } else if (rtype == "FEATURES") {
                var features = responseNode[0].getElementsByTagName("FEATURES");
            
                // get the feature count
                var featureCount = features[0].getElementsByTagName("FEATURECOUNT");
                response.features.featurecount = featureCount[0].getAttribute("count");
            
                if (response.features.featurecount > 0) {
                    // get the feature envelope
                    var envelope = features[0].getElementsByTagName("ENVELOPE");
                    response.features.envelope = this.parseAttributes(envelope[0], typeof(0));

                    // get the field values per feature
                    var featureList = features[0].getElementsByTagName("FEATURE");
                    for (var fn = 0; fn < featureList.length; fn++) {
                        var feature = new HGIS.Feature.Vector();
                        var fields = featureList[fn].getElementsByTagName("FIELD");

                        for (var fdn = 0; fdn < fields.length; fdn++) {
                            var fieldName = fields[fdn].getAttribute("name");
                            var fieldValue = fields[fdn].getAttribute("value");
                            feature.attributes[ fieldName ] = fieldValue;
                        }

                        var geom = featureList[fn].getElementsByTagName("POLYGON");

                        if (geom.length > 0) {
                            // if there is a polygon, create an HGIS polygon, and assign
                            // it to the .geometry property of the feature
                            var ring = geom[0].getElementsByTagName("RING");

                            var polys = [];
                            for (var rn = 0; rn < ring.length; rn++) {
                                var linearRings = [];
                                linearRings.push(this.parsePointGeometry(ring[rn]));

                                var holes = ring[rn].getElementsByTagName("HOLE");
                                for (var hn = 0; hn < holes.length; hn++) {
                                    linearRings.push(this.parsePointGeometry(holes[hn]));
                                }
                                holes = null;
                                polys.push(new HGIS.Geometry.Polygon(linearRings));
                                linearRings = null;
                            }
                            ring = null;
                          
                            if (polys.length == 1) {
                                feature.geometry = polys[0];
                            } else
                            {
                                feature.geometry = new HGIS.Geometry.MultiPolygon(polys);
                            }
                        }

                        response.features.feature.push(feature);
                    }
                }
            } else {
                response.error = "Unidentified response type.";
            }
        }
        return response;
    },
    
    
    /**
     * Method: parseAttributes
     *
     * Parameters:
     * node - {<DOMElement>} An element to parse attributes from.
     *
     * Returns:
     * {Object} An attributes object, with properties set to attribute values.
     */
    parseAttributes: function(node,type) {
        var attributes = {};
        for(var attr = 0; attr < node.attributes.length; attr++) {
            if (type == "number") {
                attributes[node.attributes[attr].nodeName] = parseFloat(node.attributes[attr].nodeValue);
            } else {
                attributes[node.attributes[attr].nodeName] = node.attributes[attr].nodeValue;
            }
        }
        return attributes;
    },
    
    
    /**
     * Method: parsePointGeometry
     *
     * Parameters:
     * node - {<DOMElement>} An element to parse <COORDS> or <POINT> arcxml data from.
     *
     * Returns:
     * {<HGIS.Geometry.LinearRing>} A linear ring represented by the node's points.
     */
    parsePointGeometry: function(node) {
        var ringPoints = [];
        var coords = node.getElementsByTagName("COORDS");

        if (coords.length > 0) {
            // if coords is present, it's the only coords item
            var coordArr = this.getChildValue(coords[0]);
            coordArr = coordArr.split(/;/);
            for (var cn = 0; cn < coordArr.length; cn++) {
                var coordItems = coordArr[cn].split(/ /);
                ringPoints.push(new HGIS.Geometry.Point(coordItems[0], coordItems[1]));
            }
            coords = null;
        } else {
            var point = node.getElementsByTagName("POINT");
            if (point.length > 0) {
                for (var pn = 0; pn < point.length; pn++) {
                    ringPoints.push(
                        new HGIS.Geometry.Point(
                            parseFloat(point[pn].getAttribute("x")),
                            parseFloat(point[pn].getAttribute("y"))
                        )
                    );
                }
            }
            point = null;
        }

        return new HGIS.Geometry.LinearRing(ringPoints);      
    },
    
    CLASS_NAME: "HGIS.Format.ArcXML" 
});

HGIS.Format.ArcXML.Request = HGIS.Class({
    initialize: function(params) {
        var defaults = {
            get_image: {
                properties: {
                    background: null,
                    /*{ 
                        color: { r:255, g:255, b:255 },
                        transcolor: null
                    },*/
                    draw: true,
                    envelope: {
                        minx: 0, 
                        miny: 0, 
                        maxx: 0, 
                        maxy: 0
                    },
                    featurecoordsys: { 
                        id:0, 
                        string:"",
                        datumtransformid:0,
                        datumtransformstring:""
                    },
                    filtercoordsys:{
                        id:0,
                        string:"",
                        datumtransformid:0,
                        datumtransformstring:""
                    },
                    imagesize:{
                        height:0,
                        width:0,
                        dpi:96,
                        printheight:0,
                        printwidth:0,
                        scalesymbols:false
                    },
                    layerlist:[],
                    /* no support for legends */
                    output:{
                        baseurl:"",
                        legendbaseurl:"",
                        legendname:"",
                        legendpath:"",
                        legendurl:"",
                        name:"",
                        path:"",
                        type:"jpg",
                        url:""
                    }
                }
            },

            get_feature: {
                layer: "",
                query: {
                    isspatial: false,
                    featurecoordsys: {
                        id:0,
                        string:"",
                        datumtransformid:0,
                        datumtransformstring:""
                    },
                    filtercoordsys: {
                        id:0,
                        string:"",
                        datumtransformid:0,
                        datumtransformstring:""
                    },
                    buffer:0,
                    where:"",
                    spatialfilter: {
                        relation: "envelope_intersection",
                        envelope: null
                    }
                }
            },
      
            environment: {
                separators: {
                    cs:" ",
                    ts:";"
                }
            },
      
            layer: [],
            workspaces: []
        };
      
        return HGIS.Util.extend(this, defaults);      
    },
  
    CLASS_NAME: "HGIS.Format.ArcXML.Request"
});

HGIS.Format.ArcXML.Response = HGIS.Class({  
    initialize: function(params) {
        var defaults = {
            image: {
                envelope:null,
                output:''
            },
      
            features: {
                featurecount: 0,
                envelope: null,
                feature: []
            },
      
            error:''
        };
  
        return HGIS.Util.extend(this, defaults);
    },
  
    CLASS_NAME: "HGIS.Format.ArcXML.Response"
});
/* ======================================================================
    HGIS/Request/XMLHttpRequest.js
   ====================================================================== */

// XMLHttpRequest.js Copyright (C) 2010 Sergey Ilinsky (http://www.ilinsky.com)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @requires HGIS/Request.js
 */

(function () {

    // Save reference to earlier defined object implementation (if any)
    var oXMLHttpRequest    = window.XMLHttpRequest;

    // Define on browser type
    var bGecko    = !!window.controllers,
        bIE        = window.document.all && !window.opera,
        bIE7    = bIE && window.navigator.userAgent.match(/MSIE 7.0/);

    // Enables "XMLHttpRequest()" call next to "new XMLHttpReques()"
    function fXMLHttpRequest() {
        this._object    = oXMLHttpRequest && !bIE7 ? new oXMLHttpRequest : new window.ActiveXObject("Microsoft.XMLHTTP");
        this._listeners    = [];
    };

    // Constructor
    function cXMLHttpRequest() {
        return new fXMLHttpRequest;
    };
    cXMLHttpRequest.prototype    = fXMLHttpRequest.prototype;

    // BUGFIX: Firefox with Firebug installed would break pages if not executed
    if (bGecko && oXMLHttpRequest.wrapped)
        cXMLHttpRequest.wrapped    = oXMLHttpRequest.wrapped;

    // Constants
    cXMLHttpRequest.UNSENT                = 0;
    cXMLHttpRequest.OPENED                = 1;
    cXMLHttpRequest.HEADERS_RECEIVED    = 2;
    cXMLHttpRequest.LOADING                = 3;
    cXMLHttpRequest.DONE                = 4;

    // Public Properties
    cXMLHttpRequest.prototype.readyState    = cXMLHttpRequest.UNSENT;
    cXMLHttpRequest.prototype.responseText    = '';
    cXMLHttpRequest.prototype.responseXML    = null;
    cXMLHttpRequest.prototype.status        = 0;
    cXMLHttpRequest.prototype.statusText    = '';

    // Priority proposal
    cXMLHttpRequest.prototype.priority        = "NORMAL";

    // Instance-level Events Handlers
    cXMLHttpRequest.prototype.onreadystatechange    = null;

    // Class-level Events Handlers
    cXMLHttpRequest.onreadystatechange    = null;
    cXMLHttpRequest.onopen                = null;
    cXMLHttpRequest.onsend                = null;
    cXMLHttpRequest.onabort                = null;

    // Public Methods
    cXMLHttpRequest.prototype.open    = function(sMethod, sUrl, bAsync, sUser, sPassword) {
        // Delete headers, required when object is reused
        delete this._headers;

        // When bAsync parameter value is omitted, use true as default
        if (arguments.length < 3)
            bAsync    = true;

        // Save async parameter for fixing Gecko bug with missing readystatechange in synchronous requests
        this._async        = bAsync;

        // Set the onreadystatechange handler
        var oRequest    = this,
            nState        = this.readyState,
            fOnUnload;

        // BUGFIX: IE - memory leak on page unload (inter-page leak)
        if (bIE && bAsync) {
            fOnUnload = function() {
                if (nState != cXMLHttpRequest.DONE) {
                    fCleanTransport(oRequest);
                    // Safe to abort here since onreadystatechange handler removed
                    oRequest.abort();
                }
            };
            window.attachEvent("onunload", fOnUnload);
        }

        // Add method sniffer
        if (cXMLHttpRequest.onopen)
            cXMLHttpRequest.onopen.apply(this, arguments);

        if (arguments.length > 4)
            this._object.open(sMethod, sUrl, bAsync, sUser, sPassword);
        else
        if (arguments.length > 3)
            this._object.open(sMethod, sUrl, bAsync, sUser);
        else
            this._object.open(sMethod, sUrl, bAsync);

        this.readyState    = cXMLHttpRequest.OPENED;
        fReadyStateChange(this);

        this._object.onreadystatechange    = function() {
            if (bGecko && !bAsync)
                return;

            // Synchronize state
            oRequest.readyState        = oRequest._object.readyState;

            //
            fSynchronizeValues(oRequest);

            // BUGFIX: Firefox fires unnecessary DONE when aborting
            if (oRequest._aborted) {
                // Reset readyState to UNSENT
                oRequest.readyState    = cXMLHttpRequest.UNSENT;

                // Return now
                return;
            }

            if (oRequest.readyState == cXMLHttpRequest.DONE) {
                // Free up queue
                delete oRequest._data;
/*                if (bAsync)
                    fQueue_remove(oRequest);*/
                //
                fCleanTransport(oRequest);
// Uncomment this block if you need a fix for IE cache
/*
                // BUGFIX: IE - cache issue
                if (!oRequest._object.getResponseHeader("Date")) {
                    // Save object to cache
                    oRequest._cached    = oRequest._object;

                    // Instantiate a new transport object
                    cXMLHttpRequest.call(oRequest);

                    // Re-send request
                    if (sUser) {
                         if (sPassword)
                            oRequest._object.open(sMethod, sUrl, bAsync, sUser, sPassword);
                        else
                            oRequest._object.open(sMethod, sUrl, bAsync, sUser);
                    }
                    else
                        oRequest._object.open(sMethod, sUrl, bAsync);
                    oRequest._object.setRequestHeader("If-Modified-Since", oRequest._cached.getResponseHeader("Last-Modified") || new window.Date(0));
                    // Copy headers set
                    if (oRequest._headers)
                        for (var sHeader in oRequest._headers)
                            if (typeof oRequest._headers[sHeader] == "string")    // Some frameworks prototype objects with functions
                                oRequest._object.setRequestHeader(sHeader, oRequest._headers[sHeader]);

                    oRequest._object.onreadystatechange    = function() {
                        // Synchronize state
                        oRequest.readyState        = oRequest._object.readyState;

                        if (oRequest._aborted) {
                            //
                            oRequest.readyState    = cXMLHttpRequest.UNSENT;

                            // Return
                            return;
                        }

                        if (oRequest.readyState == cXMLHttpRequest.DONE) {
                            // Clean Object
                            fCleanTransport(oRequest);

                            // get cached request
                            if (oRequest.status == 304)
                                oRequest._object    = oRequest._cached;

                            //
                            delete oRequest._cached;

                            //
                            fSynchronizeValues(oRequest);

                            //
                            fReadyStateChange(oRequest);

                            // BUGFIX: IE - memory leak in interrupted
                            if (bIE && bAsync)
                                window.detachEvent("onunload", fOnUnload);
                        }
                    };
                    oRequest._object.send(null);

                    // Return now - wait until re-sent request is finished
                    return;
                };
*/
                // BUGFIX: IE - memory leak in interrupted
                if (bIE && bAsync)
                    window.detachEvent("onunload", fOnUnload);
            }

            // BUGFIX: Some browsers (Internet Explorer, Gecko) fire OPEN readystate twice
            if (nState != oRequest.readyState)
                fReadyStateChange(oRequest);

            nState    = oRequest.readyState;
        }
    };
    function fXMLHttpRequest_send(oRequest) {
        oRequest._object.send(oRequest._data);

        // BUGFIX: Gecko - missing readystatechange calls in synchronous requests
        if (bGecko && !oRequest._async) {
            oRequest.readyState    = cXMLHttpRequest.OPENED;

            // Synchronize state
            fSynchronizeValues(oRequest);

            // Simulate missing states
            while (oRequest.readyState < cXMLHttpRequest.DONE) {
                oRequest.readyState++;
                fReadyStateChange(oRequest);
                // Check if we are aborted
                if (oRequest._aborted)
                    return;
            }
        }
    };
    cXMLHttpRequest.prototype.send    = function(vData) {
        // Add method sniffer
        if (cXMLHttpRequest.onsend)
            cXMLHttpRequest.onsend.apply(this, arguments);

        if (!arguments.length)
            vData    = null;

        // BUGFIX: Safari - fails sending documents created/modified dynamically, so an explicit serialization required
        // BUGFIX: IE - rewrites any custom mime-type to "text/xml" in case an XMLNode is sent
        // BUGFIX: Gecko - fails sending Element (this is up to the implementation either to standard)
        if (vData && vData.nodeType) {
            vData    = window.XMLSerializer ? new window.XMLSerializer().serializeToString(vData) : vData.xml;
            if (!this._headers["Content-Type"])
                this._object.setRequestHeader("Content-Type", "application/xml");
        }

        this._data    = vData;
/*
        // Add to queue
        if (this._async)
            fQueue_add(this);
        else*/
            fXMLHttpRequest_send(this);
    };
    cXMLHttpRequest.prototype.abort    = function() {
        // Add method sniffer
        if (cXMLHttpRequest.onabort)
            cXMLHttpRequest.onabort.apply(this, arguments);

        // BUGFIX: Gecko - unnecessary DONE when aborting
        if (this.readyState > cXMLHttpRequest.UNSENT)
            this._aborted    = true;

        this._object.abort();

        // BUGFIX: IE - memory leak
        fCleanTransport(this);

        this.readyState    = cXMLHttpRequest.UNSENT;

        delete this._data;
/*        if (this._async)
            fQueue_remove(this);*/
    };
    cXMLHttpRequest.prototype.getAllResponseHeaders    = function() {
        return this._object.getAllResponseHeaders();
    };
    cXMLHttpRequest.prototype.getResponseHeader    = function(sName) {
        return this._object.getResponseHeader(sName);
    };
    cXMLHttpRequest.prototype.setRequestHeader    = function(sName, sValue) {
        // BUGFIX: IE - cache issue
        if (!this._headers)
            this._headers    = {};
        this._headers[sName]    = sValue;

        return this._object.setRequestHeader(sName, sValue);
    };

    // EventTarget interface implementation
    cXMLHttpRequest.prototype.addEventListener    = function(sName, fHandler, bUseCapture) {
        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
            if (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture)
                return;
        // Add listener
        this._listeners.push([sName, fHandler, bUseCapture]);
    };

    cXMLHttpRequest.prototype.removeEventListener    = function(sName, fHandler, bUseCapture) {
        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
            if (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture)
                break;
        // Remove listener
        if (oListener)
            this._listeners.splice(nIndex, 1);
    };

    cXMLHttpRequest.prototype.dispatchEvent    = function(oEvent) {
        var oEventPseudo    = {
            'type':            oEvent.type,
            'target':        this,
            'currentTarget':this,
            'eventPhase':    2,
            'bubbles':        oEvent.bubbles,
            'cancelable':    oEvent.cancelable,
            'timeStamp':    oEvent.timeStamp,
            'stopPropagation':    function() {},    // There is no flow
            'preventDefault':    function() {},    // There is no default action
            'initEvent':        function() {}    // Original event object should be initialized
        };

        // Execute onreadystatechange
        if (oEventPseudo.type == "readystatechange" && this.onreadystatechange)
            (this.onreadystatechange.handleEvent || this.onreadystatechange).apply(this, [oEventPseudo]);

        // Execute listeners
        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
            if (oListener[0] == oEventPseudo.type && !oListener[2])
                (oListener[1].handleEvent || oListener[1]).apply(this, [oEventPseudo]);
    };

    //
    cXMLHttpRequest.prototype.toString    = function() {
        return '[' + "object" + ' ' + "XMLHttpRequest" + ']';
    };

    cXMLHttpRequest.toString    = function() {
        return '[' + "XMLHttpRequest" + ']';
    };

    // Helper function
    function fReadyStateChange(oRequest) {
        // Sniffing code
        if (cXMLHttpRequest.onreadystatechange)
            cXMLHttpRequest.onreadystatechange.apply(oRequest);

        // Fake event
        oRequest.dispatchEvent({
            'type':            "readystatechange",
            'bubbles':        false,
            'cancelable':    false,
            'timeStamp':    new Date + 0
        });
    };

    function fGetDocument(oRequest) {
        var oDocument    = oRequest.responseXML,
            sResponse    = oRequest.responseText;
        // Try parsing responseText
        if (bIE && sResponse && oDocument && !oDocument.documentElement && oRequest.getResponseHeader("Content-Type").match(/[^\/]+\/[^\+]+\+xml/)) {
            oDocument    = new window.ActiveXObject("Microsoft.XMLDOM");
            oDocument.async                = false;
            oDocument.validateOnParse    = false;
            oDocument.loadXML(sResponse);
        }
        // Check if there is no error in document
        if (oDocument)
            if ((bIE && oDocument.parseError != 0) || !oDocument.documentElement || (oDocument.documentElement && oDocument.documentElement.tagName == "parsererror"))
                return null;
        return oDocument;
    };

    function fSynchronizeValues(oRequest) {
        try {    oRequest.responseText    = oRequest._object.responseText;    } catch (e) {}
        try {    oRequest.responseXML    = fGetDocument(oRequest._object);    } catch (e) {}
        try {    oRequest.status            = oRequest._object.status;            } catch (e) {}
        try {    oRequest.statusText        = oRequest._object.statusText;        } catch (e) {}
    };

    function fCleanTransport(oRequest) {
        // BUGFIX: IE - memory leak (on-page leak)
        oRequest._object.onreadystatechange    = new window.Function;
    };
/*
    // Queue manager
    var oQueuePending    = {"CRITICAL":[],"HIGH":[],"NORMAL":[],"LOW":[],"LOWEST":[]},
        aQueueRunning    = [];
    function fQueue_add(oRequest) {
        oQueuePending[oRequest.priority in oQueuePending ? oRequest.priority : "NORMAL"].push(oRequest);
        //
        setTimeout(fQueue_process);
    };

    function fQueue_remove(oRequest) {
        for (var nIndex = 0, bFound    = false; nIndex < aQueueRunning.length; nIndex++)
            if (bFound)
                aQueueRunning[nIndex - 1]    = aQueueRunning[nIndex];
            else
            if (aQueueRunning[nIndex] == oRequest)
                bFound    = true;
        if (bFound)
            aQueueRunning.length--;
        //
        setTimeout(fQueue_process);
    };

    function fQueue_process() {
        if (aQueueRunning.length < 6) {
            for (var sPriority in oQueuePending) {
                if (oQueuePending[sPriority].length) {
                    var oRequest    = oQueuePending[sPriority][0];
                    oQueuePending[sPriority]    = oQueuePending[sPriority].slice(1);
                    //
                    aQueueRunning.push(oRequest);
                    // Send request
                    fXMLHttpRequest_send(oRequest);
                    break;
                }
            }
        }
    };
*/
    // Internet Explorer 5.0 (missing apply)
    if (!window.Function.prototype.apply) {
        window.Function.prototype.apply    = function(oRequest, oArguments) {
            if (!oArguments)
                oArguments    = [];
            oRequest.__func    = this;
            oRequest.__func(oArguments[0], oArguments[1], oArguments[2], oArguments[3], oArguments[4]);
            delete oRequest.__func;
        };
    };

    // Register new object with window
    /**
     * Class: HGIS.Request.XMLHttpRequest
     * Standard-compliant (W3C) cross-browser implementation of the
     *     XMLHttpRequest object.  From
     *     http://code.google.com/p/xmlhttprequest/.
     */
    if (!HGIS.Request) {
        /**
         * This allows for HGIS/Request.js to be included
         * before or after this script.
         */
        HGIS.Request = {};
    }
    HGIS.Request.XMLHttpRequest = cXMLHttpRequest;
})();
/* ======================================================================
    HGIS/Request.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Events.js
 * @requires HGIS/Request/XMLHttpRequest.js
 */

/**
 * TODO: deprecate me
 * Use HGIS.Request.proxy instead.
 */
HGIS.ProxyHost = "";

/**
 * Namespace: HGIS.Request
 * The HGIS.Request namespace contains convenience methods for working
 *     with XMLHttpRequests.  These methods work with a cross-browser
 *     W3C compliant <HGIS.Request.XMLHttpRequest> class.
 */
if (!HGIS.Request) {
    /**
     * This allows for HGIS/Request/XMLHttpRequest.js to be included
     * before or after this script.
     */
    HGIS.Request = {};
}
HGIS.Util.extend(HGIS.Request, {
    
    /**
     * Constant: DEFAULT_CONFIG
     * {Object} Default configuration for all requests.
     */
    DEFAULT_CONFIG: {
        method: "GET",
        url: window.location.href,
        async: true,
        user: undefined,
        password: undefined,
        params: null,
        proxy: HGIS.ProxyHost,
        headers: {},
        data: null,
        callback: function() {},
        success: null,
        failure: null,
        scope: null
    },
    
    /**
     * Constant: URL_SPLIT_REGEX
     */
    URL_SPLIT_REGEX: /([^:]*:)\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/,
    
    /**
     * APIProperty: events
     * {<HGIS.Events>} An events object that handles all 
     *     events on the {<HGIS.Request>} object.
     *
     * All event listeners will receive an event object with three properties:
     * request - {<HGIS.Request.XMLHttpRequest>} The request object.
     * config - {Object} The config object sent to the specific request method.
     * requestUrl - {String} The request url.
     * 
     * Supported event types:
     * complete - Triggered when we have a response from the request, if a
     *     listener returns false, no further response processing will take
     *     place.
     * success - Triggered when the HTTP response has a success code (200-299).
     * failure - Triggered when the HTTP response does not have a success code.
     */
    events: new HGIS.Events(this),
    
    /**
     * Method: makeSameOrigin
     * Using the specified proxy, returns a same origin url of the provided url.
     *
     * Parameters:
     * url - {String} An arbitrary url
     * proxy {String|Function} The proxy to use to make the provided url a
     *     same origin url.
     *
     * Returns
     * {String} the same origin url. If no proxy is provided, the returned url
     *     will be the same as the provided url.
     */
    makeSameOrigin: function(url, proxy) {
        var sameOrigin = url.indexOf("http") !== 0;
        var urlParts = !sameOrigin && url.match(this.URL_SPLIT_REGEX);
        if (urlParts) {
            var location = window.location;
            sameOrigin =
                urlParts[1] == location.protocol &&
                urlParts[3] == location.hostname;
            var uPort = urlParts[4], lPort = location.port;
            if (uPort != 80 && uPort != "" || lPort != "80" && lPort != "") {
                sameOrigin = sameOrigin && uPort == lPort;
            }
        }
        if (!sameOrigin) {
            if (proxy) {
                if (typeof proxy == "function") {
                    url = proxy(url);
                } else {
                    url = proxy + encodeURIComponent(url);
                }
            }
        }
        return url;
    },

    /**
     * APIMethod: issue
     * Create a new XMLHttpRequest object, open it, set any headers, bind
     *     a callback to done state, and send any data.  It is recommended that
     *     you use one <GET>, <POST>, <PUT>, <DELETE>, <OPTIONS>, or <HEAD>.
     *     This method is only documented to provide detail on the configuration
     *     options available to all request methods.
     *
     * Parameters:
     * config - {Object} Object containing properties for configuring the
     *     request.  Allowed configuration properties are described below.
     *     This object is modified and should not be reused.
     *
     * Allowed config properties:
     * method - {String} One of GET, POST, PUT, DELETE, HEAD, or
     *     OPTIONS.  Default is GET.
     * url - {String} URL for the request.
     * async - {Boolean} Open an asynchronous request.  Default is true.
     * user - {String} User for relevant authentication scheme.  Set
     *     to null to clear current user.
     * password - {String} Password for relevant authentication scheme.
     *     Set to null to clear current password.
     * proxy - {String} Optional proxy.  Defaults to
     *     <HGIS.ProxyHost>.
     * params - {Object} Any key:value pairs to be appended to the
     *     url as a query string.  Assumes url doesn't already include a query
     *     string or hash.  Typically, this is only appropriate for <GET>
     *     requests where the query string will be appended to the url.
     *     Parameter values that are arrays will be
     *     concatenated with a comma (note that this goes against form-encoding)
     *     as is done with <HGIS.Util.getParameterString>.
     * headers - {Object} Object with header:value pairs to be set on
     *     the request.
     * data - {String | Document} Optional data to send with the request.
     *     Typically, this is only used with <POST> and <PUT> requests.
     *     Make sure to provide the appropriate "Content-Type" header for your
     *     data.  For <POST> and <PUT> requests, the content type defaults to
     *     "application-xml".  If your data is a different content type, or
     *     if you are using a different HTTP method, set the "Content-Type"
     *     header to match your data type.
     * callback - {Function} Function to call when request is done.
     *     To determine if the request failed, check request.status (200
     *     indicates success).
     * success - {Function} Optional function to call if request status is in
     *     the 200s.  This will be called in addition to callback above and
     *     would typically only be used as an alternative.
     * failure - {Function} Optional function to call if request status is not
     *     in the 200s.  This will be called in addition to callback above and
     *     would typically only be used as an alternative.
     * scope - {Object} If callback is a public method on some object,
     *     set the scope to that object.
     *
     * Returns:
     * {XMLHttpRequest} Request object.  To abort the request before a response
     *     is received, call abort() on the request object.
     */
    issue: function(config) {        
        // apply default config - proxy host may have changed
        var defaultConfig = HGIS.Util.extend(
            this.DEFAULT_CONFIG,
            {proxy: HGIS.ProxyHost}
        );
        config = config || {};
        config.headers = config.headers || {};
        config = HGIS.Util.applyDefaults(config, defaultConfig);
        config.headers = HGIS.Util.applyDefaults(config.headers, defaultConfig.headers);
        // Always set the "X-Requested-With" header to signal that this request
        // was issued through the XHR-object. Since header keys are case 
        // insensitive and we want to allow overriding of the "X-Requested-With"
        // header through the user we cannot use applyDefaults, but have to 
        // check manually whether we were called with a "X-Requested-With"
        // header.
        var customRequestedWithHeader = false,
            headerKey;
        for(headerKey in config.headers) {
            if (config.headers.hasOwnProperty( headerKey )) {
                if (headerKey.toLowerCase() === 'x-requested-with') {
                    customRequestedWithHeader = true;
                }
            }
        }
        if (customRequestedWithHeader === false) {
            // we did not have a custom "X-Requested-With" header
            config.headers['X-Requested-With'] = 'XMLHttpRequest';
        }

        // create request, open, and set headers
        var request = new HGIS.Request.XMLHttpRequest();
        var url = HGIS.Util.urlAppend(config.url, 
            HGIS.Util.getParameterString(config.params || {}));
        url = HGIS.Request.makeSameOrigin(url, config.proxy);
        request.open(
            config.method, url, config.async, config.user, config.password
        );
        for(var header in config.headers) {
            request.setRequestHeader(header, config.headers[header]);
        }

        var events = this.events;

        // we want to execute runCallbacks with "this" as the
        // execution scope
        var self = this;
        
        request.onreadystatechange = function() {
            if(request.readyState == HGIS.Request.XMLHttpRequest.DONE) {
                var proceed = events.triggerEvent(
                    "complete",
                    {request: request, config: config, requestUrl: url}
                );
                if(proceed !== false) {
                    self.runCallbacks(
                        {request: request, config: config, requestUrl: url}
                    );
                }
            }
        };
        
        // send request (optionally with data) and return
        // call in a timeout for asynchronous requests so the return is
        // available before readyState == 4 for cached docs
        if(config.async === false) {
            request.send(config.data);
        } else {
            window.setTimeout(function(){
                if (request.readyState !== 0) { // W3C: 0-UNSENT
                    request.send(config.data);
                }
            }, 0);
        }
        return request;
    },
    
    /**
     * Method: runCallbacks
     * Calls the complete, success and failure callbacks. Application
     *    can listen to the "complete" event, have the listener 
     *    display a confirm window and always return false, and
     *    execute HGIS.Request.runCallbacks if the user
     *    hits "yes" in the confirm window.
     *
     * Parameters:
     * options - {Object} Hash containing request, config and requestUrl keys
     */
    runCallbacks: function(options) {
        var request = options.request;
        var config = options.config;
        
        // bind callbacks to readyState 4 (done)
        var complete = (config.scope) ?
            HGIS.Function.bind(config.callback, config.scope) :
            config.callback;
        
        // optional success callback
        var success;
        if(config.success) {
            success = (config.scope) ?
                HGIS.Function.bind(config.success, config.scope) :
                config.success;
        }

        // optional failure callback
        var failure;
        if(config.failure) {
            failure = (config.scope) ?
                HGIS.Function.bind(config.failure, config.scope) :
                config.failure;
        }

        if (HGIS.Util.createUrlObject(config.url).protocol == "file:" &&
                                                        request.responseText) {
            request.status = 200;
        }
        complete(request);

        if (!request.status || (request.status >= 200 && request.status < 300)) {
            this.events.triggerEvent("success", options);
            if(success) {
                success(request);
            }
        }
        if(request.status && (request.status < 200 || request.status >= 300)) {                    
            this.events.triggerEvent("failure", options);
            if(failure) {
                failure(request);
            }
        }
    },
    
    /**
     * APIMethod: GET
     * Send an HTTP GET request.  Additional configuration properties are
     *     documented in the <issue> method, with the method property set
     *     to GET.
     *
     * Parameters:
     * config - {Object} Object with properties for configuring the request.
     *     See the <issue> method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * Returns:
     * {XMLHttpRequest} Request object.
     */
    GET: function(config) {
        config = HGIS.Util.extend(config, {method: "GET"});
        return HGIS.Request.issue(config);
    },
    
    /**
     * APIMethod: POST
     * Send a POST request.  Additional configuration properties are
     *     documented in the <issue> method, with the method property set
     *     to POST and "Content-Type" header set to "application/xml".
     *
     * Parameters:
     * config - {Object} Object with properties for configuring the request.
     *     See the <issue> method for documentation of allowed properties.  The
     *     default "Content-Type" header will be set to "application-xml" if
     *     none is provided.  This object is modified and should not be reused.
     * 
     * Returns:
     * {XMLHttpRequest} Request object.
     */
    POST: function(config) {
        config = HGIS.Util.extend(config, {method: "POST"});
        // set content type to application/xml if it isn't already set
        config.headers = config.headers ? config.headers : {};
        if(!("CONTENT-TYPE" in HGIS.Util.upperCaseObject(config.headers))) {
            config.headers["Content-Type"] = "application/xml";
        }
        return HGIS.Request.issue(config);
    },
    
    /**
     * APIMethod: PUT
     * Send an HTTP PUT request.  Additional configuration properties are
     *     documented in the <issue> method, with the method property set
     *     to PUT and "Content-Type" header set to "application/xml".
     *
     * Parameters:
     * config - {Object} Object with properties for configuring the request.
     *     See the <issue> method for documentation of allowed properties.  The
     *     default "Content-Type" header will be set to "application-xml" if
     *     none is provided.  This object is modified and should not be reused.
     * 
     * Returns:
     * {XMLHttpRequest} Request object.
     */
    PUT: function(config) {
        config = HGIS.Util.extend(config, {method: "PUT"});
        // set content type to application/xml if it isn't already set
        config.headers = config.headers ? config.headers : {};
        if(!("CONTENT-TYPE" in HGIS.Util.upperCaseObject(config.headers))) {
            config.headers["Content-Type"] = "application/xml";
        }
        return HGIS.Request.issue(config);
    },
    
    /**
     * APIMethod: DELETE
     * Send an HTTP DELETE request.  Additional configuration properties are
     *     documented in the <issue> method, with the method property set
     *     to DELETE.
     *
     * Parameters:
     * config - {Object} Object with properties for configuring the request.
     *     See the <issue> method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * Returns:
     * {XMLHttpRequest} Request object.
     */
    DELETE: function(config) {
        config = HGIS.Util.extend(config, {method: "DELETE"});
        return HGIS.Request.issue(config);
    },
  
    /**
     * APIMethod: HEAD
     * Send an HTTP HEAD request.  Additional configuration properties are
     *     documented in the <issue> method, with the method property set
     *     to HEAD.
     *
     * Parameters:
     * config - {Object} Object with properties for configuring the request.
     *     See the <issue> method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * Returns:
     * {XMLHttpRequest} Request object.
     */
    HEAD: function(config) {
        config = HGIS.Util.extend(config, {method: "HEAD"});
        return HGIS.Request.issue(config);
    },
    
    /**
     * APIMethod: OPTIONS
     * Send an HTTP OPTIONS request.  Additional configuration properties are
     *     documented in the <issue> method, with the method property set
     *     to OPTIONS.
     *
     * Parameters:
     * config - {Object} Object with properties for configuring the request.
     *     See the <issue> method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * Returns:
     * {XMLHttpRequest} Request object.
     */
    OPTIONS: function(config) {
        config = HGIS.Util.extend(config, {method: "OPTIONS"});
        return HGIS.Request.issue(config);
    }

});
/* ======================================================================
    HGIS/Layer/ArcIMS.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer/Grid.js
 * @requires HGIS/Format/ArcXML.js
 * @requires HGIS/Request.js
 */

/**
 * Class: HGIS.Layer.ArcIMS
 * Instances of HGIS.Layer.ArcIMS are used to display data from ESRI ArcIMS
 *     Mapping Services. Create a new ArcIMS layer with the <HGIS.Layer.ArcIMS>
 *     constructor.
 * 
 * Inherits from:
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.ArcIMS = HGIS.Class(HGIS.Layer.Grid, {

    /**
     * Constant: DEFAULT_PARAMS
     * {Object} Default query string parameters.
     */
    DEFAULT_PARAMS: { 
        ClientVersion: "9.2",
        ServiceName: ''
    },
    
    /**
     * APIProperty: featureCoordSys
     * {String} Code for feature coordinate system.  Default is "4326".
     */
    featureCoordSys: "4326",
    
    /**
     * APIProperty: filterCoordSys
     * {String} Code for filter coordinate system.  Default is "4326".
     */
    filterCoordSys: "4326",
    
    /**
     * APIProperty: layers
     * {Array} An array of objects with layer properties.
     */
    layers: null,
    
    /**
     * APIProperty: async
     * {Boolean} Request images asynchronously.  Default is true.
     */
    async: true,
    
    /**
     * APIProperty: name
     * {String} Layer name.  Default is "ArcIMS".
     */
    name: "ArcIMS",

    /**
     * APIProperty: isBaseLayer
     * {Boolean} The layer is a base layer.  Default is true.
     */
    isBaseLayer: true,

    /**
     * Constant: DEFAULT_OPTIONS
     * {Object} Default layers properties.
     */
    DEFAULT_OPTIONS: {
        tileSize: new HGIS.Size(512, 512),
        featureCoordSys: "4326",
        filterCoordSys: "4326",
        layers: null,
        isBaseLayer: true,
        async: true,
        name: "ArcIMS"
    }, 
 
    /**
     * Constructor: HGIS.Layer.ArcIMS
     * Create a new ArcIMS layer object.
     *
     * Example:
     * (code)
     * var arcims = new HGIS.Layer.ArcIMS(
     *     "Global Sample",
     *     "http://sample.avencia.com/servlet/com.esri.esrimap.Esrimap", 
     *     {
     *         service: "HGIS_Sample", 
     *         layers: [
     *             // layers to manipulate
     *             {id: "1", visible: true}
     *         ]
     *     }
     * );
     * (end)
     *
     * Parameters:
     * name - {String} A name for the layer
     * url - {String} Base url for the ArcIMS server
     * options - {Object} Optional object with properties to be set on the
     *     layer.
     */
    initialize: function(name, url, options) {
        
        this.tileSize = new HGIS.Size(512, 512);

        // parameters
        this.params = HGIS.Util.applyDefaults(
            {ServiceName: options.serviceName},
            this.DEFAULT_PARAMS
        );
        this.options = HGIS.Util.applyDefaults(
            options, this.DEFAULT_OPTIONS
        );
          
        HGIS.Layer.Grid.prototype.initialize.apply(
            this, [name, url, this.params, options]
        );

        //layer is transparent        
        if (this.transparent) {
            
            // unless explicitly set in options, make layer an overlay
            if (!this.isBaseLayer) {
                this.isBaseLayer = false;
            } 
            
            // jpegs can never be transparent, so intelligently switch the 
            //  format, depending on the browser's capabilities
            if (this.format == "image/jpeg") {
                this.format = HGIS.Util.alphaHack() ? "image/gif" : "image/png";
            }
        }

        // create an empty layer list if no layers specified in the options
        if (this.options.layers === null) {
            this.options.layers = [];
        }
    },    

    /**
     * Method: getURL
     * Return an image url this layer.
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>} A bounds representing the bbox for the
     *     request.
     *
     * Returns:
     * {String} A string with the map image's url.
     */
    getURL: function(bounds) {
        var url = "";
        bounds = this.adjustBounds(bounds);
        
        // create an arcxml request to generate the image
        var axlReq = new HGIS.Format.ArcXML( 
            HGIS.Util.extend(this.options, {
                requesttype: "image",
                envelope: bounds.toArray(),
                tileSize: this.tileSize
            })
        );
        
        // create a synchronous ajax request to get an arcims image
        var req = new HGIS.Request.POST({
            url: this.getFullRequestString(),
            data: axlReq.write(),
            async: false
        });
        
        // if the response exists
        if (req != null) {
            var doc = req.responseXML;

            if (!doc || !doc.documentElement) {            
                doc = req.responseText;
            }

            // create a new arcxml format to read the response
            var axlResp = new HGIS.Format.ArcXML();
            var arcxml = axlResp.read(doc);
            url = this.getUrlOrImage(arcxml.image.output);
        }
        
        return url;
    },
    
    
    /**
     * Method: getURLasync
     * Get an image url this layer asynchronously, and execute a callback
     *     when the image url is generated.
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>} A bounds representing the bbox for the
     *     request.
     * callback - {Function} Function to call when image url is retrieved.
     * scope - {Object} The scope of the callback method.
     */
    getURLasync: function(bounds, callback, scope) {
        bounds = this.adjustBounds(bounds);
        
        // create an arcxml request to generate the image
        var axlReq = new HGIS.Format.ArcXML(  
            HGIS.Util.extend(this.options, { 
                requesttype: "image",
                envelope: bounds.toArray(),
                tileSize: this.tileSize
            })
        );
        
        // create an asynchronous ajax request to get an arcims image
        HGIS.Request.POST({
            url: this.getFullRequestString(),
            async: true,
            data: axlReq.write(),
            callback: function(req) {
                // process the response from ArcIMS, and call the callback function
                // to set the image URL
                var doc = req.responseXML;
                if (!doc || !doc.documentElement) {            
                    doc = req.responseText;
                }

                // create a new arcxml format to read the response
                var axlResp = new HGIS.Format.ArcXML();
                var arcxml = axlResp.read(doc);
                
                callback.call(scope, this.getUrlOrImage(arcxml.image.output));
            },
            scope: this
        });
    },
    
    /**
     * Method: getUrlOrImage
     * Extract a url or image from the ArcXML image output.
     *
     * Parameters:
     * output - {Object} The image.output property of the object returned from
     *     the ArcXML format read method.
     *
     * Returns:
     * {String} A URL for an image (potentially with the data protocol).
     */
    getUrlOrImage: function(output) {
        var ret = "";
        if(output.url) {
            // If the image response output url is a string, then the image
            // data is not inline.
            ret = output.url;
        } else if(output.data) {
            // The image data is inline and base64 encoded, create a data
            // url for the image.  This will only work for small images,
            // due to browser url length limits.
            ret = "data:image/" + output.type + 
                  ";base64," + output.data;
        }
        return ret;
    },
    
    /**
     * Method: setLayerQuery
     * Set the query definition on this layer. Query definitions are used to
     *     render parts of the spatial data in an image, and can be used to
     *     filter features or layers in the ArcIMS service.
     *
     * Parameters:
     * id - {String} The ArcIMS layer ID.
     * querydef - {Object} The query definition to apply to this layer.
     */
    setLayerQuery: function(id, querydef) {
        // find the matching layer, if it exists
        for (var lyr = 0; lyr < this.options.layers.length; lyr++) {
            if (id == this.options.layers[lyr].id) {
                // replace this layer definition
                this.options.layers[lyr].query = querydef;
                return;
            }
        }
      
        // no layer found, create a new definition
        this.options.layers.push({id: id, visible: true, query: querydef});
    },
    
    /**
     * Method: getFeatureInfo
     * Get feature information from ArcIMS.  Using the applied geometry, apply
     *     the options to the query (buffer, area/envelope intersection), and
     *     query the ArcIMS service.
     *
     * A note about accuracy:
     * ArcIMS interprets the accuracy attribute in feature requests to be
     *     something like the 'modulus' operator on feature coordinates,
     *     applied to the database geometry of the feature.  It doesn't round,
     *     so your feature coordinates may be up to (1 x accuracy) offset from
     *     the actual feature coordinates.  If the accuracy of the layer is not
     *     specified, the accuracy will be computed to be approximately 1
     *     feature coordinate per screen  pixel.
     *
     * Parameters:
     * geometry - {<HGIS.LonLat>} or {<HGIS.Geometry.Polygon>} The
     *     geometry to use when making the query. This should be a closed
     *     polygon for behavior approximating a free selection.
     * layer - {Object} The ArcIMS layer definition. This is an anonymous object
     *     that looks like:
     * (code)
     * {
     *     id: "ArcXML layer ID",  // the ArcXML layer ID
     *     query: {
     *         where: "STATE = 'PA'",  // the where clause of the query
     *         accuracy: 100           // the accuracy of the returned feature
     *     }
     * }
     * (end)
     * options - {Object} Object with non-default properties to set on the layer.
     *     Supported properties are buffer, callback, scope, and any other
     *     properties applicable to the ArcXML format.  Set the 'callback' and
     *     'scope' for an object and function to recieve the parsed features
     *     from ArcIMS.
     */
    getFeatureInfo: function(geometry, layer, options) {
        // set the buffer to 1 unit (dd/m/ft?) by default
        var buffer = options.buffer || 1;
        // empty callback by default
        var callback = options.callback || function() {};
        // default scope is window (global)
        var scope = options.scope || window;

        // apply these option to the request options
        var requestOptions = {};
        HGIS.Util.extend(requestOptions, this.options);

        // this is a feature request
        requestOptions.requesttype = "feature";

        if (geometry instanceof HGIS.LonLat) {
            // create an envelope if the geometry is really a lon/lat
            requestOptions.polygon = null;
            requestOptions.envelope = [ 
                geometry.lon - buffer, 
                geometry.lat - buffer,
                geometry.lon + buffer,
                geometry.lat + buffer
            ];
        } else if (geometry instanceof HGIS.Geometry.Polygon) {
            // use the polygon assigned, and empty the envelope
            requestOptions.envelope = null;
            requestOptions.polygon = geometry;
        }
      
        // create an arcxml request to get feature requests
        var arcxml = new HGIS.Format.ArcXML(requestOptions);

        // apply any get feature options to the arcxml request
        HGIS.Util.extend(arcxml.request.get_feature, options);

        arcxml.request.get_feature.layer = layer.id;
        if (typeof layer.query.accuracy == "number") {
            // set the accuracy if it was specified
            arcxml.request.get_feature.query.accuracy = layer.query.accuracy;
        } else {
            // guess that the accuracy is 1 per screen pixel
            var mapCenter = this.map.getCenter();
            var viewPx = this.map.getViewPortPxFromLonLat(mapCenter);
            viewPx.x++;
            var mapOffCenter = this.map.getLonLatFromPixel(viewPx);
            arcxml.request.get_feature.query.accuracy = mapOffCenter.lon - mapCenter.lon;
        }
        
        // set the get_feature query to be the same as the layer passed in
        arcxml.request.get_feature.query.where = layer.query.where;
        
        // use area_intersection
        arcxml.request.get_feature.query.spatialfilter.relation = "area_intersection";
      
        // create a new asynchronous request to get the feature info
        HGIS.Request.POST({
            url: this.getFullRequestString({'CustomService': 'Query'}),
            data: arcxml.write(),
            callback: function(request) {
                // parse the arcxml response
                var response = arcxml.parseResponse(request.responseText);
                
                if (!arcxml.iserror()) {
                    // if the arcxml is not an error, call the callback with the features parsed
                    callback.call(scope, response.features);
                } else {
                    // if the arcxml is an error, return null features selected
                    callback.call(scope, null);
                }
            }
        });
    },

    /**
     * Method: clone
     * Create a clone of this layer
     *
     * Returns:
     * {<HGIS.Layer.ArcIMS>} An exact clone of this layer
     */
    clone: function (obj) {

        if (obj == null) {
            obj = new HGIS.Layer.ArcIMS(this.name,
                                           this.url,
                                           this.getOptions());
        }

        //get all additions from superclasses
        obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },
    
    CLASS_NAME: "HGIS.Layer.ArcIMS"
});
/* ======================================================================
    HGIS/Control/PanZoom.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Control.js
 * @requires HGIS/Events/buttonclick.js
 */

/**
 * Class: HGIS.Control.PanZoom
 * The PanZoom is a visible control, composed of a
 * <HGIS.Control.PanPanel> and a <HGIS.Control.ZoomPanel>. By
 * default it is drawn in the upper left corner of the map.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.PanZoom = HGIS.Class(HGIS.Control, {

    /** 
     * APIProperty: slideFactor
     * {Integer} Number of pixels by which we'll pan the map in any direction 
     *     on clicking the arrow buttons.  If you want to pan by some ratio
     *     of the map dimensions, use <slideRatio> instead.
     */
    slideFactor: 50,

    /** 
     * APIProperty: slideRatio
     * {Number} The fraction of map width/height by which we'll pan the map            
     *     on clicking the arrow buttons.  Default is null.  If set, will
     *     override <slideFactor>. E.g. if slideRatio is .5, then the Pan Up
     *     button will pan up half the map height. 
     */
    slideRatio: null,

    /** 
     * Property: buttons
     * {Array(DOMElement)} Array of Button Divs 
     */
    buttons: null,

    /** 
     * Property: position
     * {<HGIS.Pixel>} 
     */
    position: null,

    /**
     * Constructor: HGIS.Control.PanZoom
     * 
     * Parameters:
     * options - {Object}
     */
    initialize: function(options) {
        this.position = new HGIS.Pixel(HGIS.Control.PanZoom.X,
                                             HGIS.Control.PanZoom.Y);
        HGIS.Control.prototype.initialize.apply(this, arguments);
    },

    /**
     * APIMethod: destroy
     */
    destroy: function() {
        if (this.map) {
            this.map.events.unregister("buttonclick", this, this.onButtonClick);
        }
        this.removeButtons();
        this.buttons = null;
        this.position = null;
        HGIS.Control.prototype.destroy.apply(this, arguments);
    },

    /** 
     * Method: setMap
     *
     * Properties:
     * map - {<HGIS.Map>} 
     */
    setMap: function(map) {
        HGIS.Control.prototype.setMap.apply(this, arguments);
        this.map.events.register("buttonclick", this, this.onButtonClick);
    },

    /**
     * Method: draw
     *
     * Parameters:
     * px - {<HGIS.Pixel>} 
     * 
     * Returns:
     * {DOMElement} A reference to the container div for the PanZoom control.
     */
    draw: function(px) {
        // initialize our internal div
        HGIS.Control.prototype.draw.apply(this, arguments);
        px = this.position;

        // place the controls
        this.buttons = [];

        var sz = {w: 18, h: 18};
        var centered = new HGIS.Pixel(px.x+sz.w/2, px.y);

        this._addButton("panup", "north-mini.png", centered, sz);
        px.y = centered.y+sz.h;
        this._addButton("panleft", "west-mini.png", px, sz);
        this._addButton("panright", "east-mini.png", px.add(sz.w, 0), sz);
        this._addButton("pandown", "south-mini.png", 
                        centered.add(0, sz.h*2), sz);
        this._addButton("zoomin", "zoom-plus-mini.png", 
                        centered.add(0, sz.h*3+5), sz);
        this._addButton("zoomworld", "zoom-world-mini.png", 
                        centered.add(0, sz.h*4+5), sz);
        this._addButton("zoomout", "zoom-minus-mini.png", 
                        centered.add(0, sz.h*5+5), sz);
        return this.div;
    },
    
    /**
     * Method: _addButton
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<HGIS.Pixel>} 
     * sz - {<HGIS.Size>} 
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addButton:function(id, img, xy, sz) {
        var imgLocation = HGIS.Util.getImageLocation(img);
        var btn = HGIS.Util.createAlphaImageDiv(
                                    this.id + "_" + id, 
                                    xy, sz, imgLocation, "absolute");
        btn.style.cursor = "pointer";
        //we want to add the outer div
        this.div.appendChild(btn);
        btn.action = id;
        btn.className = "olButton";
    
        //we want to remember/reference the outer div
        this.buttons.push(btn);
        return btn;
    },
    
    /**
     * Method: _removeButton
     * 
     * Parameters:
     * btn - {Object}
     */
    _removeButton: function(btn) {
        this.div.removeChild(btn);
        HGIS.Util.removeItem(this.buttons, btn);
    },
    
    /**
     * Method: removeButtons
     */
    removeButtons: function() {
        for(var i=this.buttons.length-1; i>=0; --i) {
            this._removeButton(this.buttons[i]);
        }
    },
    
    /**
     * Method: onButtonClick
     *
     * Parameters:
     * evt - {Event}
     */
    onButtonClick: function(evt) {
        var btn = evt.buttonElement;
        switch (btn.action) {
            case "panup": 
                this.map.pan(0, -this.getSlideFactor("h"));
                break;
            case "pandown": 
                this.map.pan(0, this.getSlideFactor("h"));
                break;
            case "panleft": 
                this.map.pan(-this.getSlideFactor("w"), 0);
                break;
            case "panright": 
                this.map.pan(this.getSlideFactor("w"), 0);
                break;
            case "zoomin": 
                this.map.zoomIn(); 
                break;
            case "zoomout": 
                this.map.zoomOut(); 
                break;
            case "zoomworld": 
                this.map.zoomToMaxExtent(); 
                break;
        }
    },
    
    /**
     * Method: getSlideFactor
     *
     * Parameters:
     * dim - {String} "w" or "h" (for width or height).
     *
     * Returns:
     * {Number} The slide factor for panning in the requested direction.
     */
    getSlideFactor: function(dim) {
        return this.slideRatio ?
            this.map.getSize()[dim] * this.slideRatio :
            this.slideFactor;
    },

    CLASS_NAME: "HGIS.Control.PanZoom"
});

/**
 * Constant: X
 * {Integer}
 */
HGIS.Control.PanZoom.X = 4;

/**
 * Constant: Y
 * {Integer}
 */
HGIS.Control.PanZoom.Y = 4;
/* ======================================================================
    HGIS/Control/PanZoomBar.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Control/PanZoom.js
 */

/**
 * Class: HGIS.Control.PanZoomBar
 * The PanZoomBar is a visible control composed of a
 * <HGIS.Control.PanPanel> and a <HGIS.Control.ZoomBar>. 
 * By default it is displayed in the upper left corner of the map as 4
 * directional arrows above a vertical slider.
 *
 * Inherits from:
 *  - <HGIS.Control.PanZoom>
 */
HGIS.Control.PanZoomBar = HGIS.Class(HGIS.Control.PanZoom, {

    /** 
     * APIProperty: zoomStopWidth
     */
    zoomStopWidth: 18,

    /** 
     * APIProperty: zoomStopHeight
     */
    zoomStopHeight: 11,

    /** 
     * Property: slider
     */
    slider: null,

    /** 
     * Property: sliderEvents
     * {<HGIS.Events>}
     */
    sliderEvents: null,

    /** 
     * Property: zoombarDiv
     * {DOMElement}
     */
    zoombarDiv: null,

    /** 
     * APIProperty: zoomWorldIcon
     * {Boolean}
     */
    zoomWorldIcon: false,

    /**
     * APIProperty: panIcons
     * {Boolean} Set this property to false not to display the pan icons. If
     * false the zoom world icon is placed under the zoom bar. Defaults to
     * true.
     */
    panIcons: true,

    /**
     * APIProperty: forceFixedZoomLevel
     * {Boolean} Force a fixed zoom level even though the map has 
     *     fractionalZoom
     */
    forceFixedZoomLevel: false,

    /**
     * Property: mouseDragStart
     * {<HGIS.Pixel>}
     */
    mouseDragStart: null,

    /**
     * Property: deltaY
     * {Number} The cumulative vertical pixel offset during a zoom bar drag.
     */
    deltaY: null,

    /**
     * Property: zoomStart
     * {<HGIS.Pixel>}
     */
    zoomStart: null,

    /**
     * Constructor: HGIS.Control.PanZoomBar
     */ 

    /**
     * APIMethod: destroy
     */
    destroy: function() {

        this._removeZoomBar();

        this.map.events.un({
            "changebaselayer": this.redraw,
            "updatesize": this.redraw,
            scope: this
        });

        HGIS.Control.PanZoom.prototype.destroy.apply(this, arguments);

        delete this.mouseDragStart;
        delete this.zoomStart;
    },
    
    /**
     * Method: setMap
     * 
     * Parameters:
     * map - {<HGIS.Map>} 
     */
    setMap: function(map) {
        HGIS.Control.PanZoom.prototype.setMap.apply(this, arguments);
        this.map.events.on({
            "changebaselayer": this.redraw,
            "updatesize": this.redraw,
            scope: this
        });
    },

    /** 
     * Method: redraw
     * clear the div and start over.
     */
    redraw: function() {
        if (this.div != null) {
            this.removeButtons();
            this._removeZoomBar();
        }  
        this.draw();
    },
    
    /**
    * Method: draw 
    *
    * Parameters:
    * px - {<HGIS.Pixel>} 
    */
    draw: function(px) {
        // initialize our internal div
        HGIS.Control.prototype.draw.apply(this, arguments);
        px = this.position.clone();

        // place the controls
        this.buttons = [];

        var sz = {w: 18, h: 18};
        if (this.panIcons) {
            var centered = new HGIS.Pixel(px.x+sz.w/2, px.y);
            var wposition = sz.w;

            if (this.zoomWorldIcon) {
                centered = new HGIS.Pixel(px.x+sz.w, px.y);
            }

            this._addButton("panup", "north-mini.png", centered, sz);
            px.y = centered.y+sz.h;
            this._addButton("panleft", "west-mini.png", px, sz);
            if (this.zoomWorldIcon) {
                this._addButton("zoomworld", "zoom-world-mini.png", px.add(sz.w, 0), sz);

                wposition *= 2;
            }
            this._addButton("panright", "east-mini.png", px.add(wposition, 0), sz);
            this._addButton("pandown", "south-mini.png", centered.add(0, sz.h*2), sz);
            this._addButton("zoomin", "zoom-plus-mini.png", centered.add(0, sz.h*3+5), sz);
            centered = this._addZoomBar(centered.add(0, sz.h*4 + 5));
            this._addButton("zoomout", "zoom-minus-mini.png", centered, sz);
        }
        else {
            this._addButton("zoomin", "zoom-plus-mini.png", px, sz);
            centered = this._addZoomBar(px.add(0, sz.h));
            this._addButton("zoomout", "zoom-minus-mini.png", centered, sz);
            if (this.zoomWorldIcon) {
                centered = centered.add(0, sz.h+3);
                this._addButton("zoomworld", "zoom-world-mini.png", centered, sz);
            }
        }
        return this.div;
    },

    /** 
    * Method: _addZoomBar
    * 
    * Parameters:
    * centered - {<HGIS.Pixel>} where zoombar drawing is to start.
    */
    _addZoomBar:function(centered) {
        var imgLocation = HGIS.Util.getImageLocation("slider.png");
        var id = this.id + "_" + this.map.id;
        var minZoom = this.map.getMinZoom();
        var zoomsToEnd = this.map.getNumZoomLevels() - 1 - this.map.getZoom();
        var slider = HGIS.Util.createAlphaImageDiv(id,
                       centered.add(-1, zoomsToEnd * this.zoomStopHeight), 
                       {w: 20, h: 9},
                       imgLocation,
                       "absolute");
        slider.style.cursor = "move";
        this.slider = slider;
        
        this.sliderEvents = new HGIS.Events(this, slider, null, true,
                                            {includeXY: true});
        this.sliderEvents.on({
            "touchstart": this.zoomBarDown,
            "touchmove": this.zoomBarDrag,
            "touchend": this.zoomBarUp,
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp
        });
        
        var sz = {
            w: this.zoomStopWidth,
            h: this.zoomStopHeight * (this.map.getNumZoomLevels() - minZoom)
        };
        var imgLocation = HGIS.Util.getImageLocation("zoombar.png");
        var div = null;
        
        if (HGIS.Util.alphaHack()) {
            var id = this.id + "_" + this.map.id;
            div = HGIS.Util.createAlphaImageDiv(id, centered,
                                      {w: sz.w, h: this.zoomStopHeight},
                                      imgLocation,
                                      "absolute", null, "crop");
            div.style.height = sz.h + "px";
        } else {
            div = HGIS.Util.createDiv(
                        'HGIS_Control_PanZoomBar_Zoombar' + this.map.id,
                        centered,
                        sz,
                        imgLocation);
        }
        div.style.cursor = "pointer";
        div.className = "olButton";
        this.zoombarDiv = div;
        
        this.div.appendChild(div);

        this.startTop = parseInt(div.style.top);
        this.div.appendChild(slider);

        this.map.events.register("zoomend", this, this.moveZoomBar);

        centered = centered.add(0, 
            this.zoomStopHeight * (this.map.getNumZoomLevels() - minZoom));
        return centered; 
    },
    
    /**
     * Method: _removeZoomBar
     */
    _removeZoomBar: function() {
        this.sliderEvents.un({
            "touchstart": this.zoomBarDown,
            "touchmove": this.zoomBarDrag,
            "touchend": this.zoomBarUp,
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp
        });
        this.sliderEvents.destroy();
        
        this.div.removeChild(this.zoombarDiv);
        this.zoombarDiv = null;
        this.div.removeChild(this.slider);
        this.slider = null;
        
        this.map.events.unregister("zoomend", this, this.moveZoomBar);
    },
    
    /**
     * Method: onButtonClick
     *
     * Parameters:
     * evt - {Event}
     */
    onButtonClick: function(evt) {
        HGIS.Control.PanZoom.prototype.onButtonClick.apply(this, arguments);
        if (evt.buttonElement === this.zoombarDiv) {
            var levels = evt.buttonXY.y / this.zoomStopHeight;
            if(this.forceFixedZoomLevel || !this.map.fractionalZoom) {
                levels = Math.floor(levels);
            }    
            var zoom = (this.map.getNumZoomLevels() - 1) - levels; 
            zoom = Math.min(Math.max(zoom, 0), this.map.getNumZoomLevels() - 1);
            this.map.zoomTo(zoom);
        }
    },
    
    /**
     * Method: passEventToSlider
     * This function is used to pass events that happen on the div, or the map,
     * through to the slider, which then does its moving thing.
     *
     * Parameters:
     * evt - {<HGIS.Event>} 
     */
    passEventToSlider:function(evt) {
        this.sliderEvents.handleBrowserEvent(evt);
    },
    
    /*
     * Method: zoomBarDown
     * event listener for clicks on the slider
     *
     * Parameters:
     * evt - {<HGIS.Event>} 
     */
    zoomBarDown:function(evt) {
        if (!HGIS.Event.isLeftClick(evt) && !HGIS.Event.isSingleTouch(evt)) {
            return;
        }
        this.map.events.on({
            "touchmove": this.passEventToSlider,
            "mousemove": this.passEventToSlider,
            "mouseup": this.passEventToSlider,
            scope: this
        });
        this.mouseDragStart = evt.xy.clone();
        this.zoomStart = evt.xy.clone();
        this.div.style.cursor = "move";
        // reset the div offsets just in case the div moved
        this.zoombarDiv.offsets = null; 
        HGIS.Event.stop(evt);
    },
    
    /*
     * Method: zoomBarDrag
     * This is what happens when a click has occurred, and the client is
     * dragging.  Here we must ensure that the slider doesn't go beyond the
     * bottom/top of the zoombar div, as well as moving the slider to its new
     * visual location
     *
     * Parameters:
     * evt - {<HGIS.Event>} 
     */
    zoomBarDrag:function(evt) {
        if (this.mouseDragStart != null) {
            var deltaY = this.mouseDragStart.y - evt.xy.y;
            var offsets = HGIS.Util.pagePosition(this.zoombarDiv);
            if ((evt.clientY - offsets[1]) > 0 && 
                (evt.clientY - offsets[1]) < parseInt(this.zoombarDiv.style.height) - 2) {
                var newTop = parseInt(this.slider.style.top) - deltaY;
                this.slider.style.top = newTop+"px";
                this.mouseDragStart = evt.xy.clone();
            }
            // set cumulative displacement
            this.deltaY = this.zoomStart.y - evt.xy.y;
            HGIS.Event.stop(evt);
        }
    },
    
    /*
     * Method: zoomBarUp
     * Perform cleanup when a mouseup event is received -- discover new zoom
     * level and switch to it.
     *
     * Parameters:
     * evt - {<HGIS.Event>} 
     */
    zoomBarUp:function(evt) {
        if (!HGIS.Event.isLeftClick(evt) && evt.type !== "touchend") {
            return;
        }
        if (this.mouseDragStart) {
            this.div.style.cursor="";
            this.map.events.un({
                "touchmove": this.passEventToSlider,
                "mouseup": this.passEventToSlider,
                "mousemove": this.passEventToSlider,
                scope: this
            });
            var zoomLevel = this.map.zoom;
            if (!this.forceFixedZoomLevel && this.map.fractionalZoom) {
                zoomLevel += this.deltaY/this.zoomStopHeight;
                zoomLevel = Math.min(Math.max(zoomLevel, 0), 
                                     this.map.getNumZoomLevels() - 1);
            } else {
                zoomLevel += this.deltaY/this.zoomStopHeight;
                zoomLevel = Math.max(Math.round(zoomLevel), 0);      
            }
            this.map.zoomTo(zoomLevel);
            this.mouseDragStart = null;
            this.zoomStart = null;
            this.deltaY = 0;
            HGIS.Event.stop(evt);
        }
    },
    
    /*
    * Method: moveZoomBar
    * Change the location of the slider to match the current zoom level.
    */
    moveZoomBar:function() {
        var newTop = 
            ((this.map.getNumZoomLevels()-1) - this.map.getZoom()) * 
            this.zoomStopHeight + this.startTop + 1;
        this.slider.style.top = newTop + "px";
    },    
    
    CLASS_NAME: "HGIS.Control.PanZoomBar"
});
/* ======================================================================
    HGIS/Format/WFSCapabilities.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML/VersionedOGC.js
 */

/**
 * Class: HGIS.Format.WFSCapabilities
 * Read WFS Capabilities.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML.VersionedOGC>
 */
HGIS.Format.WFSCapabilities = HGIS.Class(HGIS.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.1.0".
     */
    defaultVersion: "1.1.0",

    /**
     * Constructor: HGIS.Format.WFSCapabilities
     * Create a new parser for WFS capabilities.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return a list of layers. 
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array} List of named layers.
     */
    
    CLASS_NAME: "HGIS.Format.WFSCapabilities" 

});
/* ======================================================================
    HGIS/Format/WFSCapabilities/v1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WFSCapabilities.js
 */

/**
 * Class: HGIS.Format.WFSCapabilities.v1
 * Abstract class not to be instantiated directly.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.WFSCapabilities.v1 = HGIS.Class(
    HGIS.Format.XML, {

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        wfs: "http://www.opengis.net/wfs",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        ows: "http://www.opengis.net/ows"
    },


    /**
     * APIProperty: errorProperty
     * {String} Which property of the returned object to check for in order to
     * determine whether or not parsing has failed. In the case that the
     * errorProperty is undefined on the returned object, the document will be
     * run through an OGCExceptionReport parser.
     */
    errorProperty: "featureTypeList",

    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "wfs",
    
    /**
     * Constructor: HGIS.Format.WFSCapabilities.v1_1
     * Create an instance of one of the subclasses.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return a list of layers. 
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array} List of named layers.
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        var raw = data;
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        return capabilities;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wfs": {
            "WFS_Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "FeatureTypeList": function(node, request) {
                request.featureTypeList = {
                    featureTypes: []
                };
                this.readChildNodes(node, request.featureTypeList);
            },
            "FeatureType": function(node, featureTypeList) {
                var featureType = {};
                this.readChildNodes(node, featureType);
                featureTypeList.featureTypes.push(featureType);
            },
            "Name": function(node, obj) {
                var name = this.getChildValue(node);
                if(name) {
                    var parts = name.split(":");
                    obj.name = parts.pop();
                    if(parts.length > 0) {
                        obj.featureNS = this.lookupNamespaceURI(node, parts[0]);
                    }
                }
            },
            "Title": function(node, obj) {
                var title = this.getChildValue(node);
                if(title) {
                    obj.title = title;
                }
            },
            "Abstract": function(node, obj) {
                var abst = this.getChildValue(node);
                if(abst) {
                    obj["abstract"] = abst;
                }
            }
        }
    },

    CLASS_NAME: "HGIS.Format.WFSCapabilities.v1" 

});
/* ======================================================================
    HGIS/Format/WFSCapabilities/v1_1_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WFSCapabilities/v1.js
 * @requires HGIS/Format/OWSCommon/v1.js
 */

/**
 * Class: HGIS.Format.WFSCapabilities/v1_1_0
 * Read WFS Capabilities version 1.1.0.
 * 
 * Inherits from:
 *  - <HGIS.Format.WFSCapabilities>
 */
HGIS.Format.WFSCapabilities.v1_1_0 = HGIS.Class(
    HGIS.Format.WFSCapabilities.v1, {

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },
    
    /**
     * Constructor: HGIS.Format.WFSCapabilities.v1_1_0
     * Create a new parser for WFS capabilities version 1.1.0.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wfs": HGIS.Util.applyDefaults({
            "DefaultSRS": function(node, obj) {
                var defaultSRS = this.getChildValue(node);
                if (defaultSRS) {
                    obj.srs = defaultSRS;
                }
            }
        }, HGIS.Format.WFSCapabilities.v1.prototype.readers["wfs"]),
        "ows": HGIS.Format.OWSCommon.v1.prototype.readers.ows
    },

    CLASS_NAME: "HGIS.Format.WFSCapabilities.v1_1_0" 

});
/* ======================================================================
    HGIS/Layer/Image.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */
 
/**
 * @requires HGIS/Layer.js
 * @requires HGIS/Tile/Image.js
 */

/**
 * Class: HGIS.Layer.Image
 * Instances of HGIS.Layer.Image are used to display data from a web
 * accessible image as a map layer.  Create a new image layer with the
 * <HGIS.Layer.Image> constructor.
 *
 * Inherits from:
 *  - <HGIS.Layer>
 */
HGIS.Layer.Image = HGIS.Class(HGIS.Layer, {

    /**
     * Property: isBaseLayer
     * {Boolean} The layer is a base layer.  Default is true.  Set this property
     * in the layer options
     */
    isBaseLayer: true,
    
    /**
     * Property: url
     * {String} URL of the image to use
     */
    url: null,

    /**
     * Property: extent
     * {<HGIS.Bounds>} The image bounds in map units.  This extent will
     *     also be used as the default maxExtent for the layer.  If you wish
     *     to have a maxExtent that is different than the image extent, set the
     *     maxExtent property of the options argument (as with any other layer).
     */
    extent: null,
    
    /**
     * Property: size
     * {<HGIS.Size>} The image size in pixels
     */
    size: null,

    /**
     * Property: tile
     * {<HGIS.Tile.Image>}
     */
    tile: null,

    /**
     * Property: aspectRatio
     * {Float} The ratio of height/width represented by a single pixel in the
     * graphic
     */
    aspectRatio: null,

    /**
     * Constructor: HGIS.Layer.Image
     * Create a new image layer
     *
     * Parameters:
     * name - {String} A name for the layer.
     * url - {String} Relative or absolute path to the image
     * extent - {<HGIS.Bounds>} The extent represented by the image
     * size - {<HGIS.Size>} The size (in pixels) of the image
     * options - {Object} Hashtable of extra options to tag onto the layer
     */
    initialize: function(name, url, extent, size, options) {
        this.url = url;
        this.extent = extent;
        this.maxExtent = extent;
        this.size = size;
        HGIS.Layer.prototype.initialize.apply(this, [name, options]);

        this.aspectRatio = (this.extent.getHeight() / this.size.h) /
                           (this.extent.getWidth() / this.size.w);
    },    

    /**
     * Method: destroy
     * Destroy this layer
     */
    destroy: function() {
        if (this.tile) {
            this.removeTileMonitoringHooks(this.tile);
            this.tile.destroy();
            this.tile = null;
        }
        HGIS.Layer.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Method: clone
     * Create a clone of this layer
     *
     * Paramters:
     * obj - {Object} An optional layer (is this ever used?)
     *
     * Returns:
     * {<HGIS.Layer.Image>} An exact copy of this layer
     */
    clone: function(obj) {
        
        if(obj == null) {
            obj = new HGIS.Layer.Image(this.name,
                                               this.url,
                                               this.extent,
                                               this.size,
                                               this.getOptions());
        }

        //get all additions from superclasses
        obj = HGIS.Layer.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },    
    
    /**
     * APIMethod: setMap
     * 
     * Parameters:
     * map - {<HGIS.Map>}
     */
    setMap: function(map) {
        /**
         * If nothing to do with resolutions has been set, assume a single
         * resolution determined by ratio*extent/size - if an image has a
         * pixel aspect ratio different than one (as calculated above), the
         * image will be stretched in one dimension only.
         */
        if( this.options.maxResolution == null ) {
            this.options.maxResolution = this.aspectRatio *
                                         this.extent.getWidth() /
                                         this.size.w;
        }
        HGIS.Layer.prototype.setMap.apply(this, arguments);
    },

    /** 
     * Method: moveTo
     * Create the tile for the image or resize it for the new resolution
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     * zoomChanged - {Boolean}
     * dragging - {Boolean}
     */
    moveTo:function(bounds, zoomChanged, dragging) {
        HGIS.Layer.prototype.moveTo.apply(this, arguments);

        var firstRendering = (this.tile == null);

        if(zoomChanged || firstRendering) {

            //determine new tile size
            this.setTileSize();

            //determine new position (upper left corner of new bounds)
            var ulPx = this.map.getLayerPxFromLonLat({
                lon: this.extent.left,
                lat: this.extent.top
            });

            if(firstRendering) {
                //create the new tile
                this.tile = new HGIS.Tile.Image(this, ulPx, this.extent, 
                                                      null, this.tileSize);
                this.addTileMonitoringHooks(this.tile);
            } else {
                //just resize the tile and set it's new position
                this.tile.size = this.tileSize.clone();
                this.tile.position = ulPx.clone();
            }
            this.tile.draw();
        }
    }, 

    /**
     * Set the tile size based on the map size.
     */
    setTileSize: function() {
        var tileWidth = this.extent.getWidth() / this.map.getResolution();
        var tileHeight = this.extent.getHeight() / this.map.getResolution();
        this.tileSize = new HGIS.Size(tileWidth, tileHeight);
    },

    /** 
     * Method: addTileMonitoringHooks
     * This function takes a tile as input and adds the appropriate hooks to 
     *     the tile so that the layer can keep track of the loading tiles.
     * 
     * Parameters: 
     * tile - {<HGIS.Tile>}
     */
    addTileMonitoringHooks: function(tile) {
        tile.onLoadStart = function() {
            this.events.triggerEvent("loadstart");
        };
        tile.events.register("loadstart", this, tile.onLoadStart);
      
        tile.onLoadEnd = function() {
            this.events.triggerEvent("loadend");
        };
        tile.events.register("loadend", this, tile.onLoadEnd);
        tile.events.register("unload", this, tile.onLoadEnd);
    },

    /** 
     * Method: removeTileMonitoringHooks
     * This function takes a tile as input and removes the tile hooks 
     *     that were added in <addTileMonitoringHooks>.
     * 
     * Parameters: 
     * tile - {<HGIS.Tile>}
     */
    removeTileMonitoringHooks: function(tile) {
        tile.unload();
        tile.events.un({
            "loadstart": tile.onLoadStart,
            "loadend": tile.onLoadEnd,
            "unload": tile.onLoadEnd,
            scope: this
        });
    },
    
    /**
     * APIMethod: setUrl
     * 
     * Parameters:
     * newUrl - {String}
     */
    setUrl: function(newUrl) {
        this.url = newUrl;
        this.tile.draw();
    },

    /** 
     * APIMethod: getURL
     * The url we return is always the same (the image itself never changes)
     *     so we can ignore the bounds parameter (it will always be the same, 
     *     anyways) 
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     */
    getURL: function(bounds) {
        return this.url;
    },

    CLASS_NAME: "HGIS.Layer.Image"
});
/* ======================================================================
    HGIS/Strategy.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 */

/**
 * Class: HGIS.Strategy
 * Abstract vector layer strategy class.  Not to be instantiated directly.  Use
 *     one of the strategy subclasses instead.
 */
HGIS.Strategy = HGIS.Class({
    
    /**
     * Property: layer
     * {<HGIS.Layer.Vector>} The layer this strategy belongs to.
     */
    layer: null,
    
    /**
     * Property: options
     * {Object} Any options sent to the constructor.
     */
    options: null,

    /** 
     * Property: active 
     * {Boolean} The control is active.
     */
    active: null,

    /**
     * Property: autoActivate
     * {Boolean} The creator of the strategy can set autoActivate to false
     *      to fully control when the protocol is activated and deactivated.
     *      Defaults to true.
     */
    autoActivate: true,

    /**
     * Property: autoDestroy
     * {Boolean} The creator of the strategy can set autoDestroy to false
     *      to fully control when the strategy is destroyed. Defaults to
     *      true.
     */
    autoDestroy: true,

    /**
     * Constructor: HGIS.Strategy
     * Abstract class for vector strategies.  Create instances of a subclass.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
    initialize: function(options) {
        HGIS.Util.extend(this, options);
        this.options = options;
        // set the active property here, so that user cannot override it
        this.active = false;
    },
    
    /**
     * APIMethod: destroy
     * Clean up the strategy.
     */
    destroy: function() {
        this.deactivate();
        this.layer = null;
        this.options = null;
    },

    /**
     * Method: setLayer
     * Called to set the <layer> property.
     *
     * Parameters:
     * layer - {<HGIS.Layer.Vector>}
     */
    setLayer: function(layer) {
        this.layer = layer;
    },
    
    /**
     * Method: activate
     * Activate the strategy.  Register any listeners, do appropriate setup.
     *
     * Returns:
     * {Boolean} True if the strategy was successfully activated or false if
     *      the strategy was already active.
     */
    activate: function() {
        if (!this.active) {
            this.active = true;
            return true;
        }
        return false;
    },
    
    /**
     * Method: deactivate
     * Deactivate the strategy.  Unregister any listeners, do appropriate
     *     tear-down.
     *
     * Returns:
     * {Boolean} True if the strategy was successfully deactivated or false if
     *      the strategy was already inactive.
     */
    deactivate: function() {
        if (this.active) {
            this.active = false;
            return true;
        }
        return false;
    },
   
    CLASS_NAME: "HGIS.Strategy" 
});
/* ======================================================================
    HGIS/Strategy/Save.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Strategy.js
 */

/**
 * Class: HGIS.Strategy.Save
 * A strategy that commits newly created or modified features.  By default
 *     the strategy waits for a call to <save> before persisting changes.  By
 *     configuring the strategy with the <auto> option, changes can be saved
 *     automatically.
 *
 * Inherits from:
 *  - <HGIS.Strategy>
 */
HGIS.Strategy.Save = HGIS.Class(HGIS.Strategy, {
    
    /**
     * APIProperty: events
     * {<HGIS.Events>} An events object that handles all 
     *     events on the strategy object.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * strategy.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types:
     * start - Triggered before saving
     * success - Triggered after a successful transaction
     * fail - Triggered after a failed transaction
     * 
     */
 
    /** 
     * Property: events
     * {<HGIS.Events>} Events instance for triggering this protocol
     *    events.
     */
    events: null,
    
    /**
     * APIProperty: auto
     * {Boolean | Number} Auto-save.  Default is false.  If true, features will be
     *     saved immediately after being added to the layer and with each
     *     modification or deletion.  If auto is a number, features will be
     *     saved on an interval provided by the value (in seconds).
     */
    auto: false,
    
    /**
     * Property: timer
     * {Number} The id of the timer.
     */
    timer: null,

    /**
     * Constructor: HGIS.Strategy.Save
     * Create a new Save strategy.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
    initialize: function(options) {
        HGIS.Strategy.prototype.initialize.apply(this, [options]);
        this.events = new HGIS.Events(this);
    },
   
    /**
     * APIMethod: activate
     * Activate the strategy.  Register any listeners, do appropriate setup.
     * 
     * Returns:
     * {Boolean} The strategy was successfully activated.
     */
    activate: function() {
        var activated = HGIS.Strategy.prototype.activate.call(this);
        if(activated) {
            if(this.auto) {
                if(typeof this.auto === "number") {
                    this.timer = window.setInterval(
                        HGIS.Function.bind(this.save, this),
                        this.auto * 1000
                    );
                } else {
                    this.layer.events.on({
                        "featureadded": this.triggerSave,
                        "afterfeaturemodified": this.triggerSave,
                        scope: this
                    });
                }
            }
        }
        return activated;
    },
    
    /**
     * APIMethod: deactivate
     * Deactivate the strategy.  Unregister any listeners, do appropriate
     *     tear-down.
     * 
     * Returns:
     * {Boolean} The strategy was successfully deactivated.
     */
    deactivate: function() {
        var deactivated = HGIS.Strategy.prototype.deactivate.call(this);
        if(deactivated) {
            if(this.auto) {
                if(typeof this.auto === "number") {
                    window.clearInterval(this.timer);
                } else {
                    this.layer.events.un({
                        "featureadded": this.triggerSave,
                        "afterfeaturemodified": this.triggerSave,
                        scope: this
                    });
                }
            }
        }
        return deactivated;
    },
    
    /**
     * Method: triggerSave
     * Registered as a listener.  Calls save if a feature has insert, update,
     *     or delete state.
     *
     * Parameters:
     * event - {Object} The event this function is listening for.
     */
    triggerSave: function(event) {
        var feature = event.feature;
        if(feature.state === HGIS.State.INSERT ||
           feature.state === HGIS.State.UPDATE ||
           feature.state === HGIS.State.DELETE) {
            this.save([event.feature]);
        }
    },
    
    /**
     * APIMethod: save
     * Tell the layer protocol to commit unsaved features.  If the layer
     *     projection differs from the map projection, features will be
     *     transformed into the layer projection before being committed.
     *
     * Parameters:
     * features - {Array} Features to be saved.  If null, then default is all
     *     features in the layer.  Features are assumed to be in the map
     *     projection.
     */
    save: function(features) {
        if(!features) {
            features = this.layer.features;
        }
        this.events.triggerEvent("start", {features:features});
        var remote = this.layer.projection;
        var local = this.layer.map.getProjectionObject();
        if(!local.equals(remote)) {
            var len = features.length;
            var clones = new Array(len);
            var orig, clone;
            for(var i=0; i<len; ++i) {
                orig = features[i];
                clone = orig.clone();
                clone.fid = orig.fid;
                clone.state = orig.state;
                if(orig.url) {
                    clone.url = orig.url;
                }
                clone._original = orig;
                clone.geometry.transform(local, remote);
                clones[i] = clone;
            }
            features = clones;
        }
        this.layer.protocol.commit(features, {
            callback: this.onCommit,
            scope: this
        });
    },
    
    /**
     * Method: onCommit
     * Called after protocol commit.
     *
     * Parameters:
     * response - {<HGIS.Protocol.Response>} A response object.
     */
    onCommit: function(response) {
        var evt = {"response": response};
        if(response.success()) {
            var features = response.reqFeatures;
            // deal with inserts, updates, and deletes
            var state, feature;
            var destroys = [];
            var insertIds = response.insertIds || [];
            var j = 0;
            for(var i=0, len=features.length; i<len; ++i) {
                feature = features[i];
                // if projection was different, we may be dealing with clones
                feature = feature._original || feature;
                state = feature.state;
                if(state) {
                    if(state == HGIS.State.DELETE) {
                        destroys.push(feature);
                    } else if(state == HGIS.State.INSERT) {
                        feature.fid = insertIds[j];
                        ++j;
                    }
                    feature.state = null;
                }
            }

            if(destroys.length > 0) {
                this.layer.destroyFeatures(destroys);
            }

            this.events.triggerEvent("success", evt);

        } else {
            this.events.triggerEvent("fail", evt);
        }
    },
   
    CLASS_NAME: "HGIS.Strategy.Save" 
});
/* ======================================================================
    HGIS/Events/featureclick.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Events.js
 */

/**
 * Class: HGIS.Events.featureclick
 *
 * Extension event type for handling feature click events, including overlapping
 * features. 
 * 
 * Event types provided by this extension:
 * - featureclick 
 */
HGIS.Events.featureclick = HGIS.Class({
    
    /**
     * Property: cache
     * {Object} A cache of features under the mouse.
     */
    cache: null,
    
    /**
     * Property: map
     * {<HGIS.Map>} The map to register browser events on.
     */
    map: null,
    
    /**
     * Property: provides
     * {Array(String)} The event types provided by this extension.
     */
    provides: ["featureclick", "nofeatureclick", "featureover", "featureout"],
    
    /**
     * Constructor: HGIS.Events.featureclick
     * Create a new featureclick event type.
     *
     * Parameters:
     * target - {<HGIS.Events>} The events instance to create the events
     *     for.
     */
    initialize: function(target) {
        this.target = target;
        if (target.object instanceof HGIS.Map) {
            this.setMap(target.object);
        } else if (target.object instanceof HGIS.Layer.Vector) {
            if (target.object.map) {
                this.setMap(target.object.map);
            } else {
                target.object.events.register("added", this, function(evt) {
                    this.setMap(target.object.map);
                });
            }
        } else {
            throw("Listeners for '" + this.provides.join("', '") +
                "' events can only be registered for HGIS.Layer.Vector " + 
                "or HGIS.Map instances");
        }
        for (var i=this.provides.length-1; i>=0; --i) {
            target.extensions[this.provides[i]] = true;
        }
    },
    
    /**
     * Method: setMap
     *
     * Parameters:
     * map - {<HGIS.Map>} The map to register browser events on.
     */
    setMap: function(map) {
        this.map = map;
        this.cache = {};
        map.events.register("mousedown", this, this.start, {extension: true});
        map.events.register("mouseup", this, this.onClick, {extension: true});
        map.events.register("touchstart", this, this.start, {extension: true});
        map.events.register("touchmove", this, this.cancel, {extension: true});
        map.events.register("touchend", this, this.onClick, {extension: true});
        map.events.register("mousemove", this, this.onMousemove, {extension: true});
    },
    
    /**
     * Method: start
     * Sets startEvt = evt.
     *
     * Parameters:
     * evt - {<HGIS.Event>}
     */
    start: function(evt) {
        this.startEvt = evt;
    },
    
    /**
     * Method: cancel
     * Deletes the start event.
     *
     * Parameters:
     * evt - {<HGIS.Event>}
     */    
    cancel: function(evt) {
        delete this.startEvt;
    },
    
    /**
     * Method: onClick
     * Listener for the click event.
     *
     * Parameters:
     * evt - {<HGIS.Event>}
     */
    onClick: function(evt) {
        if (!this.startEvt || evt.type !== "touchend" &&
                !HGIS.Event.isLeftClick(evt)) {
            return;
        }
        var features = this.getFeatures(this.startEvt);
        delete this.startEvt;
        // fire featureclick events
        var feature, layer, more, clicked = {};
        for (var i=0, len=features.length; i<len; ++i) {
            feature = features[i];
            layer = feature.layer;
            clicked[layer.id] = true;
            more = this.triggerEvent("featureclick", {feature: feature});
            if (more === false) {
                break;
            }
        }
        // fire nofeatureclick events on all vector layers with no targets
        for (i=0, len=this.map.layers.length; i<len; ++i) {
            layer = this.map.layers[i];
            if (layer instanceof HGIS.Layer.Vector && !clicked[layer.id]) {
                this.triggerEvent("nofeatureclick", {layer: layer});
            }
        }
    },
    
    /**
     * Method: onMousemove
     * Listener for the mousemove event.
     *
     * Parameters:
     * evt - {<HGIS.Event>}
     */
    onMousemove: function(evt) {
        delete this.startEvt;
        var features = this.getFeatures(evt);
        var over = {}, newly = [], feature;
        for (var i=0, len=features.length; i<len; ++i) {
            feature = features[i];
            over[feature.id] = feature;
            if (!this.cache[feature.id]) {
                newly.push(feature);
            }
        }
        // check if already over features
        var out = [];
        for (var id in this.cache) {
            feature = this.cache[id];
            if (feature.layer && feature.layer.map) {
                if (!over[feature.id]) {
                    out.push(feature);
                }
            } else {
                // removed
                delete this.cache[id];
            }
        }
        // fire featureover events
        var more;
        for (i=0, len=newly.length; i<len; ++i) {
            feature = newly[i];
            this.cache[feature.id] = feature;
            more = this.triggerEvent("featureover", {feature: feature});
            if (more === false) {
                break;
            }
        }
        // fire featureout events
        for (i=0, len=out.length; i<len; ++i) {
            feature = out[i];
            delete this.cache[feature.id];
            more = this.triggerEvent("featureout", {feature: feature});
            if (more === false) {
                break;
            }
        }
    },
    
    /**
     * Method: triggerEvent
     * Determines where to trigger the event and triggers it.
     *
     * Parameters:
     * type - {String} The event type to trigger
     * evt - {Object} The listener argument
     *
     * Returns:
     * {Boolean} The last listener return.
     */
    triggerEvent: function(type, evt) {
        var layer = evt.feature ? evt.feature.layer : evt.layer,
            object = this.target.object;
        if (object instanceof HGIS.Map || object === layer) {
            return this.target.triggerEvent(type, evt);
        }
    },

    /**
     * Method: getFeatures
     * Get all features at the given screen location.
     *
     * Parameters:
     * evt - {Object} Event object.
     *
     * Returns:
     * {Array(<HGIS.Feature.Vector>)} List of features at the given point.
     */
    getFeatures: function(evt) {
        var x = evt.clientX, y = evt.clientY,
            features = [], targets = [], layers = [],
            layer, target, feature, i, len;
        // go through all layers looking for targets
        for (i=this.map.layers.length-1; i>=0; --i) {
            layer = this.map.layers[i];
            if (layer.div.style.display !== "none") {
                if (layer.renderer instanceof HGIS.Renderer.Elements) {
                    if (layer instanceof HGIS.Layer.Vector) {
                        target = document.elementFromPoint(x, y);
                        while (target && target._featureId) {
                            feature = layer.getFeatureById(target._featureId);
                            if (feature) {
                                features.push(feature);
                                target.style.display = "none";
                                targets.push(target);
                                target = document.elementFromPoint(x, y);
                            } else {
                                // sketch, all bets off
                                target = false;
                            }
                        }
                    }
                    layers.push(layer);
                    layer.div.style.display = "none";
                } else if (layer.renderer instanceof HGIS.Renderer.Canvas) {
                    feature = layer.renderer.getFeatureIdFromEvent(evt);
                    if (feature) {
                        features.push(feature);
                        layers.push(layer);
                    }
                }
            }
        }
        // restore feature visibility
        for (i=0, len=targets.length; i<len; ++i) {
            targets[i].style.display = "";
        }
        // restore layer visibility
        for (i=layers.length-1; i>=0; --i) {
            layers[i].div.style.display = "block";
        }
        return features;
    },
    
    /**
     * APIMethod: destroy
     * Clean up.
     */
    destroy: function() {
        for (var i=this.provides.length-1; i>=0; --i) {
            delete this.target.extensions[this.provides[i]];
        }        
        this.map.events.un({
            mousemove: this.onMousemove,
            mousedown: this.start,
            mouseup: this.onClick,
            touchstart: this.start,
            touchmove: this.cancel,
            touchend: this.onClick,
            scope: this
        });
        delete this.cache;
        delete this.map;
        delete this.target;
    }
    
});
 
/**
 * Class: HGIS.Events.nofeatureclick
 *
 * Extension event type for handling click events that do not hit a feature. 
 * 
 * Event types provided by this extension:
 * - nofeatureclick 
 */
HGIS.Events.nofeatureclick = HGIS.Events.featureclick;

/**
 * Class: HGIS.Events.featureover
 *
 * Extension event type for handling hovering over a feature. 
 * 
 * Event types provided by this extension:
 * - featureover 
 */
HGIS.Events.featureover = HGIS.Events.featureclick;

/**
 * Class: HGIS.Events.featureout
 *
 * Extension event type for handling leaving a feature. 
 * 
 * Event types provided by this extension:
 * - featureout 
 */
HGIS.Events.featureout = HGIS.Events.featureclick;
/* ======================================================================
    HGIS/Format/GPX.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Geometry/Point.js
 * @requires HGIS/Geometry/LineString.js
 * @requires HGIS/Projection.js
 */

/**
 * Class: HGIS.Format.GPX
 * Read/write GPX parser. Create a new instance with the 
 *     <HGIS.Format.GPX> constructor.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.GPX = HGIS.Class(HGIS.Format.XML, {
    

    /** 
     * APIProperty: defaultDesc
     * {String} Default description for the waypoints/tracks in the case
     *     where the feature has no "description" attribute.
     *     Default is "No description available".
     */
    defaultDesc: "No description available",

   /**
    * APIProperty: extractWaypoints
    * {Boolean} Extract waypoints from GPX. (default: true)
    */
    extractWaypoints: true,
    
   /**
    * APIProperty: extractTracks
    * {Boolean} Extract tracks from GPX. (default: true)
    */
    extractTracks: true,
    
   /**
    * APIProperty: extractRoutes
    * {Boolean} Extract routes from GPX. (default: true)
    */
    extractRoutes: true,
    
    /**
     * APIProperty: extractAttributes
     * {Boolean} Extract feature attributes from GPX. (default: true)
     *     NOTE: Attributes as part of extensions to the GPX standard may not
     *     be extracted.
     */
    extractAttributes: true,

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        gpx: "http://www.topografix.com/GPX/1/1",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Property: schemaLocation
     * {String} Schema location. Defaults to
     *  "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd"
     */
    schemaLocation: "http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd",

    /**
     * APIProperty: creator
     * {String} The creator attribute to be added to the written GPX files.
     * Defaults to "HGIS"
     */
    creator: "HGIS",
    
    /**
     * Constructor: HGIS.Format.GPX
     * Create a new parser for GPX.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        // GPX coordinates are always in longlat WGS84
        this.externalProjection = new HGIS.Projection("EPSG:4326");

        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * APIMethod: read
     * Return a list of features from a GPX doc
     *
     * Parameters:
     * doc - {Element} 
     *
     * Returns:
     * Array({<HGIS.Feature.Vector>})
     */
    read: function(doc) {
        if (typeof doc == "string") { 
            doc = HGIS.Format.XML.prototype.read.apply(this, [doc]);
        }
        var features = [];
        
        if(this.extractTracks) {
            var tracks = doc.getElementsByTagName("trk");
            for (var i=0, len=tracks.length; i<len; i++) {
                // Attributes are only in trk nodes, not trkseg nodes
                var attrs = {};
                if(this.extractAttributes) {
                    attrs = this.parseAttributes(tracks[i]);
                }
                
                var segs = this.getElementsByTagNameNS(tracks[i], tracks[i].namespaceURI, "trkseg");
                for (var j = 0, seglen = segs.length; j < seglen; j++) {
                    // We don't yet support extraction of trkpt attributes
                    // All trksegs of a trk get that trk's attributes
                    var track = this.extractSegment(segs[j], "trkpt");
                    features.push(new HGIS.Feature.Vector(track, attrs));
                }
            }
        }
        
        if(this.extractRoutes) {
            var routes = doc.getElementsByTagName("rte");
            for (var k=0, klen=routes.length; k<klen; k++) {
                var attrs = {};
                if(this.extractAttributes) {
                    attrs = this.parseAttributes(routes[k]);
                }
                var route = this.extractSegment(routes[k], "rtept");
                features.push(new HGIS.Feature.Vector(route, attrs));
            }
        }
        
        if(this.extractWaypoints) {
            var waypoints = doc.getElementsByTagName("wpt");
            for (var l = 0, len = waypoints.length; l < len; l++) {
                var attrs = {};
                if(this.extractAttributes) {
                    attrs = this.parseAttributes(waypoints[l]);
                }
                var wpt = new HGIS.Geometry.Point(waypoints[l].getAttribute("lon"), waypoints[l].getAttribute("lat"));
                features.push(new HGIS.Feature.Vector(wpt, attrs));
            }
        }
        
        if (this.internalProjection && this.externalProjection) {
            for (var g = 0, featLength = features.length; g < featLength; g++) {
                features[g].geometry.transform(this.externalProjection,
                                    this.internalProjection);
            }
        }
        
        return features;
    },
    
   /**
    * Method: extractSegment
    *
    * Parameters:
    * segment - {DOMElement} a trkseg or rte node to parse
    * segmentType - {String} nodeName of waypoints that form the line
    *
    * Returns:
    * {<HGIS.Geometry.LineString>} A linestring geometry
    */
    extractSegment: function(segment, segmentType) {
        var points = this.getElementsByTagNameNS(segment, segment.namespaceURI, segmentType);
        var point_features = [];
        for (var i = 0, len = points.length; i < len; i++) {
            point_features.push(new HGIS.Geometry.Point(points[i].getAttribute("lon"), points[i].getAttribute("lat")));
        }
        return new HGIS.Geometry.LineString(point_features);
    },
    
    /**
     * Method: parseAttributes
     *
     * Parameters:
     * node - {<DOMElement>}
     *
     * Returns:
     * {Object} An attributes object.
     */
    parseAttributes: function(node) {
        // node is either a wpt, trk or rte
        // attributes are children of the form <attr>value</attr>
        var attributes = {};
        var attrNode = node.firstChild, value, name;
        while(attrNode) {
            if(attrNode.nodeType == 1 && attrNode.firstChild) {
                value = attrNode.firstChild;
                if(value.nodeType == 3 || value.nodeType == 4) {
                    name = (attrNode.prefix) ?
                        attrNode.nodeName.split(":")[1] :
                        attrNode.nodeName;
                    if(name != "trkseg" && name != "rtept") {
                        attributes[name] = value.nodeValue;
                    }
                }
            }
            attrNode = attrNode.nextSibling;
        }
        return attributes;
    },

    /**
     * APIMethod: write
     * Accepts Feature Collection, and returns a string. 
     * 
     * Parameters: 
     * features - {Array(<HGIS.Feature.Vector>)} List of features to serialize into a string.
     * metadata - {Object} A key/value pairs object to build a metadata node to
     *      add to the gpx. Supported keys are 'name', 'desc', 'author'.
     */
    write: function(features, metadata) {
        features = HGIS.Util.isArray(features) ?
            features : [features];
        var gpx = this.createElementNS(this.namespaces.gpx, "gpx");
        gpx.setAttribute("version", "1.1");
        gpx.setAttribute("creator", this.creator);
        this.setAttributes(gpx, {
            "xsi:schemaLocation": this.schemaLocation
        });

        if (metadata && typeof metadata == 'object') {
            gpx.appendChild(this.buildMetadataNode(metadata));
        }
        for(var i=0, len=features.length; i<len; i++) {
            gpx.appendChild(this.buildFeatureNode(features[i]));
        }
        return HGIS.Format.XML.prototype.write.apply(this, [gpx]);
    },

    /**
     * Method: buildMetadataNode
     * Creates a "metadata" node.
     *
     * Returns:
     * {DOMElement}
     */
    buildMetadataNode: function(metadata) {
        var types = ['name', 'desc', 'author'],
            node = this.createElementNS(this.namespaces.gpx, 'metadata');
        for (var i=0; i < types.length; i++) {
            var type = types[i];
            if (metadata[type]) {
                var n = this.createElementNS(this.namespaces.gpx, type);
                n.appendChild(this.createTextNode(metadata[type]));
                node.appendChild(n);
            }
        }
        return node;
    },

    /**
     * Method: buildFeatureNode
     * Accepts an <HGIS.Feature.Vector>, and builds a node for it.
     * 
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     *
     * Returns:
     * {DOMElement} - The created node, either a 'wpt' or a 'trk'.
     */
    buildFeatureNode: function(feature) {
        var geometry = feature.geometry;
            geometry = geometry.clone();
        if (this.internalProjection && this.externalProjection) {
            geometry.transform(this.internalProjection, 
                               this.externalProjection);
        }
        if (geometry.CLASS_NAME == "HGIS.Geometry.Point") {
            var wpt = this.buildWptNode(geometry);
            this.appendAttributesNode(wpt, feature);
            return wpt;
        } else {
            var trkNode = this.createElementNS(this.namespaces.gpx, "trk");
            this.appendAttributesNode(trkNode, feature);
            var trkSegNodes = this.buildTrkSegNode(geometry);
            trkSegNodes = HGIS.Util.isArray(trkSegNodes) ?
                trkSegNodes : [trkSegNodes];
            for (var i = 0, len = trkSegNodes.length; i < len; i++) {
                trkNode.appendChild(trkSegNodes[i]);
            }
            return trkNode;
        }
    },

    /**
     * Method: buildTrkSegNode
     * Builds trkseg node(s) given a geometry
     *
     * Parameters:
     * trknode
     * geometry - {<HGIS.Geometry>}
     */
    buildTrkSegNode: function(geometry) {
        var node,
            i,
            len,
            point,
            nodes;
        if (geometry.CLASS_NAME == "HGIS.Geometry.LineString" ||
            geometry.CLASS_NAME == "HGIS.Geometry.LinearRing") {
            node = this.createElementNS(this.namespaces.gpx, "trkseg");
            for (i = 0, len=geometry.components.length; i < len; i++) {
                point = geometry.components[i];
                node.appendChild(this.buildTrkPtNode(point));
            }
            return node;
        } else {
            nodes = [];
            for (i = 0, len = geometry.components.length; i < len; i++) {
                nodes.push(this.buildTrkSegNode(geometry.components[i]));
            }
            return nodes;
        }
    },
    
    /**
     * Method: buildTrkPtNode
     * Builds a trkpt node given a point 
     *
     * Parameters:
     * point - {<HGIS.Geometry.Point>}
     *
     * Returns:
     * {DOMElement} A trkpt node
     */
    buildTrkPtNode: function(point) {
        var node = this.createElementNS(this.namespaces.gpx, "trkpt");
        node.setAttribute("lon", point.x);
        node.setAttribute("lat", point.y);
        return node;
    },

    /**
     * Method: buildWptNode
     * Builds a wpt node given a point
     *
     * Parameters:
     * geometry - {<HGIS.Geometry.Point>}
     *
     * Returns:
     * {DOMElement} A wpt node
     */
    buildWptNode: function(geometry) {
        var node = this.createElementNS(this.namespaces.gpx, "wpt");
        node.setAttribute("lon", geometry.x);
        node.setAttribute("lat", geometry.y);
        return node;
    },

    /**
     * Method: appendAttributesNode
     * Adds some attributes node.
     *
     * Parameters:
     * node - {DOMElement} the node to append the attribute nodes to.
     * feature - {<HGIS.Feature.Vector>}
     */
    appendAttributesNode: function(node, feature) {
        var name = this.createElementNS(this.namespaces.gpx, 'name');
        name.appendChild(this.createTextNode(
            feature.attributes.name || feature.id));
        node.appendChild(name);
        var desc = this.createElementNS(this.namespaces.gpx, 'desc');
        desc.appendChild(this.createTextNode(
            feature.attributes.description || this.defaultDesc));
        node.appendChild(desc);
        // TBD - deal with remaining (non name/description) attributes.
    },

    CLASS_NAME: "HGIS.Format.GPX"
});
/* ======================================================================
    HGIS/Format/WMSDescribeLayer.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML/VersionedOGC.js
 */

/**
 * Class: HGIS.Format.WMSDescribeLayer
 * Read SLD WMS DescribeLayer response
 * DescribeLayer is meant to couple WMS to WFS and WCS
 * 
 * Inherits from:
 *  - <HGIS.Format.XML.VersionedOGC>
 */
HGIS.Format.WMSDescribeLayer = HGIS.Class(HGIS.Format.XML.VersionedOGC, {

    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.1.1".
     */
    defaultVersion: "1.1.1",
   
    /**
     * Constructor: HGIS.Format.WMSDescribeLayer
     * Create a new parser for WMS DescribeLayer responses.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read DescribeLayer data from a string, and return the response. 
     * The OGC currently defines 2 formats which are allowed for output,
     * so we need to parse these 2 types
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array} Array of {<LayerDescription>} objects which have:
     * - {String} owsType: WFS/WCS
     * - {String} owsURL: the online resource
     * - {String} typeName: the name of the typename on the service
     */
    
    CLASS_NAME: "HGIS.Format.WMSDescribeLayer" 

});
/* ======================================================================
    HGIS/Format/WMSDescribeLayer/v1_1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WMSDescribeLayer.js
 * @requires HGIS/Format/OGCExceptionReport.js
 */

/**
 * Class: HGIS.Format.WMSDescribeLayer.v1_1_1
 * Read SLD WMS DescribeLayer response for WMS 1.1.X
 * WMS 1.1.X is tightly coupled to SLD 1.0.0
 *
 * Example DescribeLayer request: 
 * http://demo.opengeo.org/geoserver/wms?request=DescribeLayer&version=1.1.1&layers=topp:states
 *
 * Inherits from:
 *  - <HGIS.Format.WMSDescribeLayer>
 */
HGIS.Format.WMSDescribeLayer.v1_1_1 = HGIS.Class(
    HGIS.Format.WMSDescribeLayer, {
    
    /**
     * Constructor: HGIS.Format.WMSDescribeLayer
     * Create a new parser for WMS DescribeLayer responses.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        HGIS.Format.WMSDescribeLayer.prototype.initialize.apply(this, 
            [options]);
    },

    /**
     * APIMethod: read
     * Read DescribeLayer data from a string, and return the response. 
     * The OGC defines 2 formats which are allowed for output,
     * so we need to parse these 2 types for version 1.1.X
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Object with a layerDescriptions property, which holds an Array
     * of {<LayerDescription>} objects which have:
     * - {String} owsType: WFS/WCS
     * - {String} owsURL: the online resource
     * - {String} typeName: the name of the typename on the owsType service
     * - {String} layerName: the name of the WMS layer we did a lookup for
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        var root = data.documentElement;
        var children = root.childNodes; 
        var describelayer = {layerDescriptions: []};
        var childNode, nodeName;
        for(var i=0; i<children.length; ++i) { 
            childNode = children[i];
            nodeName = childNode.nodeName; 
            if (nodeName == 'LayerDescription') {
                var layerName = childNode.getAttribute('name');
                var owsType = '';
                var owsURL = '';
                var typeName = '';
                // check for owsType and owsURL attributes
                if (childNode.getAttribute('owsType')) {
                  owsType = childNode.getAttribute('owsType');
                  owsURL = childNode.getAttribute('owsURL');
                } else {
                    // look for wfs or wcs attribute
                    if (childNode.getAttribute('wfs') != '') {
                        owsType = 'WFS';
                        owsURL = childNode.getAttribute('wfs');
                    } else if (childNode.getAttribute('wcs') != '') {
                        owsType = 'WCS';
                        owsURL = childNode.getAttribute('wcs');
                    }
                }
                // look for Query child
                var query = childNode.getElementsByTagName('Query');
                if(query.length > 0) {
                    typeName = query[0].getAttribute('typeName');
                    if (!typeName) {
                        // because of Ionic bug
                        typeName = query[0].getAttribute('typename');
                    }
                }
                var layerDescription = {
                    layerName: layerName, owsType: owsType, 
                    owsURL: owsURL, typeName: typeName
                };
                describelayer.layerDescriptions.push(layerDescription);
                
                //TODO do this in deprecated.js instead:
                // array style index for backwards compatibility
                describelayer.length = describelayer.layerDescriptions.length;
                describelayer[describelayer.length - 1] = layerDescription; 
                
            } else if (nodeName == 'ServiceException') {
                // an exception must have occurred, so parse it
                var parser = new HGIS.Format.OGCExceptionReport();
                return {
                    error: parser.read(data)
                };
            }
        }
        return describelayer;
    },
    
    CLASS_NAME: "HGIS.Format.WMSDescribeLayer.v1_1_1"

});

// Version alias - workaround for http://trac.osgeo.org/mapserver/ticket/2257
HGIS.Format.WMSDescribeLayer.v1_1_0 =
    HGIS.Format.WMSDescribeLayer.v1_1_1;
/* ======================================================================
    HGIS/Layer/XYZ.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer/Grid.js
 */

/** 
 * Class: HGIS.Layer.XYZ
 * The XYZ class is designed to make it easier for people who have tiles
 * arranged by a standard XYZ grid. 
 * 
 * Inherits from:
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.XYZ = HGIS.Class(HGIS.Layer.Grid, {
    
    /**
     * APIProperty: isBaseLayer
     * Default is true, as this is designed to be a base tile source. 
     */
    isBaseLayer: true,
    
    /**
     * APIProperty: sphericalMercator
     * Whether the tile extents should be set to the defaults for 
     *    spherical mercator. Useful for things like OpenStreetMap.
     *    Default is false, except for the OSM subclass.
     */
    sphericalMercator: false,

    /**
     * APIProperty: zoomOffset
     * {Number} If your cache has more zoom levels than you want to provide
     *     access to with this layer, supply a zoomOffset.  This zoom offset
     *     is added to the current map zoom level to determine the level
     *     for a requested tile.  For example, if you supply a zoomOffset
     *     of 3, when the map is at the zoom 0, tiles will be requested from
     *     level 3 of your cache.  Default is 0 (assumes cache level and map
     *     zoom are equivalent).  Using <zoomOffset> is an alternative to
     *     setting <serverResolutions> if you only want to expose a subset
     *     of the server resolutions.
     */
    zoomOffset: 0,
    
    /**
     * APIProperty: serverResolutions
     * {Array} A list of all resolutions available on the server.  Only set this
     *     property if the map resolutions differ from the server. This
     *     property serves two purposes. (a) <serverResolutions> can include
     *     resolutions that the server supports and that you don't want to
     *     provide with this layer; you can also look at <zoomOffset>, which is
     *     an alternative to <serverResolutions> for that specific purpose.
     *     (b) The map can work with resolutions that aren't supported by
     *     the server, i.e. that aren't in <serverResolutions>. When the
     *     map is displayed in such a resolution data for the closest
     *     server-supported resolution is loaded and the layer div is
     *     stretched as necessary.
     */
    serverResolutions: null,

    /**
     * Constructor: HGIS.Layer.XYZ
     *
     * Parameters:
     * name - {String}
     * url - {String}
     * options - {Object} Hashtable of extra options to tag onto the layer
     */
    initialize: function(name, url, options) {
        if (options && options.sphericalMercator || this.sphericalMercator) {
            options = HGIS.Util.extend({
                projection: "EPSG:900913",
                numZoomLevels: 19
            }, options);
        }
        HGIS.Layer.Grid.prototype.initialize.apply(this, [
            name || this.name, url || this.url, {}, options
        ]);
    },
    
    /**
     * APIMethod: clone
     * Create a clone of this layer
     *
     * Parameters:
     * obj - {Object} Is this ever used?
     * 
     * Returns:
     * {<HGIS.Layer.XYZ>} An exact clone of this HGIS.Layer.XYZ
     */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new HGIS.Layer.XYZ(this.name,
                                            this.url,
                                            this.getOptions());
        }

        //get all additions from superclasses
        obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);

        return obj;
    },    

    /**
     * Method: getURL
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     *
     * Returns:
     * {String} A string with the layer's url and parameters and also the
     *          passed-in bounds and appropriate tile size specified as
     *          parameters
     */
    getURL: function (bounds) {
        var xyz = this.getXYZ(bounds);
        var url = this.url;
        if (HGIS.Util.isArray(url)) {
            var s = '' + xyz.x + xyz.y + xyz.z;
            url = this.selectUrl(s, url);
        }
        
        return HGIS.String.format(url, xyz);
    },
    
    /**
     * Method: getXYZ
     * Calculates x, y and z for the given bounds.
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     *
     * Returns:
     * {Object} - an object with x, y and z properties.
     */
    getXYZ: function(bounds) {
        var res = this.getServerResolution();
        var x = Math.round((bounds.left - this.maxExtent.left) /
            (res * this.tileSize.w));
        var y = Math.round((this.maxExtent.top - bounds.top) /
            (res * this.tileSize.h));
        var z = this.getServerZoom();

        if (this.wrapDateLine) {
            var limit = Math.pow(2, z);
            x = ((x % limit) + limit) % limit;
        }

        return {'x': x, 'y': y, 'z': z};
    },
    
    /* APIMethod: setMap
     * When the layer is added to a map, then we can fetch our origin 
     *    (if we don't have one.) 
     * 
     * Parameters:
     * map - {<HGIS.Map>}
     */
    setMap: function(map) {
        HGIS.Layer.Grid.prototype.setMap.apply(this, arguments);
        if (!this.tileOrigin) { 
            this.tileOrigin = new HGIS.LonLat(this.maxExtent.left,
                                                this.maxExtent.bottom);
        }                                       
    },

    CLASS_NAME: "HGIS.Layer.XYZ"
});
/* ======================================================================
    HGIS/Layer/OSM.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer/XYZ.js
 */

/**
 * Class: HGIS.Layer.OSM
 * This layer allows accessing OpenStreetMap tiles. By default the OpenStreetMap
 *    hosted tile.openstreetmap.org Mapnik tileset is used. If you wish to use
 *    a different layer instead, you need to provide a different
 *    URL to the constructor. Here's an example for using OpenCycleMap:
 * 
 * (code)
 *     new HGIS.Layer.OSM("OpenCycleMap", 
 *       ["http://a.tile.opencyclemap.org/cycle/${z}/${x}/${y}.png",
 *        "http://b.tile.opencyclemap.org/cycle/${z}/${x}/${y}.png",
 *        "http://c.tile.opencyclemap.org/cycle/${z}/${x}/${y}.png"]); 
 * (end)
 *
 * Inherits from:
 *  - <HGIS.Layer.XYZ>
 */
HGIS.Layer.OSM = HGIS.Class(HGIS.Layer.XYZ, {

    /**
     * APIProperty: name
     * {String} The layer name. Defaults to "OpenStreetMap" if the first
     * argument to the constructor is null or undefined.
     */
    name: "OpenStreetMap",

    /**
     * APIProperty: url
     * {String} The tileset URL scheme. Defaults to
     * : http://[a|b|c].tile.openstreetmap.org/${z}/${x}/${y}.png
     * (the official OSM tileset) if the second argument to the constructor
     * is null or undefined. To use another tileset you can have something
     * like this:
     * (code)
     *     new HGIS.Layer.OSM("OpenCycleMap", 
     *       ["http://a.tile.opencyclemap.org/cycle/${z}/${x}/${y}.png",
     *        "http://b.tile.opencyclemap.org/cycle/${z}/${x}/${y}.png",
     *        "http://c.tile.opencyclemap.org/cycle/${z}/${x}/${y}.png"]); 
     * (end)
     */
    url: [
        'http://a.tile.openstreetmap.org/${z}/${x}/${y}.png',
        'http://b.tile.openstreetmap.org/${z}/${x}/${y}.png',
        'http://c.tile.openstreetmap.org/${z}/${x}/${y}.png'
    ],

    /**
     * Property: attribution
     * {String} The layer attribution.
     */
    attribution: "&copy; <a href='http://www.openstreetmap.org/copyright'>OpenStreetMap</a> contributors",

    /**
     * Property: sphericalMercator
     * {Boolean}
     */
    sphericalMercator: true,

    /**
     * Property: wrapDateLine
     * {Boolean}
     */
    wrapDateLine: true,

    /** APIProperty: tileOptions
     *  {Object} optional configuration options for <HGIS.Tile> instances
     *  created by this Layer. Default is
     *
     *  (code)
     *  {crossOriginKeyword: 'anonymous'}
     *  (end)
     *
     *  When using OSM tilesets other than the default ones, it may be
     *  necessary to set this to
     *
     *  (code)
     *  {crossOriginKeyword: null}
     *  (end)
     *
     *  if the server does not send Access-Control-Allow-Origin headers.
     */
    tileOptions: null,

    /**
     * Constructor: HGIS.Layer.OSM
     *
     * Parameters:
     * name - {String} The layer name.
     * url - {String} The tileset URL scheme.
     * options - {Object} Configuration options for the layer. Any inherited
     *     layer option can be set in this object (e.g.
     *     <HGIS.Layer.Grid.buffer>).
     */
    initialize: function(name, url, options) {
        HGIS.Layer.XYZ.prototype.initialize.apply(this, arguments);
        this.tileOptions = HGIS.Util.extend({
            crossOriginKeyword: 'anonymous'
        }, this.options && this.options.tileOptions);
    },

    /**
     * Method: clone
     */
    clone: function(obj) {
        if (obj == null) {
            obj = new HGIS.Layer.OSM(
                this.name, this.url, this.getOptions());
        }
        obj = HGIS.Layer.XYZ.prototype.clone.apply(this, [obj]);
        return obj;
    },

    CLASS_NAME: "HGIS.Layer.OSM"
});
/* ======================================================================
    HGIS/Renderer.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 */

/**
 * Class: HGIS.Renderer 
 * This is the base class for all renderers.
 *
 * This is based on a merger code written by Paul Spencer and Bertil Chapuis.
 * It is largely composed of virtual functions that are to be implemented
 * in technology-specific subclasses, but there is some generic code too.
 * 
 * The functions that *are* implemented here merely deal with the maintenance
 *  of the size and extent variables, as well as the cached 'resolution' 
 *  value. 
 * 
 * A note to the user that all subclasses should use getResolution() instead
 *  of directly accessing this.resolution in order to correctly use the 
 *  cacheing system.
 *
 */
HGIS.Renderer = HGIS.Class({

    /** 
     * Property: container
     * {DOMElement} 
     */
    container: null,
    
    /**
     * Property: root
     * {DOMElement}
     */
    root: null,

    /** 
     * Property: extent
     * {<HGIS.Bounds>}
     */
    extent: null,

    /**
     * Property: locked
     * {Boolean} If the renderer is currently in a state where many things
     *     are changing, the 'locked' property is set to true. This means 
     *     that renderers can expect at least one more drawFeature event to be
     *     called with the 'locked' property set to 'true': In some renderers,
     *     this might make sense to use as a 'only update local information'
     *     flag. 
     */  
    locked: false,
    
    /** 
     * Property: size
     * {<HGIS.Size>} 
     */
    size: null,
    
    /**
     * Property: resolution
     * {Float} cache of current map resolution
     */
    resolution: null,
    
    /**
     * Property: map  
     * {<HGIS.Map>} Reference to the map -- this is set in Vector's setMap()
     */
    map: null,
    
    /**
     * Property: featureDx
     * {Number} Feature offset in x direction. Will be calculated for and
     * applied to the current feature while rendering (see
     * <calculateFeatureDx>).
     */
    featureDx: 0,
    
    /**
     * Constructor: HGIS.Renderer 
     *
     * Parameters:
     * containerID - {<String>} 
     * options - {Object} options for this renderer. See sublcasses for
     *     supported options.
     */
    initialize: function(containerID, options) {
        this.container = HGIS.Util.getElement(containerID);
        HGIS.Util.extend(this, options);
    },
    
    /**
     * APIMethod: destroy
     */
    destroy: function() {
        this.container = null;
        this.extent = null;
        this.size =  null;
        this.resolution = null;
        this.map = null;
    },

    /**
     * APIMethod: supported
     * This should be overridden by specific subclasses
     * 
     * Returns:
     * {Boolean} Whether or not the browser supports the renderer class
     */
    supported: function() {
        return false;
    },    
    
    /**
     * Method: setExtent
     * Set the visible part of the layer.
     *
     * Resolution has probably changed, so we nullify the resolution 
     * cache (this.resolution) -- this way it will be re-computed when 
     * next it is needed.
     * We nullify the resolution cache (this.resolution) if resolutionChanged
     * is set to true - this way it will be re-computed on the next
     * getResolution() request.
     *
     * Parameters:
     * extent - {<HGIS.Bounds>}
     * resolutionChanged - {Boolean}
     *
     * Returns:
     * {Boolean} true to notify the layer that the new extent does not exceed
     *     the coordinate range, and the features will not need to be redrawn.
     *     False otherwise.
     */
    setExtent: function(extent, resolutionChanged) {
        this.extent = extent.clone();
        if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
            var ratio = extent.getWidth() / this.map.getExtent().getWidth(),
                extent = extent.scale(1 / ratio);
            this.extent = extent.wrapDateLine(this.map.getMaxExtent()).scale(ratio);
        }
        if (resolutionChanged) {
            this.resolution = null;
        }
        return true;
    },
    
    /**
     * Method: setSize
     * Sets the size of the drawing surface.
     * 
     * Resolution has probably changed, so we nullify the resolution 
     * cache (this.resolution) -- this way it will be re-computed when 
     * next it is needed.
     *
     * Parameters:
     * size - {<HGIS.Size>} 
     */
    setSize: function(size) {
        this.size = size.clone();
        this.resolution = null;
    },
    
    /** 
     * Method: getResolution
     * Uses cached copy of resolution if available to minimize computing
     * 
     * Returns:
     * {Float} The current map's resolution
     */
    getResolution: function() {
        this.resolution = this.resolution || this.map.getResolution();
        return this.resolution;
    },
    
    /**
     * Method: drawFeature
     * Draw the feature.  The optional style argument can be used
     * to override the feature's own style.  This method should only
     * be called from layer.drawFeature().
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} 
     * style - {<Object>}
     * 
     * Returns:
     * {Boolean} true if the feature has been drawn completely, false if not,
     *     undefined if the feature had no geometry
     */
    drawFeature: function(feature, style) {
        if(style == null) {
            style = feature.style;
        }
        if (feature.geometry) {
            var bounds = feature.geometry.getBounds();
            if(bounds) {
                var worldBounds;
                if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
                    worldBounds = this.map.getMaxExtent();
                }
                if (!bounds.intersectsBounds(this.extent, {worldBounds: worldBounds})) {
                    style = {display: "none"};
                } else {
                    this.calculateFeatureDx(bounds, worldBounds);
                }
                var rendered = this.drawGeometry(feature.geometry, style, feature.id);
                if(style.display != "none" && style.label && rendered !== false) {

                    var location = feature.geometry.getCentroid(); 
                    if(style.labelXOffset || style.labelYOffset) {
                        var xOffset = isNaN(style.labelXOffset) ? 0 : style.labelXOffset;
                        var yOffset = isNaN(style.labelYOffset) ? 0 : style.labelYOffset;
                        var res = this.getResolution();
                        location.move(xOffset*res, yOffset*res);
                    }
                    this.drawText(feature.id, style, location);
                } else {
                    this.removeText(feature.id);
                }
                return rendered;
            }
        }
    },

    /**
     * Method: calculateFeatureDx
     * {Number} Calculates the feature offset in x direction. Looking at the
     * center of the feature bounds and the renderer extent, we calculate how
     * many world widths the two are away from each other. This distance is
     * used to shift the feature as close as possible to the center of the
     * current enderer extent, which ensures that the feature is visible in the
     * current viewport.
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>} Bounds of the feature
     * worldBounds - {<HGIS.Bounds>} Bounds of the world
     */
    calculateFeatureDx: function(bounds, worldBounds) {
        this.featureDx = 0;
        if (worldBounds) {
            var worldWidth = worldBounds.getWidth(),
                rendererCenterX = (this.extent.left + this.extent.right) / 2,
                featureCenterX = (bounds.left + bounds.right) / 2,
                worldsAway = Math.round((featureCenterX - rendererCenterX) / worldWidth);
            this.featureDx = worldsAway * worldWidth;
        }
    },

    /** 
     * Method: drawGeometry
     * 
     * Draw a geometry.  This should only be called from the renderer itself.
     * Use layer.drawFeature() from outside the renderer.
     * virtual function
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>} 
     * style - {Object} 
     * featureId - {<String>} 
     */
    drawGeometry: function(geometry, style, featureId) {},
        
    /**
     * Method: drawText
     * Function for drawing text labels.
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * featureId - {String}
     * style -
     * location - {<HGIS.Geometry.Point>}
     */
    drawText: function(featureId, style, location) {},

    /**
     * Method: removeText
     * Function for removing text labels.
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * featureId - {String}
     */
    removeText: function(featureId) {},
    
    /**
     * Method: clear
     * Clear all vectors from the renderer.
     * virtual function.
     */    
    clear: function() {},

    /**
     * Method: getFeatureIdFromEvent
     * Returns a feature id from an event on the renderer.  
     * How this happens is specific to the renderer.  This should be
     * called from layer.getFeatureFromEvent().
     * Virtual function.
     * 
     * Parameters:
     * evt - {<HGIS.Event>} 
     *
     * Returns:
     * {String} A feature id or undefined.
     */
    getFeatureIdFromEvent: function(evt) {},
    
    /**
     * Method: eraseFeatures 
     * This is called by the layer to erase features
     * 
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} 
     */
    eraseFeatures: function(features) {
        if(!(HGIS.Util.isArray(features))) {
            features = [features];
        }
        for(var i=0, len=features.length; i<len; ++i) {
            var feature = features[i];
            this.eraseGeometry(feature.geometry, feature.id);
            this.removeText(feature.id);
        }
    },
    
    /**
     * Method: eraseGeometry
     * Remove a geometry from the renderer (by id).
     * virtual function.
     * 
     * Parameters:
     * geometry - {<HGIS.Geometry>} 
     * featureId - {String}
     */
    eraseGeometry: function(geometry, featureId) {},
    
    /**
     * Method: moveRoot
     * moves this renderer's root to a (different) renderer.
     * To be implemented by subclasses that require a common renderer root for
     * feature selection.
     * 
     * Parameters:
     * renderer - {<HGIS.Renderer>} target renderer for the moved root
     */
    moveRoot: function(renderer) {},

    /**
     * Method: getRenderLayerId
     * Gets the layer that this renderer's output appears on. If moveRoot was
     * used, this will be different from the id of the layer containing the
     * features rendered by this renderer.
     * 
     * Returns:
     * {String} the id of the output layer.
     */
    getRenderLayerId: function() {
        return this.container.id;
    },
    
    /**
     * Method: applyDefaultSymbolizer
     * 
     * Parameters:
     * symbolizer - {Object}
     * 
     * Returns:
     * {Object}
     */
    applyDefaultSymbolizer: function(symbolizer) {
        var result = HGIS.Util.extend({},
            HGIS.Renderer.defaultSymbolizer);
        if(symbolizer.stroke === false) {
            delete result.strokeWidth;
            delete result.strokeColor;
        }
        if(symbolizer.fill === false) {
            delete result.fillColor;
        }
        HGIS.Util.extend(result, symbolizer);
        return result;
    },

    CLASS_NAME: "HGIS.Renderer"
});

/**
 * Constant: HGIS.Renderer.defaultSymbolizer
 * {Object} Properties from this symbolizer will be applied to symbolizers
 *     with missing properties. This can also be used to set a global
 *     symbolizer default in HGIS. To be SLD 1.x compliant, add the
 *     following code before rendering any vector features:
 * (code)
 * HGIS.Renderer.defaultSymbolizer = {
 *     fillColor: "#808080",
 *     fillOpacity: 1,
 *     strokeColor: "#000000",
 *     strokeOpacity: 1,
 *     strokeWidth: 1,
 *     pointRadius: 3,
 *     graphicName: "square"
 * };
 * (end)
 */
HGIS.Renderer.defaultSymbolizer = {
    fillColor: "#000000",
    strokeColor: "#000000",
    strokeWidth: 2,
    fillOpacity: 1,
    strokeOpacity: 1,
    pointRadius: 0,
    labelAlign: 'cm'
};
    


/**
 * Constant: HGIS.Renderer.symbol
 * Coordinate arrays for well known (named) symbols.
 */
HGIS.Renderer.symbol = {
    "star": [350,75, 379,161, 469,161, 397,215, 423,301, 350,250, 277,301,
            303,215, 231,161, 321,161, 350,75],
    "cross": [4,0, 6,0, 6,4, 10,4, 10,6, 6,6, 6,10, 4,10, 4,6, 0,6, 0,4, 4,4,
            4,0],
    "x": [0,0, 25,0, 50,35, 75,0, 100,0, 65,50, 100,100, 75,100, 50,65, 25,100, 0,100, 35,50, 0,0],
    "square": [0,0, 0,1, 1,1, 1,0, 0,0],
    "triangle": [0,10, 10,10, 5,0, 0,10],
    "arrow": [0,0, 5,-10, 10,0, 5,-2, 0,0]
};
/* ======================================================================
    HGIS/Renderer/Canvas.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Renderer.js
 */

/**
 * Class: HGIS.Renderer.Canvas 
 * A renderer based on the 2D 'canvas' drawing element.
 * 
 * Inherits:
 *  - <HGIS.Renderer>
 */
HGIS.Renderer.Canvas = HGIS.Class(HGIS.Renderer, {
    
    /**
     * APIProperty: hitDetection
     * {Boolean} Allow for hit detection of features.  Default is true.
     */
    hitDetection: true,
    
    /**
     * Property: hitOverflow
     * {Number} The method for converting feature identifiers to color values
     *     supports 16777215 sequential values.  Two features cannot be 
     *     predictably detected if their identifiers differ by more than this
     *     value.  The hitOverflow allows for bigger numbers (but the 
     *     difference in values is still limited).
     */
    hitOverflow: 0,

    /**
     * Property: canvas
     * {Canvas} The canvas context object.
     */
    canvas: null, 
    
    /**
     * Property: features
     * {Object} Internal object of feature/style pairs for use in redrawing the layer.
     */
    features: null,
    
    /**
     * Property: pendingRedraw
     * {Boolean} The renderer needs a redraw call to render features added while
     *     the renderer was locked.
     */
    pendingRedraw: false,
    
    /**
     * Property: cachedSymbolBounds
     * {Object} Internal cache of calculated symbol extents.
     */
    cachedSymbolBounds: {},
    
    /**
     * Constructor: HGIS.Renderer.Canvas
     *
     * Parameters:
     * containerID - {<String>}
     * options - {Object} Optional properties to be set on the renderer.
     */
    initialize: function(containerID, options) {
        HGIS.Renderer.prototype.initialize.apply(this, arguments);
        this.root = document.createElement("canvas");
        this.container.appendChild(this.root);
        this.canvas = this.root.getContext("2d");
        this.features = {};
        if (this.hitDetection) {
            this.hitCanvas = document.createElement("canvas");
            this.hitContext = this.hitCanvas.getContext("2d");
        }
    },
    
    /**
     * Method: setExtent
     * Set the visible part of the layer.
     *
     * Parameters:
     * extent - {<HGIS.Bounds>}
     * resolutionChanged - {Boolean}
     *
     * Returns:
     * {Boolean} true to notify the layer that the new extent does not exceed
     *     the coordinate range, and the features will not need to be redrawn.
     *     False otherwise.
     */
    setExtent: function() {
        HGIS.Renderer.prototype.setExtent.apply(this, arguments);
        // always redraw features
        return false;
    },
    
    /** 
     * Method: eraseGeometry
     * Erase a geometry from the renderer. Because the Canvas renderer has
     *     'memory' of the features that it has drawn, we have to remove the
     *     feature so it doesn't redraw.   
     * 
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * featureId - {String}
     */
    eraseGeometry: function(geometry, featureId) {
        this.eraseFeatures(this.features[featureId][0]);
    },

    /**
     * APIMethod: supported
     * 
     * Returns:
     * {Boolean} Whether or not the browser supports the renderer class
     */
    supported: function() {
        return HGIS.CANVAS_SUPPORTED;
    },    
    
    /**
     * Method: setSize
     * Sets the size of the drawing surface.
     *
     * Once the size is updated, redraw the canvas.
     *
     * Parameters:
     * size - {<HGIS.Size>} 
     */
    setSize: function(size) {
        this.size = size.clone();
        var root = this.root;
        root.style.width = size.w + "px";
        root.style.height = size.h + "px";
        root.width = size.w;
        root.height = size.h;
        this.resolution = null;
        if (this.hitDetection) {
            var hitCanvas = this.hitCanvas;
            hitCanvas.style.width = size.w + "px";
            hitCanvas.style.height = size.h + "px";
            hitCanvas.width = size.w;
            hitCanvas.height = size.h;
        }
    },
    
    /**
     * Method: drawFeature
     * Draw the feature. Stores the feature in the features list,
     * then redraws the layer. 
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} 
     * style - {<Object>} 
     *
     * Returns:
     * {Boolean} The feature has been drawn completely.  If the feature has no
     *     geometry, undefined will be returned.  If the feature is not rendered
     *     for other reasons, false will be returned.
     */
    drawFeature: function(feature, style) {
        var rendered;
        if (feature.geometry) {
            style = this.applyDefaultSymbolizer(style || feature.style);
            // don't render if display none or feature outside extent
            var bounds = feature.geometry.getBounds();

            var worldBounds;
            if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
                worldBounds = this.map.getMaxExtent();
            }

            var intersects = bounds && bounds.intersectsBounds(this.extent, {worldBounds: worldBounds});

            rendered = (style.display !== "none") && !!bounds && intersects;
            if (rendered) {
                // keep track of what we have rendered for redraw
                this.features[feature.id] = [feature, style];
            }
            else {
                // remove from features tracked for redraw
                delete(this.features[feature.id]);
            }
            this.pendingRedraw = true;
        }
        if (this.pendingRedraw && !this.locked) {
            this.redraw();
            this.pendingRedraw = false;
        }
        return rendered;
    },

    /** 
     * Method: drawGeometry
     * Used when looping (in redraw) over the features; draws
     * the canvas. 
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>} 
     * style - {Object} 
     */
    drawGeometry: function(geometry, style, featureId) {
        var className = geometry.CLASS_NAME;
        if ((className == "HGIS.Geometry.Collection") ||
            (className == "HGIS.Geometry.MultiPoint") ||
            (className == "HGIS.Geometry.MultiLineString") ||
            (className == "HGIS.Geometry.MultiPolygon")) {
            for (var i = 0; i < geometry.components.length; i++) {
                this.drawGeometry(geometry.components[i], style, featureId);
            }
            return;
        }
        switch (geometry.CLASS_NAME) {
            case "HGIS.Geometry.Point":
                this.drawPoint(geometry, style, featureId);
                break;
            case "HGIS.Geometry.LineString":
                this.drawLineString(geometry, style, featureId);
                break;
            case "HGIS.Geometry.LinearRing":
                this.drawLinearRing(geometry, style, featureId);
                break;
            case "HGIS.Geometry.Polygon":
                this.drawPolygon(geometry, style, featureId);
                break;
            default:
                break;
        }
    },

    /**
     * Method: drawExternalGraphic
     * Called to draw External graphics. 
     * 
     * Parameters: 
     * geometry - {<HGIS.Geometry>}
     * style    - {Object}
     * featureId - {String}
     */ 
    drawExternalGraphic: function(geometry, style, featureId) {
        var img = new Image();

        var title = style.title || style.graphicTitle;        
        if (title) {
            img.title = title;           
        }

        var width = style.graphicWidth || style.graphicHeight;
        var height = style.graphicHeight || style.graphicWidth;
        width = width ? width : style.pointRadius * 2;
        height = height ? height : style.pointRadius * 2;
        var xOffset = (style.graphicXOffset != undefined) ?
           style.graphicXOffset : -(0.5 * width);
        var yOffset = (style.graphicYOffset != undefined) ?
           style.graphicYOffset : -(0.5 * height);

        var opacity = style.graphicOpacity || style.fillOpacity;
        
        var onLoad = function() {
            if(!this.features[featureId]) {
                return;
            }
            var pt = this.getLocalXY(geometry);
            var p0 = pt[0];
            var p1 = pt[1];
            if(!isNaN(p0) && !isNaN(p1)) {
                var x = (p0 + xOffset) | 0;
                var y = (p1 + yOffset) | 0;
                var canvas = this.canvas;
                canvas.globalAlpha = opacity;
                var factor = HGIS.Renderer.Canvas.drawImageScaleFactor ||
                    (HGIS.Renderer.Canvas.drawImageScaleFactor =
                        /android 2.1/.test(navigator.userAgent.toLowerCase()) ?
                            // 320 is the screen width of the G1 phone, for
                            // which drawImage works out of the box.
                            320 / window.screen.width : 1
                    );
                canvas.drawImage(
                    img, x*factor, y*factor, width*factor, height*factor
                );
                if (this.hitDetection) {
                    this.setHitContextStyle("fill", featureId);
                    this.hitContext.fillRect(x, y, width, height);
                }
            }
        };

        img.onload = HGIS.Function.bind(onLoad, this);
        img.src = style.externalGraphic;
    },

    /**
     * Method: drawNamedSymbol
     * Called to draw Well Known Graphic Symbol Name. 
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * geometry - {<HGIS.Geometry>}
     * style    - {Object}
     * featureId - {String}
     */ 
    drawNamedSymbol: function(geometry, style, featureId) {
        var x, y, cx, cy, i, symbolBounds, scaling, angle;
        var unscaledStrokeWidth;
        var deg2rad = Math.PI / 180.0;
        
        var symbol = HGIS.Renderer.symbol[style.graphicName];
         
        if (!symbol) {
            throw new Error(style.graphicName + ' is not a valid symbol name');
        }
        
        if (!symbol.length || symbol.length < 2) return;
        
        var pt = this.getLocalXY(geometry);
        var p0 = pt[0];
        var p1 = pt[1];
       
        if (isNaN(p0) || isNaN(p1)) return;
        
        // Use rounded line caps
        this.canvas.lineCap = "round";
        this.canvas.lineJoin = "round";
        
        if (this.hitDetection) {
            this.hitContext.lineCap = "round";
            this.hitContext.lineJoin = "round";
        }
        
        // Scale and rotate symbols, using precalculated bounds whenever possible.
        if (style.graphicName in this.cachedSymbolBounds) {
            symbolBounds = this.cachedSymbolBounds[style.graphicName];
        } else {
            symbolBounds = new HGIS.Bounds();
            for(i = 0; i < symbol.length; i+=2) {
                symbolBounds.extend(new HGIS.LonLat(symbol[i], symbol[i+1]));
            }
            this.cachedSymbolBounds[style.graphicName] = symbolBounds;
        }
        
        // Push symbol scaling, translation and rotation onto the transformation stack in reverse order.
        // Don't forget to apply all canvas transformations to the hitContext canvas as well(!)
        this.canvas.save();
        if (this.hitDetection) { this.hitContext.save(); }
        
        // Step 3: place symbol at the desired location
        this.canvas.translate(p0,p1);
        if (this.hitDetection) { this.hitContext.translate(p0,p1); }
        
        // Step 2a. rotate the symbol if necessary
        angle = deg2rad * style.rotation; // will be NaN when style.rotation is undefined.
        if (!isNaN(angle)) {
            this.canvas.rotate(angle);
            if (this.hitDetection) { this.hitContext.rotate(angle); }
        }
                
        // // Step 2: scale symbol such that pointRadius equals half the maximum symbol dimension.
        scaling = 2.0 * style.pointRadius / Math.max(symbolBounds.getWidth(), symbolBounds.getHeight());
        this.canvas.scale(scaling,scaling);
        if (this.hitDetection) { this.hitContext.scale(scaling,scaling); }
        
        // Step 1: center the symbol at the origin        
        cx = symbolBounds.getCenterLonLat().lon;
        cy = symbolBounds.getCenterLonLat().lat;
        this.canvas.translate(-cx,-cy);
        if (this.hitDetection) { this.hitContext.translate(-cx,-cy); }        

        // Don't forget to scale stroke widths, because they are affected by canvas scale transformations as well(!)
        // Alternative: scale symbol coordinates manually, so stroke width scaling is not needed anymore.
        unscaledStrokeWidth = style.strokeWidth;
        style.strokeWidth = unscaledStrokeWidth / scaling;
            
        if (style.fill !== false) {
            this.setCanvasStyle("fill", style);
            this.canvas.beginPath();
            for (i=0; i<symbol.length; i=i+2) {
                x = symbol[i];
                y = symbol[i+1];
                if (i == 0) this.canvas.moveTo(x,y);
                this.canvas.lineTo(x,y);
            }
            this.canvas.closePath();
            this.canvas.fill();

            if (this.hitDetection) {
                this.setHitContextStyle("fill", featureId, style);
                this.hitContext.beginPath();
                for (i=0; i<symbol.length; i=i+2) {
                    x = symbol[i];
                    y = symbol[i+1];
                    if (i == 0) this.canvas.moveTo(x,y);
                    this.hitContext.lineTo(x,y);
                }
                this.hitContext.closePath();
                this.hitContext.fill();
            }
        }  
        
        if (style.stroke !== false) {
            this.setCanvasStyle("stroke", style);
            this.canvas.beginPath();
            for (i=0; i<symbol.length; i=i+2) {
                x = symbol[i];
                y = symbol[i+1];
                if (i == 0) this.canvas.moveTo(x,y);
                this.canvas.lineTo(x,y);
            }
            this.canvas.closePath();
            this.canvas.stroke();
            
            
            if (this.hitDetection) {
                this.setHitContextStyle("stroke", featureId, style, scaling);
                this.hitContext.beginPath();
                for (i=0; i<symbol.length; i=i+2) {
                    x = symbol[i];
                    y = symbol[i+1];
                    if (i == 0) this.hitContext.moveTo(x,y);
                    this.hitContext.lineTo(x,y);
                }
                this.hitContext.closePath();
                this.hitContext.stroke();
            }
            
        }
        
        style.strokeWidth = unscaledStrokeWidth;
        this.canvas.restore();
        if (this.hitDetection) { this.hitContext.restore(); }
        this.setCanvasStyle("reset");  
    },

    /**
     * Method: setCanvasStyle
     * Prepare the canvas for drawing by setting various global settings.
     *
     * Parameters:
     * type - {String} one of 'stroke', 'fill', or 'reset'
     * style - {Object} Symbolizer hash
     */
    setCanvasStyle: function(type, style) {
        if (type === "fill") {     
            this.canvas.globalAlpha = style['fillOpacity'];
            this.canvas.fillStyle = style['fillColor'];
        } else if (type === "stroke") {  
            this.canvas.globalAlpha = style['strokeOpacity'];
            this.canvas.strokeStyle = style['strokeColor'];
            this.canvas.lineWidth = style['strokeWidth'];
        } else {
            this.canvas.globalAlpha = 0;
            this.canvas.lineWidth = 1;
        }
    },
    
    /**
     * Method: featureIdToHex
     * Convert a feature ID string into an RGB hex string.
     *
     * Parameters:
     * featureId - {String} Feature id
     *
     * Returns:
     * {String} RGB hex string.
     */
    featureIdToHex: function(featureId) {
        var id = Number(featureId.split("_").pop()) + 1; // zero for no feature
        if (id >= 16777216) {
            this.hitOverflow = id - 16777215;
            id = id % 16777216 + 1;
        }
        var hex = "000000" + id.toString(16);
        var len = hex.length;
        hex = "#" + hex.substring(len-6, len);
        return hex;
    },
    
    /**
     * Method: setHitContextStyle
     * Prepare the hit canvas for drawing by setting various global settings.
     *
     * Parameters:
     * type - {String} one of 'stroke', 'fill', or 'reset'
     * featureId - {String} The feature id.
     * symbolizer - {<HGIS.Symbolizer>} The symbolizer.
     */
    setHitContextStyle: function(type, featureId, symbolizer, strokeScaling) {
        var hex = this.featureIdToHex(featureId);
        if (type == "fill") {
            this.hitContext.globalAlpha = 1.0;
            this.hitContext.fillStyle = hex;
        } else if (type == "stroke") {  
            this.hitContext.globalAlpha = 1.0;
            this.hitContext.strokeStyle = hex;
            // bump up stroke width to deal with antialiasing. If strokeScaling is defined, we're rendering a symbol 
            // on a transformed canvas, so the antialias width bump has to scale as well.
            if (typeof strokeScaling === "undefined") {
                this.hitContext.lineWidth = symbolizer.strokeWidth + 2;
            } else {
                if (!isNaN(strokeScaling)) { this.hitContext.lineWidth = symbolizer.strokeWidth + 2.0 / strokeScaling; }
            }
        } else {
            this.hitContext.globalAlpha = 0;
            this.hitContext.lineWidth = 1;
        }
    },

    /**
     * Method: drawPoint
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * geometry - {<HGIS.Geometry>}
     * style    - {Object}
     * featureId - {String}
     */ 
    drawPoint: function(geometry, style, featureId) {
        if(style.graphic !== false) {
            if(style.externalGraphic) {
                this.drawExternalGraphic(geometry, style, featureId);
            } else if (style.graphicName && (style.graphicName != "circle")) {
                this.drawNamedSymbol(geometry, style, featureId);
            } else {
                var pt = this.getLocalXY(geometry);
                var p0 = pt[0];
                var p1 = pt[1];
                if(!isNaN(p0) && !isNaN(p1)) {
                    var twoPi = Math.PI*2;
                    var radius = style.pointRadius;
                    if(style.fill !== false) {
                        this.setCanvasStyle("fill", style);
                        this.canvas.beginPath();
                        this.canvas.arc(p0, p1, radius, 0, twoPi, true);
                        this.canvas.fill();
                        if (this.hitDetection) {
                            this.setHitContextStyle("fill", featureId, style);
                            this.hitContext.beginPath();
                            this.hitContext.arc(p0, p1, radius, 0, twoPi, true);
                            this.hitContext.fill();
                        }
                    }

                    if(style.stroke !== false) {
                        this.setCanvasStyle("stroke", style);
                        this.canvas.beginPath();
                        this.canvas.arc(p0, p1, radius, 0, twoPi, true);
                        this.canvas.stroke();
                        if (this.hitDetection) {
                            this.setHitContextStyle("stroke", featureId, style);
                            this.hitContext.beginPath();
                            this.hitContext.arc(p0, p1, radius, 0, twoPi, true);
                            this.hitContext.stroke();
                        }
                        this.setCanvasStyle("reset");
                    }
                }
            }
        }
    },
    
    /**
     * Method: drawLineString
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * geometry - {<HGIS.Geometry>}
     * style    - {Object}
     * featureId - {String}
     */ 
    drawLineString: function(geometry, style, featureId) {
        style = HGIS.Util.applyDefaults({fill: false}, style);
        this.drawLinearRing(geometry, style, featureId);
    },    
    
    /**
     * Method: drawLinearRing
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * geometry - {<HGIS.Geometry>}
     * style    - {Object}
     * featureId - {String}
     */ 
    drawLinearRing: function(geometry, style, featureId) {
        if (style.fill !== false) {
            this.setCanvasStyle("fill", style);
            this.renderPath(this.canvas, geometry, style, featureId, "fill");
            if (this.hitDetection) {
                this.setHitContextStyle("fill", featureId, style);
                this.renderPath(this.hitContext, geometry, style, featureId, "fill");
            }
        }
        if (style.stroke !== false) {
            this.setCanvasStyle("stroke", style);
            this.renderPath(this.canvas, geometry, style, featureId, "stroke");
            if (this.hitDetection) {
                this.setHitContextStyle("stroke", featureId, style);
                this.renderPath(this.hitContext, geometry, style, featureId, "stroke");
            }
        }
        this.setCanvasStyle("reset");
    },
    
    /**
     * Method: renderPath
     * Render a path with stroke and optional fill.
     */
    renderPath: function(context, geometry, style, featureId, type) {
        var components = geometry.components;
        var len = components.length;
        context.beginPath();
        var start = this.getLocalXY(components[0]);
        var x = start[0];
        var y = start[1];
        if (!isNaN(x) && !isNaN(y)) {
            context.moveTo(start[0], start[1]);
            for (var i=1; i<len; ++i) {
                var pt = this.getLocalXY(components[i]);
                context.lineTo(pt[0], pt[1]);
            }
            if (type === "fill") {
                context.fill();
            } else {
                context.stroke();
            }
        }
    },
    
    /**
     * Method: drawPolygon
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * geometry - {<HGIS.Geometry>}
     * style    - {Object}
     * featureId - {String}
     */ 
    drawPolygon: function(geometry, style, featureId) {
        var components = geometry.components;
        var len = components.length;
        this.drawLinearRing(components[0], style, featureId);
        // erase inner rings
        for (var i=1; i<len; ++i) {
            /** 
             * Note that this is overly agressive.  Here we punch holes through 
             * all previously rendered features on the same canvas.  A better 
             * solution for polygons with interior rings would be to draw the 
             * polygon on a sketch canvas first.  We could erase all holes 
             * there and then copy the drawing to the layer canvas. 
             * TODO: http://trac.osgeo.org/HGIS/ticket/3130 
             */
            this.canvas.globalCompositeOperation = "destination-out";
            if (this.hitDetection) {
                this.hitContext.globalCompositeOperation = "destination-out";
            }
            this.drawLinearRing(
                components[i], 
                HGIS.Util.applyDefaults({stroke: false, fillOpacity: 1.0}, style),
                featureId
            );
            this.canvas.globalCompositeOperation = "source-over";
            if (this.hitDetection) {
                this.hitContext.globalCompositeOperation = "source-over";
            }
            this.drawLinearRing(
                components[i], 
                HGIS.Util.applyDefaults({fill: false}, style),
                featureId
            );
        }
    },
    
    /**
     * Method: drawText
     * This method is only called by the renderer itself.
     *
     * Parameters:
     * location - {<HGIS.Point>}
     * style    - {Object}
     */
    drawText: function(location, style) {
        var pt = this.getLocalXY(location);

        this.setCanvasStyle("reset");
        this.canvas.fillStyle = style.fontColor;
        this.canvas.globalAlpha = style.fontOpacity || 1.0;
        var fontStyle = [style.fontStyle ? style.fontStyle : "normal",
                         "normal", // "font-variant" not supported
                         style.fontWeight ? style.fontWeight : "normal",
                         style.fontSize ? style.fontSize : "1em",
                         style.fontFamily ? style.fontFamily : "sans-serif"].join(" ");
        var labelRows = style.label.split('\n');
        var numRows = labelRows.length;
        if (this.canvas.fillText) {
            // HTML5
            this.canvas.font = fontStyle;
            this.canvas.textAlign =
                HGIS.Renderer.Canvas.LABEL_ALIGN[style.labelAlign[0]] ||
                "center";
            this.canvas.textBaseline =
                HGIS.Renderer.Canvas.LABEL_ALIGN[style.labelAlign[1]] ||
                "middle";
            var vfactor =
                HGIS.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[1]];
            if (vfactor == null) {
                vfactor = -.5;
            }
            var lineHeight =
                this.canvas.measureText('Mg').height ||
                this.canvas.measureText('xx').width;
            pt[1] += lineHeight*vfactor*(numRows-1);
            for (var i = 0; i < numRows; i++) {
                if (style.labelOutlineWidth) {
                    this.canvas.save();
                    this.canvas.globalAlpha = style.labelOutlineOpacity || style.fontOpacity || 1.0;
                    this.canvas.strokeStyle = style.labelOutlineColor;
                    this.canvas.lineWidth = style.labelOutlineWidth;
                    this.canvas.strokeText(labelRows[i], pt[0], pt[1] + (lineHeight*i) + 1);
                    this.canvas.restore();
                }
                this.canvas.fillText(labelRows[i], pt[0], pt[1] + (lineHeight*i));
            }
        } else if (this.canvas.mozDrawText) {
            // Mozilla pre-Gecko1.9.1 (<FF3.1)
            this.canvas.mozTextStyle = fontStyle;
            // No built-in text alignment, so we measure and adjust the position
            var hfactor =
                HGIS.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[0]];
            if (hfactor == null) {
                hfactor = -.5;
            }
            var vfactor =
                HGIS.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[1]];
            if (vfactor == null) {
                vfactor = -.5;
            }
            var lineHeight = this.canvas.mozMeasureText('xx');
            pt[1] += lineHeight*(1 + (vfactor*numRows));
            for (var i = 0; i < numRows; i++) {
                var x = pt[0] + (hfactor*this.canvas.mozMeasureText(labelRows[i]));
                var y = pt[1] + (i*lineHeight);
                this.canvas.translate(x, y);
                this.canvas.mozDrawText(labelRows[i]);
                this.canvas.translate(-x, -y);
            }
        }
        this.setCanvasStyle("reset");
    },
    
    /**
     * Method: getLocalXY
     * transform geographic xy into pixel xy
     *
     * Parameters: 
     * point - {<HGIS.Geometry.Point>}
     */
    getLocalXY: function(point) {
        var resolution = this.getResolution();
        var extent = this.extent;
        var x = ((point.x - this.featureDx) / resolution + (-extent.left / resolution));
        var y = ((extent.top / resolution) - point.y / resolution);
        return [x, y];
    },

    /**
     * Method: clear
     * Clear all vectors from the renderer.
     */    
    clear: function() {
        var height = this.root.height;
        var width = this.root.width;
        this.canvas.clearRect(0, 0, width, height);
        this.features = {};
        if (this.hitDetection) {
            this.hitContext.clearRect(0, 0, width, height);
        }
    },

    /**
     * Method: getFeatureIdFromEvent
     * Returns a feature id from an event on the renderer.  
     * 
     * Parameters:
     * evt - {<HGIS.Event>} 
     *
     * Returns:
     * {<HGIS.Feature.Vector} A feature or undefined.  This method returns a 
     *     feature instead of a feature id to avoid an unnecessary lookup on the
     *     layer.
     */
    getFeatureIdFromEvent: function(evt) {
        var featureId, feature;
        
        if (this.hitDetection && this.root.style.display !== "none") {
            // this dragging check should go in the feature handler
            if (!this.map.dragging) {
                var xy = evt.xy;
                var x = xy.x | 0;
                var y = xy.y | 0;
                var data = this.hitContext.getImageData(x, y, 1, 1).data;
                if (data[3] === 255) { // antialiased
                    var id = data[2] + (256 * (data[1] + (256 * data[0])));
                    if (id) {
                        featureId = "HGIS_Feature_Vector_" + (id - 1 + this.hitOverflow);
                        try {
                            feature = this.features[featureId][0];
                        } catch(err) {
                            // Because of antialiasing on the canvas, when the hit location is at a point where the edge of
                            // one symbol intersects the interior of another symbol, a wrong hit color (and therefore id) results.
                            // todo: set Antialiasing = 'off' on the hitContext as soon as browsers allow it.
                        }
                    }
                }
            }
        }
        return feature;
    },
    
    /**
     * Method: eraseFeatures 
     * This is called by the layer to erase features; removes the feature from
     *     the list, then redraws the layer.
     * 
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} 
     */
    eraseFeatures: function(features) {
        if(!(HGIS.Util.isArray(features))) {
            features = [features];
        }
        for(var i=0; i<features.length; ++i) {
            delete this.features[features[i].id];
        }
        this.redraw();
    },

    /**
     * Method: redraw
     * The real 'meat' of the function: any time things have changed,
     *     redraw() can be called to loop over all the data and (you guessed
     *     it) redraw it.  Unlike Elements-based Renderers, we can't interact
     *     with things once they're drawn, to remove them, for example, so
     *     instead we have to just clear everything and draw from scratch.
     */
    redraw: function() {
        if (!this.locked) {
            var height = this.root.height;
            var width = this.root.width;
            this.canvas.clearRect(0, 0, width, height);
            if (this.hitDetection) {
                this.hitContext.clearRect(0, 0, width, height);
            }
            //var labelMap = [];
            var feature, geometry, style;
            var worldBounds = (this.map.baseLayer && this.map.baseLayer.wrapDateLine) && this.map.getMaxExtent();
            for (var id in this.features) {
                if (!this.features.hasOwnProperty(id)) { continue; }
                feature = this.features[id][0];
                geometry = feature.geometry;
                this.calculateFeatureDx(geometry.getBounds(), worldBounds);
                style = this.features[id][1];
                this.drawGeometry(geometry, style, feature.id);
                if(style.label) {
                    //labelMap.push([feature, style]);
                	this.drawText(geometry.getCentroid(),style);//2018年8月6日增加该行，并注释掉了上面一行和下面的for循环。
                }
            }
            /*
            var item;
            for (var i=0, len=labelMap.length; i<len; ++i) {
                item = labelMap[i];
                this.drawText(item[0].geometry.getCentroid(), item[1]);
            }*/
        }    
    },

    CLASS_NAME: "HGIS.Renderer.Canvas"
});

/**
 * Constant: HGIS.Renderer.Canvas.LABEL_ALIGN
 * {Object}
 */
HGIS.Renderer.Canvas.LABEL_ALIGN = {
    "l": "left",
    "r": "right",
    "t": "top",
    "b": "bottom"
};

/**
 * Constant: HGIS.Renderer.Canvas.LABEL_FACTOR
 * {Object}
 */
HGIS.Renderer.Canvas.LABEL_FACTOR = {
    "l": 0,
    "r": -1,
    "t": 0,
    "b": -1
};

/**
 * Constant: HGIS.Renderer.Canvas.drawImageScaleFactor
 * {Number} Scale factor to apply to the canvas drawImage arguments. This
 *     is always 1 except for Android 2.1 devices, to work around
 *     http://code.google.com/p/android/issues/detail?id=5141.
 */
HGIS.Renderer.Canvas.drawImageScaleFactor = null;
/* ======================================================================
    HGIS/Format/OSM.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Geometry/Point.js
 * @requires HGIS/Geometry/LineString.js
 * @requires HGIS/Geometry/Polygon.js
 * @requires HGIS/Projection.js
 */

/**  
 * Class: HGIS.Format.OSM
 * OSM parser. Create a new instance with the 
 *     <HGIS.Format.OSM> constructor.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.OSM = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * APIProperty: checkTags
     * {Boolean} Should tags be checked to determine whether something
     * should be treated as a seperate node. Will slow down parsing.
     * Default is false.
     */
    checkTags: false,

    /**
     * Property: interestingTagsExclude
     * {Array} List of tags to exclude from 'interesting' checks on nodes.
     * Must be set when creating the format. Will only be used if checkTags
     * is set.
     */
    interestingTagsExclude: null, 
    
    /**
     * APIProperty: areaTags
     * {Array} List of tags indicating that something is an area.  
     * Must be set when creating the format. Will only be used if 
     * checkTags is true.
     */
    areaTags: null, 
    
    /**
     * Constructor: HGIS.Format.OSM
     * Create a new parser for OSM.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        var layer_defaults = {
          'interestingTagsExclude': ['source', 'source_ref', 
              'source:ref', 'history', 'attribution', 'created_by'],
          'areaTags': ['area', 'building', 'leisure', 'tourism', 'ruins',
              'historic', 'landuse', 'military', 'natural', 'sport'] 
        };
          
        layer_defaults = HGIS.Util.extend(layer_defaults, options);
        
        var interesting = {};
        for (var i = 0; i < layer_defaults.interestingTagsExclude.length; i++) {
            interesting[layer_defaults.interestingTagsExclude[i]] = true;
        }
        layer_defaults.interestingTagsExclude = interesting;
        
        var area = {};
        for (var i = 0; i < layer_defaults.areaTags.length; i++) {
            area[layer_defaults.areaTags[i]] = true;
        }
        layer_defaults.areaTags = area;

        // OSM coordinates are always in longlat WGS84
        this.externalProjection = new HGIS.Projection("EPSG:4326");
        
        HGIS.Format.XML.prototype.initialize.apply(this, [layer_defaults]);
    },
    
    /**
     * APIMethod: read
     * Return a list of features from a OSM doc
     
     * Parameters:
     * doc - {Element} 
     *
     * Returns:
     * Array({<HGIS.Feature.Vector>})
     */
    read: function(doc) {
        if (typeof doc == "string") { 
            doc = HGIS.Format.XML.prototype.read.apply(this, [doc]);
        }

        var nodes = this.getNodes(doc);
        var ways = this.getWays(doc);
        
        // Geoms will contain at least ways.length entries.
        var feat_list = new Array(ways.length);
        
        for (var i = 0; i < ways.length; i++) {
            // We know the minimal of this one ahead of time. (Could be -1
            // due to areas/polygons)
            var point_list = new Array(ways[i].nodes.length);
            
            var poly = this.isWayArea(ways[i]) ? 1 : 0; 
            for (var j = 0; j < ways[i].nodes.length; j++) {
               var node = nodes[ways[i].nodes[j]];
               
               var point = new HGIS.Geometry.Point(node.lon, node.lat);
               
               // Since OSM is topological, we stash the node ID internally. 
               point.osm_id = parseInt(ways[i].nodes[j]);
               point_list[j] = point;
               
               // We don't display nodes if they're used inside other 
               // elements.
               node.used = true; 
            }
            var geometry = null;
            if (poly) { 
                geometry = new HGIS.Geometry.Polygon(
                    new HGIS.Geometry.LinearRing(point_list));
            } else {    
                geometry = new HGIS.Geometry.LineString(point_list);
            }
            if (this.internalProjection && this.externalProjection) {
                geometry.transform(this.externalProjection, 
                    this.internalProjection);
            }        
            var feat = new HGIS.Feature.Vector(geometry,
                ways[i].tags);
            feat.osm_id = parseInt(ways[i].id);
            feat.fid = "way." + feat.osm_id;
            feat_list[i] = feat;
        } 
        for (var node_id in nodes) {
            var node = nodes[node_id];
            if (!node.used || this.checkTags) {
                var tags = null;
                
                if (this.checkTags) {
                    var result = this.getTags(node.node, true);
                    if (node.used && !result[1]) {
                        continue;
                    }
                    tags = result[0];
                } else { 
                    tags = this.getTags(node.node);
                }    
                
                var feat = new HGIS.Feature.Vector(
                    new HGIS.Geometry.Point(node['lon'], node['lat']),
                    tags);
                if (this.internalProjection && this.externalProjection) {
                    feat.geometry.transform(this.externalProjection, 
                        this.internalProjection);
                }        
                feat.osm_id = parseInt(node_id); 
                feat.fid = "node." + feat.osm_id;
                feat_list.push(feat);
            }   
            // Memory cleanup
            node.node = null;
        }        
        return feat_list;
    },

    /**
     * Method: getNodes
     * Return the node items from a doc.  
     *
     * Parameters:
     * doc - {DOMElement} node to parse tags from
     */
    getNodes: function(doc) {
        var node_list = doc.getElementsByTagName("node");
        var nodes = {};
        for (var i = 0; i < node_list.length; i++) {
            var node = node_list[i];
            var id = node.getAttribute("id");
            nodes[id] = {
                'lat': node.getAttribute("lat"),
                'lon': node.getAttribute("lon"),
                'node': node
            };
        }
        return nodes;
    },

    /**
     * Method: getWays
     * Return the way items from a doc.  
     *
     * Parameters:
     * doc - {DOMElement} node to parse tags from
     */
    getWays: function(doc) {
        var way_list = doc.getElementsByTagName("way");
        var return_ways = [];
        for (var i = 0; i < way_list.length; i++) {
            var way = way_list[i];
            var way_object = {
              id: way.getAttribute("id")
            };
            
            way_object.tags = this.getTags(way);
            
            var node_list = way.getElementsByTagName("nd");
            
            way_object.nodes = new Array(node_list.length);
            
            for (var j = 0; j < node_list.length; j++) {
                way_object.nodes[j] = node_list[j].getAttribute("ref");
            }  
            return_ways.push(way_object);
        }
        return return_ways; 
        
    },  
    
    /**
     * Method: getTags
     * Return the tags list attached to a specific DOM element.
     *
     * Parameters:
     * dom_node - {DOMElement} node to parse tags from
     * interesting_tags - {Boolean} whether the return from this function should
     *    return a boolean indicating that it has 'interesting tags' -- 
     *    tags like attribution and source are ignored. (To change the list
     *    of tags, see interestingTagsExclude)
     * 
     * Returns:
     * tags - {Object} hash of tags
     * interesting - {Boolean} if interesting_tags is passed, returns
     *     whether there are any interesting tags on this element.
     */
    getTags: function(dom_node, interesting_tags) {
        var tag_list = dom_node.getElementsByTagName("tag");
        var tags = {};
        var interesting = false;
        for (var j = 0; j < tag_list.length; j++) {
            var key = tag_list[j].getAttribute("k");
            tags[key] = tag_list[j].getAttribute("v");
            if (interesting_tags) {
                if (!this.interestingTagsExclude[key]) {
                    interesting = true;
                }
            }    
        }  
        return interesting_tags ? [tags, interesting] : tags;     
    },

    /** 
     * Method: isWayArea
     * Given a way object from getWays, check whether the tags and geometry
     * indicate something is an area.
     *
     * Returns:
     * {Boolean}
     */
    isWayArea: function(way) { 
        var poly_shaped = false;
        var poly_tags = false;
        
        if (way.nodes[0] == way.nodes[way.nodes.length - 1]) {
            poly_shaped = true;
        }
        if (this.checkTags) {
            for(var key in way.tags) {
                if (this.areaTags[key]) {
                    poly_tags = true;
                    break;
                }
            }
        }    
        return poly_shaped && (this.checkTags ? poly_tags : true);            
    }, 

    /**
     * APIMethod: write 
     * Takes a list of features, returns a serialized OSM format file for use
     * in tools like JOSM.
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)}
     */
    write: function(features) { 
        if (!(HGIS.Util.isArray(features))) {
            features = [features];
        }
        
        this.osm_id = 1;
        this.created_nodes = {};
        var root_node = this.createElementNS(null, "osm");
        root_node.setAttribute("version", "0.5");
        root_node.setAttribute("generator", "HGIS "+ HGIS.VERSION_NUMBER);

        // Loop backwards, because the deserializer puts nodes last, and 
        // we want them first if possible
        for(var i = features.length - 1; i >= 0; i--) {
            var nodes = this.createFeatureNodes(features[i]);
            for (var j = 0; j < nodes.length; j++) {
                root_node.appendChild(nodes[j]);
            }    
        }
        return HGIS.Format.XML.prototype.write.apply(this, [root_node]);
    },

    /**
     * Method: createFeatureNodes
     * Takes a feature, returns a list of nodes from size 0->n.
     * Will include all pieces of the serialization that are required which
     * have not already been created. Calls out to createXML based on geometry
     * type.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     */
    createFeatureNodes: function(feature) {
        var nodes = [];
        var className = feature.geometry.CLASS_NAME;
        var type = className.substring(className.lastIndexOf(".") + 1);
        type = type.toLowerCase();
        var builder = this.createXML[type];
        if (builder) {
            nodes = builder.apply(this, [feature]);
        }
        return nodes;
    },
    
    /**
     * Method: createXML
     * Takes a feature, returns a list of nodes from size 0->n.
     * Will include all pieces of the serialization that are required which
     * have not already been created.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     */
    createXML: {
        'point': function(point) {
            var id = null;
            var geometry = point.geometry ? point.geometry : point;
            
            if (this.internalProjection && this.externalProjection) {
                geometry = geometry.clone();
                geometry.transform(this.internalProjection, 
                                   this.externalProjection);
            }                       
            
            var already_exists = false; // We don't return anything if the node
                                        // has already been created
            if (point.osm_id) {
                id = point.osm_id;
                if (this.created_nodes[id]) {
                    already_exists = true;
                }    
            } else {
               id = -this.osm_id;
               this.osm_id++; 
            }
            if (already_exists) {
                node = this.created_nodes[id];
            } else {    
                var node = this.createElementNS(null, "node");
            }
            this.created_nodes[id] = node;
            node.setAttribute("id", id);
            node.setAttribute("lon", geometry.x); 
            node.setAttribute("lat", geometry.y);
            if (point.attributes) {
                this.serializeTags(point, node);
            }
            this.setState(point, node);
            return already_exists ? [] : [node];
        }, 
        linestring: function(feature) {
            var id;
            var nodes = [];
            var geometry = feature.geometry;
            if (feature.osm_id) {
                id = feature.osm_id;
            } else {
                id = -this.osm_id;
                this.osm_id++; 
            }
            var way = this.createElementNS(null, "way");
            way.setAttribute("id", id);
            for (var i = 0; i < geometry.components.length; i++) {
                var node = this.createXML['point'].apply(this, [geometry.components[i]]);
                if (node.length) {
                    node = node[0];
                    var node_ref = node.getAttribute("id");
                    nodes.push(node);
                } else {
                    node_ref = geometry.components[i].osm_id;
                    node = this.created_nodes[node_ref];
                }
                this.setState(feature, node);
                var nd_dom = this.createElementNS(null, "nd");
                nd_dom.setAttribute("ref", node_ref);
                way.appendChild(nd_dom);
            }
            this.serializeTags(feature, way);
            nodes.push(way);
            
            return nodes;
        },
        polygon: function(feature) {
            var attrs = HGIS.Util.extend({'area':'yes'}, feature.attributes);
            var feat = new HGIS.Feature.Vector(feature.geometry.components[0], attrs); 
            feat.osm_id = feature.osm_id;
            return this.createXML['linestring'].apply(this, [feat]);
        }
    },

    /**
     * Method: serializeTags
     * Given a feature, serialize the attributes onto the given node.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     * node - {DOMNode}
     */
    serializeTags: function(feature, node) {
        for (var key in feature.attributes) {
            var tag = this.createElementNS(null, "tag");
            tag.setAttribute("k", key);
            tag.setAttribute("v", feature.attributes[key]);
            node.appendChild(tag);
        }
    },

    /**
     * Method: setState 
     * OpenStreetMap has a convention that 'state' is stored for modification or deletion.
     * This allows the file to be uploaded via JOSM or the bulk uploader tool.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     * node - {DOMNode}
     */
    setState: function(feature, node) {
        if (feature.state) {
            var state = null;
            switch(feature.state) {
                case HGIS.State.UPDATE:
                    state = "modify";
                case HGIS.State.DELETE:
                    state = "delete";
            }
            if (state) {
                node.setAttribute("action", state);
            }
        }    
    },

    CLASS_NAME: "HGIS.Format.OSM" 
});     
/* ======================================================================
    HGIS/Handler/Keyboard.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Handler.js
 * @requires HGIS/Events.js
 */

/**
 * Class: HGIS.handler.Keyboard
 * A handler for keyboard events.  Create a new instance with the
 *     <HGIS.Handler.Keyboard> constructor.
 * 
 * Inherits from:
 *  - <HGIS.Handler> 
 */
HGIS.Handler.Keyboard = HGIS.Class(HGIS.Handler, {

    /* http://www.quirksmode.org/js/keys.html explains key x-browser
        key handling quirks in pretty nice detail */

    /** 
     * Constant: KEY_EVENTS
     * keydown, keypress, keyup
     */
    KEY_EVENTS: ["keydown", "keyup"],

    /** 
    * Property: eventListener
    * {Function}
    */
    eventListener: null,

    /**
     * Property: observeElement
     * {DOMElement|String} The DOM element on which we listen for
     *     key events. Default to the document.
     */
    observeElement: null,

    /**
     * Constructor: HGIS.Handler.Keyboard
     * Returns a new keyboard handler.
     * 
     * Parameters:
     * control - {<HGIS.Control>} The control that is making use of
     *     this handler.  If a handler is being used without a control, the
     *     handlers setMap method must be overridden to deal properly with
     *     the map.
     * callbacks - {Object} An object containing a single function to be
     *     called when the drag operation is finished. The callback should
     *     expect to recieve a single argument, the pixel location of the event.
     *     Callbacks for 'keydown', 'keypress', and 'keyup' are supported.
     * options - {Object} Optional object whose properties will be set on the
     *     handler.
     */
    initialize: function(control, callbacks, options) {
        HGIS.Handler.prototype.initialize.apply(this, arguments);
        // cache the bound event listener method so it can be unobserved later
        this.eventListener = HGIS.Function.bindAsEventListener(
            this.handleKeyEvent, this
        );
    },
    
    /**
     * Method: destroy
     */
    destroy: function() {
        this.deactivate();
        this.eventListener = null;
        HGIS.Handler.prototype.destroy.apply(this, arguments);
    },

    /**
     * Method: activate
     */
    activate: function() {
        if (HGIS.Handler.prototype.activate.apply(this, arguments)) {
            this.observeElement = this.observeElement || document;
            for (var i=0, len=this.KEY_EVENTS.length; i<len; i++) {
                HGIS.Event.observe(
                    this.observeElement, this.KEY_EVENTS[i], this.eventListener);
            }
            return true;
        } else {
            return false;
        }
    },

    /**
     * Method: deactivate
     */
    deactivate: function() {
        var deactivated = false;
        if (HGIS.Handler.prototype.deactivate.apply(this, arguments)) {
            for (var i=0, len=this.KEY_EVENTS.length; i<len; i++) {
                HGIS.Event.stopObserving(
                    this.observeElement, this.KEY_EVENTS[i], this.eventListener);
            }
            deactivated = true;
        }
        return deactivated;
    },

    /**
     * Method: handleKeyEvent 
     */
    handleKeyEvent: function (evt) {
        if (this.checkModifiers(evt)) {
            this.callback(evt.type, [evt]);
        }
    },

    CLASS_NAME: "HGIS.Handler.Keyboard"
});
/* ======================================================================
    HGIS/Control/ModifyFeature.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Handler/Drag.js
 * @requires HGIS/Handler/Keyboard.js
 */

/**
 * Class: HGIS.Control.ModifyFeature
 * Control to modify features.  When activated, a click renders the vertices
 *     of a feature - these vertices can then be dragged.  By default, the
 *     delete key will delete the vertex under the mouse.  New features are
 *     added by dragging "virtual vertices" between vertices.  Create a new
 *     control with the <HGIS.Control.ModifyFeature> constructor.
 *
 * Inherits From:
 *  - <HGIS.Control>
 */
HGIS.Control.ModifyFeature = HGIS.Class(HGIS.Control, {

    /**
     * APIProperty: documentDrag
     * {Boolean} If set to true, dragging vertices will continue even if the
     *     mouse cursor leaves the map viewport. Default is false.
     */
    documentDrag: false,

    /**
     * APIProperty: geometryTypes
     * {Array(String)} To restrict modification to a limited set of geometry
     *     types, send a list of strings corresponding to the geometry class
     *     names.
     */
    geometryTypes: null,

    /**
     * APIProperty: clickout
     * {Boolean} Unselect features when clicking outside any feature.
     *     Default is true.
     */
    clickout: true,

    /**
     * APIProperty: toggle
     * {Boolean} Unselect a selected feature on click.
     *      Default is true.
     */
    toggle: true,

    /**
     * APIProperty: standalone
     * {Boolean} Set to true to create a control without SelectFeature
     *     capabilities. Default is false.  If standalone is true, to modify
     *     a feature, call the <selectFeature> method with the target feature.
     *     Note that you must call the <unselectFeature> method to finish
     *     feature modification in standalone mode (before starting to modify
     *     another feature).
     */
    standalone: false,

    /**
     * Property: layer
     * {<HGIS.Layer.Vector>}
     */
    layer: null,

    /**
     * Property: feature
     * {<HGIS.Feature.Vector>} Feature currently available for modification.
     */
    feature: null,

    /**
     * Property: vertex
     * {<HGIS.Feature.Vector>} Vertex currently being modified.
     */
    vertex: null,

    /**
     * Property: vertices
     * {Array(<HGIS.Feature.Vector>)} Verticies currently available
     *     for dragging.
     */
    vertices: null,

    /**
     * Property: virtualVertices
     * {Array(<HGIS.Feature.Vector>)} Virtual vertices in the middle
     *     of each edge.
     */
    virtualVertices: null,

    /**
     * Property: handlers
     * {Object}
     */
    handlers: null,

    /**
     * APIProperty: deleteCodes
     * {Array(Integer)} Keycodes for deleting verticies.  Set to null to disable
     *     vertex deltion by keypress.  If non-null, keypresses with codes
     *     in this array will delete vertices under the mouse. Default
     *     is 46 and 68, the 'delete' and lowercase 'd' keys.
     */
    deleteCodes: null,

    /**
     * APIProperty: virtualStyle
     * {Object} A symbolizer to be used for virtual vertices.
     */
    virtualStyle: null,

    /**
     * APIProperty: vertexRenderIntent
     * {String} The renderIntent to use for vertices. If no <virtualStyle> is
     * provided, this renderIntent will also be used for virtual vertices, with
     * a fillOpacity and strokeOpacity of 0.3. Default is null, which means
     * that the layer's default style will be used for vertices.
     */
    vertexRenderIntent: null,

    /**
     * APIProperty: mode
     * {Integer} Bitfields specifying the modification mode. Defaults to
     *      HGIS.Control.ModifyFeature.RESHAPE. To set the mode to a
     *      combination of options, use the | operator. For example, to allow
     *      the control to both resize and rotate features, use the following
     *      syntax
     * (code)
     * control.mode = HGIS.Control.ModifyFeature.RESIZE |
     *                HGIS.Control.ModifyFeature.ROTATE;
     *  (end)
     */
    mode: null,

    /**
     * APIProperty: createVertices
     * {Boolean} Create new vertices by dragging the virtual vertices
     *     in the middle of each edge. Default is true.
     */
    createVertices: true,

    /**
     * Property: modified
     * {Boolean} The currently selected feature has been modified.
     */
    modified: false,

    /**
     * Property: radiusHandle
     * {<HGIS.Feature.Vector>} A handle for rotating/resizing a feature.
     */
    radiusHandle: null,

    /**
     * Property: dragHandle
     * {<HGIS.Feature.Vector>} A handle for dragging a feature.
     */
    dragHandle: null,

    /**
     * APIProperty: onModificationStart 
     * {Function} *Deprecated*.  Register for "beforefeaturemodified" instead.
     *     The "beforefeaturemodified" event is triggered on the layer before
     *     any modification begins.
     *
     * Optional function to be called when a feature is selected
     *     to be modified. The function should expect to be called with a
     *     feature.  This could be used for example to allow to lock the
     *     feature on server-side.
     */
    onModificationStart: function() {},

    /**
     * APIProperty: onModification
     * {Function} *Deprecated*.  Register for "featuremodified" instead.
     *     The "featuremodified" event is triggered on the layer with each
     *     feature modification.
     *
     * Optional function to be called when a feature has been
     *     modified.  The function should expect to be called with a feature.
     */
    onModification: function() {},

    /**
     * APIProperty: onModificationEnd
     * {Function} *Deprecated*.  Register for "afterfeaturemodified" instead.
     *     The "afterfeaturemodified" event is triggered on the layer after
     *     a feature has been modified.
     *
     * Optional function to be called when a feature is finished 
     *     being modified.  The function should expect to be called with a
     *     feature.
     */
    onModificationEnd: function() {},

    /**
     * Constructor: HGIS.Control.ModifyFeature
     * Create a new modify feature control.
     *
     * Parameters:
     * layer - {<HGIS.Layer.Vector>} Layer that contains features that
     *     will be modified.
     * options - {Object} Optional object whose properties will be set on the
     *     control.
     */
    initialize: function(layer, options) {
        options = options || {};
        this.layer = layer;
        this.vertices = [];
        this.virtualVertices = [];
        this.virtualStyle = HGIS.Util.extend({},
            this.layer.style ||
            this.layer.styleMap.createSymbolizer(null, options.vertexRenderIntent)
        );
        this.virtualStyle.fillOpacity = 0.3;
        this.virtualStyle.strokeOpacity = 0.3;
        this.deleteCodes = [46, 68];
        this.mode = HGIS.Control.ModifyFeature.RESHAPE;
        HGIS.Control.prototype.initialize.apply(this, [options]);
        if(!(HGIS.Util.isArray(this.deleteCodes))) {
            this.deleteCodes = [this.deleteCodes];
        }
        
        // configure the drag handler
        var dragCallbacks = {
            down: function(pixel) {
                this.vertex = null;
                var feature = this.layer.getFeatureFromEvent(
                        this.handlers.drag.evt);
                if (feature) {
                    this.dragStart(feature);
                } else if (this.clickout) {
                    this._unselect = this.feature;
                }
            },
            move: function(pixel) {
                delete this._unselect;
                if (this.vertex) {
                    this.dragVertex(this.vertex, pixel);
                }
            },
            up: function() {
                this.handlers.drag.stopDown = false;
                if (this._unselect) {
                    this.unselectFeature(this._unselect);
                    delete this._unselect;
                }
            },
            done: function(pixel) {
                if (this.vertex) {
                    this.dragComplete(this.vertex);
                }
            }
        };
        var dragOptions = {
            documentDrag: this.documentDrag,
            stopDown: false
        };

        // configure the keyboard handler
        var keyboardOptions = {
            keydown: this.handleKeypress
        };
        this.handlers = {
            keyboard: new HGIS.Handler.Keyboard(this, keyboardOptions),
            drag: new HGIS.Handler.Drag(this, dragCallbacks, dragOptions)
        };
    },

    /**
     * APIMethod: destroy
     * Take care of things that are not handled in superclass.
     */
    destroy: function() {
        if (this.map) {
            this.map.events.un({
                "removelayer": this.handleMapEvents,
                "changelayer": this.handleMapEvents,
                scope: this
            });
        }
        this.layer = null;
        HGIS.Control.prototype.destroy.apply(this, []);
    },

    /**
     * APIMethod: activate
     * Activate the control.
     * 
     * Returns:
     * {Boolean} Successfully activated the control.
     */
    activate: function() {
        this.moveLayerToTop();
        this.map.events.on({
            "removelayer": this.handleMapEvents,
            "changelayer": this.handleMapEvents,
            scope: this
        });
        return (this.handlers.keyboard.activate() &&
                this.handlers.drag.activate() &&
                HGIS.Control.prototype.activate.apply(this, arguments));
    },

    /**
     * APIMethod: deactivate
     * Deactivate the control.
     *
     * Returns: 
     * {Boolean} Successfully deactivated the control.
     */
    deactivate: function() {
        var deactivated = false;
        // the return from the controls is unimportant in this case
        if(HGIS.Control.prototype.deactivate.apply(this, arguments)) {
            this.moveLayerBack();
            this.map.events.un({
                "removelayer": this.handleMapEvents,
                "changelayer": this.handleMapEvents,
                scope: this
            });
            this.layer.removeFeatures(this.vertices, {silent: true});
            this.layer.removeFeatures(this.virtualVertices, {silent: true});
            this.vertices = [];
            this.handlers.drag.deactivate();
            this.handlers.keyboard.deactivate();
            var feature = this.feature;
            if (feature && feature.geometry && feature.layer) {
                this.unselectFeature(feature);
            }
            deactivated = true;
        }
        return deactivated;
    },

    /**
     * Method: beforeSelectFeature
     * Called before a feature is selected.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} The feature about to be selected.
     */
    beforeSelectFeature: function(feature) {
        return this.layer.events.triggerEvent(
            "beforefeaturemodified", {feature: feature}
        );
    },

    /**
     * APIMethod: selectFeature
     * Select a feature for modification in standalone mode. In non-standalone
     * mode, this method is called when a feature is selected by clicking.
     * Register a listener to the beforefeaturemodified event and return false
     * to prevent feature modification.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} the selected feature.
     */
    selectFeature: function(feature) {
        if (this.feature === feature ||
           (this.geometryTypes && HGIS.Util.indexOf(this.geometryTypes,
           feature.geometry.CLASS_NAME) == -1)) {
            return;
        }
        if (this.beforeSelectFeature(feature) !== false) {
            if (this.feature) {
                this.unselectFeature(this.feature);
            }
            this.feature = feature;
            this.layer.selectedFeatures.push(feature);
            this.layer.drawFeature(feature, 'select');
            this.modified = false;
            this.resetVertices();
            this.onModificationStart(this.feature);
        }
        // keep track of geometry modifications
        var modified = feature.modified;
        if (feature.geometry && !(modified && modified.geometry)) {
            this._originalGeometry = feature.geometry.clone();
        }
    },

    /**
     * APIMethod: unselectFeature
     * Called when the select feature control unselects a feature.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} The unselected feature.
     */
    unselectFeature: function(feature) {
        this.layer.removeFeatures(this.vertices, {silent: true});
        this.vertices = [];
        this.layer.destroyFeatures(this.virtualVertices, {silent: true});
        this.virtualVertices = [];
        if(this.dragHandle) {
            this.layer.destroyFeatures([this.dragHandle], {silent: true});
            delete this.dragHandle;
        }
        if(this.radiusHandle) {
            this.layer.destroyFeatures([this.radiusHandle], {silent: true});
            delete this.radiusHandle;
        }
        this.layer.drawFeature(this.feature, 'default');
        this.feature = null;
        HGIS.Util.removeItem(this.layer.selectedFeatures, feature);
        this.onModificationEnd(feature);
        this.layer.events.triggerEvent("afterfeaturemodified", {
            feature: feature,
            modified: this.modified
        });
        this.modified = false;
    },
    
    
    /**
     * Method: dragStart
     * Called by the drag handler before a feature is dragged.  This method is
     *     used to differentiate between points and vertices
     *     of higher order geometries.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} The point or vertex about to be
     *     dragged.
     */
    dragStart: function(feature) {
        var isPoint = feature.geometry.CLASS_NAME ==
                'HGIS.Geometry.Point';
        if (!this.standalone &&
                ((!feature._sketch && isPoint) || !feature._sketch)) {
            if (this.toggle && this.feature === feature) {
                // mark feature for unselection
                this._unselect = feature;
            }
            this.selectFeature(feature);
        }
        if (feature._sketch || isPoint) {
            // feature is a drag or virtual handle or point
            this.vertex = feature;
            this.handlers.drag.stopDown = true;
        }
    },

    /**
     * Method: dragVertex
     * Called by the drag handler with each drag move of a vertex.
     *
     * Parameters:
     * vertex - {<HGIS.Feature.Vector>} The vertex being dragged.
     * pixel - {<HGIS.Pixel>} Pixel location of the mouse event.
     */
    dragVertex: function(vertex, pixel) {
        var pos = this.map.getLonLatFromViewPortPx(pixel);
        var geom = vertex.geometry;
        geom.move(pos.lon - geom.x, pos.lat - geom.y);
        this.modified = true;
        /**
         * Five cases:
         * 1) dragging a simple point
         * 2) dragging a virtual vertex
         * 3) dragging a drag handle
         * 4) dragging a real vertex
         * 5) dragging a radius handle
         */
        if(this.feature.geometry.CLASS_NAME == "HGIS.Geometry.Point") {
            // dragging a simple point
            this.layer.events.triggerEvent("vertexmodified", {
                vertex: vertex.geometry,
                feature: this.feature,
                pixel: pixel
            });
        } else {
            if(vertex._index) {
                // dragging a virtual vertex
                vertex.geometry.parent.addComponent(vertex.geometry,
                                                    vertex._index);
                // move from virtual to real vertex
                delete vertex._index;
                HGIS.Util.removeItem(this.virtualVertices, vertex);
                this.vertices.push(vertex);
            } else if(vertex == this.dragHandle) {
                // dragging a drag handle
                this.layer.removeFeatures(this.vertices, {silent: true});
                this.vertices = [];
                if(this.radiusHandle) {
                    this.layer.destroyFeatures([this.radiusHandle], {silent: true});
                    this.radiusHandle = null;
                }
            } else if(vertex !== this.radiusHandle) {
                // dragging a real vertex
                this.layer.events.triggerEvent("vertexmodified", {
                    vertex: vertex.geometry,
                    feature: this.feature,
                    pixel: pixel
                });
            }
            // dragging a radius handle - no special treatment
            if(this.virtualVertices.length > 0) {
                this.layer.destroyFeatures(this.virtualVertices, {silent: true});
                this.virtualVertices = [];
            }
            this.layer.drawFeature(this.feature, this.standalone ? undefined :
                                            'select');
        }
        // keep the vertex on top so it gets the mouseout after dragging
        // this should be removed in favor of an option to draw under or
        // maintain node z-index
        this.layer.drawFeature(vertex);
    },
    
    /**
     * Method: dragComplete
     * Called by the drag handler when the feature dragging is complete.
     *
     * Parameters:
     * vertex - {<HGIS.Feature.Vector>} The vertex being dragged.
     */
    dragComplete: function(vertex) {
        this.resetVertices();
        this.setFeatureState();
        this.onModification(this.feature);
        this.layer.events.triggerEvent("featuremodified", 
                                       {feature: this.feature});
    },
    
    /**
     * Method: setFeatureState
     * Called when the feature is modified.  If the current state is not
     *     INSERT or DELETE, the state is set to UPDATE.
     */
    setFeatureState: function() {
        if(this.feature.state != HGIS.State.INSERT &&
           this.feature.state != HGIS.State.DELETE) {
            this.feature.state = HGIS.State.UPDATE;
            if (this.modified && this._originalGeometry) {
                var feature = this.feature;
                feature.modified = HGIS.Util.extend(feature.modified, {
                    geometry: this._originalGeometry
                });
                delete this._originalGeometry;
            }
        }
    },
    
    /**
     * Method: resetVertices
     */
    resetVertices: function() {
        if(this.vertices.length > 0) {
            this.layer.removeFeatures(this.vertices, {silent: true});
            this.vertices = [];
        }
        if(this.virtualVertices.length > 0) {
            this.layer.removeFeatures(this.virtualVertices, {silent: true});
            this.virtualVertices = [];
        }
        if(this.dragHandle) {
            this.layer.destroyFeatures([this.dragHandle], {silent: true});
            this.dragHandle = null;
        }
        if(this.radiusHandle) {
            this.layer.destroyFeatures([this.radiusHandle], {silent: true});
            this.radiusHandle = null;
        }
        if(this.feature &&
           this.feature.geometry.CLASS_NAME != "HGIS.Geometry.Point") {
            if((this.mode & HGIS.Control.ModifyFeature.DRAG)) {
                this.collectDragHandle();
            }
            if((this.mode & (HGIS.Control.ModifyFeature.ROTATE |
                             HGIS.Control.ModifyFeature.RESIZE))) {
                this.collectRadiusHandle();
            }
            if(this.mode & HGIS.Control.ModifyFeature.RESHAPE){
                // Don't collect vertices when we're resizing
                if (!(this.mode & HGIS.Control.ModifyFeature.RESIZE)){
                    this.collectVertices();
                }
            }
        }
    },
    
    /**
     * Method: handleKeypress
     * Called by the feature handler on keypress.  This is used to delete
     *     vertices. If the <deleteCode> property is set, vertices will
     *     be deleted when a feature is selected for modification and
     *     the mouse is over a vertex.
     *
     * Parameters:
     * evt - {Event} Keypress event.
     */
    handleKeypress: function(evt) {
        var code = evt.keyCode;
        
        // check for delete key
        if(this.feature &&
           HGIS.Util.indexOf(this.deleteCodes, code) != -1) {
            var vertex = this.layer.getFeatureFromEvent(this.handlers.drag.evt);
            if (vertex &&
                    HGIS.Util.indexOf(this.vertices, vertex) != -1 &&
                    !this.handlers.drag.dragging && vertex.geometry.parent) {
                // remove the vertex
                vertex.geometry.parent.removeComponent(vertex.geometry);
                this.layer.events.triggerEvent("vertexremoved", {
                    vertex: vertex.geometry,
                    feature: this.feature,
                    pixel: evt.xy
                });
                this.layer.drawFeature(this.feature, this.standalone ?
                                       undefined : 'select');
                this.modified = true;
                this.resetVertices();
                this.setFeatureState();
                this.onModification(this.feature);
                this.layer.events.triggerEvent("featuremodified", 
                                               {feature: this.feature});
            }
        }
    },

    /**
     * Method: collectVertices
     * Collect the vertices from the modifiable feature's geometry and push
     *     them on to the control's vertices array.
     */
    collectVertices: function() {
        this.vertices = [];
        this.virtualVertices = [];        
        var control = this;
        function collectComponentVertices(geometry) {
            var i, vertex, component, len;
            if(geometry.CLASS_NAME == "HGIS.Geometry.Point") {
                vertex = new HGIS.Feature.Vector(geometry);
                vertex._sketch = true;
                vertex.renderIntent = control.vertexRenderIntent;
                control.vertices.push(vertex);
            } else {
                var numVert = geometry.components.length;
                if(geometry.CLASS_NAME == "HGIS.Geometry.LinearRing") {
                    numVert -= 1;
                }
                for(i=0; i<numVert; ++i) {
                    component = geometry.components[i];
                    if(component.CLASS_NAME == "HGIS.Geometry.Point") {
                        vertex = new HGIS.Feature.Vector(component);
                        vertex._sketch = true;
                        vertex.renderIntent = control.vertexRenderIntent;
                        control.vertices.push(vertex);
                    } else {
                        collectComponentVertices(component);
                    }
                }
                
                // add virtual vertices in the middle of each edge
                if (control.createVertices && geometry.CLASS_NAME != "HGIS.Geometry.MultiPoint") {
                    for(i=0, len=geometry.components.length; i<len-1; ++i) {
                        var prevVertex = geometry.components[i];
                        var nextVertex = geometry.components[i + 1];
                        if(prevVertex.CLASS_NAME == "HGIS.Geometry.Point" &&
                           nextVertex.CLASS_NAME == "HGIS.Geometry.Point") {
                            var x = (prevVertex.x + nextVertex.x) / 2;
                            var y = (prevVertex.y + nextVertex.y) / 2;
                            var point = new HGIS.Feature.Vector(
                                new HGIS.Geometry.Point(x, y),
                                null, control.virtualStyle
                            );
                            // set the virtual parent and intended index
                            point.geometry.parent = geometry;
                            point._index = i + 1;
                            point._sketch = true;
                            control.virtualVertices.push(point);
                        }
                    }
                }
            }
        }
        collectComponentVertices.call(this, this.feature.geometry);
        this.layer.addFeatures(this.virtualVertices, {silent: true});
        this.layer.addFeatures(this.vertices, {silent: true});
    },

    /**
     * Method: collectDragHandle
     * Collect the drag handle for the selected geometry.
     */
    collectDragHandle: function() {
        var geometry = this.feature.geometry;
        var center = geometry.getBounds().getCenterLonLat();
        var originGeometry = new HGIS.Geometry.Point(
            center.lon, center.lat
        );
        var origin = new HGIS.Feature.Vector(originGeometry);
        originGeometry.move = function(x, y) {
            HGIS.Geometry.Point.prototype.move.call(this, x, y);
            geometry.move(x, y);
        };
        origin._sketch = true;
        this.dragHandle = origin;
        this.dragHandle.renderIntent = this.vertexRenderIntent;
        this.layer.addFeatures([this.dragHandle], {silent: true});
    },

    /**
     * Method: collectRadiusHandle
     * Collect the radius handle for the selected geometry.
     */
    collectRadiusHandle: function() {
        var geometry = this.feature.geometry;
        var bounds = geometry.getBounds();
        var center = bounds.getCenterLonLat();
        var originGeometry = new HGIS.Geometry.Point(
            center.lon, center.lat
        );
        var radiusGeometry = new HGIS.Geometry.Point(
            bounds.right, bounds.bottom
        );
        var radius = new HGIS.Feature.Vector(radiusGeometry);
        var resize = (this.mode & HGIS.Control.ModifyFeature.RESIZE);
        var reshape = (this.mode & HGIS.Control.ModifyFeature.RESHAPE);
        var rotate = (this.mode & HGIS.Control.ModifyFeature.ROTATE);

        radiusGeometry.move = function(x, y) {
            HGIS.Geometry.Point.prototype.move.call(this, x, y);
            var dx1 = this.x - originGeometry.x;
            var dy1 = this.y - originGeometry.y;
            var dx0 = dx1 - x;
            var dy0 = dy1 - y;
            if(rotate) {
                var a0 = Math.atan2(dy0, dx0);
                var a1 = Math.atan2(dy1, dx1);
                var angle = a1 - a0;
                angle *= 180 / Math.PI;
                geometry.rotate(angle, originGeometry);
            }
            if(resize) {
                var scale, ratio;
                // 'resize' together with 'reshape' implies that the aspect 
                // ratio of the geometry will not be preserved whilst resizing 
                if (reshape) {
                    scale = dy1 / dy0;
                    ratio = (dx1 / dx0) / scale;
                } else {
                    var l0 = Math.sqrt((dx0 * dx0) + (dy0 * dy0));
                    var l1 = Math.sqrt((dx1 * dx1) + (dy1 * dy1));
                    scale = l1 / l0;
                }
                geometry.resize(scale, originGeometry, ratio);
            }
        };
        radius._sketch = true;
        this.radiusHandle = radius;
        this.radiusHandle.renderIntent = this.vertexRenderIntent;
        this.layer.addFeatures([this.radiusHandle], {silent: true});
    },

    /**
     * Method: setMap
     * Set the map property for the control and all handlers.
     *
     * Parameters:
     * map - {<HGIS.Map>} The control's map.
     */
    setMap: function(map) {
        this.handlers.drag.setMap(map);
        HGIS.Control.prototype.setMap.apply(this, arguments);
    },

    /**
     * Method: handleMapEvents
     * 
     * Parameters:
     * evt - {Object}
     */
    handleMapEvents: function(evt) {
        if (evt.type == "removelayer" || evt.property == "order") {
            this.moveLayerToTop();
        }
    },

    /**
     * Method: moveLayerToTop
     * Moves the layer for this handler to the top, so mouse events can reach
     * it.
     */
    moveLayerToTop: function() {
        var index = Math.max(this.map.Z_INDEX_BASE['Feature'] - 1,
            this.layer.getZIndex()) + 1;
        this.layer.setZIndex(index);
        
    },

    /**
     * Method: moveLayerBack
     * Moves the layer back to the position determined by the map's layers
     * array.
     */
    moveLayerBack: function() {
        var index = this.layer.getZIndex() - 1;
        if (index >= this.map.Z_INDEX_BASE['Feature']) {
            this.layer.setZIndex(index);
        } else {
            this.map.setLayerZIndex(this.layer,
                this.map.getLayerIndex(this.layer));
        }
    },

    CLASS_NAME: "HGIS.Control.ModifyFeature"
});

/**
 * Constant: RESHAPE
 * {Integer} Constant used to make the control work in reshape mode
 */
HGIS.Control.ModifyFeature.RESHAPE = 1;
/**
 * Constant: RESIZE
 * {Integer} Constant used to make the control work in resize mode
 */
HGIS.Control.ModifyFeature.RESIZE = 2;
/**
 * Constant: ROTATE
 * {Integer} Constant used to make the control work in rotate mode
 */
HGIS.Control.ModifyFeature.ROTATE = 4;
/**
 * Constant: DRAG
 * {Integer} Constant used to make the control work in drag mode
 */
HGIS.Control.ModifyFeature.DRAG = 8;
/* ======================================================================
    HGIS/Layer/Bing.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer/XYZ.js
 */

/** 
 * Class: HGIS.Layer.Bing
 * Bing layer using direct tile access as provided by Bing Maps REST Services.
 * See http://msdn.microsoft.com/en-us/library/ff701713.aspx for more
 * information. Note: Terms of Service compliant use requires the map to be
 * configured with an <HGIS.Control.Attribution> control and the
 * attribution placed on or near the map.
 * 
 * Inherits from:
 *  - <HGIS.Layer.XYZ>
 */
HGIS.Layer.Bing = HGIS.Class(HGIS.Layer.XYZ, {

    /**
     * Property: key
     * {String} API key for Bing maps, get your own key 
     *     at http://bingmapsportal.com/ .
     */
    key: null,

    /**
     * Property: serverResolutions
     * {Array} the resolutions provided by the Bing servers.
     */
    serverResolutions: [
        156543.03390625, 78271.516953125, 39135.7584765625,
        19567.87923828125, 9783.939619140625, 4891.9698095703125,
        2445.9849047851562, 1222.9924523925781, 611.4962261962891,
        305.74811309814453, 152.87405654907226, 76.43702827453613,
        38.218514137268066, 19.109257068634033, 9.554628534317017,
        4.777314267158508, 2.388657133579254, 1.194328566789627,
        0.5971642833948135, 0.29858214169740677, 0.14929107084870338,
        0.07464553542435169
    ],
    
    /**
     * Property: attributionTemplate
     * {String}
     */
    attributionTemplate: '<span class="olBingAttribution ${type}">' +
         '<div><a target="_blank" href="http://www.bing.com/maps/">' +
         '<img src="${logo}" /></a></div>${copyrights}' +
         '<a style="white-space: nowrap" target="_blank" '+
         'href="http://www.microsoft.com/maps/product/terms.html">' +
         'Terms of Use</a></span>',

    /**
     * Property: metadata
     * {Object} Metadata for this layer, as returned by the callback script
     */
    metadata: null,

    /**
     * Property: protocolRegex
     * {RegExp} Regular expression to match and replace http: in bing urls
     */
    protocolRegex: /^http:/i,
    
    /**
     * APIProperty: type
     * {String} The layer identifier.  Any non-birdseye imageryType
     *     from http://msdn.microsoft.com/en-us/library/ff701716.aspx can be
     *     used.  Default is "Road".
     */
    type: "Road",
    
    /**
     * APIProperty: culture
     * {String} The culture identifier.  See http://msdn.microsoft.com/en-us/library/ff701709.aspx
     * for the definition and the possible values.  Default is "en-US".
     */
    culture: "en-US",
    
    /**
     * APIProperty: metadataParams
     * {Object} Optional url parameters for the Get Imagery Metadata request
     * as described here: http://msdn.microsoft.com/en-us/library/ff701716.aspx
     */
    metadataParams: null,

    /** APIProperty: tileOptions
     *  {Object} optional configuration options for <HGIS.Tile> instances
     *  created by this Layer. Default is
     *
     *  (code)
     *  {crossOriginKeyword: 'anonymous'}
     *  (end)
     */
    tileOptions: null,

    /** APIProperty: protocol
     *  {String} Protocol to use to fetch Imagery Metadata, tiles and bing logo
     *  Can be 'http:' 'https:' or ''
     *
     *  Warning: tiles may not be available under both HTTP and HTTPS protocols.
     *  Microsoft approved use of both HTTP and HTTPS urls for tiles. However
     *  this is undocumented and the Imagery Metadata API always returns HTTP
     *  urls.
     *
     *  Default is '', unless when executed from a file:/// uri, in which case
     *  it is 'http:'.
     */
    protocol: ~window.location.href.indexOf('http') ? '' : 'http:',

    /**
     * Constructor: HGIS.Layer.Bing
     * Create a new Bing layer.
     *
     * Example:
     * (code)
     * var road = new HGIS.Layer.Bing({
     *     name: "My Bing Aerial Layer",
     *     type: "Aerial",
     *     key: "my-api-key-here",
     * });
     * (end)
     *
     * Parameters:
     * options - {Object} Configuration properties for the layer.
     *
     * Required configuration properties:
     * key - {String} Bing Maps API key for your application. Get one at
     *     http://bingmapsportal.com/.
     * type - {String} The layer identifier.  Any non-birdseye imageryType
     *     from http://msdn.microsoft.com/en-us/library/ff701716.aspx can be
     *     used.
     *
     * Any other documented layer properties can be provided in the config object.
     */
    initialize: function(options) {
        options = HGIS.Util.applyDefaults({
            sphericalMercator: true
        }, options);
        var name = options.name || "Bing " + (options.type || this.type);
        
        var newArgs = [name, null, options];
        HGIS.Layer.XYZ.prototype.initialize.apply(this, newArgs);
        this.tileOptions = HGIS.Util.extend({
            crossOriginKeyword: 'anonymous'
        }, this.options.tileOptions);
        this.loadMetadata(); 
    },

    /**
     * Method: loadMetadata
     */
    loadMetadata: function() {
        this._callbackId = "_callback_" + this.id.replace(/\./g, "_");
        // link the processMetadata method to the global scope and bind it
        // to this instance
        window[this._callbackId] = HGIS.Function.bind(
            HGIS.Layer.Bing.processMetadata, this
        );
        var params = HGIS.Util.applyDefaults({
            key: this.key,
            jsonp: this._callbackId,
            include: "ImageryProviders"
        }, this.metadataParams);
        var url = this.protocol + "//dev.virtualearth.net/REST/v1/Imagery/Metadata/" +
            this.type + "?" + HGIS.Util.getParameterString(params);
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = url;
        script.id = this._callbackId;
        document.getElementsByTagName("head")[0].appendChild(script);
    },
    
    /**
     * Method: initLayer
     *
     * Sets layer properties according to the metadata provided by the API
     */
    initLayer: function() {
        var res = this.metadata.resourceSets[0].resources[0];
        var url = res.imageUrl.replace("{quadkey}", "${quadkey}");
        url = url.replace("{culture}", this.culture);
        url = url.replace(this.protocolRegex, this.protocol);
        this.url = [];
        for (var i=0; i<res.imageUrlSubdomains.length; ++i) {
            this.url.push(url.replace("{subdomain}", res.imageUrlSubdomains[i]));
        }
        this.addOptions({
            maxResolution: Math.min(
                this.serverResolutions[res.zoomMin],
                this.maxResolution || Number.POSITIVE_INFINITY
            ),
            numZoomLevels: Math.min(
                res.zoomMax + 1 - res.zoomMin, this.numZoomLevels
            )
        }, true);
        if (!this.isBaseLayer) {
            this.redraw();
        }
        this.updateAttribution();
    },
    
    /**
     * Method: getURL
     *
     * Paramters:
     * bounds - {<HGIS.Bounds>}
     */
    getURL: function(bounds) {
        if (!this.url) {
            return;
        }
        var xyz = this.getXYZ(bounds), x = xyz.x, y = xyz.y, z = xyz.z;
        var quadDigits = [];
        for (var i = z; i > 0; --i) {
            var digit = '0';
            var mask = 1 << (i - 1);
            if ((x & mask) != 0) {
                digit++;
            }
            if ((y & mask) != 0) {
                digit++;
                digit++;
            }
            quadDigits.push(digit);
        }
        var quadKey = quadDigits.join("");
        var url = this.selectUrl('' + x + y + z, this.url);

        return HGIS.String.format(url, {'quadkey': quadKey});
    },
    
    /**
     * Method: updateAttribution
     * Updates the attribution according to the requirements outlined in
     * http://gis.638310.n2.nabble.com/Bing-imagery-td5789168.html
     */
    updateAttribution: function() {
        var metadata = this.metadata;
        if (!metadata.resourceSets || !this.map || !this.map.center) {
            return;
        }
        var res = metadata.resourceSets[0].resources[0];
        var extent = this.map.getExtent().transform(
            this.map.getProjectionObject(),
            new HGIS.Projection("EPSG:4326")
        );
        var providers = res.imageryProviders || [],
            zoom = HGIS.Util.indexOf(this.serverResolutions,
                                           this.getServerResolution()),
            copyrights = "", provider, i, ii, j, jj, bbox, coverage;
        for (i=0,ii=providers.length; i<ii; ++i) {
            provider = providers[i];
            for (j=0,jj=provider.coverageAreas.length; j<jj; ++j) {
                coverage = provider.coverageAreas[j];
                // axis order provided is Y,X
                bbox = HGIS.Bounds.fromArray(coverage.bbox, true);
                if (extent.intersectsBounds(bbox) &&
                        zoom <= coverage.zoomMax && zoom >= coverage.zoomMin) {
                    copyrights += provider.attribution + " ";
                }
            }
        }
        var logo = metadata.brandLogoUri.replace(this.protocolRegex, this.protocol);
        this.attribution = HGIS.String.format(this.attributionTemplate, {
            type: this.type.toLowerCase(),
            logo: logo,
            copyrights: copyrights
        });
        this.map && this.map.events.triggerEvent("changelayer", {
            layer: this,
            property: "attribution"
        });
    },
    
    /**
     * Method: setMap
     */
    setMap: function() {
        HGIS.Layer.XYZ.prototype.setMap.apply(this, arguments);
        this.map.events.register("moveend", this, this.updateAttribution);
    },
    
    /**
     * APIMethod: clone
     * 
     * Parameters:
     * obj - {Object}
     * 
     * Returns:
     * {<HGIS.Layer.Bing>} An exact clone of this <HGIS.Layer.Bing>
     */
    clone: function(obj) {
        if (obj == null) {
            obj = new HGIS.Layer.Bing(this.options);
        }
        //get all additions from superclasses
        obj = HGIS.Layer.XYZ.prototype.clone.apply(this, [obj]);
        // copy/set any non-init, non-simple values here
        return obj;
    },
    
    /**
     * Method: destroy
     */
    destroy: function() {
        this.map &&
            this.map.events.unregister("moveend", this, this.updateAttribution);
        HGIS.Layer.XYZ.prototype.destroy.apply(this, arguments);
    },
    
    CLASS_NAME: "HGIS.Layer.Bing"
});

/**
 * Function: HGIS.Layer.Bing.processMetadata
 * This function will be bound to an instance, linked to the global scope with
 * an id, and called by the JSONP script returned by the API.
 *
 * Parameters:
 * metadata - {Object} metadata as returned by the API
 */
HGIS.Layer.Bing.processMetadata = function(metadata) {
    this.metadata = metadata;
    this.initLayer();
    var script = document.getElementById(this._callbackId);
    script.parentNode.removeChild(script);
    window[this._callbackId] = undefined; // cannot delete from window in IE
    delete this._callbackId;
};
/* ======================================================================
    HGIS/StyleMap.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Style.js
 * @requires HGIS/Feature/Vector.js
 */
 
/**
 * Class: HGIS.StyleMap
 */
HGIS.StyleMap = HGIS.Class({
    
    /**
     * Property: styles
     * {Object} Hash of {<HGIS.Style>}, keyed by names of well known
     * rendering intents (e.g. "default", "temporary", "select", "delete").
     */
    styles: null,
    
    /**
     * Property: extendDefault
     * {Boolean} if true, every render intent will extend the symbolizers
     * specified for the "default" intent at rendering time. Otherwise, every
     * rendering intent will be treated as a completely independent style.
     */
    extendDefault: true,
    
    /**
     * Constructor: HGIS.StyleMap
     * 
     * Parameters:
     * style   - {Object} Optional. Either a style hash, or a style object, or
     *           a hash of style objects (style hashes) keyed by rendering
     *           intent. If just one style hash or style object is passed,
     *           this will be used for all known render intents (default,
     *           select, temporary)
     * options - {Object} optional hash of additional options for this
     *           instance
     */
    initialize: function (style, options) {
        this.styles = {
            "default": new HGIS.Style(
                HGIS.Feature.Vector.style["default"]),
            "select": new HGIS.Style(
                HGIS.Feature.Vector.style["select"]),
            "temporary": new HGIS.Style(
                HGIS.Feature.Vector.style["temporary"]),
            "delete": new HGIS.Style(
                HGIS.Feature.Vector.style["delete"])
        };
        
        // take whatever the user passed as style parameter and convert it
        // into parts of stylemap.
        if(style instanceof HGIS.Style) {
            // user passed a style object
            this.styles["default"] = style;
            this.styles["select"] = style;
            this.styles["temporary"] = style;
            this.styles["delete"] = style;
        } else if(typeof style == "object") {
            for(var key in style) {
                if(style[key] instanceof HGIS.Style) {
                    // user passed a hash of style objects
                    this.styles[key] = style[key];
                } else if(typeof style[key] == "object") {
                    // user passsed a hash of style hashes
                    this.styles[key] = new HGIS.Style(style[key]);
                } else {
                    // user passed a style hash (i.e. symbolizer)
                    this.styles["default"] = new HGIS.Style(style);
                    this.styles["select"] = new HGIS.Style(style);
                    this.styles["temporary"] = new HGIS.Style(style);
                    this.styles["delete"] = new HGIS.Style(style);
                    break;
                }
            }
        }
        HGIS.Util.extend(this, options);
    },

    /**
     * Method: destroy
     */
    destroy: function() {
        for(var key in this.styles) {
            this.styles[key].destroy();
        }
        this.styles = null;
    },
    
    /**
     * Method: createSymbolizer
     * Creates the symbolizer for a feature for a render intent.
     * 
     * Parameters:
     * feature - {<HGIS.Feature>} The feature to evaluate the rules
     *           of the intended style against.
     * intent  - {String} The intent determines the symbolizer that will be
     *           used to draw the feature. Well known intents are "default"
     *           (for just drawing the features), "select" (for selected
     *           features) and "temporary" (for drawing features).
     * 
     * Returns:
     * {Object} symbolizer hash
     */
    createSymbolizer: function(feature, intent) {
        if(!feature) {
            feature = new HGIS.Feature.Vector();
        }
        if(!this.styles[intent]) {
            intent = "default";
        }
        feature.renderIntent = intent;
        var defaultSymbolizer = {};
        if(this.extendDefault && intent != "default") {
            defaultSymbolizer = this.styles["default"].createSymbolizer(feature);
        }
        return HGIS.Util.extend(defaultSymbolizer,
            this.styles[intent].createSymbolizer(feature));
    },
    
    /**
     * Method: addUniqueValueRules
     * Convenience method to create comparison rules for unique values of a
     * property. The rules will be added to the style object for a specified
     * rendering intent. This method is a shortcut for creating something like
     * the "unique value legends" familiar from well known desktop GIS systems
     * 
     * Parameters:
     * renderIntent - {String} rendering intent to add the rules to
     * property     - {String} values of feature attributes to create the
     *                rules for
     * symbolizers  - {Object} Hash of symbolizers, keyed by the desired
     *                property values 
     * context      - {Object} An optional object with properties that
     *                symbolizers' property values should be evaluated
     *                against. If no context is specified, feature.attributes
     *                will be used
     */
    addUniqueValueRules: function(renderIntent, property, symbolizers, context) {
        var rules = [];
        for (var value in symbolizers) {
            rules.push(new HGIS.Rule({
                symbolizer: symbolizers[value],
                context: context,
                filter: new HGIS.Filter.Comparison({
                    type: HGIS.Filter.Comparison.EQUAL_TO,
                    property: property,
                    value: value
                })
            }));
        }
        this.styles[renderIntent].addRules(rules);
    },

    CLASS_NAME: "HGIS.StyleMap"
});
/* ======================================================================
    HGIS/Layer/Vector.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer.js
 * @requires HGIS/Renderer.js
 * @requires HGIS/StyleMap.js
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Console.js
 * @requires HGIS/Lang.js
 */

/**
 * Class: HGIS.Layer.Vector
 * Instances of HGIS.Layer.Vector are used to render vector data from
 *     a variety of sources. Create a new vector layer with the
 *     <HGIS.Layer.Vector> constructor.
 *
 * Inherits from:
 *  - <HGIS.Layer>
 */
HGIS.Layer.Vector = HGIS.Class(HGIS.Layer, {

    /**
     * APIProperty: events
     * {<HGIS.Events>}
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * layer.events.register(type, obj, listener);
     * (end)
     *
     * Listeners will be called with a reference to an event object.  The
     *     properties of this event depends on exactly what happened.
     *
     * All event objects have at least the following properties:
     * object - {Object} A reference to layer.events.object.
     * element - {DOMElement} A reference to layer.events.element.
     *
     * Supported map event types (in addition to those from <HGIS.Layer.events>):
     * beforefeatureadded - Triggered before a feature is added.  Listeners
     *      will receive an object with a *feature* property referencing the
     *      feature to be added.  To stop the feature from being added, a
     *      listener should return false.
     * beforefeaturesadded - Triggered before an array of features is added.
     *      Listeners will receive an object with a *features* property
     *      referencing the feature to be added. To stop the features from
     *      being added, a listener should return false.
     * featureadded - Triggered after a feature is added.  The event
     *      object passed to listeners will have a *feature* property with a
     *      reference to the added feature.
     * featuresadded - Triggered after features are added.  The event
     *      object passed to listeners will have a *features* property with a
     *      reference to an array of added features.
     * beforefeatureremoved - Triggered before a feature is removed. Listeners
     *      will receive an object with a *feature* property referencing the
     *      feature to be removed.
     * beforefeaturesremoved - Triggered before multiple features are removed. 
     *      Listeners will receive an object with a *features* property
     *      referencing the features to be removed.
     * featureremoved - Triggerd after a feature is removed. The event
     *      object passed to listeners will have a *feature* property with a
     *      reference to the removed feature.
     * featuresremoved - Triggered after features are removed. The event
     *      object passed to listeners will have a *features* property with a
     *      reference to an array of removed features.
     * beforefeatureselected - Triggered before a feature is selected.  Listeners
     *      will receive an object with a *feature* property referencing the
     *      feature to be selected. To stop the feature from being selectd, a
     *      listener should return false.
     * featureselected - Triggered after a feature is selected.  Listeners
     *      will receive an object with a *feature* property referencing the
     *      selected feature.
     * featureunselected - Triggered after a feature is unselected.
     *      Listeners will receive an object with a *feature* property
     *      referencing the unselected feature.
     * beforefeaturemodified - Triggered when a feature is selected to 
     *      be modified.  Listeners will receive an object with a *feature* 
     *      property referencing the selected feature.
     * featuremodified - Triggered when a feature has been modified.
     *      Listeners will receive an object with a *feature* property referencing 
     *      the modified feature.
     * afterfeaturemodified - Triggered when a feature is finished being modified.
     *      Listeners will receive an object with a *feature* property referencing 
     *      the modified feature.
     * vertexmodified - Triggered when a vertex within any feature geometry
     *      has been modified.  Listeners will receive an object with a
     *      *feature* property referencing the modified feature, a *vertex*
     *      property referencing the vertex modified (always a point geometry),
     *      and a *pixel* property referencing the pixel location of the
     *      modification.
     * vertexremoved - Triggered when a vertex within any feature geometry
     *      has been deleted.  Listeners will receive an object with a
     *      *feature* property referencing the modified feature, a *vertex*
     *      property referencing the vertex modified (always a point geometry),
     *      and a *pixel* property referencing the pixel location of the
     *      removal.
     * sketchstarted - Triggered when a feature sketch bound for this layer
     *      is started.  Listeners will receive an object with a *feature*
     *      property referencing the new sketch feature and a *vertex* property
     *      referencing the creation point.
     * sketchmodified - Triggered when a feature sketch bound for this layer
     *      is modified.  Listeners will receive an object with a *vertex*
     *      property referencing the modified vertex and a *feature* property
     *      referencing the sketch feature.
     * sketchcomplete - Triggered when a feature sketch bound for this layer
     *      is complete.  Listeners will receive an object with a *feature*
     *      property referencing the sketch feature.  By returning false, a
     *      listener can stop the sketch feature from being added to the layer.
     * refresh - Triggered when something wants a strategy to ask the protocol
     *      for a new set of features.
     */

    /**
     * APIProperty: isBaseLayer
     * {Boolean} The layer is a base layer.  Default is false.  Set this property
     * in the layer options.
     */
    isBaseLayer: false,

    /** 
     * APIProperty: isFixed
     * {Boolean} Whether the layer remains in one place while dragging the
     * map. Note that setting this to true will move the layer to the bottom
     * of the layer stack.
     */
    isFixed: false,

    /** 
     * APIProperty: features
     * {Array(<HGIS.Feature.Vector>)} 
     */
    features: null,
    
    /** 
     * Property: filter
     * {<HGIS.Filter>} The filter set in this layer,
     *     a strategy launching read requests can combined
     *     this filter with its own filter.
     */
    filter: null,
    
    /** 
     * Property: selectedFeatures
     * {Array(<HGIS.Feature.Vector>)} 
     */
    selectedFeatures: null,
    
    /**
     * Property: unrenderedFeatures
     * {Object} hash of features, keyed by feature.id, that the renderer
     *     failed to draw
     */
    unrenderedFeatures: null,

    /**
     * APIProperty: reportError
     * {Boolean} report friendly error message when loading of renderer
     * fails.
     */
    reportError: true, 

    /** 
     * APIProperty: style
     * {Object} Default style for the layer
     */
    style: null,
    
    /**
     * Property: styleMap
     * {<HGIS.StyleMap>}
     */
    styleMap: null,
    
    /**
     * Property: strategies
     * {Array(<HGIS.Strategy>})} Optional list of strategies for the layer.
     */
    strategies: null,
    
    /**
     * Property: protocol
     * {<HGIS.Protocol>} Optional protocol for the layer.
     */
    protocol: null,
    
    /**
     * Property: renderers
     * {Array(String)} List of supported Renderer classes. Add to this list to
     * add support for additional renderers. This list is ordered:
     * the first renderer which returns true for the  'supported()'
     * method will be used, if not defined in the 'renderer' option.
     */
    renderers: ['SVG', 'VML', 'Canvas'],
    
    /** 
     * Property: renderer
     * {<HGIS.Renderer>}
     */
    renderer: null,
    
    /**
     * APIProperty: rendererOptions
     * {Object} Options for the renderer. See {<HGIS.Renderer>} for
     *     supported options.
     */
    rendererOptions: null,
    
    /** 
     * APIProperty: geometryType
     * {String} geometryType allows you to limit the types of geometries this
     * layer supports. This should be set to something like
     * "HGIS.Geometry.Point" to limit types.
     */
    geometryType: null,

    /** 
     * Property: drawn
     * {Boolean} Whether the Vector Layer features have been drawn yet.
     */
    drawn: false,
    
    /** 
     * APIProperty: ratio
     * {Float} This specifies the ratio of the size of the visiblity of the Vector Layer features to the size of the map.
     */   
    ratio: 1,

    /**
     * Constructor: HGIS.Layer.Vector
     * Create a new vector layer
     *
     * Parameters:
     * name - {String} A name for the layer
     * options - {Object} Optional object with non-default properties to set on
     *           the layer.
     *
     * Returns:
     * {<HGIS.Layer.Vector>} A new vector layer
     */
    initialize: function(name, options) {
        HGIS.Layer.prototype.initialize.apply(this, arguments);

        // allow user-set renderer, otherwise assign one
        if (!this.renderer || !this.renderer.supported()) {  
            this.assignRenderer();
        }

        // if no valid renderer found, display error
        if (!this.renderer || !this.renderer.supported()) {
            this.renderer = null;
            this.displayError();
        } 

        if (!this.styleMap) {
            this.styleMap = new HGIS.StyleMap();
        }

        this.features = [];
        this.selectedFeatures = [];
        this.unrenderedFeatures = {};
        
        // Allow for custom layer behavior
        if(this.strategies){
            for(var i=0, len=this.strategies.length; i<len; i++) {
                this.strategies[i].setLayer(this);
            }
        }

    },

    /**
     * APIMethod: destroy
     * Destroy this layer
     */
    destroy: function() {
        if (this.strategies) {
            var strategy, i, len;
            for(i=0, len=this.strategies.length; i<len; i++) {
                strategy = this.strategies[i];
                if(strategy.autoDestroy) {
                    strategy.destroy();
                }
            }
            this.strategies = null;
        }
        if (this.protocol) {
            if(this.protocol.autoDestroy) {
                this.protocol.destroy();
            }
            this.protocol = null;
        }
        this.destroyFeatures();
        this.features = null;
        this.selectedFeatures = null;
        this.unrenderedFeatures = null;
        if (this.renderer) {
            this.renderer.destroy();
        }
        this.renderer = null;
        this.geometryType = null;
        this.drawn = null;
        HGIS.Layer.prototype.destroy.apply(this, arguments);  
    },

    /**
     * Method: clone
     * Create a clone of this layer.
     * 
     * Note: Features of the layer are also cloned.
     *
     * Returns:
     * {<HGIS.Layer.Vector>} An exact clone of this layer
     */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new HGIS.Layer.Vector(this.name, this.getOptions());
        }

        //get all additions from superclasses
        obj = HGIS.Layer.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here
        var features = this.features;
        var len = features.length;
        var clonedFeatures = new Array(len);
        for(var i=0; i<len; ++i) {
            clonedFeatures[i] = features[i].clone();
        }
        obj.features = clonedFeatures;

        return obj;
    },    
    
    /**
     * Method: refresh
     * Ask the layer to request features again and redraw them.  Triggers
     *     the refresh event if the layer is in range and visible.
     *
     * Parameters:
     * obj - {Object} Optional object with properties for any listener of
     *     the refresh event.
     */
    refresh: function(obj) {
        if(this.calculateInRange() && this.visibility) {
            this.events.triggerEvent("refresh", obj);
        }
    },

    /** 
     * Method: assignRenderer
     * Iterates through the available renderer implementations and selects 
     * and assigns the first one whose "supported()" function returns true.
     */    
    assignRenderer: function()  {
        for (var i=0, len=this.renderers.length; i<len; i++) {
            var rendererClass = this.renderers[i];
            var renderer = (typeof rendererClass == "function") ?
                rendererClass :
                HGIS.Renderer[rendererClass];
            if (renderer && renderer.prototype.supported()) {
                this.renderer = new renderer(this.div, this.rendererOptions);
                break;
            }  
        }  
    },

    /** 
     * Method: displayError 
     * Let the user know their browser isn't supported.
     */
    displayError: function() {
        if (this.reportError) {
            HGIS.Console.userError(HGIS.i18n("browserNotSupported", 
                                     {renderers: this. renderers.join('\n')}));
        }    
    },

    /** 
     * Method: setMap
     * The layer has been added to the map. 
     * 
     * If there is no renderer set, the layer can't be used. Remove it.
     * Otherwise, give the renderer a reference to the map and set its size.
     * 
     * Parameters:
     * map - {<HGIS.Map>} 
     */
    setMap: function(map) {        
        HGIS.Layer.prototype.setMap.apply(this, arguments);

        if (!this.renderer) {
            this.map.removeLayer(this);
        } else {
            this.renderer.map = this.map;

            var newSize = this.map.getSize();
            newSize.w = newSize.w * this.ratio;
            newSize.h = newSize.h * this.ratio;
            this.renderer.setSize(newSize);
        }
    },

    /**
     * Method: afterAdd
     * Called at the end of the map.addLayer sequence.  At this point, the map
     *     will have a base layer.  Any autoActivate strategies will be
     *     activated here.
     */
    afterAdd: function() {
        if(this.strategies) {
            var strategy, i, len;
            for(i=0, len=this.strategies.length; i<len; i++) {
                strategy = this.strategies[i];
                if(strategy.autoActivate) {
                    strategy.activate();
                }
            }
        }
    },

    /**
     * Method: removeMap
     * The layer has been removed from the map.
     *
     * Parameters:
     * map - {<HGIS.Map>}
     */
    removeMap: function(map) {
        this.drawn = false;
        if(this.strategies) {
            var strategy, i, len;
            for(i=0, len=this.strategies.length; i<len; i++) {
                strategy = this.strategies[i];
                if(strategy.autoActivate) {
                    strategy.deactivate();
                }
            }
        }
    },
    
    /**
     * Method: onMapResize
     * Notify the renderer of the change in size. 
     * 
     */
    onMapResize: function() {
        HGIS.Layer.prototype.onMapResize.apply(this, arguments);
        
        var newSize = this.map.getSize();
        newSize.w = newSize.w * this.ratio;
        newSize.h = newSize.h * this.ratio;
        this.renderer.setSize(newSize);
    },

    /**
     * Method: moveTo
     *  Reset the vector layer's div so that it once again is lined up with 
     *   the map. Notify the renderer of the change of extent, and in the
     *   case of a change of zoom level (resolution), have the 
     *   renderer redraw features.
     * 
     *  If the layer has not yet been drawn, cycle through the layer's 
     *   features and draw each one.
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>} 
     * zoomChanged - {Boolean} 
     * dragging - {Boolean} 
     */
    moveTo: function(bounds, zoomChanged, dragging) {
        HGIS.Layer.prototype.moveTo.apply(this, arguments);
        
        var coordSysUnchanged = true;
        if (!dragging) {
            this.renderer.root.style.visibility = 'hidden';

            var viewSize = this.map.getSize(),
                viewWidth = viewSize.w,
                viewHeight = viewSize.h,
                offsetLeft = (viewWidth / 2 * this.ratio) - viewWidth / 2,
                offsetTop = (viewHeight / 2 * this.ratio) - viewHeight / 2;
            offsetLeft += this.map.layerContainerOriginPx.x;
            offsetLeft = -Math.round(offsetLeft);
            offsetTop += this.map.layerContainerOriginPx.y;
            offsetTop = -Math.round(offsetTop);

            this.div.style.left = offsetLeft + 'px';
            this.div.style.top = offsetTop + 'px';

            var extent = this.map.getExtent().scale(this.ratio);
            coordSysUnchanged = this.renderer.setExtent(extent, zoomChanged);

            this.renderer.root.style.visibility = 'visible';

            // Force a reflow on gecko based browsers to prevent jump/flicker.
            // This seems to happen on only certain configurations; it was originally
            // noticed in FF 2.0 and Linux.
            if (HGIS.IS_GECKO === true) {
                this.div.scrollLeft = this.div.scrollLeft;
            }
            
            if (!zoomChanged && coordSysUnchanged) {
                for (var i in this.unrenderedFeatures) {
                    var feature = this.unrenderedFeatures[i];
                    this.drawFeature(feature);
                }
            }
        }
        if (!this.drawn || zoomChanged || !coordSysUnchanged) {
            this.drawn = true;
            var feature;
            for(var i=0, len=this.features.length; i<len; i++) {
                this.renderer.locked = (i !== (len - 1));
                feature = this.features[i];
                this.drawFeature(feature);
            }
        }    
    },
    
    /** 
     * APIMethod: display
     * Hide or show the Layer
     * 
     * Parameters:
     * display - {Boolean}
     */
    display: function(display) {
        HGIS.Layer.prototype.display.apply(this, arguments);
        // we need to set the display style of the root in case it is attached
        // to a foreign layer
        var currentDisplay = this.div.style.display;
        if(currentDisplay != this.renderer.root.style.display) {
            this.renderer.root.style.display = currentDisplay;
        }
    },

    /**
     * APIMethod: addFeatures
     * Add Features to the layer.
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} 
     * options - {Object}
     */
    addFeatures: function(features, options) {
        if (!(HGIS.Util.isArray(features))) {
            features = [features];
        }
        
        var notify = !options || !options.silent;
        if(notify) {
            var event = {features: features};
            var ret = this.events.triggerEvent("beforefeaturesadded", event);
            if(ret === false) {
                return;
            }
            features = event.features;
        }
        
        // Track successfully added features for featuresadded event, since
        // beforefeatureadded can veto single features.
        var featuresAdded = [];
        for (var i=0, len=features.length; i<len; i++) {
            if (i != (features.length - 1)) {
                this.renderer.locked = true;
            } else {
                this.renderer.locked = false;
            }    
            var feature = features[i];
            
            if (this.geometryType &&
              !(feature.geometry instanceof this.geometryType)) {
                throw new TypeError('addFeatures: component should be an ' +
                                    this.geometryType.prototype.CLASS_NAME);
              }

            //give feature reference to its layer
            feature.layer = this;

            if (!feature.style && this.style) {
                feature.style = HGIS.Util.extend({}, this.style);
            }

            if (notify) {
                if(this.events.triggerEvent("beforefeatureadded",
                                            {feature: feature}) === false) {
                    continue;
                }
                this.preFeatureInsert(feature);
            }

            featuresAdded.push(feature);
            this.features.push(feature);
            this.drawFeature(feature);
            
            if (notify) {
                this.events.triggerEvent("featureadded", {
                    feature: feature
                });
                this.onFeatureInsert(feature);
            }
        }
        
        if(notify) {
            this.events.triggerEvent("featuresadded", {features: featuresAdded});
        }
    },


    /**
     * APIMethod: removeFeatures
     * Remove features from the layer.  This erases any drawn features and
     *     removes them from the layer's control.  The beforefeatureremoved
     *     and featureremoved events will be triggered for each feature.  The
     *     featuresremoved event will be triggered after all features have
     *     been removed.  To supress event triggering, use the silent option.
     * 
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} List of features to be
     *     removed.
     * options - {Object} Optional properties for changing behavior of the
     *     removal.
     *
     * Valid options:
     * silent - {Boolean} Supress event triggering.  Default is false.
     */
    removeFeatures: function(features, options) {
        if(!features || features.length === 0) {
            return;
        }
        if (features === this.features) {
            return this.removeAllFeatures(options);
        }
        if (!(HGIS.Util.isArray(features))) {
            features = [features];
        }
        if (features === this.selectedFeatures) {
            features = features.slice();
        }

        var notify = !options || !options.silent;
        
        if (notify) {
            this.events.triggerEvent(
                "beforefeaturesremoved", {features: features}
            );
        }

        for (var i = features.length - 1; i >= 0; i--) {
            // We remain locked so long as we're not at 0
            // and the 'next' feature has a geometry. We do the geometry check
            // because if all the features after the current one are 'null', we
            // won't call eraseGeometry, so we break the 'renderer functions
            // will always be called with locked=false *last*' rule. The end result
            // is a possible gratiutious unlocking to save a loop through the rest 
            // of the list checking the remaining features every time. So long as
            // null geoms are rare, this is probably okay.    
            if (i != 0 && features[i-1].geometry) {
                this.renderer.locked = true;
            } else {
                this.renderer.locked = false;
            }
    
            var feature = features[i];
            delete this.unrenderedFeatures[feature.id];

            if (notify) {
                this.events.triggerEvent("beforefeatureremoved", {
                    feature: feature
                });
            }

            this.features = HGIS.Util.removeItem(this.features, feature);
            // feature has no layer at this point
            feature.layer = null;

            if (feature.geometry) {
                this.renderer.eraseFeatures(feature);
            }
                    
            //in the case that this feature is one of the selected features, 
            // remove it from that array as well.
            if (HGIS.Util.indexOf(this.selectedFeatures, feature) != -1){
                HGIS.Util.removeItem(this.selectedFeatures, feature);
            }

            if (notify) {
                this.events.triggerEvent("featureremoved", {
                    feature: feature
                });
            }
        }

        if (notify) {
            this.events.triggerEvent("featuresremoved", {features: features});
        }
    },
    
    /** 
     * APIMethod: removeAllFeatures
     * Remove all features from the layer.
     *
     * Parameters:
     * options - {Object} Optional properties for changing behavior of the
     *     removal.
     *
     * Valid options:
     * silent - {Boolean} Supress event triggering.  Default is false.
     */
    removeAllFeatures: function(options) {
        var notify = !options || !options.silent;
        var features = this.features;
        if (notify) {
            this.events.triggerEvent(
                "beforefeaturesremoved", {features: features}
            );
        }
        var feature;
        for (var i = features.length-1; i >= 0; i--) {
            feature = features[i];
            if (notify) {
                this.events.triggerEvent("beforefeatureremoved", {
                    feature: feature
                });
            }
            feature.layer = null;
            if (notify) {
                this.events.triggerEvent("featureremoved", {
                    feature: feature
                });
            }
        }
        this.renderer.clear();
        this.features = [];
        this.unrenderedFeatures = {};
        this.selectedFeatures = [];
        if (notify) {
            this.events.triggerEvent("featuresremoved", {features: features});
        }
    },

    /**
     * APIMethod: destroyFeatures
     * Erase and destroy features on the layer.
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} An optional array of
     *     features to destroy.  If not supplied, all features on the layer
     *     will be destroyed.
     * options - {Object}
     */
    destroyFeatures: function(features, options) {
        var all = (features == undefined); // evaluates to true if
                                           // features is null
        if(all) {
            features = this.features;
        }
        if(features) {
            this.removeFeatures(features, options);
            for(var i=features.length-1; i>=0; i--) {
                features[i].destroy();
            }
        }
    },

    /**
     * APIMethod: drawFeature
     * Draw (or redraw) a feature on the layer.  If the optional style argument
     * is included, this style will be used.  If no style is included, the
     * feature's style will be used.  If the feature doesn't have a style,
     * the layer's style will be used.
     * 
     * This function is not designed to be used when adding features to 
     * the layer (use addFeatures instead). It is meant to be used when
     * the style of a feature has changed, or in some other way needs to 
     * visually updated *after* it has already been added to a layer. You
     * must add the feature to the layer for most layer-related events to 
     * happen.
     *
     * Parameters: 
     * feature - {<HGIS.Feature.Vector>} 
     * style - {String | Object} Named render intent or full symbolizer object.
     */
    drawFeature: function(feature, style) {
        // don't try to draw the feature with the renderer if the layer is not 
        // drawn itself
        if (!this.drawn) {
            return;
        }
        if (typeof style != "object") {
            if(!style && feature.state === HGIS.State.DELETE) {
                style = "delete";
            }
            var renderIntent = style || feature.renderIntent;
            style = feature.style || this.style;
            if (!style) {
                style = this.styleMap.createSymbolizer(feature, renderIntent);
            }
        }
        
        var drawn = this.renderer.drawFeature(feature, style);
        //TODO remove the check for null when we get rid of Renderer.SVG
        if (drawn === false || drawn === null) {
            this.unrenderedFeatures[feature.id] = feature;
        } else {
            delete this.unrenderedFeatures[feature.id];
        }
    },
    
    /**
     * Method: eraseFeatures
     * Erase features from the layer.
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} 
     */
    eraseFeatures: function(features) {
        this.renderer.eraseFeatures(features);
    },

    /**
     * Method: getFeatureFromEvent
     * Given an event, return a feature if the event occurred over one.
     * Otherwise, return null.
     *
     * Parameters:
     * evt - {Event} 
     *
     * Returns:
     * {<HGIS.Feature.Vector>} A feature if one was under the event.
     */
    getFeatureFromEvent: function(evt) {
        if (!this.renderer) {
            throw new Error('getFeatureFromEvent called on layer with no ' +
                            'renderer. This usually means you destroyed a ' +
                            'layer, but not some handler which is associated ' +
                            'with it.');
        }
        var feature = null;
        var featureId = this.renderer.getFeatureIdFromEvent(evt);
        if (featureId) {
            if (typeof featureId === "string") {
                feature = this.getFeatureById(featureId);
            } else {
                feature = featureId;
            }
        }
        return feature;
    },

    /**
     * APIMethod: getFeatureBy
     * Given a property value, return the feature if it exists in the features array
     *
     * Parameters:
     * property - {String}
     * value - {String}
     *
     * Returns:
     * {<HGIS.Feature.Vector>} A feature corresponding to the given
     * property value or null if there is no such feature.
     */
    getFeatureBy: function(property, value) {
        //TBD - would it be more efficient to use a hash for this.features?
        var feature = null;
        for(var i=0, len=this.features.length; i<len; ++i) {
            if(this.features[i][property] == value) {
                feature = this.features[i];
                break;
            }
        }
        return feature;
    },

    /**
     * APIMethod: getFeatureById
     * Given a feature id, return the feature if it exists in the features array
     *
     * Parameters:
     * featureId - {String}
     *
     * Returns:
     * {<HGIS.Feature.Vector>} A feature corresponding to the given
     * featureId or null if there is no such feature.
     */
    getFeatureById: function(featureId) {
        return this.getFeatureBy('id', featureId);
    },

    /**
     * APIMethod: getFeatureByFid
     * Given a feature fid, return the feature if it exists in the features array
     *
     * Parameters:
     * featureFid - {String}
     *
     * Returns:
     * {<HGIS.Feature.Vector>} A feature corresponding to the given
     * featureFid or null if there is no such feature.
     */
    getFeatureByFid: function(featureFid) {
        return this.getFeatureBy('fid', featureFid);
    },
    
    /**
     * APIMethod: getFeaturesByAttribute
     * Returns an array of features that have the given attribute key set to the
     * given value. Comparison of attribute values takes care of datatypes, e.g.
     * the string '1234' is not equal to the number 1234.
     *
     * Parameters:
     * attrName - {String}
     * attrValue - {Mixed}
     *
     * Returns:
     * Array({<HGIS.Feature.Vector>}) An array of features that have the 
     * passed named attribute set to the given value.
     */
    getFeaturesByAttribute: function(attrName, attrValue) {
        var i,
            feature,    
            len = this.features.length,
            foundFeatures = [];
        for(i = 0; i < len; i++) {            
            feature = this.features[i];
            if(feature && feature.attributes) {
                if (feature.attributes[attrName] === attrValue) {
                    foundFeatures.push(feature);
                }
            }
        }
        return foundFeatures;
    },

    /**
     * Unselect the selected features
     * i.e. clears the featureSelection array
     * change the style back
    clearSelection: function() {

       var vectorLayer = this.map.vectorLayer;
        for (var i = 0; i < this.map.featureSelection.length; i++) {
            var featureSelection = this.map.featureSelection[i];
            vectorLayer.drawFeature(featureSelection, vectorLayer.style);
        }
        this.map.featureSelection = [];
    },
     */


    /**
     * APIMethod: onFeatureInsert
     * method called after a feature is inserted.
     * Does nothing by default. Override this if you
     * need to do something on feature updates.
     *
     * Parameters: 
     * feature - {<HGIS.Feature.Vector>} 
     */
    onFeatureInsert: function(feature) {
    },
    
    /**
     * APIMethod: preFeatureInsert
     * method called before a feature is inserted.
     * Does nothing by default. Override this if you
     * need to do something when features are first added to the
     * layer, but before they are drawn, such as adjust the style.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} 
     */
    preFeatureInsert: function(feature) {
    },

    /** 
     * APIMethod: getDataExtent
     * Calculates the max extent which includes all of the features.
     * 
     * Returns:
     * {<HGIS.Bounds>} or null if the layer has no features with
     * geometries.
     */
    getDataExtent: function () {
        var maxExtent = null;
        var features = this.features;
        if(features && (features.length > 0)) {
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    if (maxExtent === null) {
                        maxExtent = new HGIS.Bounds();
                    }
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },

    CLASS_NAME: "HGIS.Layer.Vector"
});
/* ======================================================================
    HGIS/Layer/PointGrid.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer/Vector.js
 * @requires HGIS/Geometry/Polygon.js
 */

/**
 * Class: HGIS.Layer.PointGrid
 * A point grid layer dynamically generates a regularly spaced grid of point
 *     features.  This is a specialty layer for cases where an application needs
 *     a regular grid of points.  It can be used, for example, in an editing
 *     environment to snap to a grid.
 *
 * Create a new vector layer with the <HGIS.Layer.PointGrid> constructor.
 * (code)
 * // create a grid with points spaced at 10 map units
 * var points = new HGIS.Layer.PointGrid({dx: 10, dy: 10});
 *
 * // create a grid with different x/y spacing rotated 15 degrees clockwise.
 * var points = new HGIS.Layer.PointGrid({dx: 5, dy: 10, rotation: 15});
 * (end)
 *
 * Inherits from:
 *  - <HGIS.Layer.Vector>
 */
HGIS.Layer.PointGrid = HGIS.Class(HGIS.Layer.Vector, {

    /**
     * APIProperty: dx
     * {Number} Point grid spacing in the x-axis direction (map units).  
     * Read-only.  Use the <setSpacing> method to modify this value.
     */
    dx: null,

    /**
     * APIProperty: dy
     * {Number} Point grid spacing in the y-axis direction (map units).  
     * Read-only.  Use the <setSpacing> method to modify this value.
     */
    dy: null,

    /**
     * APIProperty: ratio
     * {Number} Ratio of the desired grid size to the map viewport size.  
     * Default is 1.5.  Larger ratios mean the grid is recalculated less often 
     * while panning.  The <maxFeatures> setting has precedence when determining
     * grid size.  Read-only.  Use the <setRatio> method to modify this value.
     */
    ratio: 1.5,

    /**
     * APIProperty: maxFeatures
     * {Number} The maximum number of points to generate in the grid.  Default
     * is 250.  Read-only.  Use the <setMaxFeatures> method to modify this value.
     */
    maxFeatures: 250,

    /**
     * APIProperty: rotation
     * {Number} Grid rotation (in degrees clockwise from the positive x-axis).
     * Default is 0.  Read-only.  Use the <setRotation> method to modify this
     * value.
     */
    rotation: 0,

    /**
     * APIProperty: origin
     * {<HGIS.LonLat>} Grid origin.  The grid lattice will be aligned with 
     * the origin.  If not set at construction, the center of the map's maximum 
     * extent is used.  Read-only.  Use the <setOrigin> method to modify this 
     * value.
     */
    origin: null,

    /**
     * Property: gridBounds
     * {<HGIS.Bounds>}  Internally cached grid bounds (with optional 
     * rotation applied).
     */
    gridBounds: null,

    /**
     * Constructor: HGIS.Layer.PointGrid
     * Creates a new point grid layer.
     *
     * Parameters:
     * config - {Object} An object containing all configuration properties for
     *     the layer.  The <dx> and <dy> properties are required to be set at 
     *     construction.  Any other layer properties may be set in this object.
     */
    initialize: function(config) {
        config = config || {};
        HGIS.Layer.Vector.prototype.initialize.apply(this, [config.name, config]);
    },
    
    /** 
     * Method: setMap
     * The layer has been added to the map. 
     * 
     * Parameters:
     * map - {<HGIS.Map>} 
     */
    setMap: function(map) {        
        HGIS.Layer.Vector.prototype.setMap.apply(this, arguments);
        map.events.register("moveend", this, this.onMoveEnd);
    },

    /**
     * Method: removeMap
     * The layer has been removed from the map.
     *
     * Parameters:
     * map - {<HGIS.Map>}
     */
    removeMap: function(map) {
        map.events.unregister("moveend", this, this.onMoveEnd);
        HGIS.Layer.Vector.prototype.removeMap.apply(this, arguments);
    },
    
    /**
     * APIMethod: setRatio
     * Set the grid <ratio> property and update the grid.  Can only be called
     *     after the layer has been added to a map with a center/extent.
     *
     * Parameters:
     * ratio - {Number}
     */
    setRatio: function(ratio) {
        this.ratio = ratio;
        this.updateGrid(true);
    },
    
    /**
     * APIMethod: setMaxFeatures
     * Set the grid <maxFeatures> property and update the grid.  Can only be 
     *     called after the layer has been added to a map with a center/extent.
     *
     * Parameters:
     * maxFeatures - {Number}
     */
    setMaxFeatures: function(maxFeatures) {
        this.maxFeatures = maxFeatures;
        this.updateGrid(true);
    },

    /**
     * APIMethod: setSpacing
     * Set the grid <dx> and <dy> properties and update the grid.  If only one
     *     argument is provided, it will be set as <dx> and <dy>.  Can only be 
     *     called after the layer has been added to a map with a center/extent.
     *
     * Parameters:
     * dx - {Number}
     * dy - {Number}
     */
    setSpacing: function(dx, dy) {
        this.dx = dx;
        this.dy = dy || dx;
        this.updateGrid(true);
    },
    
    /**
     * APIMethod: setOrigin
     * Set the grid <origin> property and update the grid.  Can only be called
     *     after the layer has been added to a map with a center/extent.
     *
     * Parameters:
     * origin - {<HGIS.LonLat>}
     */
    setOrigin: function(origin) {
        this.origin = origin;
        this.updateGrid(true);
    },
    
    /**
     * APIMethod: getOrigin
     * Get the grid <origin> property.
     *
     * Returns:
     * {<HGIS.LonLat>} The grid origin.
     */
    getOrigin: function() {
        if (!this.origin) {
            this.origin = this.map.getExtent().getCenterLonLat();
        }
        return this.origin;
    },
    
    /**
     * APIMethod: setRotation
     * Set the grid <rotation> property and update the grid.  Rotation values
     *     are in degrees clockwise from the positive x-axis (negative values
     *     for counter-clockwise rotation).  Can only be called after the layer 
     *     has been added to a map with a center/extent.
     *
     * Parameters:
     * rotation - {Number} Degrees clockwise from the positive x-axis.
     */
    setRotation: function(rotation) {
        this.rotation = rotation;
        this.updateGrid(true);
    },
    
    /**
     * Method: onMoveEnd
     * Listener for map "moveend" events.
     */
    onMoveEnd: function() {
        this.updateGrid();
    },
    
    /**
     * Method: getViewBounds
     * Gets the (potentially rotated) view bounds for grid calculations.
     *
     * Returns:
     * {<HGIS.Bounds>}
     */
    getViewBounds: function() {
        var bounds = this.map.getExtent();
        if (this.rotation) {
            var origin = this.getOrigin();
            var rotationOrigin = new HGIS.Geometry.Point(origin.lon, origin.lat);
            var rect = bounds.toGeometry();
            rect.rotate(-this.rotation, rotationOrigin);
            bounds = rect.getBounds();
        }
        return bounds;
    },
    
    /**
     * Method: updateGrid
     * Update the grid.
     *
     * Parameters:
     * force - {Boolean} Update the grid even if the previous bounds are still
     *     valid.
     */
    updateGrid: function(force) {
        if (force || this.invalidBounds()) {
            var viewBounds = this.getViewBounds();
            var origin = this.getOrigin();
            var rotationOrigin = new HGIS.Geometry.Point(origin.lon, origin.lat);
            var viewBoundsWidth = viewBounds.getWidth();
            var viewBoundsHeight = viewBounds.getHeight();
            var aspectRatio = viewBoundsWidth / viewBoundsHeight;
            var maxHeight = Math.sqrt(this.dx * this.dy * this.maxFeatures / aspectRatio);
            var maxWidth = maxHeight * aspectRatio; 
            var gridWidth = Math.min(viewBoundsWidth * this.ratio, maxWidth);
            var gridHeight = Math.min(viewBoundsHeight * this.ratio, maxHeight);
            var center = viewBounds.getCenterLonLat();
            this.gridBounds = new HGIS.Bounds(
                center.lon - (gridWidth / 2),
                center.lat - (gridHeight / 2),
                center.lon + (gridWidth / 2),
                center.lat + (gridHeight / 2)
            );
            var rows = Math.floor(gridHeight / this.dy);
            var cols = Math.floor(gridWidth / this.dx);
            var gridLeft = origin.lon + (this.dx * Math.ceil((this.gridBounds.left - origin.lon) / this.dx));
            var gridBottom = origin.lat + (this.dy * Math.ceil((this.gridBounds.bottom - origin.lat) / this.dy));
            var features = new Array(rows * cols);
            var x, y, point;
            for (var i=0; i<cols; ++i) {
                x = gridLeft + (i * this.dx);
                for (var j=0; j<rows; ++j) {
                    y = gridBottom + (j * this.dy);
                    point = new HGIS.Geometry.Point(x, y);
                    if (this.rotation) {
                        point.rotate(this.rotation, rotationOrigin);
                    }
                    features[(i*rows)+j] = new HGIS.Feature.Vector(point);
                }
            }
            this.destroyFeatures(this.features, {silent: true});
            this.addFeatures(features, {silent: true});
        }
    },

    /**
     * Method: invalidBounds
     * Determine whether the previously generated point grid is invalid. 
     *     This occurs when the map bounds extends beyond the previously 
     *     generated grid bounds.
     *
     * Returns:
     * {Boolean} 
     */
    invalidBounds: function() {
        return !this.gridBounds || !this.gridBounds.containsBounds(this.getViewBounds());
    },

    CLASS_NAME: "HGIS.Layer.PointGrid"
    
});
/* ======================================================================
    HGIS/Handler/MouseWheel.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Handler.js
 */

/**
 * Class: HGIS.Handler.MouseWheel
 * Handler for wheel up/down events.
 * 
 * Inherits from:
 *  - <HGIS.Handler>
 */
HGIS.Handler.MouseWheel = HGIS.Class(HGIS.Handler, {
    /** 
     * Property: wheelListener 
     * {function} 
     */
    wheelListener: null,

    /**
     * Property: interval
     * {Integer} In order to increase server performance, an interval (in 
     *     milliseconds) can be set to reduce the number of up/down events 
     *     called. If set, a new up/down event will not be set until the 
     *     interval has passed. 
     *     Defaults to 0, meaning no interval. 
     */
    interval: 0,
    
    /**
     * Property: maxDelta
     * {Integer} Maximum delta to collect before breaking from the current
     *    interval. In cumulative mode, this also limits the maximum delta
     *    returned from the handler. Default is Number.POSITIVE_INFINITY.
     */
    maxDelta: Number.POSITIVE_INFINITY,
    
    /**
     * Property: delta
     * {Integer} When interval is set, delta collects the mousewheel z-deltas
     *     of the events that occur within the interval.
     *      See also the cumulative option
     */
    delta: 0,
    
    /**
     * Property: cumulative
     * {Boolean} When interval is set: true to collect all the mousewheel 
     *     z-deltas, false to only record the delta direction (positive or
     *     negative)
     */
    cumulative: true,
    
    /**
     * Constructor: HGIS.Handler.MouseWheel
     *
     * Parameters:
     * control - {<HGIS.Control>} 
     * callbacks - {Object} An object containing a single function to be
     *                          called when the drag operation is finished.
     *                          The callback should expect to recieve a single
     *                          argument, the point geometry.
     * options - {Object} 
     */
    initialize: function(control, callbacks, options) {
        HGIS.Handler.prototype.initialize.apply(this, arguments);
        this.wheelListener = HGIS.Function.bindAsEventListener(
            this.onWheelEvent, this
        );
    },

    /**
     * Method: destroy
     */    
    destroy: function() {
        HGIS.Handler.prototype.destroy.apply(this, arguments);
        this.wheelListener = null;
    },

    /**
     *  Mouse ScrollWheel code thanks to http://adomas.org/javascript-mouse-wheel/
     */

    /** 
     * Method: onWheelEvent
     * Catch the wheel event and handle it xbrowserly
     * 
     * Parameters:
     * e - {Event} 
     */
    onWheelEvent: function(e){
        
        // make sure we have a map and check keyboard modifiers
        if (!this.map || !this.checkModifiers(e)) {
            return;
        }
        
        // Ride up the element's DOM hierarchy to determine if it or any of 
        //  its ancestors was: 
        //   * specifically marked as scrollable (CSS overflow property)
        //   * one of our layer divs or a div marked as scrollable
        //     ('olScrollable' CSS class)
        //   * the map div
        //
        var overScrollableDiv = false;
        var allowScroll = false;
        var overMapDiv = false;
        
        var elem = HGIS.Event.element(e);
        while((elem != null) && !overMapDiv && !overScrollableDiv) {

            if (!overScrollableDiv) {
                try {
                    var overflow;
                    if (elem.currentStyle) {
                        overflow = elem.currentStyle["overflow"];
                    } else {
                        var style = 
                            document.defaultView.getComputedStyle(elem, null);
                        overflow = style.getPropertyValue("overflow");
                    }
                    overScrollableDiv = ( overflow && 
                        (overflow == "auto") || (overflow == "scroll") );
                } catch(err) {
                    //sometimes when scrolling in a popup, this causes 
                    // obscure browser error
                }
            }

            if (!allowScroll) {
                allowScroll = HGIS.Element.hasClass(elem, 'olScrollable');
                if (!allowScroll) {
                    for (var i = 0, len = this.map.layers.length; i < len; i++) {
                        // Are we in the layer div? Note that we have two cases
                        // here: one is to catch EventPane layers, which have a
                        // pane above the layer (layer.pane)
                        var layer = this.map.layers[i];
                        if (elem == layer.div || elem == layer.pane) {
                            allowScroll = true;
                            break;
                        }
                    }
                }
            }
            overMapDiv = (elem == this.map.div);

            elem = elem.parentNode;
        }
        
        // Logic below is the following:
        //
        // If we are over a scrollable div or not over the map div:
        //  * do nothing (let the browser handle scrolling)
        //
        //    otherwise 
        // 
        //    If we are over the layer div or a 'olScrollable' div:
        //     * zoom/in out
        //     then
        //     * kill event (so as not to also scroll the page after zooming)
        //
        //       otherwise
        //
        //       Kill the event (dont scroll the page if we wheel over the 
        //        layerswitcher or the pan/zoom control)
        //
        if (!overScrollableDiv && overMapDiv) {
            if (allowScroll) {
                var delta = 0;
                
                if (e.wheelDelta) {
                    delta = e.wheelDelta;
                    if (delta % 160 === 0) {
                        // opera have steps of 160 instead of 120
                        delta = delta * 0.75;
                    }
                    delta = delta / 120;
                } else if (e.detail) {
                    // detail in Firefox on OS X is 1/3 of Windows
                    // so force delta 1 / -1
                    delta = - (e.detail / Math.abs(e.detail));
                }
                this.delta += delta;

                window.clearTimeout(this._timeoutId);
                if(this.interval && Math.abs(this.delta) < this.maxDelta) {
                    // store e because window.event might change during delay
                    var evt = HGIS.Util.extend({}, e);
                    this._timeoutId = window.setTimeout(
                        HGIS.Function.bind(function(){
                            this.wheelZoom(evt);
                        }, this),
                        this.interval
                    );
                } else {
                    this.wheelZoom(e);
                }
            }
            HGIS.Event.stop(e);
        }
    },

    /**
     * Method: wheelZoom
     * Given the wheel event, we carry out the appropriate zooming in or out,
     *     based on the 'wheelDelta' or 'detail' property of the event.
     * 
     * Parameters:
     * e - {Event}
     */
    wheelZoom: function(e) {
        var delta = this.delta;
        this.delta = 0;
        
        if (delta) {
            e.xy = this.map.events.getMousePosition(e);
            if (delta < 0) {
                this.callback("down",
                    [e, this.cumulative ? Math.max(-this.maxDelta, delta) : -1]);
            } else {
                this.callback("up",
                    [e, this.cumulative ? Math.min(this.maxDelta, delta) : 1]);
            }
        }
    },
    
    /**
     * Method: activate 
     */
    activate: function (evt) {
        if (HGIS.Handler.prototype.activate.apply(this, arguments)) {
            //register mousewheel events specifically on the window and document
            var wheelListener = this.wheelListener;
            HGIS.Event.observe(window, "DOMMouseScroll", wheelListener);
            HGIS.Event.observe(window, "mousewheel", wheelListener);
            HGIS.Event.observe(document, "mousewheel", wheelListener);
            return true;
        } else {
            return false;
        }
    },

    /**
     * Method: deactivate 
     */
    deactivate: function (evt) {
        if (HGIS.Handler.prototype.deactivate.apply(this, arguments)) {
            // unregister mousewheel events specifically on the window and document
            var wheelListener = this.wheelListener;
            HGIS.Event.stopObserving(window, "DOMMouseScroll", wheelListener);
            HGIS.Event.stopObserving(window, "mousewheel", wheelListener);
            HGIS.Event.stopObserving(document, "mousewheel", wheelListener);
            return true;
        } else {
            return false;
        }
    },

    CLASS_NAME: "HGIS.Handler.MouseWheel"
});
/* ======================================================================
    HGIS/Symbolizer.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 */

/**
 * Class: HGIS.Symbolizer
 * Base class representing a symbolizer used for feature rendering.
 */
HGIS.Symbolizer = HGIS.Class({
    

    /**
     * APIProperty: zIndex
     * {Number} The zIndex determines the rendering order for a symbolizer.
     *     Symbolizers with larger zIndex values are rendered over symbolizers
     *     with smaller zIndex values.  Default is 0.
     */
    zIndex: 0,
    
    /**
     * Constructor: HGIS.Symbolizer
     * Instances of this class are not useful.  See one of the subclasses.
     *
     * Parameters:
     * config - {Object} An object containing properties to be set on the 
     *     symbolizer.  Any documented symbolizer property can be set at 
     *     construction.
     *
     * Returns:
     * A new symbolizer.
     */
    initialize: function(config) {
        HGIS.Util.extend(this, config);
    },
    
    /** 
     * APIMethod: clone
     * Create a copy of this symbolizer.
     *
     * Returns a symbolizer of the same type with the same properties.
     */
    clone: function() {
        var Type = eval(this.CLASS_NAME);
        return new Type(HGIS.Util.extend({}, this));
    },
    
    CLASS_NAME: "HGIS.Symbolizer"
    
});

/* ======================================================================
    HGIS/Symbolizer/Raster.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Symbolizer.js
 */

/**
 * Class: HGIS.Symbolizer.Raster
 * A symbolizer used to render raster images.
 */
HGIS.Symbolizer.Raster = HGIS.Class(HGIS.Symbolizer, {
    
    /**
     * Constructor: HGIS.Symbolizer.Raster
     * Create a symbolizer for rendering rasters.
     *
     * Parameters:
     * config - {Object} An object containing properties to be set on the 
     *     symbolizer.  Any documented symbolizer property can be set at 
     *     construction.
     *
     * Returns:
     * A new raster symbolizer.
     */
    initialize: function(config) {
        HGIS.Symbolizer.prototype.initialize.apply(this, arguments);
    },
    
    CLASS_NAME: "HGIS.Symbolizer.Raster"
    
});
/* ======================================================================
    HGIS/Rule.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Util.js
 * @requires HGIS/Style.js
 */

/**
 * Class: HGIS.Rule
 * This class represents an SLD Rule, as being used for rule-based SLD styling.
 */
HGIS.Rule = HGIS.Class({
    
    /**
     * Property: id
     * {String} A unique id for this session.
     */
    id: null,
    
    /**
     * APIProperty: name
     * {String} name of this rule
     */
    name: null,
    
    /**
     * Property: title
     * {String} Title of this rule (set if included in SLD)
     */
    title: null,
    
    /**
     * Property: description
     * {String} Description of this rule (set if abstract is included in SLD)
     */
    description: null,

    /**
     * Property: context
     * {Object} An optional object with properties that the rule should be
     * evaluated against. If no context is specified, feature.attributes will
     * be used.
     */
    context: null,
    
    /**
     * Property: filter
     * {<HGIS.Filter>} Optional filter for the rule.
     */
    filter: null,

    /**
     * Property: elseFilter
     * {Boolean} Determines whether this rule is only to be applied only if
     * no other rules match (ElseFilter according to the SLD specification). 
     * Default is false.  For instances of HGIS.Rule, if elseFilter is
     * false, the rule will always apply.  For subclasses, the else property is 
     * ignored.
     */
    elseFilter: false,
    
    /**
     * Property: symbolizer
     * {Object} Symbolizer or hash of symbolizers for this rule. If hash of
     * symbolizers, keys are one or more of ["Point", "Line", "Polygon"]. The
     * latter if useful if it is required to style e.g. vertices of a line
     * with a point symbolizer. Note, however, that this is not implemented
     * yet in HGIS, but it is the way how symbolizers are defined in
     * SLD.
     */
    symbolizer: null,
    
    /**
     * Property: symbolizers
     * {Array} Collection of symbolizers associated with this rule.  If 
     *     provided at construction, the symbolizers array has precedence
     *     over the deprecated symbolizer property.  Note that multiple 
     *     symbolizers are not currently supported by the vector renderers.
     *     Rules with multiple symbolizers are currently only useful for
     *     maintaining elements in an SLD document.
     */
    symbolizers: null,
    
    /**
     * APIProperty: minScaleDenominator
     * {Number} or {String} minimum scale at which to draw the feature.
     * In the case of a String, this can be a combination of text and
     * propertyNames in the form "literal ${propertyName}"
     */
    minScaleDenominator: null,

    /**
     * APIProperty: maxScaleDenominator
     * {Number} or {String} maximum scale at which to draw the feature.
     * In the case of a String, this can be a combination of text and
     * propertyNames in the form "literal ${propertyName}"
     */
    maxScaleDenominator: null,
    
    /** 
     * Constructor: HGIS.Rule
     * Creates a Rule.
     *
     * Parameters:
     * options - {Object} An optional object with properties to set on the
     *           rule
     * 
     * Returns:
     * {<HGIS.Rule>}
     */
    initialize: function(options) {
        this.symbolizer = {};
        HGIS.Util.extend(this, options);
        if (this.symbolizers) {
            delete this.symbolizer;
        }
        this.id = HGIS.Util.createUniqueID(this.CLASS_NAME + "_");
    },

    /** 
     * APIMethod: destroy
     * nullify references to prevent circular references and memory leaks
     */
    destroy: function() {
        for (var i in this.symbolizer) {
            this.symbolizer[i] = null;
        }
        this.symbolizer = null;
        delete this.symbolizers;
    },
    
    /**
     * APIMethod: evaluate
     * evaluates this rule for a specific feature
     * 
     * Parameters:
     * feature - {<HGIS.Feature>} feature to apply the rule to.
     * 
     * Returns:
     * {Boolean} true if the rule applies, false if it does not.
     * This rule is the default rule and always returns true.
     */
    evaluate: function(feature) {
        var context = this.getContext(feature);
        var applies = true;

        if (this.minScaleDenominator || this.maxScaleDenominator) {
            var scale = feature.layer.map.getScale();
        }
        
        // check if within minScale/maxScale bounds
        if (this.minScaleDenominator) {
            applies = scale >= HGIS.Style.createLiteral(
                    this.minScaleDenominator, context);
        }
        if (applies && this.maxScaleDenominator) {
            applies = scale < HGIS.Style.createLiteral(
                    this.maxScaleDenominator, context);
        }
        
        // check if optional filter applies
        if(applies && this.filter) {
            // feature id filters get the feature, others get the context
            if(this.filter.CLASS_NAME == "HGIS.Filter.FeatureId") {
                applies = this.filter.evaluate(feature);
            } else {
                applies = this.filter.evaluate(context);
            }
        }

        return applies;
    },
    
    /**
     * Method: getContext
     * Gets the context for evaluating this rule
     * 
     * Paramters:
     * feature - {<HGIS.Feature>} feature to take the context from if
     *           none is specified.
     */
    getContext: function(feature) {
        var context = this.context;
        if (!context) {
            context = feature.attributes || feature.data;
        }
        if (typeof this.context == "function") {
            context = this.context(feature);
        }
        return context;
    },
    
    /**
     * APIMethod: clone
     * Clones this rule.
     * 
     * Returns:
     * {<HGIS.Rule>} Clone of this rule.
     */
    clone: function() {
        var options = HGIS.Util.extend({}, this);
        if (this.symbolizers) {
            // clone symbolizers
            var len = this.symbolizers.length;
            options.symbolizers = new Array(len);
            for (var i=0; i<len; ++i) {
                options.symbolizers[i] = this.symbolizers[i].clone();
            }
        } else {
            // clone symbolizer
            options.symbolizer = {};
            var value, type;
            for(var key in this.symbolizer) {
                value = this.symbolizer[key];
                type = typeof value;
                if(type === "object") {
                    options.symbolizer[key] = HGIS.Util.extend({}, value);
                } else if(type === "string") {
                    options.symbolizer[key] = value;
                }
            }
        }
        // clone filter
        options.filter = this.filter && this.filter.clone();
        // clone context
        options.context = this.context && HGIS.Util.extend({}, this.context);
        return new HGIS.Rule(options);
    },
        
    CLASS_NAME: "HGIS.Rule"
});
/* ======================================================================
    HGIS/Format/SLD.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML/VersionedOGC.js
 * @requires HGIS/Style.js
 * @requires HGIS/Rule.js
 * @requires HGIS/Filter/FeatureId.js
 * @requires HGIS/Filter/Logical.js
 * @requires HGIS/Filter/Comparison.js
 * @requires HGIS/Filter/Spatial.js
 */

/**
 * Class: HGIS.Format.SLD
 * Read/Write SLD. Create a new instance with the <HGIS.Format.SLD>
 *     constructor.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML.VersionedOGC>
 */
HGIS.Format.SLD = HGIS.Class(HGIS.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: profile
     * {String} If provided, use a custom profile.
     *
     * Currently supported profiles:
     * - GeoServer - parses GeoServer vendor specific capabilities for SLD.
     */
    profile: null,

    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.0.0".
     */
    defaultVersion: "1.0.0",
    
    /**
     * APIProperty: stringifyOutput
     * {Boolean} If true, write will return a string otherwise a DOMElement.
     * Default is true.
     */
    stringifyOutput: true,
    
    /**
     * APIProperty: namedLayersAsArray
     * {Boolean} Generate a namedLayers array.  If false, the namedLayers
     *     property value will be an object keyed by layer name. Default is
     *     false.
     */
    namedLayersAsArray: false,
    
    /**
     * APIMethod: write
     * Write a SLD document given a list of styles.
     *
     * Parameters:
     * sld - {Object} An object representing the SLD.
     * options - {Object} Optional configuration object.
     *
     * Returns:
     * {String} An SLD document string.
     */
    
    /**
     * APIMethod: read
     * Read and SLD doc and return an object representing the SLD.
     *
     * Parameters:
     * data - {String | DOMElement} Data to read.
     * options - {Object} Options for the reader.
     *
     * Returns:
     * {Object} An object representing the SLD.
     */

    CLASS_NAME: "HGIS.Format.SLD" 
});
/* ======================================================================
    HGIS/Symbolizer/Polygon.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Symbolizer.js
 */

/**
 * Class: HGIS.Symbolizer.Polygon
 * A symbolizer used to render line features.
 */
HGIS.Symbolizer.Polygon = HGIS.Class(HGIS.Symbolizer, {
    
    /**
     * APIProperty: strokeColor
     * {String} Color for line stroke.  This is a RGB hex value (e.g. "#ff0000"
     *     for red).
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: strokeOpacity
     * {Number} Stroke opacity (0-1).
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: strokeWidth
     * {Number} Pixel stroke width.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: strokeLinecap
     * {String} Stroke cap type ("butt", "round", or "square").
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * Property: strokeDashstyle
     * {String} Stroke dash style according to the SLD spec. Note that the
     *     HGIS values for strokeDashstyle ("dot", "dash", "dashdot",
     *     "longdash", "longdashdot", or "solid") will not work in SLD, but
     *     most SLD patterns will render correctly in HGIS.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */

    /**
     * APIProperty: fillColor
     * {String} RGB hex fill color (e.g. "#ff0000" for red).
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: fillOpacity
     * {Number} Fill opacity (0-1).
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */

    /**
     * Constructor: HGIS.Symbolizer.Polygon
     * Create a symbolizer for rendering polygons.
     *
     * Parameters:
     * config - {Object} An object containing properties to be set on the 
     *     symbolizer.  Any documented symbolizer property can be set at 
     *     construction.
     *
     * Returns:
     * A new polygon symbolizer.
     */
    initialize: function(config) {
        HGIS.Symbolizer.prototype.initialize.apply(this, arguments);
    },
    
    CLASS_NAME: "HGIS.Symbolizer.Polygon"
    
});

/* ======================================================================
    HGIS/Format/GML/v2.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/GML/Base.js
 */

/**
 * Class: HGIS.Format.GML.v2
 * Parses GML version 2.
 *
 * Inherits from:
 *  - <HGIS.Format.GML.Base>
 */
HGIS.Format.GML.v2 = HGIS.Class(HGIS.Format.GML.Base, {
    
    /**
     * Property: schemaLocation
     * {String} Schema location for a particular minor version.
     */
    schemaLocation: "http://www.opengis.net/gml http://schemas.opengis.net/gml/2.1.2/feature.xsd",

    /**
     * Constructor: HGIS.Format.GML.v2
     * Create a parser for GML v2.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     *
     * Valid options properties:
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (required).
     * geometryName - {String} Geometry element name.
     */
    initialize: function(options) {
        HGIS.Format.GML.Base.prototype.initialize.apply(this, [options]);
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "gml": HGIS.Util.applyDefaults({
            "outerBoundaryIs": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.outer = obj.components[0];
            },
            "innerBoundaryIs": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.inner.push(obj.components[0]);
            },
            "Box": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                var min = obj.points[0];
                var max = obj.points[1];
                container.components.push(
                    new HGIS.Bounds(min.x, min.y, max.x, max.y)
                );
            }
        }, HGIS.Format.GML.Base.prototype.readers["gml"]),
        "feature": HGIS.Format.GML.Base.prototype.readers["feature"],
        "wfs": HGIS.Format.GML.Base.prototype.readers["wfs"]
    },

    /**
     * Method: write
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>) | HGIS.Feature.Vector}
     *     An array of features or a single feature.
     *
     * Returns:
     * {String} Given an array of features, a doc with a gml:featureMembers
     *     element will be returned.  Given a single feature, a doc with a
     *     gml:featureMember element will be returned.
     */
    write: function(features) {
        var name;
        if(HGIS.Util.isArray(features)) {
            // GML2 only has abstract feature collections
            // wfs provides a feature collection from a well-known schema
            name = "wfs:FeatureCollection";
        } else {
            name = "gml:featureMember";
        }
        var root = this.writeNode(name, features);
        this.setAttributeNS(
            root, this.namespaces["xsi"],
            "xsi:schemaLocation", this.schemaLocation
        );

        return HGIS.Format.XML.prototype.write.apply(this, [root]);
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "gml": HGIS.Util.applyDefaults({
            "Point": function(geometry) {
                var node = this.createElementNSPlus("gml:Point");
                this.writeNode("coordinates", [geometry], node);
                return node;
            },
            "coordinates": function(points) {
                var numPoints = points.length;
                var parts = new Array(numPoints);
                var point;
                for(var i=0; i<numPoints; ++i) {
                    point = points[i];
                    if(this.xy) {
                        parts[i] = point.x + "," + point.y;
                    } else {
                        parts[i] = point.y + "," + point.x;
                    }
                    if(point.z != undefined) { // allow null or undefined
                        parts[i] += "," + point.z;
                    }
                }
                return this.createElementNSPlus("gml:coordinates", {
                    attributes: {
                        decimal: ".", cs: ",", ts: " "
                    },
                    value: (numPoints == 1) ? parts[0] : parts.join(" ")
                });
            },
            "LineString": function(geometry) {
                var node = this.createElementNSPlus("gml:LineString");
                this.writeNode("coordinates", geometry.components, node);
                return node;
            },
            "Polygon": function(geometry) {
                var node = this.createElementNSPlus("gml:Polygon");
                this.writeNode("outerBoundaryIs", geometry.components[0], node);
                for(var i=1; i<geometry.components.length; ++i) {
                    this.writeNode(
                        "innerBoundaryIs", geometry.components[i], node
                    );
                }
                return node;
            },
            "outerBoundaryIs": function(ring) {
                var node = this.createElementNSPlus("gml:outerBoundaryIs");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "innerBoundaryIs": function(ring) {
                var node = this.createElementNSPlus("gml:innerBoundaryIs");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "LinearRing": function(ring) {
                var node = this.createElementNSPlus("gml:LinearRing");
                this.writeNode("coordinates", ring.components, node);
                return node;
            },
            "Box": function(bounds) {
                var node = this.createElementNSPlus("gml:Box");
                this.writeNode("coordinates", [
                    {x: bounds.left, y: bounds.bottom},
                    {x: bounds.right, y: bounds.top}
                ], node);
                // srsName attribute is optional for gml:Box
                if(this.srsName) {
                    node.setAttribute("srsName", this.srsName);
                }
                return node;
            }
        }, HGIS.Format.GML.Base.prototype.writers["gml"]),
        "feature": HGIS.Format.GML.Base.prototype.writers["feature"],
        "wfs": HGIS.Format.GML.Base.prototype.writers["wfs"]
    },
    
    CLASS_NAME: "HGIS.Format.GML.v2" 

});
/* ======================================================================
    HGIS/Format/Filter/v1_0_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/GML/v2.js
 * @requires HGIS/Format/Filter/v1.js
 */

/**
 * Class: HGIS.Format.Filter.v1_0_0
 * Write ogc:Filter version 1.0.0.
 * 
 * Inherits from:
 *  - <HGIS.Format.GML.v2>
 *  - <HGIS.Format.Filter.v1>
 */
HGIS.Format.Filter.v1_0_0 = HGIS.Class(
    HGIS.Format.GML.v2, HGIS.Format.Filter.v1, {
    
    /**
     * Constant: VERSION
     * {String} 1.0.0
     */
    VERSION: "1.0.0",
    
    /**
     * Property: schemaLocation
     * {String} http://www.opengis.net/ogc/filter/1.0.0/filter.xsd
     */
    schemaLocation: "http://www.opengis.net/ogc/filter/1.0.0/filter.xsd",

    /**
     * Constructor: HGIS.Format.Filter.v1_0_0
     * Instances of this class are not created directly.  Use the
     *     <HGIS.Format.Filter> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        HGIS.Format.GML.v2.prototype.initialize.apply(
            this, [options]
        );
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ogc": HGIS.Util.applyDefaults({
            "PropertyIsEqualTo": function(node, obj) {
                var filter = new HGIS.Filter.Comparison({
                    type: HGIS.Filter.Comparison.EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsNotEqualTo": function(node, obj) {
                var filter = new HGIS.Filter.Comparison({
                    type: HGIS.Filter.Comparison.NOT_EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLike": function(node, obj) {
                var filter = new HGIS.Filter.Comparison({
                    type: HGIS.Filter.Comparison.LIKE
                });
                this.readChildNodes(node, filter);
                var wildCard = node.getAttribute("wildCard");
                var singleChar = node.getAttribute("singleChar");
                var esc = node.getAttribute("escape");
                filter.value2regex(wildCard, singleChar, esc);
                obj.filters.push(filter);
            }
        }, HGIS.Format.Filter.v1.prototype.readers["ogc"]),
        "gml": HGIS.Format.GML.v2.prototype.readers["gml"],
        "feature": HGIS.Format.GML.v2.prototype.readers["feature"]        
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "ogc": HGIS.Util.applyDefaults({
            "PropertyIsEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsNotEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsNotEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsLike": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLike", {
                    attributes: {
                        wildCard: "*", singleChar: ".", escape: "!"
                    }
                });
                // no ogc:expression handling for now
                this.writeNode("PropertyName", filter, node);
                // convert regex string to ogc string
                this.writeNode("Literal", filter.regex2value(), node);
                return node;
            },
            "BBOX": function(filter) {
                var node = this.createElementNSPlus("ogc:BBOX");
                // PropertyName is mandatory in 1.0.0, but e.g. GeoServer also
                // accepts filters without it. When this is used with
                // HGIS.Protocol.WFS, HGIS.Format.WFST will set a
                // missing filter.property to the geometryName that is
                // configured with the protocol, which defaults to "the_geom".
                // So the only way to omit this mandatory property is to not
                // set the property on the filter and to set the geometryName
                // on the WFS protocol to null. The latter also happens when
                // the protocol is configured without a geometryName and a
                // featureNS.
                filter.property && this.writeNode("PropertyName", filter, node);
                var box = this.writeNode("gml:Box", filter.value, node);
                if(filter.projection) {
                    box.setAttribute("srsName", filter.projection);
                }
                return node;
            }
        }, HGIS.Format.Filter.v1.prototype.writers["ogc"]),
        "gml": HGIS.Format.GML.v2.prototype.writers["gml"],
        "feature": HGIS.Format.GML.v2.prototype.writers["feature"]
    },

    /**
     * Method: writeSpatial
     *
     * Read a {<HGIS.Filter.Spatial>} filter and converts it into XML.
     *
     * Parameters:
     * filter - {<HGIS.Filter.Spatial>} The filter.
     * name - {String} Name of the generated XML element.
     *
     * Returns:
     * {DOMElement} The created XML element.
     */
    writeSpatial: function(filter, name) {
        var node = this.createElementNSPlus("ogc:"+name);
        this.writeNode("PropertyName", filter, node);
        if(filter.value instanceof HGIS.Filter.Function) {
            this.writeNode("Function", filter.value, node);
        } else {
        var child;
        if(filter.value instanceof HGIS.Geometry) {
            child = this.writeNode("feature:_geometry", filter.value).firstChild;
        } else {
            child = this.writeNode("gml:Box", filter.value);
        }
        if(filter.projection) {
            child.setAttribute("srsName", filter.projection);
        }
        node.appendChild(child);
        }
        return node;
    },


    CLASS_NAME: "HGIS.Format.Filter.v1_0_0" 

});
/* ======================================================================
    HGIS/Format/WFST/v1_0_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WFST/v1.js
 * @requires HGIS/Format/Filter/v1_0_0.js
 */

/**
 * Class: HGIS.Format.WFST.v1_0_0
 * A format for creating WFS v1.0.0 transactions.  Create a new instance with the
 *     <HGIS.Format.WFST.v1_0_0> constructor.
 *
 * Inherits from:
 *  - <HGIS.Format.Filter.v1_0_0>
 *  - <HGIS.Format.WFST.v1>
 */
HGIS.Format.WFST.v1_0_0 = HGIS.Class(
    HGIS.Format.Filter.v1_0_0, HGIS.Format.WFST.v1, {
    
    /**
     * Property: version
     * {String} WFS version number.
     */
    version: "1.0.0",

    /**
     * APIProperty: srsNameInQuery
     * {Boolean} If true the reference system is passed in Query requests
     *     via the "srsName" attribute to the "wfs:Query" element, this
     *     property defaults to false as it isn't WFS 1.0.0 compliant.
     */
    srsNameInQuery: false,
    
    /**
     * Property: schemaLocations
     * {Object} Properties are namespace aliases, values are schema locations.
     */
    schemaLocations: {
        "wfs": "http://schemas.opengis.net/wfs/1.0.0/WFS-transaction.xsd"
    },

    /**
     * Constructor: HGIS.Format.WFST.v1_0_0
     * A class for parsing and generating WFS v1.0.0 transactions.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties:
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (optional).
     * featurePrefix - {String} Feature namespace alias (optional - only used
     *     if featureNS is provided).  Default is 'feature'.
     * geometryName - {String} Name of geometry attribute.  Default is 'the_geom'.
     */
    initialize: function(options) {
        HGIS.Format.Filter.v1_0_0.prototype.initialize.apply(this, [options]);
        HGIS.Format.WFST.v1.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Method: readNode
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     *
     * Parameters:
     * node - {DOMElement} The node to be read (required).
     * obj - {Object} The object to be modified (optional).
     * first - {Boolean} Should be set to true for the first node read. This
     *     is usually the readNode call in the read method. Without this being
     *     set, auto-configured properties will stick on subsequent reads.
     *
     * Returns:
     * {Object} The input object, modified (or a new one if none was provided).
     */
    readNode: function(node, obj, first) {
        // Not the superclass, only the mixin classes inherit from
        // Format.GML.v2. We need this because we don't want to get readNode
        // from the superclass's superclass, which is HGIS.Format.XML.
        return HGIS.Format.GML.v2.prototype.readNode.apply(this, arguments);
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wfs": HGIS.Util.applyDefaults({
            "WFS_TransactionResponse": function(node, obj) {
                obj.insertIds = [];
                obj.success = false;
                this.readChildNodes(node, obj);
            },
            "InsertResult": function(node, container) {
                var obj = {fids: []};
                this.readChildNodes(node, obj);
                container.insertIds = container.insertIds.concat(obj.fids);
            },
            "TransactionResult": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Status": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "SUCCESS": function(node, obj) {
                obj.success = true;
            }
        }, HGIS.Format.WFST.v1.prototype.readers["wfs"]),
        "gml": HGIS.Format.GML.v2.prototype.readers["gml"],
        "feature": HGIS.Format.GML.v2.prototype.readers["feature"],
        "ogc": HGIS.Format.Filter.v1_0_0.prototype.readers["ogc"]
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "wfs": HGIS.Util.applyDefaults({
            "Query": function(options) {
                options = HGIS.Util.extend({
                    featureNS: this.featureNS,
                    featurePrefix: this.featurePrefix,
                    featureType: this.featureType,
                    srsName: this.srsName,
                    srsNameInQuery: this.srsNameInQuery
                }, options);
                var prefix = options.featurePrefix;
                var node = this.createElementNSPlus("wfs:Query", {
                    attributes: {
                        typeName: (prefix ? prefix + ":" : "") +
                            options.featureType
                    }
                });
                if(options.srsNameInQuery && options.srsName) {
                    node.setAttribute("srsName", options.srsName);
                }
                if(options.featureNS) {
                    node.setAttribute("xmlns:" + prefix, options.featureNS);
                }
                if(options.propertyNames) {
                    for(var i=0,len = options.propertyNames.length; i<len; i++) {
                        this.writeNode(
                            "ogc:PropertyName", 
                            {property: options.propertyNames[i]},
                            node
                        );
                    }
                }
                if(options.filter) {
                    this.setFilterProperty(options.filter);
                    this.writeNode("ogc:Filter", options.filter, node);
                }
                return node;
            }
        }, HGIS.Format.WFST.v1.prototype.writers["wfs"]),
        "gml": HGIS.Format.GML.v2.prototype.writers["gml"],
        "feature": HGIS.Format.GML.v2.prototype.writers["feature"],
        "ogc": HGIS.Format.Filter.v1_0_0.prototype.writers["ogc"]
    },
   
    CLASS_NAME: "HGIS.Format.WFST.v1_0_0" 
});
/* ======================================================================
    HGIS/Renderer/Elements.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Renderer.js
 */

/**
 * Class: HGIS.ElementsIndexer
 * This class takes care of figuring out which order elements should be
 *     placed in the DOM based on given indexing methods. 
 */
HGIS.ElementsIndexer = HGIS.Class({
   
    /**
     * Property: maxZIndex
     * {Integer} This is the largest-most z-index value for a node
     *     contained within the indexer.
     */
    maxZIndex: null,
    
    /**
     * Property: order
     * {Array<String>} This is an array of node id's stored in the
     *     order that they should show up on screen. Id's higher up in the
     *     array (higher array index) represent nodes with higher z-indeces.
     */
    order: null, 
    
    /**
     * Property: indices
     * {Object} This is a hash that maps node ids to their z-index value
     *     stored in the indexer. This is done to make finding a nodes z-index 
     *     value O(1).
     */
    indices: null,
    
    /**
     * Property: compare
     * {Function} This is the function used to determine placement of
     *     of a new node within the indexer. If null, this defaults to to
     *     the Z_ORDER_DRAWING_ORDER comparison method.
     */
    compare: null,
    
    /**
     * APIMethod: initialize
     * Create a new indexer with 
     * 
     * Parameters:
     * yOrdering - {Boolean} Whether to use y-ordering.
     */
    initialize: function(yOrdering) {

        this.compare = yOrdering ? 
            HGIS.ElementsIndexer.IndexingMethods.Z_ORDER_Y_ORDER :
            HGIS.ElementsIndexer.IndexingMethods.Z_ORDER_DRAWING_ORDER;

        this.clear();
    },
    
    /**
     * APIMethod: insert
     * Insert a new node into the indexer. In order to find the correct 
     *     positioning for the node to be inserted, this method uses a binary 
     *     search. This makes inserting O(log(n)). 
     * 
     * Parameters:
     * newNode - {DOMElement} The new node to be inserted.
     * 
     * Returns
     * {DOMElement} the node before which we should insert our newNode, or
     *     null if newNode can just be appended.
     */
    insert: function(newNode) {
        // If the node is known to the indexer, remove it so we can
        // recalculate where it should go.
        if (this.exists(newNode)) {
            this.remove(newNode);
        }
        
        var nodeId = newNode.id;
        
        this.determineZIndex(newNode);       

        var leftIndex = -1;
        var rightIndex = this.order.length;
        var middle;

        while (rightIndex - leftIndex > 1) {
            middle = parseInt((leftIndex + rightIndex) / 2);
            
            var placement = this.compare(this, newNode,
                HGIS.Util.getElement(this.order[middle]));
            
            if (placement > 0) {
                leftIndex = middle;
            } else {
                rightIndex = middle;
            } 
        }
        
        this.order.splice(rightIndex, 0, nodeId);
        this.indices[nodeId] = this.getZIndex(newNode);
        
        // If the new node should be before another in the index
        // order, return the node before which we have to insert the new one;
        // else, return null to indicate that the new node can be appended.
        return this.getNextElement(rightIndex);
    },
    
    /**
     * APIMethod: remove
     * 
     * Parameters:
     * node - {DOMElement} The node to be removed.
     */
    remove: function(node) {
        var nodeId = node.id;
        var arrayIndex = HGIS.Util.indexOf(this.order, nodeId);
        if (arrayIndex >= 0) {
            // Remove it from the order array, as well as deleting the node
            // from the indeces hash.
            this.order.splice(arrayIndex, 1);
            delete this.indices[nodeId];
            
            // Reset the maxium z-index based on the last item in the 
            // order array.
            if (this.order.length > 0) {
                var lastId = this.order[this.order.length - 1];
                this.maxZIndex = this.indices[lastId];
            } else {
                this.maxZIndex = 0;
            }
        }
    },
    
    /**
     * APIMethod: clear
     */
    clear: function() {
        this.order = [];
        this.indices = {};
        this.maxZIndex = 0;
    },
    
    /**
     * APIMethod: exists
     *
     * Parameters:
     * node - {DOMElement} The node to test for existence.
     *
     * Returns:
     * {Boolean} Whether or not the node exists in the indexer?
     */
    exists: function(node) {
        return (this.indices[node.id] != null);
    },

    /**
     * APIMethod: getZIndex
     * Get the z-index value for the current node from the node data itself.
     * 
     * Parameters:
     * node - {DOMElement} The node whose z-index to get.
     * 
     * Returns:
     * {Integer} The z-index value for the specified node (from the node 
     *     data itself).
     */
    getZIndex: function(node) {
        return node._style.graphicZIndex;  
    },
    
    /**
     * Method: determineZIndex
     * Determine the z-index for the current node if there isn't one, 
     *     and set the maximum value if we've found a new maximum.
     * 
     * Parameters:
     * node - {DOMElement} 
     */
    determineZIndex: function(node) {
        var zIndex = node._style.graphicZIndex;
        
        // Everything must have a zIndex. If none is specified,
        // this means the user *must* (hint: assumption) want this
        // node to succomb to drawing order. To enforce drawing order
        // over all indexing methods, we'll create a new z-index that's
        // greater than any currently in the indexer.
        if (zIndex == null) {
            zIndex = this.maxZIndex;
            node._style.graphicZIndex = zIndex; 
        } else if (zIndex > this.maxZIndex) {
            this.maxZIndex = zIndex;
        }
    },

    /**
     * APIMethod: getNextElement
     * Get the next element in the order stack.
     * 
     * Parameters:
     * index - {Integer} The index of the current node in this.order.
     * 
     * Returns:
     * {DOMElement} the node following the index passed in, or
     *     null.
     */
    getNextElement: function(index) {
        var nextIndex = index + 1;
        if (nextIndex < this.order.length) {
            var nextElement = HGIS.Util.getElement(this.order[nextIndex]);
            if (nextElement == undefined) {
                nextElement = this.getNextElement(nextIndex);
            }
            return nextElement;
        } else {
            return null;
        } 
    },
    
    CLASS_NAME: "HGIS.ElementsIndexer"
});

/**
 * Namespace: HGIS.ElementsIndexer.IndexingMethods
 * These are the compare methods for figuring out where a new node should be 
 *     placed within the indexer. These methods are very similar to general 
 *     sorting methods in that they return -1, 0, and 1 to specify the 
 *     direction in which new nodes fall in the ordering.
 */
HGIS.ElementsIndexer.IndexingMethods = {
    
    /**
     * Method: Z_ORDER
     * This compare method is used by other comparison methods.
     *     It can be used individually for ordering, but is not recommended,
     *     because it doesn't subscribe to drawing order.
     * 
     * Parameters:
     * indexer - {<HGIS.ElementsIndexer>}
     * newNode - {DOMElement}
     * nextNode - {DOMElement}
     * 
     * Returns:
     * {Integer}
     */
    Z_ORDER: function(indexer, newNode, nextNode) {
        var newZIndex = indexer.getZIndex(newNode);

        var returnVal = 0;
        if (nextNode) {
            var nextZIndex = indexer.getZIndex(nextNode);
            returnVal = newZIndex - nextZIndex; 
        }
        
        return returnVal;
    },

    /**
     * APIMethod: Z_ORDER_DRAWING_ORDER
     * This method orders nodes by their z-index, but does so in a way
     *     that, if there are other nodes with the same z-index, the newest 
     *     drawn will be the front most within that z-index. This is the 
     *     default indexing method.
     * 
     * Parameters:
     * indexer - {<HGIS.ElementsIndexer>}
     * newNode - {DOMElement}
     * nextNode - {DOMElement}
     * 
     * Returns:
     * {Integer}
     */
    Z_ORDER_DRAWING_ORDER: function(indexer, newNode, nextNode) {
        var returnVal = HGIS.ElementsIndexer.IndexingMethods.Z_ORDER(
            indexer, 
            newNode, 
            nextNode
        );
        
        // Make Z_ORDER subscribe to drawing order by pushing it above
        // all of the other nodes with the same z-index.
        if (nextNode && returnVal == 0) {
            returnVal = 1;
        }
        
        return returnVal;
    },

    /**
     * APIMethod: Z_ORDER_Y_ORDER
     * This one should really be called Z_ORDER_Y_ORDER_DRAWING_ORDER, as it
     *     best describes which ordering methods have precedence (though, the 
     *     name would be too long). This method orders nodes by their z-index, 
     *     but does so in a way that, if there are other nodes with the same 
     *     z-index, the nodes with the lower y position will be "closer" than 
     *     those with a higher y position. If two nodes have the exact same y 
     *     position, however, then this method will revert to using drawing  
     *     order to decide placement.
     * 
     * Parameters:
     * indexer - {<HGIS.ElementsIndexer>}
     * newNode - {DOMElement}
     * nextNode - {DOMElement}
     * 
     * Returns:
     * {Integer}
     */
    Z_ORDER_Y_ORDER: function(indexer, newNode, nextNode) {
        var returnVal = HGIS.ElementsIndexer.IndexingMethods.Z_ORDER(
            indexer, 
            newNode, 
            nextNode
        );
        
        if (nextNode && returnVal === 0) {            
            var result = nextNode._boundsBottom - newNode._boundsBottom;
            returnVal = (result === 0) ? 1 : result;
        }
        
        return returnVal;       
    }
};

/**
 * Class: HGIS.Renderer.Elements
 * This is another virtual class in that it should never be instantiated by 
 *  itself as a Renderer. It exists because there is *tons* of shared 
 *  functionality between different vector libraries which use nodes/elements
 *  as a base for rendering vectors. 
 * 
 * The highlevel bits of code that are implemented here are the adding and 
 *  removing of geometries, which is essentially the same for any 
 *  element-based renderer. The details of creating each node and drawing the
 *  paths are of course different, but the machinery is the same. 
 * 
 * Inherits:
 *  - <HGIS.Renderer>
 */
HGIS.Renderer.Elements = HGIS.Class(HGIS.Renderer, {

    /**
     * Property: rendererRoot
     * {DOMElement}
     */
    rendererRoot: null,
    
    /**
     * Property: root
     * {DOMElement}
     */
    root: null,
    
    /**
     * Property: vectorRoot
     * {DOMElement}
     */
    vectorRoot: null,

    /**
     * Property: textRoot
     * {DOMElement}
     */
    textRoot: null,

    /**
     * Property: xmlns
     * {String}
     */    
    xmlns: null,
    
    /**
     * Property: xOffset
     * {Number} Offset to apply to the renderer viewport translation in x
     * direction. If the renderer extent's center is on the right of the
     * dateline (i.e. exceeds the world bounds), we shift the viewport to the
     * left by one world width. This avoids that features disappear from the
     * map viewport. Because our dateline handling logic in other places
     * ensures that extents crossing the dateline always have a center
     * exceeding the world bounds on the left, we need this offset to make sure
     * that the same is true for the renderer extent in pixel space as well.
     */
    xOffset: 0,
    
    /**
     * Property: rightOfDateLine
     * {Boolean} Keeps track of the location of the map extent relative to the
     * date line. The <setExtent> method compares this value (which is the one
     * from the previous <setExtent> call) with the current position of the map
     * extent relative to the date line and updates the xOffset when the extent
     * has moved from one side of the date line to the other.
     */
    
    /**
     * Property: Indexer
     * {<HGIS.ElementIndexer>} An instance of HGIS.ElementsIndexer 
     *     created upon initialization if the zIndexing or yOrdering options
     *     passed to this renderer's constructor are set to true.
     */
    indexer: null, 
    
    /**
     * Constant: BACKGROUND_ID_SUFFIX
     * {String}
     */
    BACKGROUND_ID_SUFFIX: "_background",
    
    /**
     * Constant: LABEL_ID_SUFFIX
     * {String}
     */
    LABEL_ID_SUFFIX: "_label",
    
    /**
     * Constant: LABEL_OUTLINE_SUFFIX
     * {String}
     */
    LABEL_OUTLINE_SUFFIX: "_outline",

    /**
     * Constructor: HGIS.Renderer.Elements
     * 
     * Parameters:
     * containerID - {String}
     * options - {Object} options for this renderer. 
     *
     * Supported options are:
     *     yOrdering - {Boolean} Whether to use y-ordering
     *     zIndexing - {Boolean} Whether to use z-indexing. Will be ignored
     *         if yOrdering is set to true.
     */
    initialize: function(containerID, options) {
        HGIS.Renderer.prototype.initialize.apply(this, arguments);

        this.rendererRoot = this.createRenderRoot();
        this.root = this.createRoot("_root");
        this.vectorRoot = this.createRoot("_vroot");
        this.textRoot = this.createRoot("_troot");
        
        this.root.appendChild(this.vectorRoot);
        this.root.appendChild(this.textRoot);
        
        this.rendererRoot.appendChild(this.root);
        this.container.appendChild(this.rendererRoot);
        
        if(options && (options.zIndexing || options.yOrdering)) {
            this.indexer = new HGIS.ElementsIndexer(options.yOrdering);
        }
    },
    
    /**
     * Method: destroy
     */
    destroy: function() {

        this.clear(); 

        this.rendererRoot = null;
        this.root = null;
        this.xmlns = null;

        HGIS.Renderer.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Method: clear
     * Remove all the elements from the root
     */    
    clear: function() {
        var child;
        var root = this.vectorRoot;
        if (root) {
            while (child = root.firstChild) {
                root.removeChild(child);
            }
        }
        root = this.textRoot;
        if (root) {
            while (child = root.firstChild) {
                root.removeChild(child);
            }
        }
        if (this.indexer) {
            this.indexer.clear();
        }
    },
    
    /**
     * Method: setExtent
     * Set the visible part of the layer.
     *
     * Parameters:
     * extent - {<HGIS.Bounds>}
     * resolutionChanged - {Boolean}
     *
     * Returns:
     * {Boolean} true to notify the layer that the new extent does not exceed
     *     the coordinate range, and the features will not need to be redrawn.
     *     False otherwise.
     */
    setExtent: function(extent, resolutionChanged) {
        var coordSysUnchanged = HGIS.Renderer.prototype.setExtent.apply(this, arguments);
        var resolution = this.getResolution();
        if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
            var rightOfDateLine,
                ratio = extent.getWidth() / this.map.getExtent().getWidth(),
                extent = extent.scale(1 / ratio),
                world = this.map.getMaxExtent();
            if (world.right > extent.left && world.right < extent.right) {
                rightOfDateLine = true;
            } else if (world.left > extent.left && world.left < extent.right) {
                rightOfDateLine = false;
            }
            if (rightOfDateLine !== this.rightOfDateLine || resolutionChanged) {
                coordSysUnchanged = false;
                this.xOffset = rightOfDateLine === true ?
                    world.getWidth() / resolution : 0;
            }
            this.rightOfDateLine = rightOfDateLine;
        }
        return coordSysUnchanged;
    },

    /** 
     * Method: getNodeType
     * This function is in charge of asking the specific renderer which type
     *     of node to create for the given geometry and style. All geometries
     *     in an Elements-based renderer consist of one node and some
     *     attributes. We have the nodeFactory() function which creates a node
     *     for us, but it takes a 'type' as input, and that is precisely what
     *     this function tells us.  
     *  
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * style - {Object}
     * 
     * Returns:
     * {String} The corresponding node type for the specified geometry
     */
    getNodeType: function(geometry, style) { },

    /** 
     * Method: drawGeometry 
     * Draw the geometry, creating new nodes, setting paths, setting style,
     *     setting featureId on the node.  This method should only be called
     *     by the renderer itself.
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * style - {Object}
     * featureId - {String}
     * 
     * Returns:
     * {Boolean} true if the geometry has been drawn completely; null if
     *     incomplete; false otherwise
     */
    drawGeometry: function(geometry, style, featureId) {
        var className = geometry.CLASS_NAME;
        var rendered = true;
        if ((className == "HGIS.Geometry.Collection") ||
            (className == "HGIS.Geometry.MultiPoint") ||
            (className == "HGIS.Geometry.MultiLineString") ||
            (className == "HGIS.Geometry.MultiPolygon")) {
            for (var i = 0, len=geometry.components.length; i<len; i++) {
                rendered = this.drawGeometry(
                    geometry.components[i], style, featureId) && rendered;
            }
            return rendered;
        }

        rendered = false;
        var removeBackground = false;
        if (style.display != "none") {
            if (style.backgroundGraphic) {
                this.redrawBackgroundNode(geometry.id, geometry, style,
                    featureId);
            } else {
                removeBackground = true;
            }
            rendered = this.redrawNode(geometry.id, geometry, style,
                featureId);
        }
        if (rendered == false) {
            var node = document.getElementById(geometry.id);
            if (node) {
                if (node._style.backgroundGraphic) {
                    removeBackground = true;
                }
                node.parentNode.removeChild(node);
            }
        }
        if (removeBackground) {
            var node = document.getElementById(
                geometry.id + this.BACKGROUND_ID_SUFFIX);
            if (node) {
                node.parentNode.removeChild(node);
            }
        }
        return rendered;
    },
    
    /**
     * Method: redrawNode
     * 
     * Parameters:
     * id - {String}
     * geometry - {<HGIS.Geometry>}
     * style - {Object}
     * featureId - {String}
     * 
     * Returns:
     * {Boolean} true if the complete geometry could be drawn, null if parts of
     *     the geometry could not be drawn, false otherwise
     */
    redrawNode: function(id, geometry, style, featureId) {
        style = this.applyDefaultSymbolizer(style);
        // Get the node if it's already on the map.
        var node = this.nodeFactory(id, this.getNodeType(geometry, style));
        
        // Set the data for the node, then draw it.
        node._featureId = featureId;
        node._boundsBottom = geometry.getBounds().bottom;
        node._geometryClass = geometry.CLASS_NAME;
        node._style = style;

        var drawResult = this.drawGeometryNode(node, geometry, style);
        if(drawResult === false) {
            return false;
        }
         
        node = drawResult.node;
        
        // Insert the node into the indexer so it can show us where to
        // place it. Note that this operation is O(log(n)). If there's a
        // performance problem (when dragging, for instance) this is
        // likely where it would be.
        if (this.indexer) {
            var insert = this.indexer.insert(node);
            if (insert) {
                this.vectorRoot.insertBefore(node, insert);
            } else {
                this.vectorRoot.appendChild(node);
            }
        } else {
            // if there's no indexer, simply append the node to root,
            // but only if the node is a new one
            if (node.parentNode !== this.vectorRoot){ 
                this.vectorRoot.appendChild(node);
            }
        }
        
        this.postDraw(node);
        
        return drawResult.complete;
    },
    
    /**
     * Method: redrawBackgroundNode
     * Redraws the node using special 'background' style properties. Basically
     *     just calls redrawNode(), but instead of directly using the 
     *     'externalGraphic', 'graphicXOffset', 'graphicYOffset', and 
     *     'graphicZIndex' properties directly from the specified 'style' 
     *     parameter, we create a new style object and set those properties 
     *     from the corresponding 'background'-prefixed properties from 
     *     specified 'style' parameter.
     * 
     * Parameters:
     * id - {String}
     * geometry - {<HGIS.Geometry>}
     * style - {Object}
     * featureId - {String}
     * 
     * Returns:
     * {Boolean} true if the complete geometry could be drawn, null if parts of
     *     the geometry could not be drawn, false otherwise
     */
    redrawBackgroundNode: function(id, geometry, style, featureId) {
        var backgroundStyle = HGIS.Util.extend({}, style);
        
        // Set regular style attributes to apply to the background styles.
        backgroundStyle.externalGraphic = backgroundStyle.backgroundGraphic;
        backgroundStyle.graphicXOffset = backgroundStyle.backgroundXOffset;
        backgroundStyle.graphicYOffset = backgroundStyle.backgroundYOffset;
        backgroundStyle.graphicZIndex = backgroundStyle.backgroundGraphicZIndex;
        backgroundStyle.graphicWidth = backgroundStyle.backgroundWidth || backgroundStyle.graphicWidth;
        backgroundStyle.graphicHeight = backgroundStyle.backgroundHeight || backgroundStyle.graphicHeight;
        
        // Erase background styles.
        backgroundStyle.backgroundGraphic = null;
        backgroundStyle.backgroundXOffset = null;
        backgroundStyle.backgroundYOffset = null;
        backgroundStyle.backgroundGraphicZIndex = null;
        
        return this.redrawNode(
            id + this.BACKGROUND_ID_SUFFIX, 
            geometry, 
            backgroundStyle, 
            null
        );
    },

    /**
     * Method: drawGeometryNode
     * Given a node, draw a geometry on the specified layer.
     *     node and geometry are required arguments, style is optional.
     *     This method is only called by the render itself.
     *
     * Parameters:
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * style - {Object}
     * 
     * Returns:
     * {Object} a hash with properties "node" (the drawn node) and "complete"
     *     (null if parts of the geometry could not be drawn, false if nothing
     *     could be drawn)
     */
    drawGeometryNode: function(node, geometry, style) {
        style = style || node._style;

        var options = {
            'isFilled': style.fill === undefined ?
                true :
                style.fill,
            'isStroked': style.stroke === undefined ?
                !!style.strokeWidth :
                style.stroke
        };
        var drawn;
        switch (geometry.CLASS_NAME) {
            case "HGIS.Geometry.Point":
                if(style.graphic === false) {
                    options.isFilled = false;
                    options.isStroked = false;
                }
                drawn = this.drawPoint(node, geometry);
                break;
            case "HGIS.Geometry.LineString":
                options.isFilled = false;
                drawn = this.drawLineString(node, geometry);
                break;
            case "HGIS.Geometry.LinearRing":
                drawn = this.drawLinearRing(node, geometry);
                break;
            case "HGIS.Geometry.Polygon":
                drawn = this.drawPolygon(node, geometry);
                break;
            case "HGIS.Geometry.Rectangle":
                drawn = this.drawRectangle(node, geometry);
                break;
            default:
                break;
        }

        node._options = options; 

        //set style
        //TBD simplify this
        if (drawn != false) {
            return {
                node: this.setStyle(node, style, options, geometry),
                complete: drawn
            };
        } else {
            return false;
        }
    },
    
    /**
     * Method: postDraw
     * Things that have do be done after the geometry node is appended
     *     to its parent node. To be overridden by subclasses.
     * 
     * Parameters:
     * node - {DOMElement}
     */
    postDraw: function(node) {},
    
    /**
     * Method: drawPoint
     * Virtual function for drawing Point Geometry. 
     *     Should be implemented by subclasses.
     *     This method is only called by the renderer itself.
     * 
     * Parameters: 
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement} or false if the renderer could not draw the point
     */ 
    drawPoint: function(node, geometry) {},

    /**
     * Method: drawLineString
     * Virtual function for drawing LineString Geometry. 
     *     Should be implemented by subclasses.
     *     This method is only called by the renderer itself.
     * 
     * Parameters: 
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement} or null if the renderer could not draw all components of
     *     the linestring, or false if nothing could be drawn
     */ 
    drawLineString: function(node, geometry) {},

    /**
     * Method: drawLinearRing
     * Virtual function for drawing LinearRing Geometry. 
     *     Should be implemented by subclasses.
     *     This method is only called by the renderer itself.
     * 
     * Parameters: 
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement} or null if the renderer could not draw all components
     *     of the linear ring, or false if nothing could be drawn
     */ 
    drawLinearRing: function(node, geometry) {},

    /**
     * Method: drawPolygon
     * Virtual function for drawing Polygon Geometry. 
     *    Should be implemented by subclasses.
     *    This method is only called by the renderer itself.
     * 
     * Parameters: 
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement} or null if the renderer could not draw all components
     *     of the polygon, or false if nothing could be drawn
     */ 
    drawPolygon: function(node, geometry) {},

    /**
     * Method: drawRectangle
     * Virtual function for drawing Rectangle Geometry. 
     *     Should be implemented by subclasses.
     *     This method is only called by the renderer itself.
     * 
     * Parameters: 
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement} or false if the renderer could not draw the rectangle
     */ 
    drawRectangle: function(node, geometry) {},

    /**
     * Method: drawCircle
     * Virtual function for drawing Circle Geometry. 
     *     Should be implemented by subclasses.
     *     This method is only called by the renderer itself.
     * 
     * Parameters: 
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement} or false if the renderer could not draw the circle
     */ 
    drawCircle: function(node, geometry) {},

    /**
     * Method: removeText
     * Removes a label
     * 
     * Parameters:
     * featureId - {String}
     */
    removeText: function(featureId) {
    	var id = featureId + this.LABEL_ID_SUFFIX ;
        var label = document.getElementById( id );
        if (label) {
        	if(this.textRoot&& this.textRoot.children &&this.textRoot.children.length >0 ){
        		this.textRoot.removeChild(label);
        	}else{
        		if(this.vectorRoot.children && this.vectorRoot.children.length >0){
               	 this.vectorRoot.removeChild(label);//2018年8月6日修改，将textRoot改为vectorRoot
               }else {  // if(this.vectorRoot.childNodes && this.vectorRoot.childNodes.length >0 ) 
	           		this.vectorRoot.removeChild(label);
	           	}
        	}		
        }
        //去掉背景
		var labelBackground = document.getElementById(featureId + this.LABEL_ID_SUFFIX + "_bg");
		if(labelBackground){
		  //this.textRoot.removeChild(labelBackground);
		  this.vectorRoot.removeChild(labelBackground);//2018年8月6日修改，将textRoot改为vectorRoot
		}
		
        var outline = document.getElementById(featureId + this.LABEL_OUTLINE_SUFFIX);
        if (outline) {
            //this.textRoot.removeChild(outline);
            this.vectorRoot.removeChild(outline);//2018年8月6日修改，将textRoot改为vectorRoot
        }
    },

    /**
     * Method: getFeatureIdFromEvent
     * 
     * Parameters:
     * evt - {Object} An <HGIS.Event> object
     *
     * Returns:
     * {String} A feature id or undefined.
     */
    getFeatureIdFromEvent: function(evt) {
        var target = evt.target;
        var useElement = target && target.correspondingUseElement;
        var node = useElement ? useElement : (target || evt.srcElement);
        return node._featureId;
    },

    /** 
     * Method: eraseGeometry
     * Erase a geometry from the renderer. In the case of a multi-geometry, 
     *     we cycle through and recurse on ourselves. Otherwise, we look for a 
     *     node with the geometry.id, destroy its geometry, and remove it from
     *     the DOM.
     * 
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * featureId - {String}
     */
    eraseGeometry: function(geometry, featureId) {
        if ((geometry.CLASS_NAME == "HGIS.Geometry.MultiPoint") ||
            (geometry.CLASS_NAME == "HGIS.Geometry.MultiLineString") ||
            (geometry.CLASS_NAME == "HGIS.Geometry.MultiPolygon") ||
            (geometry.CLASS_NAME == "HGIS.Geometry.Collection")) {
            for (var i=0, len=geometry.components.length; i<len; i++) {
                this.eraseGeometry(geometry.components[i], featureId);
            }
        } else {    
            var element = HGIS.Util.getElement(geometry.id);
            if (element && element.parentNode) {
                if (element.geometry) {
                    element.geometry.destroy();
                    element.geometry = null;
                }
                element.parentNode.removeChild(element);

                if (this.indexer) {
                    this.indexer.remove(element);
                }
                
                if (element._style.backgroundGraphic) {
                    var backgroundId = geometry.id + this.BACKGROUND_ID_SUFFIX;
                    var bElem = HGIS.Util.getElement(backgroundId);
                    if (bElem && bElem.parentNode) {
                        // No need to destroy the geometry since the element and the background
                        // node share the same geometry.
                        bElem.parentNode.removeChild(bElem);
                    }
                }
            }
        }
    },

    /** 
     * Method: nodeFactory
     * Create new node of the specified type, with the (optional) specified id.
     * 
     * If node already exists with same ID and a different type, we remove it
     *     and then call ourselves again to recreate it.
     * 
     * Parameters:
     * id - {String}
     * type - {String} type Kind of node to draw.
     * 
     * Returns:
     * {DOMElement} A new node of the given type and id.
     */
    nodeFactory: function(id, type) {
        var node = HGIS.Util.getElement(id);
        if (node) {
            if (!this.nodeTypeCompare(node, type)) {
                node.parentNode.removeChild(node);
                node = this.nodeFactory(id, type);
            }
        } else {
            node = this.createNode(type, id);
        }
        return node;
    },
    
    /** 
     * Method: nodeTypeCompare
     * 
     * Parameters:
     * node - {DOMElement}
     * type - {String} Kind of node
     * 
     * Returns:
     * {Boolean} Whether or not the specified node is of the specified type
     *     This function must be overridden by subclasses.
     */
    nodeTypeCompare: function(node, type) {},
    
    /** 
     * Method: createNode
     * 
     * Parameters:
     * type - {String} Kind of node to draw.
     * id - {String} Id for node.
     * 
     * Returns:
     * {DOMElement} A new node of the given type and id.
     *     This function must be overridden by subclasses.
     */
    createNode: function(type, id) {},

    /**
     * Method: moveRoot
     * moves this renderer's root to a different renderer.
     * 
     * Parameters:
     * renderer - {<HGIS.Renderer>} target renderer for the moved root
     */
    moveRoot: function(renderer) {
        var root = this.root;
        if(renderer.root.parentNode == this.rendererRoot) {
            root = renderer.root;
        }
        root.parentNode.removeChild(root);
        renderer.rendererRoot.appendChild(root);
    },
    
    /**
     * Method: getRenderLayerId
     * Gets the layer that this renderer's output appears on. If moveRoot was
     * used, this will be different from the id of the layer containing the
     * features rendered by this renderer.
     * 
     * Returns:
     * {String} the id of the output layer.
     */
    getRenderLayerId: function() {
        return this.root.parentNode.parentNode.id;
    },
    
    /**
     * Method: isComplexSymbol
     * Determines if a symbol cannot be rendered using drawCircle
     * 
     * Parameters:
     * graphicName - {String}
     * 
     * Returns
     * {Boolean} true if the symbol is complex, false if not
     */
    isComplexSymbol: function(graphicName) {
        return (graphicName != "circle") && !!graphicName;
    },

    CLASS_NAME: "HGIS.Renderer.Elements"
});

/* ======================================================================
    HGIS/Control/ArgParser.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Control.js
 */

/**
 * Class: HGIS.Control.ArgParser
 * The ArgParser control adds location bar query string parsing functionality 
 * to an HGIS Map.
 * When added to a Map control, on a page load/refresh, the Map will 
 * automatically take the href string and parse it for lon, lat, zoom, and 
 * layers information. 
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.ArgParser = HGIS.Class(HGIS.Control, {

    /**
     * Property: center
     * {<HGIS.LonLat>}
     */
    center: null,
    
    /**
     * Property: zoom
     * {int}
     */
    zoom: null,

    /**
     * Property: layers
     * {String} Each character represents the state of the corresponding layer 
     *     on the map.
     */
    layers: null,
    
    /** 
     * APIProperty: displayProjection
     * {<HGIS.Projection>} Requires proj4js support. 
     *     Projection used when reading the coordinates from the URL. This will
     *     reproject the map coordinates from the URL into the map's
     *     projection.
     *
     *     If you are using this functionality, be aware that any permalink
     *     which is added to the map will determine the coordinate type which
     *     is read from the URL, which means you should not add permalinks with
     *     different displayProjections to the same map. 
     */
    displayProjection: null, 

    /**
     * Constructor: HGIS.Control.ArgParser
     *
     * Parameters:
     * options - {Object}
     */

    /**
     * Method: getParameters
     */    
    getParameters: function(url) {
        url = url || window.location.href;
        var parameters = HGIS.Util.getParameters(url);

        // If we have an anchor in the url use it to split the url
        var index = url.indexOf('#');
        if (index > 0) {
            // create an url to parse on the getParameters
            url = '?' + url.substring(index + 1, url.length);

            HGIS.Util.extend(parameters,
                    HGIS.Util.getParameters(url));
        }
        return parameters;
    },
    
    /**
     * Method: setMap
     * Set the map property for the control. 
     * 
     * Parameters:
     * map - {<HGIS.Map>} 
     */
    setMap: function(map) {
        HGIS.Control.prototype.setMap.apply(this, arguments);

        //make sure we dont already have an arg parser attached
        for(var i=0, len=this.map.controls.length; i<len; i++) {
            var control = this.map.controls[i];
            if ( (control != this) &&
                 (control.CLASS_NAME == "HGIS.Control.ArgParser") ) {
                
                // If a second argparser is added to the map, then we 
                // override the displayProjection to be the one added to the
                // map. 
                if (control.displayProjection != this.displayProjection) {
                    this.displayProjection = control.displayProjection;
                }    
                
                break;
            }
        }
        if (i == this.map.controls.length) {

            var args = this.getParameters();
            // Be careful to set layer first, to not trigger unnecessary layer loads
            if (args.layers) {
                this.layers = args.layers;
    
                // when we add a new layer, set its visibility 
                this.map.events.register('addlayer', this, 
                                         this.configureLayers);
                this.configureLayers();
            }
            if (args.lat && args.lon) {
                this.center = new HGIS.LonLat(parseFloat(args.lon),
                                                    parseFloat(args.lat));
                if (args.zoom) {
                    this.zoom = parseFloat(args.zoom);
                }
    
                // when we add a new baselayer to see when we can set the center
                this.map.events.register('changebaselayer', this, 
                                         this.setCenter);
                this.setCenter();
            }
        }
    },
   
    /** 
     * Method: setCenter
     * As soon as a baseLayer has been loaded, we center and zoom
     *   ...and remove the handler.
     */
    setCenter: function() {
        
        if (this.map.baseLayer) {
            //dont need to listen for this one anymore
            this.map.events.unregister('changebaselayer', this, 
                                       this.setCenter);
            
            if (this.displayProjection) {
                this.center.transform(this.displayProjection, 
                                      this.map.getProjectionObject()); 
            }      

            this.map.setCenter(this.center, this.zoom);
        }
    },

    /** 
     * Method: configureLayers
     * As soon as all the layers are loaded, cycle through them and 
     *   hide or show them. 
     */
    configureLayers: function() {

        if (this.layers.length == this.map.layers.length) { 
            this.map.events.unregister('addlayer', this, this.configureLayers);

            for(var i=0, len=this.layers.length; i<len; i++) {
                
                var layer = this.map.layers[i];
                var c = this.layers.charAt(i);
                
                if (c == "B") {
                    this.map.setBaseLayer(layer);
                } else if ( (c == "T") || (c == "F") ) {
                    layer.setVisibility(c == "T");
                }
            }
        }
    },     

    CLASS_NAME: "HGIS.Control.ArgParser"
});
/* ======================================================================
    HGIS/Control/Permalink.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Control.js
 * @requires HGIS/Control/ArgParser.js
 * @requires HGIS/Lang.js
 */

/**
 * Class: HGIS.Control.Permalink
 * The Permalink control is hyperlink that will return the user to the 
 * current map view. By default it is drawn in the lower right corner of the
 * map. The href is updated as the map is zoomed, panned and whilst layers
 * are switched.
 * 
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.Permalink = HGIS.Class(HGIS.Control, {
    
    /**
     * APIProperty: argParserClass
     * {Class} The ArgParser control class (not instance) to use with this
     *     control.
     */
    argParserClass: HGIS.Control.ArgParser,

    /** 
     * Property: element 
     * {DOMElement}
     */
    element: null,
    
    /** 
     * APIProperty: anchor
     * {Boolean} This option changes 3 things:
     *     the character '#' is used in place of the character '?',
     *     the window.href is updated if no element is provided.
     *     When this option is set to true it's not recommend to provide
     *     a base without provide an element.
     */
    anchor: false,

    /** 
     * APIProperty: base
     * {String}
     */
    base: '',

    /** 
     * APIProperty: displayProjection
     * {<HGIS.Projection>} Requires proj4js support.  Projection used
     *     when creating the coordinates in the link. This will reproject the
     *     map coordinates into display coordinates. If you are using this
     *     functionality, the permalink which is last added to the map will
     *     determine the coordinate type which is read from the URL, which
     *     means you should not add permalinks with different
     *     displayProjections to the same map. 
     */
    displayProjection: null, 

    /**
     * Constructor: HGIS.Control.Permalink
     *
     * Parameters: 
     * element - {DOMElement} 
     * base - {String} 
     * options - {Object} options to the control.
     *
     * Or for anchor:
     * options - {Object} options to the control.
     */
    initialize: function(element, base, options) {
        if (element !== null && typeof element == 'object' && !HGIS.Util.isElement(element)) {
            options = element;
            this.base = document.location.href;
            HGIS.Control.prototype.initialize.apply(this, [options]);
            if (this.element != null) {
                this.element = HGIS.Util.getElement(this.element);
            }
        }
        else {
            HGIS.Control.prototype.initialize.apply(this, [options]);
            this.element = HGIS.Util.getElement(element);
            this.base = base || document.location.href;
        }
    },
    
    /**
     * APIMethod: destroy
     */
    destroy: function()  {
        if (this.element && this.element.parentNode == this.div) {
            this.div.removeChild(this.element);
            this.element = null;
        }
        if (this.map) {
            this.map.events.unregister('moveend', this, this.updateLink);
        }

        HGIS.Control.prototype.destroy.apply(this, arguments); 
    },

    /**
     * Method: setMap
     * Set the map property for the control. 
     * 
     * Parameters:
     * map - {<HGIS.Map>} 
     */
    setMap: function(map) {
        HGIS.Control.prototype.setMap.apply(this, arguments);

        //make sure we have an arg parser attached
        for(var i=0, len=this.map.controls.length; i<len; i++) {
            var control = this.map.controls[i];
            if (control.CLASS_NAME == this.argParserClass.CLASS_NAME) {
                
                // If a permalink is added to the map, and an ArgParser already
                // exists, we override the displayProjection to be the one
                // on the permalink. 
                if (control.displayProjection != this.displayProjection) {
                    this.displayProjection = control.displayProjection;
                }    
                
                break;
            }
        }
        if (i == this.map.controls.length) {
            this.map.addControl(new this.argParserClass(
                { 'displayProjection': this.displayProjection }));       
        }

    },

    /**
     * Method: draw
     *
     * Returns:
     * {DOMElement}
     */    
    draw: function() {
        HGIS.Control.prototype.draw.apply(this, arguments);
          
        if (!this.element && !this.anchor) {
            this.element = document.createElement("a");
            this.element.innerHTML = HGIS.i18n("Permalink");
            this.element.href="";
            this.div.appendChild(this.element);
        }
        this.map.events.on({
            'moveend': this.updateLink,
            'changelayer': this.updateLink,
            'changebaselayer': this.updateLink,
            scope: this
        });
        
        // Make it so there is at least a link even though the map may not have
        // moved yet.
        this.updateLink();
        
        return this.div;
    },
   
    /**
     * Method: updateLink 
     */
    updateLink: function() {
        var separator = this.anchor ? '#' : '?';
        var href = this.base;
        var anchor = null;
        if (href.indexOf("#") != -1 && this.anchor == false) {
            anchor = href.substring( href.indexOf("#"), href.length);
        }
        if (href.indexOf(separator) != -1) {
            href = href.substring( 0, href.indexOf(separator) );
        }
        var splits = href.split("#");
        href = splits[0] + separator+ HGIS.Util.getParameterString(this.createParams());
        if (anchor) {
            href += anchor;
        }
        if (this.anchor && !this.element) {
            window.location.href = href;
        }
        else {
            this.element.href = href;
        }
    }, 
    
    /**
     * APIMethod: createParams
     * Creates the parameters that need to be encoded into the permalink url.
     * 
     * Parameters:
     * center - {<HGIS.LonLat>} center to encode in the permalink.
     *     Defaults to the current map center.
     * zoom - {Integer} zoom level to encode in the permalink. Defaults to the
     *     current map zoom level.
     * layers - {Array(<HGIS.Layer>)} layers to encode in the permalink.
     *     Defaults to the current map layers.
     * 
     * Returns:
     * {Object} Hash of parameters that will be url-encoded into the
     * permalink.
     */
    createParams: function(center, zoom, layers) {
        center = center || this.map.getCenter();
          
        var params = HGIS.Util.getParameters(this.base);
        
        // If there's still no center, map is not initialized yet. 
        // Break out of this function, and simply return the params from the
        // base link.
        if (center) { 

            //zoom
            params.zoom = zoom || this.map.getZoom(); 

            //lon,lat
            var lat = center.lat;
            var lon = center.lon;
            
            if (this.displayProjection) {
                var mapPosition = HGIS.Projection.transform(
                  { x: lon, y: lat }, 
                  this.map.getProjectionObject(), 
                  this.displayProjection );
                lon = mapPosition.x;  
                lat = mapPosition.y;  
            }       
            params.lat = Math.round(lat*100000)/100000;
            params.lon = Math.round(lon*100000)/100000;
    
            //layers        
            layers = layers || this.map.layers;  
            params.layers = '';
            for (var i=0, len=layers.length; i<len; i++) {
                var layer = layers[i];
    
                if (layer.isBaseLayer) {
                    params.layers += (layer == this.map.baseLayer) ? "B" : "0";
                } else {
                    params.layers += (layer.getVisibility()) ? "T" : "F";           
                }
            }
        }

        return params;
    }, 

    CLASS_NAME: "HGIS.Control.Permalink"
});
/* ======================================================================
    HGIS/Layer/TMS.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer/Grid.js
 */

/**
 * Class: HGIS.Layer.TMS
 * Create a layer for accessing tiles from services that conform with the 
 *     Tile Map Service Specification 
 *     (http://wiki.osgeo.org/wiki/Tile_Map_Service_Specification).
 *
 * Example:
 * (code)
 *     var layer = new HGIS.Layer.TMS(
 *         "My Layer", // name for display in LayerSwitcher
 *         "http://tilecache.osgeo.org/wms-c/Basic.py/", // service endpoint
 *         {layername: "basic", type: "png"} // required properties
 *     );
 * (end)
 * 
 * Inherits from:
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.TMS = HGIS.Class(HGIS.Layer.Grid, {

    /**
     * APIProperty: serviceVersion
     * {String} Service version for tile requests.  Default is "1.0.0".
     */
    serviceVersion: "1.0.0",

    /**
     * APIProperty: layername
     * {String} The identifier for the <TileMap> as advertised by the service.  
     *     For example, if the service advertises a <TileMap> with 
     *    'href="http://tms.osgeo.org/1.0.0/vmap0"', the <layername> property 
     *     would be set to "vmap0".
     */
    layername: null,

    /**
     * APIProperty: type
     * {String} The format extension corresponding to the requested tile image
     *     type.  This is advertised in a <TileFormat> element as the 
     *     "extension" attribute.  For example, if the service advertises a 
     *     <TileMap> with <TileFormat width="256" height="256" mime-type="image/jpeg" extension="jpg" />,
     *     the <type> property would be set to "jpg".
     */
    type: null,

    /**
     * APIProperty: isBaseLayer
     * {Boolean} Make this layer a base layer.  Default is true.  Set false to
     *     use the layer as an overlay.
     */
    isBaseLayer: true,

    /**
     * APIProperty: tileOrigin
     * {<HGIS.LonLat>} Optional origin for aligning the grid of tiles.
     *     If provided, requests for tiles at all resolutions will be aligned
     *     with this location (no tiles shall overlap this location).  If
     *     not provided, the grid of tiles will be aligned with the bottom-left
     *     corner of the map's <maxExtent>.  Default is ``null``.
     *
     * Example:
     * (code)
     *     var layer = new HGIS.Layer.TMS(
     *         "My Layer",
     *         "http://tilecache.osgeo.org/wms-c/Basic.py/",
     *         {
     *             layername: "basic", 
     *             type: "png",
     *             // set if different than the bottom left of map.maxExtent
     *             tileOrigin: new HGIS.LonLat(-180, -90)
     *         }
     *     );
     * (end)
     */
    tileOrigin: null,

    /**
     * APIProperty: serverResolutions
     * {Array} A list of all resolutions available on the server.  Only set this
     *     property if the map resolutions differ from the server. This
     *     property serves two purposes. (a) <serverResolutions> can include
     *     resolutions that the server supports and that you don't want to
     *     provide with this layer; you can also look at <zoomOffset>, which is
     *     an alternative to <serverResolutions> for that specific purpose.
     *     (b) The map can work with resolutions that aren't supported by
     *     the server, i.e. that aren't in <serverResolutions>. When the
     *     map is displayed in such a resolution data for the closest
     *     server-supported resolution is loaded and the layer div is
     *     stretched as necessary.
     */
    serverResolutions: null,

    /**
     * APIProperty: zoomOffset
     * {Number} If your cache has more zoom levels than you want to provide
     *     access to with this layer, supply a zoomOffset.  This zoom offset
     *     is added to the current map zoom level to determine the level
     *     for a requested tile.  For example, if you supply a zoomOffset
     *     of 3, when the map is at the zoom 0, tiles will be requested from
     *     level 3 of your cache.  Default is 0 (assumes cache level and map
     *     zoom are equivalent).  Using <zoomOffset> is an alternative to
     *     setting <serverResolutions> if you only want to expose a subset
     *     of the server resolutions.
     */
    zoomOffset: 0,
    
    /**
     * Constructor: HGIS.Layer.TMS
     * 
     * Parameters:
     * name - {String} Title to be displayed in a <HGIS.Control.LayerSwitcher>
     * url - {String} Service endpoint (without the version number).  E.g.
     *     "http://tms.osgeo.org/".
     * options - {Object} Additional properties to be set on the layer.  The
     *     <layername> and <type> properties must be set here.
     */
    initialize: function(name, url, options) {
        var newArguments = [];
        newArguments.push(name, url, {}, options);
        HGIS.Layer.Grid.prototype.initialize.apply(this, newArguments);
    },    

    /**
     * APIMethod: clone
     * Create a complete copy of this layer.
     *
     * Parameters:
     * obj - {Object} Should only be provided by subclasses that call this
     *     method.
     * 
     * Returns:
     * {<HGIS.Layer.TMS>} An exact clone of this <HGIS.Layer.TMS>
     */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new HGIS.Layer.TMS(this.name,
                                           this.url,
                                           this.getOptions());
        }

        //get all additions from superclasses
        obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },    
    
    /**
     * Method: getURL
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     * 
     * Returns:
     * {String} A string with the layer's url and parameters and also the 
     *          passed-in bounds and appropriate tile size specified as 
     *          parameters
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);
        var res = this.getServerResolution();
        var x = Math.round((bounds.left - this.tileOrigin.lon) / (res * this.tileSize.w));
        var y = Math.round((bounds.bottom - this.tileOrigin.lat) / (res * this.tileSize.h));
        var z = this.getServerZoom();
        var path = this.serviceVersion + "/" + this.layername + "/" + z + "/" + x + "/" + y + "." + this.type; 
        var url = this.url;
        if (HGIS.Util.isArray(url)) {
            url = this.selectUrl(path, url);
        }
        return url + path;
    },

    /** 
     * Method: setMap
     * When the layer is added to a map, then we can fetch our origin 
     *    (if we don't have one.) 
     * 
     * Parameters:
     * map - {<HGIS.Map>}
     */
    setMap: function(map) {
        HGIS.Layer.Grid.prototype.setMap.apply(this, arguments);
        if (!this.tileOrigin) { 
            this.tileOrigin = new HGIS.LonLat(this.map.maxExtent.left,
                                                this.map.maxExtent.bottom);
        }                                       
    },

    CLASS_NAME: "HGIS.Layer.TMS"
});
/* ======================================================================
    HGIS/Format/WCSCapabilities.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML/VersionedOGC.js
 */

/**
 * Class: HGIS.Format.WCSCapabilities
 * Read WCS Capabilities.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML.VersionedOGC>
 */
HGIS.Format.WCSCapabilities = HGIS.Class(HGIS.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.1.0".
     */
    defaultVersion: "1.1.0",

    /**
     * Constructor: HGIS.Format.WCSCapabilities
     * Create a new parser for WCS capabilities.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return a list of coverages. 
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array} List of named coverages.
     */
    
    CLASS_NAME: "HGIS.Format.WCSCapabilities" 

});
/* ======================================================================
    HGIS/Format/WCSCapabilities/v1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WCSCapabilities.js
 */

/**
 * Class: HGIS.Format.WCSCapabilities.v1
 * Abstract class not to be instantiated directly.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.WCSCapabilities.v1 = HGIS.Class(
    HGIS.Format.XML, {

    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        splitSpace: (/\s+/)
    },

    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "wcs",

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return a list of coverages. 
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array} List of named coverages.
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        var raw = data;
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        return capabilities;
    },

    CLASS_NAME: "HGIS.Format.WCSCapabilities.v1" 

});
/* ======================================================================
    HGIS/Format/WCSCapabilities/v1_0_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WCSCapabilities/v1.js
 * @requires HGIS/Format/GML/v3.js
 */

/**
 * Class: HGIS.Format.WCSCapabilities/v1_0_0
 * Read WCS Capabilities version 1.0.0.
 * 
 * Inherits from:
 *  - <HGIS.Format.WCSCapabilities.v1>
 */
HGIS.Format.WCSCapabilities.v1_0_0 = HGIS.Class(
    HGIS.Format.WCSCapabilities.v1, {
    
    /**
     * Constructor: HGIS.Format.WCSCapabilities.v1_0_0
     * Create a new parser for WCS capabilities version 1.0.0.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        wcs: "http://www.opengis.net/wcs",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        ows: "http://www.opengis.net/ows"
    },

    /**
     * Property: errorProperty
     * {String} Which property of the returned object to check for in order to
     * determine whether or not parsing has failed. In the case that the
     * errorProperty is undefined on the returned object, the document will be
     * run through an OGCExceptionReport parser.
     */
    errorProperty: "service",

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wcs": {
             "WCS_Capabilities": function(node, obj) {          
                this.readChildNodes(node, obj);
            },
            "Service": function(node, obj) {
                obj.service = {};
                this.readChildNodes(node, obj.service);
            },
            "name": function(node, service) {  
                service.name = this.getChildValue(node);
            },
            "label": function(node, service) {  
                service.label = this.getChildValue(node);
            },
            "keywords": function(node, service) { 
                service.keywords = []; 
                this.readChildNodes(node, service.keywords);
            },
            "keyword": function(node, keywords) { 
                // Append the keyword to the keywords list
                keywords.push(this.getChildValue(node));      
            },
            "responsibleParty": function(node, service) {
                service.responsibleParty = {};
                this.readChildNodes(node, service.responsibleParty);   
            },
            "individualName": function(node, responsibleParty) {
                responsibleParty.individualName = this.getChildValue(node);
            },
            "organisationName": function(node, responsibleParty) {
                responsibleParty.organisationName = this.getChildValue(node);
            },
            "positionName": function(node, responsibleParty) {
                responsibleParty.positionName = this.getChildValue(node);
            },
            "contactInfo": function(node, responsibleParty) {
                responsibleParty.contactInfo = {};
                this.readChildNodes(node, responsibleParty.contactInfo);
            },
            "phone": function(node, contactInfo) {
                contactInfo.phone = {};
                this.readChildNodes(node, contactInfo.phone);
            },
            "voice": function(node, phone) {
                phone.voice = this.getChildValue(node);
            },
            "facsimile": function(node, phone) {
                phone.facsimile = this.getChildValue(node);
            },
            "address": function(node, contactInfo) {
                contactInfo.address = {};
                this.readChildNodes(node, contactInfo.address);
            },
            "deliveryPoint": function(node, address) {
                address.deliveryPoint = this.getChildValue(node);
            },
            "city": function(node, address) {
                address.city = this.getChildValue(node);
            },
            "postalCode": function(node, address) {
                address.postalCode = this.getChildValue(node);
            },
            "country": function(node, address) {
                address.country = this.getChildValue(node);
            },
            "electronicMailAddress": function(node, address) {
                address.electronicMailAddress = this.getChildValue(node);
            },
            "fees": function(node, service) {
                service.fees = this.getChildValue(node);
            },
            "accessConstraints": function(node, service) {
                service.accessConstraints = this.getChildValue(node);
            },
            "ContentMetadata": function(node, obj) {
                obj.contentMetadata = [];
                this.readChildNodes(node, obj.contentMetadata);
            },
            "CoverageOfferingBrief": function(node, contentMetadata) {
                var coverageOfferingBrief = {};
                this.readChildNodes(node, coverageOfferingBrief);
                contentMetadata.push(coverageOfferingBrief);
            },
            "name": function(node, coverageOfferingBrief) {
                coverageOfferingBrief.name = this.getChildValue(node);
            },
            "label": function(node, coverageOfferingBrief) {
                coverageOfferingBrief.label = this.getChildValue(node);
            },
            "lonLatEnvelope": function(node, coverageOfferingBrief) {
                var nodeList = this.getElementsByTagNameNS(node, "http://www.opengis.net/gml", "pos");

                // We expect two nodes here, to create the corners of a bounding box
                if(nodeList.length == 2) {
                    var min = {};
                    var max = {};

                    HGIS.Format.GML.v3.prototype.readers["gml"].pos.apply(this, [nodeList[0], min]);
                    HGIS.Format.GML.v3.prototype.readers["gml"].pos.apply(this, [nodeList[1], max]);

                    coverageOfferingBrief.lonLatEnvelope = {};
                    coverageOfferingBrief.lonLatEnvelope.srsName = node.getAttribute("srsName");
                    coverageOfferingBrief.lonLatEnvelope.min = min.points[0];
                    coverageOfferingBrief.lonLatEnvelope.max = max.points[0];
                }
            }
        }
    },
    
    CLASS_NAME: "HGIS.Format.WCSCapabilities.v1_0_0" 

});
/* ======================================================================
    HGIS/Strategy/Fixed.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Strategy.js
 */

/**
 * Class: HGIS.Strategy.Fixed
 * A simple strategy that requests features once and never requests new data.
 *
 * Inherits from:
 *  - <HGIS.Strategy>
 */
HGIS.Strategy.Fixed = HGIS.Class(HGIS.Strategy, {
    
    /**
     * APIProperty: preload
     * {Boolean} Load data before layer made visible. Enabling this may result
     *   in considerable overhead if your application loads many data layers
     *   that are not visible by default. Default is false.
     */
    preload: false,

    /**
     * Constructor: HGIS.Strategy.Fixed
     * Create a new Fixed strategy.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */

    /**
     * Method: activate
     * Activate the strategy: load data or add listener to load when visible
     *
     * Returns:
     * {Boolean} True if the strategy was successfully activated or false if
     *      the strategy was already active.
     */
    activate: function() {
        var activated = HGIS.Strategy.prototype.activate.apply(this, arguments);
        if(activated) {
            this.layer.events.on({
                "refresh": this.load,
                scope: this
            });
            if(this.layer.visibility == true || this.preload) {
                this.load();
            } else {
                this.layer.events.on({
                    "visibilitychanged": this.load,
                    scope: this
                });
            }
        }
        return activated;
    },
    
    /**
     * Method: deactivate
     * Deactivate the strategy.  Undo what is done in <activate>.
     * 
     * Returns:
     * {Boolean} The strategy was successfully deactivated.
     */
    deactivate: function() {
        var deactivated = HGIS.Strategy.prototype.deactivate.call(this);
        if(deactivated) {
            this.layer.events.un({
                "refresh": this.load,
                "visibilitychanged": this.load,
                scope: this
            });
        }
        return deactivated;
    },

    /**
     * Method: load
     * Tells protocol to load data and unhooks the visibilitychanged event
     *
     * Parameters:
     * options - {Object} options to pass to protocol read.
     */
    load: function(options) {
        var layer = this.layer;
        layer.events.triggerEvent("loadstart", {filter: layer.filter});
        layer.protocol.read(HGIS.Util.applyDefaults({
            callback: this.merge,
            filter: layer.filter,
            scope: this
        }, options));
        layer.events.un({
            "visibilitychanged": this.load,
            scope: this
        });
    },

    /**
     * Method: merge
     * Add all features to the layer.
     *     If the layer projection differs from the map projection, features
     *     will be transformed from the layer projection to the map projection.
     *
     * Parameters:
     * resp - {<HGIS.Protocol.Response>} The response object passed
     *      by the protocol.
     */
    merge: function(resp) {
        var layer = this.layer;
        layer.destroyFeatures();
        var features = resp.features;
        if (features && features.length > 0) {
            var remote = layer.projection;
            var local = layer.map.getProjectionObject();
            if(!local.equals(remote)) {
                var geom;
                for(var i=0, len=features.length; i<len; ++i) {
                    geom = features[i].geometry;
                    if(geom) {
                        geom.transform(remote, local);
                    }
                }
            }
            layer.addFeatures(features);
        }
        layer.events.triggerEvent("loadend", {response: resp});
    },

    CLASS_NAME: "HGIS.Strategy.Fixed"
});
/* ======================================================================
    HGIS/Control/Zoom.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Events/buttonclick.js
 */

/**
 * Class: HGIS.Control.Zoom
 * The Zoom control is a pair of +/- links for zooming in and out.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.Zoom = HGIS.Class(HGIS.Control, {
    
    /**
     * APIProperty: zoomInText
     * {String}
     * Text for zoom-in link.  Default is "+".
     */
    zoomInText: "+",

    /**
     * APIProperty: zoomInId
     * {String}
     * Instead of having the control create a zoom in link, you can provide 
     *     the identifier for an anchor element already added to the document.
     *     By default, an element with id "olZoomInLink" will be searched for
     *     and used if it exists.
     */
    zoomInId: "olZoomInLink",

    /**
     * APIProperty: zoomOutText
     * {String}
     * Text for zoom-out link.  Default is "\u2212".
     */
    zoomOutText: "\u2212",

    /**
     * APIProperty: zoomOutId
     * {String}
     * Instead of having the control create a zoom out link, you can provide 
     *     the identifier for an anchor element already added to the document.
     *     By default, an element with id "olZoomOutLink" will be searched for
     *     and used if it exists.
     */
    zoomOutId: "olZoomOutLink",

    /**
     * Method: draw
     *
     * Returns:
     * {DOMElement} A reference to the DOMElement containing the zoom links.
     */
    draw: function() {
        var div = HGIS.Control.prototype.draw.apply(this),
            links = this.getOrCreateLinks(div),
            zoomIn = links.zoomIn,
            zoomOut = links.zoomOut,
            eventsInstance = this.map.events;
        
        if (zoomOut.parentNode !== div) {
            eventsInstance = this.events;
            eventsInstance.attachToElement(zoomOut.parentNode);
        }
        eventsInstance.register("buttonclick", this, this.onZoomClick);
        
        this.zoomInLink = zoomIn;
        this.zoomOutLink = zoomOut;
        return div;
    },
    
    /**
     * Method: getOrCreateLinks
     * 
     * Parameters:
     * el - {DOMElement}
     *
     * Return: 
     * {Object} Object with zoomIn and zoomOut properties referencing links.
     */
    getOrCreateLinks: function(el) {
        var zoomIn = document.getElementById(this.zoomInId),
            zoomOut = document.getElementById(this.zoomOutId);
        if (!zoomIn) {
            zoomIn = document.createElement("a");
            zoomIn.href = "#zoomIn";
            zoomIn.appendChild(document.createTextNode(this.zoomInText));
            zoomIn.className = "olControlZoomIn";
            el.appendChild(zoomIn);
        }
        HGIS.Element.addClass(zoomIn, "olButton");
        if (!zoomOut) {
            zoomOut = document.createElement("a");
            zoomOut.href = "#zoomOut";
            zoomOut.appendChild(document.createTextNode(this.zoomOutText));
            zoomOut.className = "olControlZoomOut";
            el.appendChild(zoomOut);
        }
        HGIS.Element.addClass(zoomOut, "olButton");
        return {
            zoomIn: zoomIn, zoomOut: zoomOut
        };
    },
    
    /**
     * Method: onZoomClick
     * Called when zoomin/out link is clicked.
     */
    onZoomClick: function(evt) {
        var button = evt.buttonElement;
        if (button === this.zoomInLink) {
            this.map.zoomIn();
        } else if (button === this.zoomOutLink) {
            this.map.zoomOut();
        }
    },

    /** 
     * Method: destroy
     * Clean up.
     */
    destroy: function() {
        if (this.map) {
            this.map.events.unregister("buttonclick", this, this.onZoomClick);
        }
        delete this.zoomInLink;
        delete this.zoomOutLink;
        HGIS.Control.prototype.destroy.apply(this);
    },

    CLASS_NAME: "HGIS.Control.Zoom"
});
/* ======================================================================
    HGIS/Layer/PointTrack.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer/Vector.js
 */

/**
 * Class: HGIS.Layer.PointTrack
 * Vector layer to display ordered point features as a line, creating one
 * LineString feature for each pair of two points.
 *
 * Inherits from:
 *  - <HGIS.Layer.Vector> 
 */
HGIS.Layer.PointTrack = HGIS.Class(HGIS.Layer.Vector, {
  
    /**
     * APIProperty: dataFrom
     *     {<HGIS.Layer.PointTrack.TARGET_NODE>} or
     *     {<HGIS.Layer.PointTrack.SOURCE_NODE>} optional. If the lines
     *     should get the data/attributes from one of the two points it is
     *     composed of, which one should it be?
     */
    dataFrom: null,
    
    /**
     * APIProperty: styleFrom
     *     {<HGIS.Layer.PointTrack.TARGET_NODE>} or
     *     {<HGIS.Layer.PointTrack.SOURCE_NODE>} optional. If the lines
     *     should get the style from one of the two points it is composed of,
     *     which one should it be?
     */
    styleFrom: null,
    
    /**
     * Constructor: HGIS.PointTrack
     * Constructor for a new HGIS.PointTrack instance.
     *
     * Parameters:
     * name     - {String} name of the layer
     * options  - {Object} Optional object with properties to tag onto the
     *            instance.
     */    
        
    /**
     * APIMethod: addNodes
     * Adds point features that will be used to create lines from, using point
     * pairs. The first point of a pair will be the source node, the second
     * will be the target node.
     * 
     * Parameters:
     * pointFeatures - {Array(<HGIS.Feature>)}
     * options - {Object}
     * 
     * Supported options:
     * silent - {Boolean} true to suppress (before)feature(s)added events
     */
    addNodes: function(pointFeatures, options) {
        if (pointFeatures.length < 2) {
            throw new Error("At least two point features have to be added to " +
                            "create a line from");
        }
        
        var lines = new Array(pointFeatures.length-1);
        
        var pointFeature, startPoint, endPoint;
        for(var i=0, len=pointFeatures.length; i<len; i++) {
            pointFeature = pointFeatures[i];
            endPoint = pointFeature.geometry;
            
            if (!endPoint) {
              var lonlat = pointFeature.lonlat;
              endPoint = new HGIS.Geometry.Point(lonlat.lon, lonlat.lat);
            } else if(endPoint.CLASS_NAME != "HGIS.Geometry.Point") {
                throw new TypeError("Only features with point geometries are supported.");
            }
            
            if(i > 0) {
                var attributes = (this.dataFrom != null) ?
                        (pointFeatures[i+this.dataFrom].data ||
                                pointFeatures[i+this.dataFrom].attributes) :
                        null;
                var style = (this.styleFrom != null) ?
                        (pointFeatures[i+this.styleFrom].style) :
                        null;
                var line = new HGIS.Geometry.LineString([startPoint,
                        endPoint]);
                        
                lines[i-1] = new HGIS.Feature.Vector(line, attributes,
                    style);
            }
            
            startPoint = endPoint;
        }

        this.addFeatures(lines, options);
    },
    
    CLASS_NAME: "HGIS.Layer.PointTrack"
});

/**
 * Constant: HGIS.Layer.PointTrack.SOURCE_NODE
 * {Number} value for <HGIS.Layer.PointTrack.dataFrom> and
 * <HGIS.Layer.PointTrack.styleFrom>
 */
HGIS.Layer.PointTrack.SOURCE_NODE = -1;

/**
 * Constant: HGIS.Layer.PointTrack.TARGET_NODE
 * {Number} value for <HGIS.Layer.PointTrack.dataFrom> and
 * <HGIS.Layer.PointTrack.styleFrom>
 */
HGIS.Layer.PointTrack.TARGET_NODE = 0;

/**
 * Constant: HGIS.Layer.PointTrack.dataFrom
 * {Object} with the following keys - *deprecated*
 * - SOURCE_NODE: take data/attributes from the source node of the line
 * - TARGET_NODE: take data/attributes from the target node of the line
 */
HGIS.Layer.PointTrack.dataFrom = {'SOURCE_NODE': -1, 'TARGET_NODE': 0};
/* ======================================================================
    HGIS/Protocol/WFS.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Protocol.js
 */

/**
 * Class: HGIS.Protocol.WFS
 * Used to create a versioned WFS protocol.  Default version is 1.0.0.
 *
 * Returns:
 * {<HGIS.Protocol>} A WFS protocol of the given version.
 *
 * Example:
 * (code)
 *     var protocol = new HGIS.Protocol.WFS({
 *         version: "1.1.0",
 *         url:  "http://demo.opengeo.org/geoserver/wfs",
 *         featureType: "tasmania_roads",
 *         featureNS: "http://www.openplans.org/topp",
 *         geometryName: "the_geom"
 *     });
 * (end)
 *
 * See the protocols for specific WFS versions for more detail.
 */
HGIS.Protocol.WFS = function(options) {
    options = HGIS.Util.applyDefaults(
        options, HGIS.Protocol.WFS.DEFAULTS
    );
    var cls = HGIS.Protocol.WFS["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported WFS version: " + options.version;
    }
    return new cls(options);
};

/**
 * Function: fromWMSLayer
 * Convenience function to create a WFS protocol from a WMS layer.  This makes
 *     the assumption that a WFS requests can be issued at the same URL as
 *     WMS requests and that a WFS featureType exists with the same name as the
 *     WMS layer.
 *     
 * This function is designed to auto-configure <url>, <featureType>,
 *     <featurePrefix> and <srsName> for WFS <version> 1.1.0. Note that
 *     srsName matching with the WMS layer will not work with WFS 1.0.0.
 * 
 * Parameters:
 * layer - {<HGIS.Layer.WMS>} WMS layer that has a matching WFS
 *     FeatureType at the same server url with the same typename.
 * options - {Object} Default properties to be set on the protocol.
 *
 * Returns:
 * {<HGIS.Protocol.WFS>}
 */
HGIS.Protocol.WFS.fromWMSLayer = function(layer, options) {
    var typeName, featurePrefix;
    var param = layer.params["LAYERS"];
    var parts = (HGIS.Util.isArray(param) ? param[0] : param).split(":");
    if(parts.length > 1) {
        featurePrefix = parts[0];
    }
    typeName = parts.pop();
    var protocolOptions = {
        url: layer.url,
        featureType: typeName,
        featurePrefix: featurePrefix,
        srsName: layer.projection && layer.projection.getCode() ||
                 layer.map && layer.map.getProjectionObject().getCode(),
        version: "1.1.0"
    };
    return new HGIS.Protocol.WFS(HGIS.Util.applyDefaults(
        options, protocolOptions
    ));
};

/**
 * Constant: HGIS.Protocol.WFS.DEFAULTS
 */
HGIS.Protocol.WFS.DEFAULTS = {
    "version": "1.0.0"
};
/* ======================================================================
    HGIS/Layer/Markers.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer.js
 */

/**
 * Class: HGIS.Layer.Markers
 * 
 * Inherits from:
 *  - <HGIS.Layer> 
 */
HGIS.Layer.Markers = HGIS.Class(HGIS.Layer, {
    
    /** 
     * APIProperty: isBaseLayer 
     * {Boolean} Markers layer is never a base layer.  
     */
    isBaseLayer: false,
    
    /** 
     * APIProperty: markers 
     * {Array(<HGIS.Marker>)} internal marker list 
     */
    markers: null,


    /** 
     * Property: drawn 
     * {Boolean} internal state of drawing. This is a workaround for the fact
     * that the map does not call moveTo with a zoomChanged when the map is
     * first starting up. This lets us catch the case where we have *never*
     * drawn the layer, and draw it even if the zoom hasn't changed.
     */
    drawn: false,
    
    /**
     * Constructor: HGIS.Layer.Markers 
     * Create a Markers layer.
     *
     * Parameters:
     * name - {String} 
     * options - {Object} Hashtable of extra options to tag onto the layer
     */
    initialize: function(name, options) {
        HGIS.Layer.prototype.initialize.apply(this, arguments);
        this.markers = [];
    },
    
    /**
     * APIMethod: destroy 
     */
    destroy: function() {
        this.clearMarkers();
        this.markers = null;
        HGIS.Layer.prototype.destroy.apply(this, arguments);
    },

    /**
     * APIMethod: setOpacity
     * Sets the opacity for all the markers.
     * 
     * Parameters:
     * opacity - {Float}
     */
    setOpacity: function(opacity) {
        if (opacity != this.opacity) {
            this.opacity = opacity;
            for (var i=0, len=this.markers.length; i<len; i++) {
                this.markers[i].setOpacity(this.opacity);
            }
        }
    },

    /** 
     * Method: moveTo
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>} 
     * zoomChanged - {Boolean} 
     * dragging - {Boolean} 
     */
    moveTo:function(bounds, zoomChanged, dragging) {
        HGIS.Layer.prototype.moveTo.apply(this, arguments);

        if (zoomChanged || !this.drawn) {
            for(var i=0, len=this.markers.length; i<len; i++) {
                this.drawMarker(this.markers[i]);
            }
            this.drawn = true;
        }
    },

    /**
     * APIMethod: addMarker
     *
     * Parameters:
     * marker - {<HGIS.Marker>} 
     */
    addMarker: function(marker) {
        this.markers.push(marker);

        if (this.opacity < 1) {
            marker.setOpacity(this.opacity);
        }

        if (this.map && this.map.getExtent()) {
            marker.map = this.map;
            this.drawMarker(marker);
        }
    },

    /**
     * APIMethod: removeMarker
     *
     * Parameters:
     * marker - {<HGIS.Marker>} 
     */
    removeMarker: function(marker) {
        if (this.markers && this.markers.length) {
            HGIS.Util.removeItem(this.markers, marker);
            marker.erase();
        }
    },

    /**
     * Method: clearMarkers
     * This method removes all markers from a layer. The markers are not
     * destroyed by this function, but are removed from the list of markers.
     */
    clearMarkers: function() {
        if (this.markers != null) {
            while(this.markers.length > 0) {
                this.removeMarker(this.markers[0]);
            }
        }
    },

    /** 
     * Method: drawMarker
     * Calculate the pixel location for the marker, create it, and 
     *    add it to the layer's div
     *
     * Parameters:
     * marker - {<HGIS.Marker>} 
     */
    drawMarker: function(marker) {
        var px = this.map.getLayerPxFromLonLat(marker.lonlat);
        if (px == null) {
            marker.display(false);
        } else {
            if (!marker.isDrawn()) {
                var markerImg = marker.draw(px);
                this.div.appendChild(markerImg);
            } else if(marker.icon) {
                marker.icon.moveTo(px);
            }
        }
    },
    
    /** 
     * APIMethod: getDataExtent
     * Calculates the max extent which includes all of the markers.
     * 
     * Returns:
     * {<HGIS.Bounds>}
     */
    getDataExtent: function () {
        var maxExtent = null;
        
        if ( this.markers && (this.markers.length > 0)) {
            var maxExtent = new HGIS.Bounds();
            for(var i=0, len=this.markers.length; i<len; i++) {
                var marker = this.markers[i];
                maxExtent.extend(marker.lonlat);
            }
        }

        return maxExtent;
    },

    CLASS_NAME: "HGIS.Layer.Markers"
});
/* ======================================================================
    HGIS/Control/Pan.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control/Button.js
 */

/**
 * Class: HGIS.Control.Pan
 * The Pan control is a single button to pan the map in one direction. For
 * a more complete control see <HGIS.Control.PanPanel>.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.Pan = HGIS.Class(HGIS.Control.Button, {

    /** 
     * APIProperty: slideFactor
     * {Integer} Number of pixels by which we'll pan the map in any direction 
     *     on clicking the arrow buttons, defaults to 50.  If you want to pan
     *     by some ratio of the map dimensions, use <slideRatio> instead.
     */
    slideFactor: 50,

    /** 
     * APIProperty: slideRatio
     * {Number} The fraction of map width/height by which we'll pan the map            
     *     on clicking the arrow buttons.  Default is null.  If set, will
     *     override <slideFactor>. E.g. if slideRatio is .5, then Pan Up will
     *     pan up half the map height. 
     */
    slideRatio: null,

    /** 
     * Property: direction
     * {String} in {'North', 'South', 'East', 'West'}
     */
    direction: null,

    /**
     * Constructor: HGIS.Control.Pan 
     * Control which handles the panning (in any of the cardinal directions)
     *     of the map by a set px distance. 
     *
     * Parameters:
     * direction - {String} The direction this button should pan.
     * options - {Object} An optional object whose properties will be used
     *     to extend the control.
     */
    initialize: function(direction, options) {
    
        this.direction = direction;
        this.CLASS_NAME += this.direction;
        
        HGIS.Control.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Method: trigger
     */
    trigger: function(){
        if (this.map) {
            var getSlideFactor = HGIS.Function.bind(function (dim) {
                return this.slideRatio ?
                    this.map.getSize()[dim] * this.slideRatio :
                    this.slideFactor;
            }, this);
    
            switch (this.direction) {
                case HGIS.Control.Pan.NORTH: 
                    this.map.pan(0, -getSlideFactor("h"));
                    break;
                case HGIS.Control.Pan.SOUTH: 
                    this.map.pan(0, getSlideFactor("h"));
                    break;
                case HGIS.Control.Pan.WEST: 
                    this.map.pan(-getSlideFactor("w"), 0);
                    break;
                case HGIS.Control.Pan.EAST: 
                    this.map.pan(getSlideFactor("w"), 0);
                    break;
            }   
        }
    },

    CLASS_NAME: "HGIS.Control.Pan"
});

HGIS.Control.Pan.NORTH = "North";
HGIS.Control.Pan.SOUTH = "South";
HGIS.Control.Pan.EAST = "East";
HGIS.Control.Pan.WEST = "West";
/* ======================================================================
    HGIS/Format/CSWGetDomain.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format.js
 */

/**
 * Class: HGIS.Format.CSWGetDomain
 * Default version is 2.0.2.
 *
 * Returns:
 * {<HGIS.Format>} A CSWGetDomain format of the given version.
 */
HGIS.Format.CSWGetDomain = function(options) {
    options = HGIS.Util.applyDefaults(
        options, HGIS.Format.CSWGetDomain.DEFAULTS
    );
    var cls = HGIS.Format.CSWGetDomain["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported CSWGetDomain version: " + options.version;
    }
    return new cls(options);
};

/**
 * Constant: DEFAULTS
 * {Object} Default properties for the CSWGetDomain format.
 */
HGIS.Format.CSWGetDomain.DEFAULTS = {
    "version": "2.0.2"
};
/* ======================================================================
    HGIS/Format/CSWGetDomain/v2_0_2.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/CSWGetDomain.js
 */

/**
 * Class: HGIS.Format.CSWGetDomain.v2_0_2
 *     A format for creating CSWGetDomain v2.0.2 transactions. 
 *     Create a new instance with the
 *     <HGIS.Format.CSWGetDomain.v2_0_2> constructor.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.CSWGetDomain.v2_0_2 = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        csw: "http://www.opengis.net/cat/csw/2.0.2"
    },

    /**
     * Property: defaultPrefix
     * {String} The default prefix (used by Format.XML).
     */
    defaultPrefix: "csw",
    
    /**
     * Property: version
     * {String} CSW version number.
     */
    version: "2.0.2",
    
    /**
     * Property: schemaLocation
     * {String} http://www.opengis.net/cat/csw/2.0.2
     *   http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd
     */
    schemaLocation: "http://www.opengis.net/cat/csw/2.0.2 http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd",

    /**
     * APIProperty: PropertyName
     * {String} Value of the csw:PropertyName element, used when
     *     writing a GetDomain document.
     */
    PropertyName: null,

    /**
     * APIProperty: ParameterName
     * {String} Value of the csw:ParameterName element, used when
     *     writing a GetDomain document.
     */
    ParameterName: null,
    
    /**
     * Constructor: HGIS.Format.CSWGetDomain.v2_0_2
     * A class for parsing and generating CSWGetDomain v2.0.2 transactions.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties:
     * - PropertyName
     * - ParameterName
     */

    /**
     * APIMethod: read
     * Parse the response from a GetDomain request.
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var obj = {};
        this.readNode(data, obj);
        return obj;
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "csw": {
            "GetDomainResponse": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "DomainValues": function(node, obj) {
                if (!(HGIS.Util.isArray(obj.DomainValues))) {
                    obj.DomainValues = [];
                }
                var attrs = node.attributes;
                var domainValue = {};
                for(var i=0, len=attrs.length; i<len; ++i) {
                    domainValue[attrs[i].name] = attrs[i].nodeValue;
                }
                this.readChildNodes(node, domainValue);
                obj.DomainValues.push(domainValue);
            },
            "PropertyName": function(node, obj) {
                obj.PropertyName = this.getChildValue(node);
            },
            "ParameterName": function(node, obj) {
                obj.ParameterName = this.getChildValue(node);
            },
            "ListOfValues": function(node, obj) {
                if (!(HGIS.Util.isArray(obj.ListOfValues))) {
                    obj.ListOfValues = [];
                }
                this.readChildNodes(node, obj.ListOfValues);
            },
            "Value": function(node, obj) {
                var attrs = node.attributes;
                var value = {};
                for(var i=0, len=attrs.length; i<len; ++i) {
                    value[attrs[i].name] = attrs[i].nodeValue;
                }
                value.value = this.getChildValue(node);
                obj.push({Value: value});
            },
            "ConceptualScheme": function(node, obj) {
                obj.ConceptualScheme = {};
                this.readChildNodes(node, obj.ConceptualScheme);
            },
            "Name": function(node, obj) {
                obj.Name = this.getChildValue(node);
            },
            "Document": function(node, obj) {
                obj.Document = this.getChildValue(node);
            },
            "Authority": function(node, obj) {
                obj.Authority = this.getChildValue(node);
            },
            "RangeOfValues": function(node, obj) {
                obj.RangeOfValues = {};
                this.readChildNodes(node, obj.RangeOfValues);
            },
            "MinValue": function(node, obj) {
                var attrs = node.attributes;
                var value = {};
                for(var i=0, len=attrs.length; i<len; ++i) {
                    value[attrs[i].name] = attrs[i].nodeValue;
                }
                value.value = this.getChildValue(node);
                obj.MinValue = value;
            },
            "MaxValue": function(node, obj) {
                var attrs = node.attributes;
                var value = {};
                for(var i=0, len=attrs.length; i<len; ++i) {
                    value[attrs[i].name] = attrs[i].nodeValue;
                }
                value.value = this.getChildValue(node);
                obj.MaxValue = value;
            }
        }
    },
    
    /**
     * APIMethod: write
     * Given an configuration js object, write a CSWGetDomain request. 
     *
     * Parameters:
     * options - {Object} A object mapping the request.
     *
     * Returns:
     * {String} A serialized CSWGetDomain request.
     */
    write: function(options) {
        var node = this.writeNode("csw:GetDomain", options);
        return HGIS.Format.XML.prototype.write.apply(this, [node]);
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "csw": {
            "GetDomain": function(options) {
                var node = this.createElementNSPlus("csw:GetDomain", {
                    attributes: {
                        service: "CSW",
                        version: this.version
                    }
                });
                if (options.PropertyName || this.PropertyName) {
                    this.writeNode(
                        "csw:PropertyName",
                        options.PropertyName || this.PropertyName,
                        node
                    );
                } else if (options.ParameterName || this.ParameterName) {
                    this.writeNode(
                        "csw:ParameterName",
                        options.ParameterName || this.ParameterName,
                        node
                    );
                }
                this.readChildNodes(node, options);
                return node;
            },
            "PropertyName": function(value) {
                var node = this.createElementNSPlus("csw:PropertyName", {
                    value: value
                });
                return node;
            },
            "ParameterName": function(value) {
                var node = this.createElementNSPlus("csw:ParameterName", {
                    value: value
                });
                return node;
            }
        }
    },
   
    CLASS_NAME: "HGIS.Format.CSWGetDomain.v2_0_2" 
});
/* ======================================================================
    HGIS/Format/ArcXML/Features.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/ArcXML.js
 */

/**
 * Class: HGIS.Format.ArcXML.Features
 * Read/Write ArcXML features. Create a new instance with the 
 *     <HGIS.Format.ArcXML.Features> constructor.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.ArcXML.Features = HGIS.Class(HGIS.Format.XML, {

    /**
     * Constructor: HGIS.Format.ArcXML.Features
     * Create a new parser/writer for ArcXML Features.  Create an instance of this class
     * to get a set of features from an ArcXML response.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    
    /**
     * APIMethod: read
     * Read data from a string of ArcXML, and return a set of HGIS features. 
     * 
     * Parameters:
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array(<HGIS.Feature.Vector>)} A collection of features.
     */
    read: function(data) {
        var axl = new HGIS.Format.ArcXML();
        var parsed = axl.read(data);
        
        return parsed.features.feature;
    }
});
/* ======================================================================
    HGIS/Control/Snapping.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Layer/Vector.js
 */

/**
 * Class: HGIS.Control.Snapping
 * Acts as a snapping agent while editing vector features.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.Snapping = HGIS.Class(HGIS.Control, {

    /** 
     * APIProperty: events
     * {<HGIS.Events>} Events instance for listeners and triggering
     *     control specific events.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types (in addition to those from <HGIS.Control.events>):
     * beforesnap - Triggered before a snap occurs.  Listeners receive an
     *     event object with *point*, *x*, *y*, *distance*, *layer*, and
     *     *snapType* properties.  The point property will be original point
     *     geometry considered for snapping. The x and y properties represent
     *     coordinates the point will receive. The distance is the distance
     *     of the snap.  The layer is the target layer.  The snapType property
     *     will be one of "node", "vertex", or "edge". Return false to stop
     *     snapping from occurring.
     * snap - Triggered when a snap occurs.  Listeners receive an event with
     *     *point*, *snapType*, *layer*, and *distance* properties.  The point
     *     will be the location snapped to.  The snapType will be one of "node",
     *     "vertex", or "edge".  The layer will be the target layer.  The
     *     distance will be the distance of the snap in map units.
     * unsnap - Triggered when a vertex is unsnapped.  Listeners receive an
     *     event with a *point* property.
     */
    
    /**
     * CONSTANT: DEFAULTS
     * Default target properties.
     */
    DEFAULTS: {
        tolerance: 10,
        node: true,
        edge: true,
        vertex: true
    },
    
    /**
     * Property: greedy
     * {Boolean} Snap to closest feature in first layer with an eligible
     *     feature.  Default is true.
     */
    greedy: true,
    
    /**
     * Property: precedence
     * {Array} List representing precedence of different snapping types.
     *     Default is "node", "vertex", "edge".
     */
    precedence: ["node", "vertex", "edge"],
    
    /**
     * Property: resolution
     * {Float} The map resolution for the previously considered snap.
     */
    resolution: null,
    
    /**
     * Property: geoToleranceCache
     * {Object} A cache of geo-tolerances.  Tolerance values (in map units) are
     *     calculated when the map resolution changes.
     */
    geoToleranceCache: null,
    
    /**
     * Property: layer
     * {<HGIS.Layer.Vector>} The current editable layer.  Set at
     *     construction or after construction with <setLayer>.
     */
    layer: null,
    
    /**
     * Property: feature
     * {<HGIS.Feature.Vector>} The current editable feature.
     */
    feature: null,
    
    /**
     * Property: point
     * {<HGIS.Geometry.Point>} The currently snapped vertex.
     */
    point: null,

    /**
     * Constructor: HGIS.Control.Snapping
     * Creates a new snapping control. A control is constructed with an editable
     *     layer and a set of configuration objects for target layers. While the
     *     control is active, dragging vertices while drawing new features or
     *     modifying existing features on the editable layer will engage
     *     snapping to features on the target layers. Whether a vertex snaps to
     *     a feature on a target layer depends on the target layer configuration.
     *
     * Parameters:
     * options - {Object} An object containing all configuration properties for
     *     the control.
     *
     * Valid options:
     * layer - {<HGIS.Layer.Vector>} The editable layer.  Features from this
     *     layer that are digitized or modified may have vertices snapped to
     *     features from any of the target layers.
     * targets - {Array(Object | HGIS.Layer.Vector)} A list of objects for
     *     configuring target layers.  See valid properties of the target
     *     objects below.  If the items in the targets list are vector layers
     *     (instead of configuration objects), the defaults from the <defaults>
     *     property will apply.  The editable layer itself may be a target
     *     layer, allowing newly created or edited features to be snapped to
     *     existing features from the same layer.  If no targets are provided
     *     the layer given in the constructor (as <layer>) will become the
     *     initial target.
     * defaults - {Object} An object with default properties to be applied
     *     to all target objects.
     * greedy - {Boolean} Snap to closest feature in first target layer that
     *     applies.  Default is true.  If false, all features in all target
     *     layers will be checked and the closest feature in all target layers
     *     will be chosen.  The greedy property determines if the order of the
     *     target layers is significant.  By default, the order of the target
     *     layers is significant where layers earlier in the target layer list
     *     have precedence over layers later in the list.  Within a single
     *     layer, the closest feature is always chosen for snapping.  This
     *     property only determines whether the search for a closer feature
     *     continues after an eligible feature is found in a target layer.
     *
     * Valid target properties:
     * layer - {<HGIS.Layer.Vector>} A target layer.  Features from this
     *     layer will be eligible to act as snapping target for the editable
     *     layer.
     * tolerance - {Float} The distance (in pixels) at which snapping may occur.
     *     Default is 10.
     * node - {Boolean} Snap to nodes (first or last point in a geometry) in
     *     target layer.  Default is true.
     * nodeTolerance - {Float} Optional distance at which snapping may occur
     *     for nodes specifically.  If none is provided, <tolerance> will be
     *     used.
     * vertex - {Boolean} Snap to vertices in target layer.  Default is true.
     * vertexTolerance - {Float} Optional distance at which snapping may occur
     *     for vertices specifically.  If none is provided, <tolerance> will be
     *     used.
     * edge - {Boolean} Snap to edges in target layer.  Default is true.
     * edgeTolerance - {Float} Optional distance at which snapping may occur
     *     for edges specifically.  If none is provided, <tolerance> will be
     *     used.
     * filter - {<HGIS.Filter>} Optional filter to evaluate to determine if
     *     feature is eligible for snapping.  If filter evaluates to true for a
     *     target feature a vertex may be snapped to the feature. 
     * minResolution - {Number} If a minResolution is provided, snapping to this
     *     target will only be considered if the map resolution is greater than
     *     or equal to this value (the minResolution is inclusive).  Default is
     *     no minimum resolution limit.
     * maxResolution - {Number} If a maxResolution is provided, snapping to this
     *     target will only be considered if the map resolution is strictly
     *     less than this value (the maxResolution is exclusive).  Default is
     *     no maximum resolution limit.
     */
    initialize: function(options) {
        HGIS.Control.prototype.initialize.apply(this, [options]);
        this.options = options || {}; // TODO: this could be done by the super
        
        // set the editable layer if provided
        if(this.options.layer) {
            this.setLayer(this.options.layer);
        }
        // configure target layers
        var defaults = HGIS.Util.extend({}, this.options.defaults);
        this.defaults = HGIS.Util.applyDefaults(defaults, this.DEFAULTS);
        this.setTargets(this.options.targets);
        if(this.targets.length === 0 && this.layer) {
            this.addTargetLayer(this.layer);
        }

        this.geoToleranceCache = {};
    },
    
    /**
     * APIMethod: setLayer
     * Set the editable layer.  Call the setLayer method if the editable layer
     *     changes and the same control should be used on a new editable layer.
     *     If the control is already active, it will be active after the new
     *     layer is set.
     *
     * Parameters:
     * layer - {<HGIS.Layer.Vector>}  The new editable layer.
     */
    setLayer: function(layer) {
        if(this.active) {
            this.deactivate();
            this.layer = layer;
            this.activate();
        } else {
            this.layer = layer;
        }
    },
    
    /**
     * Method: setTargets
     * Set the targets for the snapping agent.
     *
     * Parameters:
     * targets - {Array} An array of target configs or target layers.
     */
    setTargets: function(targets) {
        this.targets = [];
        if(targets && targets.length) {
            var target;
            for(var i=0, len=targets.length; i<len; ++i) {
                target = targets[i];
                if(target instanceof HGIS.Layer.Vector) {
                    this.addTargetLayer(target);
                } else {
                    this.addTarget(target);
                }
            }
        }
    },
    
    /**
     * Method: addTargetLayer
     * Add a target layer with the default target config.
     *
     * Parameters:
     * layer - {<HGIS.Layer.Vector>} A target layer.
     */
    addTargetLayer: function(layer) {
        this.addTarget({layer: layer});
    },
    
    /**
     * Method: addTarget
     * Add a configured target layer.
     *
     * Parameters:
     * target - {Object} A target config.
     */
    addTarget: function(target) {
        target = HGIS.Util.applyDefaults(target, this.defaults);
        target.nodeTolerance = target.nodeTolerance || target.tolerance;
        target.vertexTolerance = target.vertexTolerance || target.tolerance;
        target.edgeTolerance = target.edgeTolerance || target.tolerance;
        this.targets.push(target);
    },
    
    /**
     * Method: removeTargetLayer
     * Remove a target layer.
     *
     * Parameters:
     * layer - {<HGIS.Layer.Vector>} The target layer to remove.
     */
    removeTargetLayer: function(layer) {
        var target;
        for(var i=this.targets.length-1; i>=0; --i) {
            target = this.targets[i];
            if(target.layer === layer) {
                this.removeTarget(target);
            }
        }
    },
    
    /**
     * Method: removeTarget
     * Remove a target.
     *
     * Parameters:
     * target - {Object} A target config.
     *
     * Returns:
     * {Array} The targets array.
     */
    removeTarget: function(target) {
        return HGIS.Util.removeItem(this.targets, target);
    },
    
    /**
     * APIMethod: activate
     * Activate the control.  Activating the control registers listeners for
     *     editing related events so that during feature creation and
     *     modification, moving vertices will trigger snapping.
     */
    activate: function() {
        var activated = HGIS.Control.prototype.activate.call(this);
        if(activated) {
            if(this.layer && this.layer.events) {
                this.layer.events.on({
                    sketchstarted: this.onSketchModified,
                    sketchmodified: this.onSketchModified,
                    vertexmodified: this.onVertexModified,
                    scope: this
                });
            }
        }
        return activated;
    },
    
    /**
     * APIMethod: deactivate
     * Deactivate the control.  Deactivating the control unregisters listeners
     *     so feature editing may proceed without engaging the snapping agent.
     */
    deactivate: function() {
        var deactivated = HGIS.Control.prototype.deactivate.call(this);
        if(deactivated) {
            if(this.layer && this.layer.events) {
                this.layer.events.un({
                    sketchstarted: this.onSketchModified,
                    sketchmodified: this.onSketchModified,
                    vertexmodified: this.onVertexModified,
                    scope: this
                });
            }
        }
        this.feature = null;
        this.point = null;
        return deactivated;
    },
    
    /**
     * Method: onSketchModified
     * Registered as a listener for the sketchmodified event on the editable
     *     layer.
     *
     * Parameters:
     * event - {Object} The sketch modified event.
     */
    onSketchModified: function(event) {
        this.feature = event.feature;
        this.considerSnapping(event.vertex, event.vertex);
    },
    
    /**
     * Method: onVertexModified
     * Registered as a listener for the vertexmodified event on the editable
     *     layer.
     *
     * Parameters:
     * event - {Object} The vertex modified event.
     */
    onVertexModified: function(event) {
        this.feature = event.feature;
        var loc = this.layer.map.getLonLatFromViewPortPx(event.pixel);
        this.considerSnapping(
            event.vertex, new HGIS.Geometry.Point(loc.lon, loc.lat)
        );
    },

    /**
     * Method: considerSnapping
     *
     * Parameters:
     * point - {<HGIS.Geometry.Point>} The vertex to be snapped (or
     *     unsnapped).
     * loc - {<HGIS.Geometry.Point>} The location of the mouse in map
     *     coords.
     */
    considerSnapping: function(point, loc) {
        var best = {
            rank: Number.POSITIVE_INFINITY,
            dist: Number.POSITIVE_INFINITY,
            x: null, y: null
        };
        var snapped = false;
        var result, target;
        for(var i=0, len=this.targets.length; i<len; ++i) {
            target = this.targets[i];
            result = this.testTarget(target, loc);
            if(result) {
                if(this.greedy) {
                    best = result;
                    best.target = target; 
                    snapped = true;
                    break;
                } else {
                    if((result.rank < best.rank) ||
                       (result.rank === best.rank && result.dist < best.dist)) {
                        best = result;
                        best.target = target;
                        snapped = true;
                    }
                }
            }
        }
        if(snapped) {
            var proceed = this.events.triggerEvent("beforesnap", {
                point: point, x: best.x, y: best.y, distance: best.dist,
                layer: best.target.layer, snapType: this.precedence[best.rank]
            });
            if(proceed !== false) {
                point.x = best.x;
                point.y = best.y;
                this.point = point;
                this.events.triggerEvent("snap", {
                    point: point,
                    snapType: this.precedence[best.rank],
                    layer: best.target.layer,
                    distance: best.dist
                });
            } else {
                snapped = false;
            }
        }
        if(this.point && !snapped) {
            point.x = loc.x;
            point.y = loc.y;
            this.point = null;
            this.events.triggerEvent("unsnap", {point: point});
        }
    },
    
    /**
     * Method: testTarget
     *
     * Parameters:
     * target - {Object} Object with target layer configuration.
     * loc - {<HGIS.Geometry.Point>} The location of the mouse in map
     *     coords.
     *
     * Returns:
     * {Object} A result object with rank, dist, x, and y properties.
     *     Returns null if candidate is not eligible for snapping.
     */
    testTarget: function(target, loc) {
        var resolution = this.layer.map.getResolution();
        if ("minResolution" in target) {
            if (resolution < target.minResolution) {
                return null;
            }
        }
        if ("maxResolution" in target) {
            if (resolution >= target.maxResolution) {
                return null;
            }
        }
        var tolerance = {
            node: this.getGeoTolerance(target.nodeTolerance, resolution),
            vertex: this.getGeoTolerance(target.vertexTolerance, resolution),
            edge: this.getGeoTolerance(target.edgeTolerance, resolution)
        };
        // this could be cached if we don't support setting tolerance values directly
        var maxTolerance = Math.max(
            tolerance.node, tolerance.vertex, tolerance.edge
        );
        var result = {
            rank: Number.POSITIVE_INFINITY, dist: Number.POSITIVE_INFINITY
        };
        var eligible = false;
        var features = target.layer.features;
        var feature, type, vertices, vertex, closest, dist, found;
        var numTypes = this.precedence.length;
        var ll = new HGIS.LonLat(loc.x, loc.y);
        for(var i=0, len=features.length; i<len; ++i) {
            feature = features[i];
            if(feature !== this.feature && !feature._sketch &&
               feature.state !== HGIS.State.DELETE &&
               (!target.filter || target.filter.evaluate(feature))) {
                if(feature.atPoint(ll, maxTolerance, maxTolerance)) {
                    for(var j=0, stop=Math.min(result.rank+1, numTypes); j<stop; ++j) {
                        type = this.precedence[j];
                        if(target[type]) {
                            if(type === "edge") {
                                closest = feature.geometry.distanceTo(loc, {details: true});
                                dist = closest.distance;
                                if(dist <= tolerance[type] && dist < result.dist) {
                                    result = {
                                        rank: j, dist: dist,
                                        x: closest.x0, y: closest.y0 // closest coords on feature
                                    };
                                    eligible = true;
                                    // don't look for lower precedence types for this feature
                                    break;
                                }
                            } else {
                                // look for nodes or vertices
                                vertices = feature.geometry.getVertices(type === "node");
                                found = false;
                                for(var k=0, klen=vertices.length; k<klen; ++k) {
                                    vertex = vertices[k];
                                    dist = vertex.distanceTo(loc);
                                    if(dist <= tolerance[type] &&
                                       (j < result.rank || (j === result.rank && dist < result.dist))) {
                                        result = {
                                            rank: j, dist: dist,
                                            x: vertex.x, y: vertex.y
                                        };
                                        eligible = true;
                                        found = true;
                                    }
                                }
                                if(found) {
                                    // don't look for lower precedence types for this feature
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
        return eligible ? result : null;
    },
    
    /**
     * Method: getGeoTolerance
     * Calculate a tolerance in map units given a tolerance in pixels.  This
     *     takes advantage of the <geoToleranceCache> when the map resolution
     *     has not changed.
     *     
     * Parameters:
     * tolerance - {Number} A tolerance value in pixels.
     * resolution - {Number} Map resolution.
     *
     * Returns:
     * {Number} A tolerance value in map units.
     */
    getGeoTolerance: function(tolerance, resolution) {
        if(resolution !== this.resolution) {
            this.resolution = resolution;
            this.geoToleranceCache = {};
        }
        var geoTolerance = this.geoToleranceCache[tolerance];
        if(geoTolerance === undefined) {
            geoTolerance = tolerance * resolution;
            this.geoToleranceCache[tolerance] = geoTolerance;
        }
        return geoTolerance;
    },
    
    /**
     * Method: destroy
     * Clean up the control.
     */
    destroy: function() {
        if(this.active) {
            this.deactivate(); // TODO: this should be handled by the super
        }
        delete this.layer;
        delete this.targets;
        HGIS.Control.prototype.destroy.call(this);
    },

    CLASS_NAME: "HGIS.Control.Snapping"
});
/* ======================================================================
    HGIS/Format/OWSCommon/v1_1_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/OWSCommon/v1.js
 */

/**
 * Class: HGIS.Format.OWSCommon.v1_1_0
 * Parser for OWS Common version 1.1.0.
 *
 * Inherits from:
 *  - <HGIS.Format.OWSCommon.v1>
 */
HGIS.Format.OWSCommon.v1_1_0 = HGIS.Class(HGIS.Format.OWSCommon.v1, {

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "ows": HGIS.Util.applyDefaults({
            "ExceptionReport": function(node, obj) {
                obj.exceptionReport = {
                    version: node.getAttribute('version'),
                    language: node.getAttribute('xml:lang'),
                    exceptions: []
                };
                this.readChildNodes(node, obj.exceptionReport);
            },
            "AllowedValues": function(node, parameter) {
                parameter.allowedValues = {};
                this.readChildNodes(node, parameter.allowedValues);
            },
            "AnyValue": function(node, parameter) {
                parameter.anyValue = true;
            },
            "DataType": function(node, parameter) {
                parameter.dataType = this.getChildValue(node);
            },
            "Range": function(node, allowedValues) {
                allowedValues.range = {};
                this.readChildNodes(node, allowedValues.range);
            },
            "MinimumValue": function(node, range) {
                range.minValue = this.getChildValue(node);
            },
            "MaximumValue": function(node, range) {
                range.maxValue = this.getChildValue(node);
            },
            "Identifier": function(node, obj) {
                obj.identifier = this.getChildValue(node);
            },
            "SupportedCRS": function(node, obj) {
                obj.supportedCRS = this.getChildValue(node);
            }
        }, HGIS.Format.OWSCommon.v1.prototype.readers["ows"])
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "ows": HGIS.Util.applyDefaults({
            "Range": function(range) {
                var node = this.createElementNSPlus("ows:Range", {
                    attributes: {
                        'ows:rangeClosure': range.closure
                    }
                });
                this.writeNode("ows:MinimumValue", range.minValue, node);
                this.writeNode("ows:MaximumValue", range.maxValue, node);
                return node;
            },
            "MinimumValue": function(minValue) {
                var node = this.createElementNSPlus("ows:MinimumValue", {
                    value: minValue
                });
                return node;
            },
            "MaximumValue": function(maxValue) {
                var node = this.createElementNSPlus("ows:MaximumValue", {
                    value: maxValue
                });
                return node;
            },
            "Value": function(value) {
                var node = this.createElementNSPlus("ows:Value", {
                    value: value
                });
                return node;
            }
        }, HGIS.Format.OWSCommon.v1.prototype.writers["ows"])
    },

    CLASS_NAME: "HGIS.Format.OWSCommon.v1_1_0"

});
/* ======================================================================
    HGIS/Format/WCSGetCoverage.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/OWSCommon/v1_1_0.js
 */

/**
 * Class: HGIS.Format.WCSGetCoverage version 1.1.0
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.WCSGetCoverage = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wcs: "http://www.opengis.net/wcs/1.1",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * Constant: VERSION
     * {String} 1.1.2
     */
    VERSION: "1.1.2",

    /**
     * Property: schemaLocation
     * {String} Schema location
     */
    schemaLocation: "http://www.opengis.net/wcs/1.1 http://schemas.opengis.net/wcs/1.1/wcsGetCoverage.xsd",

    /**
     * Constructor: HGIS.Format.WCSGetCoverage
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Method: write
     *
     * Parameters:
     * options - {Object} Optional object.
     *
     * Returns:
     * {String} A WCS GetCoverage request XML string.
     */
    write: function(options) {
        var node = this.writeNode("wcs:GetCoverage", options);
        this.setAttributeNS(
            node, this.namespaces.xsi,
            "xsi:schemaLocation", this.schemaLocation
        );
        return HGIS.Format.XML.prototype.write.apply(this, [node]);
    }, 

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "wcs": {
            "GetCoverage": function(options) {
                var node = this.createElementNSPlus("wcs:GetCoverage", {
                    attributes: {
                        version: options.version || this.VERSION,
                        service: 'WCS'
                    } 
                }); 
                this.writeNode("ows:Identifier", options.identifier, node);
                this.writeNode("wcs:DomainSubset", options.domainSubset, node);
                this.writeNode("wcs:Output", options.output, node);
                return node; 
            },
            "DomainSubset": function(domainSubset) {
                var node = this.createElementNSPlus("wcs:DomainSubset", {});
                this.writeNode("ows:BoundingBox", domainSubset.boundingBox, node);
                if (domainSubset.temporalSubset) {
                    this.writeNode("wcs:TemporalSubset", domainSubset.temporalSubset, node);
                }
                return node;
            },
            "TemporalSubset": function(temporalSubset) {
                var node = this.createElementNSPlus("wcs:TemporalSubset", {});
                for (var i=0, len=temporalSubset.timePeriods.length; i<len; ++i) {
                    this.writeNode("wcs:TimePeriod", temporalSubset.timePeriods[i], node);
                }
                return node;
            },
            "TimePeriod": function(timePeriod) {
                var node = this.createElementNSPlus("wcs:TimePeriod", {});
                this.writeNode("wcs:BeginPosition", timePeriod.begin, node);
                this.writeNode("wcs:EndPosition", timePeriod.end, node);
                if (timePeriod.resolution) {
                    this.writeNode("wcs:TimeResolution", timePeriod.resolution, node);
                }
                return node;
            },
            "BeginPosition": function(begin) {
                var node = this.createElementNSPlus("wcs:BeginPosition", {
                    value: begin
                });
                return node;
            },
            "EndPosition": function(end) {
                var node = this.createElementNSPlus("wcs:EndPosition", {
                    value: end
                });
                return node;
            },
            "TimeResolution": function(resolution) {
                var node = this.createElementNSPlus("wcs:TimeResolution", {
                    value: resolution
                });
                return node;
            },
            "Output": function(output) {
                var node = this.createElementNSPlus("wcs:Output", {
                    attributes: {
                        format: output.format,
                        store: output.store
                    }
                });
                if (output.gridCRS) {
                    this.writeNode("wcs:GridCRS", output.gridCRS, node);
                }
                return node;
            },
            "GridCRS": function(gridCRS) {
                var node = this.createElementNSPlus("wcs:GridCRS", {});
                this.writeNode("wcs:GridBaseCRS", gridCRS.baseCRS, node);
                if (gridCRS.type) {
                    this.writeNode("wcs:GridType", gridCRS.type, node);
                }
                if (gridCRS.origin) {
                    this.writeNode("wcs:GridOrigin", gridCRS.origin, node);
                }
                this.writeNode("wcs:GridOffsets", gridCRS.offsets, node);
                if (gridCRS.CS) {
                    this.writeNode("wcs:GridCS", gridCRS.CS, node);
                }
                return node;
            },
            "GridBaseCRS": function(baseCRS) {
                return this.createElementNSPlus("wcs:GridBaseCRS", {
                    value: baseCRS
                });
            },
            "GridOrigin": function(origin) {
                return this.createElementNSPlus("wcs:GridOrigin", {
                    value: origin
                });
            },
            "GridType": function(type) {
                return this.createElementNSPlus("wcs:GridType", {
                    value: type
                });
            },
            "GridOffsets": function(offsets) {
                return this.createElementNSPlus("wcs:GridOffsets", {
                    value: offsets
                });
            },
            "GridCS": function(CS) {
                return this.createElementNSPlus("wcs:GridCS", {
                    value: CS
                });
            }
        },
        "ows": HGIS.Format.OWSCommon.v1_1_0.prototype.writers.ows
    },
    
    CLASS_NAME: "HGIS.Format.WCSGetCoverage" 

});
/* ======================================================================
    HGIS/Format/KML.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Date.js
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Geometry/Point.js
 * @requires HGIS/Geometry/LineString.js
 * @requires HGIS/Geometry/Polygon.js
 * @requires HGIS/Geometry/Collection.js
 * @requires HGIS/Request/XMLHttpRequest.js
 * @requires HGIS/Projection.js
 */

/**
 * Class: HGIS.Format.KML
 * Read/Write KML. Create a new instance with the <HGIS.Format.KML>
 *     constructor. 
 * 
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.KML = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        kml: "http://www.opengis.net/kml/2.2",
        gx: "http://www.google.com/kml/ext/2.2"
    },

    /**
     * APIProperty: kmlns
     * {String} KML Namespace to use. Defaults to 2.0 namespace.
     */
    kmlns: "http://earth.google.com/kml/2.0",
    
    /** 
     * APIProperty: placemarksDesc
     * {String} Name of the placemarks.  Default is "No description available".
     */
    placemarksDesc: "No description available",
    
    /** 
     * APIProperty: foldersName
     * {String} Name of the folders.  Default is "HGIS export".
     *          If set to null, no name element will be created.
     */
    foldersName: "HGIS export",
    
    /** 
     * APIProperty: foldersDesc
     * {String} Description of the folders. Default is "Exported on [date]."
     *          If set to null, no description element will be created.
     */
    foldersDesc: "Exported on " + new Date(),
    
    /**
     * APIProperty: extractAttributes
     * {Boolean} Extract attributes from KML.  Default is true.
     *           Extracting styleUrls requires this to be set to true
     *           Note that currently only Data and SimpleData 
     *           elements are handled.
     */
    extractAttributes: true,
    
    /**
     * APIProperty: kvpAttributes
     * {Boolean} Only used if extractAttributes is true.
     *           If set to true, attributes will be simple
     *           key-value pairs, compatible with other formats,
     *           Any displayName elements will be ignored.
     *           If set to false, attributes will be objects,
     *           retaining any displayName elements, but not
     *           compatible with other formats. Any CDATA in
     *           displayName will be read in as a string value.
     *           Default is false.
     */
    kvpAttributes: false,
    
    /**
     * Property: extractStyles
     * {Boolean} Extract styles from KML.  Default is false.
     *           Extracting styleUrls also requires extractAttributes to be
     *           set to true
     */
    extractStyles: false,
    
    /**
     * APIProperty: extractTracks
     * {Boolean} Extract gx:Track elements from Placemark elements.  Default
     *     is false.  If true, features will be generated for all points in
     *     all gx:Track elements.  Features will have a when (Date) attribute
     *     based on when elements in the track.  If tracks include angle
     *     elements, features will have heading, tilt, and roll attributes.
     *     If track point coordinates have three values, features will have
     *     an altitude attribute with the third coordinate value.
     */
    extractTracks: false,
    
    /**
     * APIProperty: trackAttributes
     * {Array} If <extractTracks> is true, points within gx:Track elements will 
     *     be parsed as features with when, heading, tilt, and roll attributes.
     *     Any additional attribute names can be provided in <trackAttributes>.
     */
    trackAttributes: null,
    
    /**
     * Property: internalns
     * {String} KML Namespace to use -- defaults to the namespace of the
     *     Placemark node being parsed, but falls back to kmlns. 
     */
    internalns: null,

    /**
     * Property: features
     * {Array} Array of features
     *     
     */
    features: null,

    /**
     * Property: styles
     * {Object} Storage of style objects
     *     
     */
    styles: null,
    
    /**
     * Property: styleBaseUrl
     * {String}
     */
    styleBaseUrl: "",

    /**
     * Property: fetched
     * {Object} Storage of KML URLs that have been fetched before
     *     in order to prevent reloading them.
     */
    fetched: null,

    /**
     * APIProperty: maxDepth
     * {Integer} Maximum depth for recursive loading external KML URLs 
     *           Defaults to 0: do no external fetching
     */
    maxDepth: 0,

    /**
     * Constructor: HGIS.Format.KML
     * Create a new parser for KML.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        // compile regular expressions once instead of every time they are used
        this.regExes = {
            trimSpace: (/^\s*|\s*$/g),
            removeSpace: (/\s*/g),
            splitSpace: (/\s+/),
            trimComma: (/\s*,\s*/g),
            kmlColor: (/(\w{2})(\w{2})(\w{2})(\w{2})/),
            kmlIconPalette: (/root:\/\/icons\/palette-(\d+)(\.\w+)/),
            straightBracket: (/\$\[(.*?)\]/g)
        };
        // KML coordinates are always in longlat WGS84
        this.externalProjection = new HGIS.Projection("EPSG:4326");

        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: read
     * Read data from a string, and return a list of features. 
     * 
     * Parameters: 
     * data    - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array(<HGIS.Feature.Vector>)} List of features.
     */
    read: function(data) {
        this.features = [];
        this.styles   = {};
        this.fetched  = {};

        // Set default options 
        var options = {
            depth: 0,
            styleBaseUrl: this.styleBaseUrl
        };

        return this.parseData(data, options);
    },

    /**
     * Method: parseData
     * Read data from a string, and return a list of features. 
     * 
     * Parameters: 
     * data    - {String} or {DOMElement} data to read/parse.
     * options - {Object} Hash of options
     *
     * Returns:
     * {Array(<HGIS.Feature.Vector>)} List of features.
     */
    parseData: function(data, options) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }

        // Loop throught the following node types in this order and
        // process the nodes found 
        var types = ["Link", "NetworkLink", "Style", "StyleMap", "Placemark"];
        for(var i=0, len=types.length; i<len; ++i) {
            var type = types[i];

            var nodes = this.getElementsByTagNameNS(data, "*", type);

            // skip to next type if no nodes are found
            if(nodes.length == 0) { 
                continue;
            }

            switch (type.toLowerCase()) {

                // Fetch external links 
                case "link":
                case "networklink":
                    this.parseLinks(nodes, options);
                    break;

                // parse style information
                case "style":
                    if (this.extractStyles) {
                        this.parseStyles(nodes, options);
                    }
                    break;
                case "stylemap":
                    if (this.extractStyles) {
                        this.parseStyleMaps(nodes, options);
                    }
                    break;

                // parse features
                case "placemark":
                    this.parseFeatures(nodes, options);
                    break;
            }
        }
        
        return this.features;
    },

    /**
     * Method: parseLinks
     * Finds URLs of linked KML documents and fetches them
     * 
     * Parameters: 
     * nodes   - {Array} of {DOMElement} data to read/parse.
     * options - {Object} Hash of options
     * 
     */
    parseLinks: function(nodes, options) {
        
        // Fetch external links <NetworkLink> and <Link>
        // Don't do anything if we have reached our maximum depth for recursion
        if (options.depth >= this.maxDepth) {
            return false;
        }

        // increase depth
        var newOptions = HGIS.Util.extend({}, options);
        newOptions.depth++;

        for(var i=0, len=nodes.length; i<len; i++) {
            var href = this.parseProperty(nodes[i], "*", "href");
            if(href && !this.fetched[href]) {
                this.fetched[href] = true; // prevent reloading the same urls
                var data = this.fetchLink(href);
                if (data) {
                    this.parseData(data, newOptions);
                }
            } 
        }

    },

    /**
     * Method: fetchLink
     * Fetches a URL and returns the result
     * 
     * Parameters: 
     * href  - {String} url to be fetched
     * 
     */
    fetchLink: function(href) {
        var request = HGIS.Request.GET({url: href, async: false});
        if (request) {
            return request.responseText;
        }
    },

    /**
     * Method: parseStyles
     * Parses <Style> nodes
     * 
     * Parameters: 
     * nodes    - {Array} of {DOMElement} data to read/parse.
     * options  - {Object} Hash of options
     * 
     */
    parseStyles: function(nodes, options) {
        for(var i=0, len=nodes.length; i<len; i++) {
            var style = this.parseStyle(nodes[i]);
            if(style) {
                var styleName = (options.styleBaseUrl || "") + "#" + style.id;
                
                this.styles[styleName] = style;
            }
        }
    },

    /**
     * Method: parseKmlColor
     * Parses a kml color (in 'aabbggrr' format) and returns the corresponding 
     * color and opacity or null if the color is invalid.
     *
     * Parameters: 
     * kmlColor - {String} a kml formated color
     *
     * Returns:
     * {Object}
     */
    parseKmlColor: function(kmlColor) {
        var color = null;
        if (kmlColor) {
            var matches = kmlColor.match(this.regExes.kmlColor);
            if (matches) {
                color = {
                    color: '#' + matches[4] + matches[3] + matches[2],
                    opacity: parseInt(matches[1], 16) / 255
                };
            }
        }
        return color;
    },

    /**
     * Method: parseStyle
     * Parses the children of a <Style> node and builds the style hash
     * accordingly
     * 
     * Parameters: 
     * node - {DOMElement} <Style> node
     * 
     */
    parseStyle: function(node) {
        var style = {};
        
        var types = ["LineStyle", "PolyStyle", "IconStyle", "BalloonStyle", 
                     "LabelStyle"];
        var type, styleTypeNode, nodeList, geometry, parser;
        for(var i=0, len=types.length; i<len; ++i) {
            type = types[i];
            styleTypeNode = this.getElementsByTagNameNS(node, "*", type)[0];
            if(!styleTypeNode) { 
                continue;
            }

            // only deal with first geometry of this type
            switch (type.toLowerCase()) {
                case "linestyle":
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
                    var color = this.parseKmlColor(kmlColor);
                    if (color) {
                        style["strokeColor"] = color.color;
                        style["strokeOpacity"] = color.opacity;
                    }
                    
                    var width = this.parseProperty(styleTypeNode, "*", "width");
                    if (width) {
                        style["strokeWidth"] = width;
                    }
                    break;

                case "polystyle":
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
                    var color = this.parseKmlColor(kmlColor);
                    if (color) {
                        style["fillOpacity"] = color.opacity;
                        style["fillColor"] = color.color;
                    }
                    // Check if fill is disabled
                    var fill = this.parseProperty(styleTypeNode, "*", "fill");
                    if (fill == "0") {
                        style["fillColor"] = "none";
                    }
                    // Check if outline is disabled
                    var outline = this.parseProperty(styleTypeNode, "*", "outline");
                    if (outline == "0") {
                        style["strokeWidth"] = "0";
                    }
                   
                    break;

                case "iconstyle":
                    // set scale
                    var scale = parseFloat(this.parseProperty(styleTypeNode, 
                                                          "*", "scale") || 1);
  
                    // set default width and height of icon
                    var width = 32 * scale;
                    var height = 32 * scale;

                    var iconNode = this.getElementsByTagNameNS(styleTypeNode, 
                                               "*", 
                                               "Icon")[0];
                    if (iconNode) {
                        var href = this.parseProperty(iconNode, "*", "href");
                        if (href) {                                                   

                            var w = this.parseProperty(iconNode, "*", "w");
                            var h = this.parseProperty(iconNode, "*", "h");

                            // Settings for Google specific icons that are 64x64
                            // We set the width and height to 64 and halve the
                            // scale to prevent icons from being too big
                            var google = "http://maps.google.com/mapfiles/kml";
                            if (HGIS.String.startsWith(
                                                 href, google) && !w && !h) {
                                w = 64;
                                h = 64;
                                scale = scale / 2;
                            }
                                
                            // if only dimension is defined, make sure the
                            // other one has the same value
                            w = w || h;
                            h = h || w;

                            if (w) {
                                width = parseInt(w) * scale;
                            }

                            if (h) {
                                height = parseInt(h) * scale;
                            }

                            // support for internal icons 
                            //    (/root://icons/palette-x.png)
                            // x and y tell the position on the palette:
                            // - in pixels
                            // - starting from the left bottom
                            // We translate that to a position in the list 
                            // and request the appropriate icon from the 
                            // google maps website
                            var matches = href.match(this.regExes.kmlIconPalette);
                            if (matches)  {
                                var palette = matches[1];
                                var file_extension = matches[2];

                                var x = this.parseProperty(iconNode, "*", "x");
                                var y = this.parseProperty(iconNode, "*", "y");

                                var posX = x ? x/32 : 0;
                                var posY = y ? (7 - y/32) : 7;

                                var pos = posY * 8 + posX;
                                href = "http://maps.google.com/mapfiles/kml/pal" 
                                     + palette + "/icon" + pos + file_extension;
                            }

                            style["graphicOpacity"] = 1; // fully opaque
                            style["externalGraphic"] = href;
                        }

                    }


                    // hotSpots define the offset for an Icon
                    var hotSpotNode = this.getElementsByTagNameNS(styleTypeNode, 
                                               "*", 
                                               "hotSpot")[0];
                    if (hotSpotNode) {
                        var x = parseFloat(hotSpotNode.getAttribute("x"));
                        var y = parseFloat(hotSpotNode.getAttribute("y"));

                        var xUnits = hotSpotNode.getAttribute("xunits");
                        if (xUnits == "pixels") {
                            style["graphicXOffset"] = -x * scale;
                        }
                        else if (xUnits == "insetPixels") {
                            style["graphicXOffset"] = -width + (x * scale);
                        }
                        else if (xUnits == "fraction") {
                            style["graphicXOffset"] = -width * x;
                        }

                        var yUnits = hotSpotNode.getAttribute("yunits");
                        if (yUnits == "pixels") {
                            style["graphicYOffset"] = -height + (y * scale) + 1;
                        }
                        else if (yUnits == "insetPixels") {
                            style["graphicYOffset"] = -(y * scale) + 1;
                        }
                        else if (yUnits == "fraction") {
                            style["graphicYOffset"] =  -height * (1 - y) + 1;
                        }
                    }

                    style["graphicWidth"] = width;
                    style["graphicHeight"] = height;
                    break;

                case "balloonstyle":
                    var balloonStyle = HGIS.Util.getXmlNodeValue(
                                            styleTypeNode);
                    if (balloonStyle) {
                        style["balloonStyle"] = balloonStyle.replace(
                                       this.regExes.straightBracket, "${$1}");
                    }
                    break;
                case "labelstyle":
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
                    var color = this.parseKmlColor(kmlColor);
                    if (color) {
                        style["fontColor"] = color.color;
                        style["fontOpacity"] = color.opacity;
                    }
                    break;

                default:
            }
        }

        // Some polygons have no line color, so we use the fillColor for that
        if (!style["strokeColor"] && style["fillColor"]) {
            style["strokeColor"] = style["fillColor"];
        }

        var id = node.getAttribute("id");
        if (id && style) {
            style.id = id;
        }

        return style;
    },

    /**
     * Method: parseStyleMaps
     * Parses <StyleMap> nodes, but only uses the 'normal' key
     * 
     * Parameters: 
     * nodes    - {Array} of {DOMElement} data to read/parse.
     * options  - {Object} Hash of options
     * 
     */
    parseStyleMaps: function(nodes, options) {
        // Only the default or "normal" part of the StyleMap is processed now
        // To do the select or "highlight" bit, we'd need to change lots more

        for(var i=0, len=nodes.length; i<len; i++) {
            var node = nodes[i];
            var pairs = this.getElementsByTagNameNS(node, "*", 
                            "Pair");

            var id = node.getAttribute("id");
            for (var j=0, jlen=pairs.length; j<jlen; j++) {
                var pair = pairs[j];
                // Use the shortcut in the SLD format to quickly retrieve the 
                // value of a node. Maybe it's good to have a method in 
                // Format.XML to do this
                var key = this.parseProperty(pair, "*", "key");
                var styleUrl = this.parseProperty(pair, "*", "styleUrl");

                if (styleUrl && key == "normal") {
                    this.styles[(options.styleBaseUrl || "") + "#" + id] =
                        this.styles[(options.styleBaseUrl || "") + styleUrl];
                }

                // TODO: implement the "select" part
                //if (styleUrl && key == "highlight") {
                //}

            }
        }

    },


    /**
     * Method: parseFeatures
     * Loop through all Placemark nodes and parse them.
     * Will create a list of features
     * 
     * Parameters: 
     * nodes    - {Array} of {DOMElement} data to read/parse.
     * options  - {Object} Hash of options
     * 
     */
    parseFeatures: function(nodes, options) {
        var features = [];
        for(var i=0, len=nodes.length; i<len; i++) {
            var featureNode = nodes[i];
            var feature = this.parseFeature.apply(this,[featureNode]) ;
            if(feature) {

                // Create reference to styleUrl 
                if (this.extractStyles && feature.attributes &&
                    feature.attributes.styleUrl) {
                    feature.style = this.getStyle(feature.attributes.styleUrl, options);
                }

                if (this.extractStyles) {
                    // Make sure that <Style> nodes within a placemark are 
                    // processed as well
                    var inlineStyleNode = this.getElementsByTagNameNS(featureNode,
                                                        "*",
                                                        "Style")[0];
                    if (inlineStyleNode) {
                        var inlineStyle= this.parseStyle(inlineStyleNode);
                        if (inlineStyle) {
                            feature.style = HGIS.Util.extend(
                                feature.style, inlineStyle
                            );
                        }
                    }
                }

                // check if gx:Track elements should be parsed
                if (this.extractTracks) {
                    var tracks = this.getElementsByTagNameNS(
                        featureNode, this.namespaces.gx, "Track"
                    );
                    if (tracks && tracks.length > 0) {
                        var track = tracks[0];
                        var container = {
                            features: [],
                            feature: feature
                        };
                        this.readNode(track, container);
                        if (container.features.length > 0) {
                            features.push.apply(features, container.features);
                        }
                    }
                } else {
                    // add feature to list of features
                    features.push(feature);                    
                }
            } else {
                throw "Bad Placemark: " + i;
            }
        }

        // add new features to existing feature list
        this.features = this.features.concat(features);
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "kml": {
            "when": function(node, container) {
                container.whens.push(HGIS.Date.parse(
                    this.getChildValue(node)
                ));
            },
            "_trackPointAttribute": function(node, container) {
                var name = node.nodeName.split(":").pop();
                container.attributes[name].push(this.getChildValue(node));
            }
        },
        "gx": {
            "Track": function(node, container) {
                var obj = {
                    whens: [],
                    points: [],
                    angles: []
                };
                if (this.trackAttributes) {
                    var name;
                    obj.attributes = {};
                    for (var i=0, ii=this.trackAttributes.length; i<ii; ++i) {
                        name = this.trackAttributes[i];
                        obj.attributes[name] = [];
                        if (!(name in this.readers.kml)) {
                            this.readers.kml[name] = this.readers.kml._trackPointAttribute;
                        }
                    }
                }
                this.readChildNodes(node, obj);
                if (obj.whens.length !== obj.points.length) {
                    throw new Error("gx:Track with unequal number of when (" +
                                    obj.whens.length + ") and gx:coord (" +
                                    obj.points.length + ") elements.");
                }
                var hasAngles = obj.angles.length > 0;
                if (hasAngles && obj.whens.length !== obj.angles.length) {
                    throw new Error("gx:Track with unequal number of when (" +
                                    obj.whens.length + ") and gx:angles (" +
                                    obj.angles.length + ") elements.");
                }
                var feature, point, angles;
                for (var i=0, ii=obj.whens.length; i<ii; ++i) {
                    feature = container.feature.clone();
                    feature.fid = container.feature.fid || container.feature.id;
                    point = obj.points[i];
                    feature.geometry = point;
                    if ("z" in point) {
                        feature.attributes.altitude = point.z;
                    }
                    if (this.internalProjection && this.externalProjection) {
                        feature.geometry.transform(
                            this.externalProjection, this.internalProjection
                        ); 
                    }
                    if (this.trackAttributes) {
                        for (var j=0, jj=this.trackAttributes.length; j<jj; ++j) {
                            var name = this.trackAttributes[j];
                            feature.attributes[name] = obj.attributes[name][i];
                        }
                    }
                    feature.attributes.when = obj.whens[i];
                    feature.attributes.trackId = container.feature.id;
                    if (hasAngles) {
                        angles = obj.angles[i];
                        feature.attributes.heading = parseFloat(angles[0]);
                        feature.attributes.tilt = parseFloat(angles[1]);
                        feature.attributes.roll = parseFloat(angles[2]);
                    }
                    container.features.push(feature);
                }
            },
            "coord": function(node, container) {
                var str = this.getChildValue(node);
                var coords = str.replace(this.regExes.trimSpace, "").split(/\s+/);
                var point = new HGIS.Geometry.Point(coords[0], coords[1]);
                if (coords.length > 2) {
                    point.z = parseFloat(coords[2]);
                }
                container.points.push(point);
            },
            "angles": function(node, container) {
                var str = this.getChildValue(node);
                var parts = str.replace(this.regExes.trimSpace, "").split(/\s+/);
                container.angles.push(parts);
            }
        }
    },
    
    /**
     * Method: parseFeature
     * This function is the core of the KML parsing code in HGIS.
     *     It creates the geometries that are then attached to the returned
     *     feature, and calls parseAttributes() to get attribute data out.
     *
     * Parameters:
     * node - {DOMElement}
     *
     * Returns:
     * {<HGIS.Feature.Vector>} A vector feature.
     */
    parseFeature: function(node) {
        // only accept one geometry per feature - look for highest "order"
        var order = ["MultiGeometry", "Polygon", "LineString", "Point"];
        var type, nodeList, geometry, parser;
        for(var i=0, len=order.length; i<len; ++i) {
            type = order[i];
            this.internalns = node.namespaceURI ? 
                    node.namespaceURI : this.kmlns;
            nodeList = this.getElementsByTagNameNS(node, 
                                                   this.internalns, type);
            if(nodeList.length > 0) {
                // only deal with first geometry of this type
                var parser = this.parseGeometry[type.toLowerCase()];
                if(parser) {
                    geometry = parser.apply(this, [nodeList[0]]);
                    if (this.internalProjection && this.externalProjection) {
                        geometry.transform(this.externalProjection, 
                                           this.internalProjection); 
                    }                       
                } else {
                    throw new TypeError("Unsupported geometry type: " + type);
                }
                // stop looking for different geometry types
                break;
            }
        }

        // construct feature (optionally with attributes)
        var attributes;
        if(this.extractAttributes) {
            attributes = this.parseAttributes(node);
        }
        var feature = new HGIS.Feature.Vector(geometry, attributes);

        var fid = node.getAttribute("id") || node.getAttribute("name");
        if(fid != null) {
            feature.fid = fid;
        }

        return feature;
    },        
    
    /**
     * Method: getStyle
     * Retrieves a style from a style hash using styleUrl as the key
     * If the styleUrl doesn't exist yet, we try to fetch it 
     * Internet
     * 
     * Parameters: 
     * styleUrl  - {String} URL of style
     * options   - {Object} Hash of options 
     *
     * Returns:
     * {Object}  - (reference to) Style hash
     */
    getStyle: function(styleUrl, options) {

        var styleBaseUrl = HGIS.Util.removeTail(styleUrl);

        var newOptions = HGIS.Util.extend({}, options);
        newOptions.depth++;
        newOptions.styleBaseUrl = styleBaseUrl;

        // Fetch remote Style URLs (if not fetched before) 
        if (!this.styles[styleUrl] 
                && !HGIS.String.startsWith(styleUrl, "#") 
                && newOptions.depth <= this.maxDepth
                && !this.fetched[styleBaseUrl] ) {

            var data = this.fetchLink(styleBaseUrl);
            if (data) {
                this.parseData(data, newOptions);
            }

        }

        // return requested style
        var style = HGIS.Util.extend({}, this.styles[styleUrl]);
        return style;
    },
    
    /**
     * Property: parseGeometry
     * Properties of this object are the functions that parse geometries based
     *     on their type.
     */
    parseGeometry: {
        
        /**
         * Method: parseGeometry.point
         * Given a KML node representing a point geometry, create an HGIS
         *     point geometry.
         *
         * Parameters:
         * node - {DOMElement} A KML Point node.
         *
         * Returns:
         * {<HGIS.Geometry.Point>} A point geometry.
         */
        point: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
                                                       "coordinates");
            var coords = [];
            if(nodeList.length > 0) {
                var coordString = nodeList[0].firstChild.nodeValue;
                coordString = coordString.replace(this.regExes.removeSpace, "");
                coords = coordString.split(",");
            }

            var point = null;
            if(coords.length > 1) {
                // preserve third dimension
                if(coords.length == 2) {
                    coords[2] = null;
                }
                point = new HGIS.Geometry.Point(coords[0], coords[1],
                                                      coords[2]);
            } else {
                throw "Bad coordinate string: " + coordString;
            }
            return point;
        },
        
        /**
         * Method: parseGeometry.linestring
         * Given a KML node representing a linestring geometry, create an
         *     HGIS linestring geometry.
         *
         * Parameters:
         * node - {DOMElement} A KML LineString node.
         *
         * Returns:
         * {<HGIS.Geometry.LineString>} A linestring geometry.
         */
        linestring: function(node, ring) {
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
                                                       "coordinates");
            var line = null;
            if(nodeList.length > 0) {
                var coordString = this.getChildValue(nodeList[0]);

                coordString = coordString.replace(this.regExes.trimSpace,
                                                  "");
                coordString = coordString.replace(this.regExes.trimComma,
                                                  ",");
                var pointList = coordString.split(this.regExes.splitSpace);
                var numPoints = pointList.length;
                var points = new Array(numPoints);
                var coords, numCoords;
                for(var i=0; i<numPoints; ++i) {
                    coords = pointList[i].split(",");
                    numCoords = coords.length;
                    if(numCoords > 1) {
                        if(coords.length == 2) {
                            coords[2] = null;
                        }
                        points[i] = new HGIS.Geometry.Point(coords[0],
                                                                  coords[1],
                                                                  coords[2]);
                    } else {
                        throw "Bad LineString point coordinates: " +
                              pointList[i];
                    }
                }
                if(numPoints) {
                    if(ring) {
                        line = new HGIS.Geometry.LinearRing(points);
                    } else {
                        line = new HGIS.Geometry.LineString(points);
                    }
                } else {
                    throw "Bad LineString coordinates: " + coordString;
                }
            }

            return line;
        },
        
        /**
         * Method: parseGeometry.polygon
         * Given a KML node representing a polygon geometry, create an
         *     HGIS polygon geometry.
         *
         * Parameters:
         * node - {DOMElement} A KML Polygon node.
         *
         * Returns:
         * {<HGIS.Geometry.Polygon>} A polygon geometry.
         */
        polygon: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
                                                       "LinearRing");
            var numRings = nodeList.length;
            var components = new Array(numRings);
            if(numRings > 0) {
                // this assumes exterior ring first, inner rings after
                var ring;
                for(var i=0, len=nodeList.length; i<len; ++i) {
                    ring = this.parseGeometry.linestring.apply(this,
                                                        [nodeList[i], true]);
                    if(ring) {
                        components[i] = ring;
                    } else {
                        throw "Bad LinearRing geometry: " + i;
                    }
                }
            }
            return new HGIS.Geometry.Polygon(components);
        },
        
        /**
         * Method: parseGeometry.multigeometry
         * Given a KML node representing a multigeometry, create an
         *     HGIS geometry collection.
         *
         * Parameters:
         * node - {DOMElement} A KML MultiGeometry node.
         *
         * Returns:
         * {<HGIS.Geometry.Collection>} A geometry collection.
         */
        multigeometry: function(node) {
            var child, parser;
            var parts = [];
            var children = node.childNodes;
            for(var i=0, len=children.length; i<len; ++i ) {
                child = children[i];
                if(child.nodeType == 1) {
                    var type = (child.prefix) ?
                            child.nodeName.split(":")[1] :
                            child.nodeName;
                    var parser = this.parseGeometry[type.toLowerCase()];
                    if(parser) {
                        parts.push(parser.apply(this, [child]));
                    }
                }
            }
            return new HGIS.Geometry.Collection(parts);
        }
        
    },

    /**
     * Method: parseAttributes
     *
     * Parameters:
     * node - {DOMElement}
     *
     * Returns:
     * {Object} An attributes object.
     */
    parseAttributes: function(node) {
        var attributes = {};
       
        // Extended Data is parsed first.
        var edNodes = node.getElementsByTagName("ExtendedData");
        if (edNodes.length) {
            attributes = this.parseExtendedData(edNodes[0]);
        }
        
        // assume attribute nodes are type 1 children with a type 3 or 4 child
        var child, grandchildren, grandchild;
        var children = node.childNodes;

        for(var i=0, len=children.length; i<len; ++i) {
            child = children[i];
            if(child.nodeType == 1) {
                grandchildren = child.childNodes;
                if(grandchildren.length >= 1 && grandchildren.length <= 3) {
                    var grandchild;
                    switch (grandchildren.length) {
                        case 1:
                            grandchild = grandchildren[0];
                            break;
                        case 2:
                            var c1 = grandchildren[0];
                            var c2 = grandchildren[1];
                            grandchild = (c1.nodeType == 3 || c1.nodeType == 4) ?
                                c1 : c2;
                            break;
                        case 3:
                        default:
                            grandchild = grandchildren[1];
                            break;
                    }
                    if(grandchild.nodeType == 3 || grandchild.nodeType == 4) {
                        var name = (child.prefix) ?
                                child.nodeName.split(":")[1] :
                                child.nodeName;
                        var value = HGIS.Util.getXmlNodeValue(grandchild);
                        if (value) {
                            value = value.replace(this.regExes.trimSpace, "");
                            attributes[name] = value;
                        }
                    }
                } 
            }
        }
        return attributes;
    },

    /**
     * Method: parseExtendedData
     * Parse ExtendedData from KML. Limited support for schemas/datatypes.
     *     See http://code.google.com/apis/kml/documentation/kmlreference.html#extendeddata
     *     for more information on extendeddata.
     */
    parseExtendedData: function(node) {
        var attributes = {};
        var i, len, data, key;
        var dataNodes = node.getElementsByTagName("Data");
        for (i = 0, len = dataNodes.length; i < len; i++) {
            data = dataNodes[i];
            key = data.getAttribute("name");
            var ed = {};
            var valueNode = data.getElementsByTagName("value");
            if (valueNode.length) {
                ed['value'] = this.getChildValue(valueNode[0]);
            }
            if (this.kvpAttributes) {
                attributes[key] = ed['value'];
            } else {
                var nameNode = data.getElementsByTagName("displayName");
                if (nameNode.length) {
                    ed['displayName'] = this.getChildValue(nameNode[0]);
                }
                attributes[key] = ed;
            } 
        }
        var simpleDataNodes = node.getElementsByTagName("SimpleData");
        for (i = 0, len = simpleDataNodes.length; i < len; i++) {
            var ed = {};
            data = simpleDataNodes[i];
            key = data.getAttribute("name");
            ed['value'] = this.getChildValue(data);
            if (this.kvpAttributes) {
                attributes[key] = ed['value'];
            } else {
                ed['displayName'] = key;
                attributes[key] = ed;
            }
        }
        
        return attributes;    
    },
    
    /**
     * Method: parseProperty
     * Convenience method to find a node and return its value
     *
     * Parameters:
     * xmlNode    - {<DOMElement>}
     * namespace  - {String} namespace of the node to find
     * tagName    - {String} name of the property to parse
     * 
     * Returns:
     * {String} The value for the requested property (defaults to null)
     */    
    parseProperty: function(xmlNode, namespace, tagName) {
        var value;
        var nodeList = this.getElementsByTagNameNS(xmlNode, namespace, tagName);
        try {
            value = HGIS.Util.getXmlNodeValue(nodeList[0]);
        } catch(e) {
            value = null;
        }
     
        return value;
    },                                                              

    /**
     * APIMethod: write
     * Accept Feature Collection, and return a string. 
     * 
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} An array of features.
     *
     * Returns:
     * {String} A KML string.
     */
    write: function(features) {
        if(!(HGIS.Util.isArray(features))) {
            features = [features];
        }
        var kml = this.createElementNS(this.kmlns, "kml");
        var folder = this.createFolderXML();
        for(var i=0, len=features.length; i<len; ++i) {
            folder.appendChild(this.createPlacemarkXML(features[i]));
        }
        kml.appendChild(folder);
        return HGIS.Format.XML.prototype.write.apply(this, [kml]);
    },

    /**
     * Method: createFolderXML
     * Creates and returns a KML folder node
     * 
     * Returns:
     * {DOMElement}
     */
    createFolderXML: function() {
        // Folder
        var folder = this.createElementNS(this.kmlns, "Folder");

        // Folder name
        if (this.foldersName) {
            var folderName = this.createElementNS(this.kmlns, "name");
            var folderNameText = this.createTextNode(this.foldersName); 
            folderName.appendChild(folderNameText);
            folder.appendChild(folderName);
        }

        // Folder description
        if (this.foldersDesc) {
            var folderDesc = this.createElementNS(this.kmlns, "description");        
            var folderDescText = this.createTextNode(this.foldersDesc); 
            folderDesc.appendChild(folderDescText);
            folder.appendChild(folderDesc);
        }

        return folder;
    },

    /**
     * Method: createPlacemarkXML
     * Creates and returns a KML placemark node representing the given feature. 
     * 
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     * 
     * Returns:
     * {DOMElement}
     */
    createPlacemarkXML: function(feature) {        
        // Placemark name
        var placemarkName = this.createElementNS(this.kmlns, "name");
        var label = (feature.style && feature.style.label) ? feature.style.label : feature.id;
        var name = feature.attributes.name || label;
        placemarkName.appendChild(this.createTextNode(name));

        // Placemark description
        var placemarkDesc = this.createElementNS(this.kmlns, "description");
        var desc = feature.attributes.description || this.placemarksDesc;
        placemarkDesc.appendChild(this.createTextNode(desc));
        
        // Placemark
        var placemarkNode = this.createElementNS(this.kmlns, "Placemark");
        if(feature.fid != null) {
            placemarkNode.setAttribute("id", feature.fid);
        }
        placemarkNode.appendChild(placemarkName);
        placemarkNode.appendChild(placemarkDesc);

        // Geometry node (Point, LineString, etc. nodes)
        var geometryNode = this.buildGeometryNode(feature.geometry);
        placemarkNode.appendChild(geometryNode);        
        
        // output attributes as extendedData
        if (feature.attributes) {
            var edNode = this.buildExtendedData(feature.attributes);
            if (edNode) {
                placemarkNode.appendChild(edNode);
            }
        }
        
        return placemarkNode;
    },    

    /**
     * Method: buildGeometryNode
     * Builds and returns a KML geometry node with the given geometry.
     * 
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement}
     */
    buildGeometryNode: function(geometry) {
        var className = geometry.CLASS_NAME;
        var type = className.substring(className.lastIndexOf(".") + 1);
        var builder = this.buildGeometry[type.toLowerCase()];
        var node = null;
        if(builder) {
            node = builder.apply(this, [geometry]);
        }
        return node;
    },

    /**
     * Property: buildGeometry
     * Object containing methods to do the actual geometry node building
     *     based on geometry type.
     */
    buildGeometry: {
        // TBD: Anybody care about namespace aliases here (these nodes have
        //    no prefixes)?

        /**
         * Method: buildGeometry.point
         * Given an HGIS point geometry, create a KML point.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.Point>} A point geometry.
         *
         * Returns:
         * {DOMElement} A KML point node.
         */
        point: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "Point");
            kml.appendChild(this.buildCoordinatesNode(geometry));
            return kml;
        },
        
        /**
         * Method: buildGeometry.multipoint
         * Given an HGIS multipoint geometry, create a KML
         *     GeometryCollection.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.Point>} A multipoint geometry.
         *
         * Returns:
         * {DOMElement} A KML GeometryCollection node.
         */
        multipoint: function(geometry) {
            return this.buildGeometry.collection.apply(this, [geometry]);
        },

        /**
         * Method: buildGeometry.linestring
         * Given an HGIS linestring geometry, create a KML linestring.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.LineString>} A linestring geometry.
         *
         * Returns:
         * {DOMElement} A KML linestring node.
         */
        linestring: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "LineString");
            kml.appendChild(this.buildCoordinatesNode(geometry));
            return kml;
        },
        
        /**
         * Method: buildGeometry.multilinestring
         * Given an HGIS multilinestring geometry, create a KML
         *     GeometryCollection.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.Point>} A multilinestring geometry.
         *
         * Returns:
         * {DOMElement} A KML GeometryCollection node.
         */
        multilinestring: function(geometry) {
            return this.buildGeometry.collection.apply(this, [geometry]);
        },

        /**
         * Method: buildGeometry.linearring
         * Given an HGIS linearring geometry, create a KML linearring.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.LinearRing>} A linearring geometry.
         *
         * Returns:
         * {DOMElement} A KML linearring node.
         */
        linearring: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "LinearRing");
            kml.appendChild(this.buildCoordinatesNode(geometry));
            return kml;
        },
        
        /**
         * Method: buildGeometry.polygon
         * Given an HGIS polygon geometry, create a KML polygon.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.Polygon>} A polygon geometry.
         *
         * Returns:
         * {DOMElement} A KML polygon node.
         */
        polygon: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "Polygon");
            var rings = geometry.components;
            var ringMember, ringGeom, type;
            for(var i=0, len=rings.length; i<len; ++i) {
                type = (i==0) ? "outerBoundaryIs" : "innerBoundaryIs";
                ringMember = this.createElementNS(this.kmlns, type);
                ringGeom = this.buildGeometry.linearring.apply(this,
                                                               [rings[i]]);
                ringMember.appendChild(ringGeom);
                kml.appendChild(ringMember);
            }
            return kml;
        },
        
        /**
         * Method: buildGeometry.multipolygon
         * Given an HGIS multipolygon geometry, create a KML
         *     GeometryCollection.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.Point>} A multipolygon geometry.
         *
         * Returns:
         * {DOMElement} A KML GeometryCollection node.
         */
        multipolygon: function(geometry) {
            return this.buildGeometry.collection.apply(this, [geometry]);
        },

        /**
         * Method: buildGeometry.collection
         * Given an HGIS geometry collection, create a KML MultiGeometry.
         *
         * Parameters:
         * geometry - {<HGIS.Geometry.Collection>} A geometry collection.
         *
         * Returns:
         * {DOMElement} A KML MultiGeometry node.
         */
        collection: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "MultiGeometry");
            var child;
            for(var i=0, len=geometry.components.length; i<len; ++i) {
                child = this.buildGeometryNode.apply(this,
                                                     [geometry.components[i]]);
                if(child) {
                    kml.appendChild(child);
                }
            }
            return kml;
        }
    },

    /**
     * Method: buildCoordinatesNode
     * Builds and returns the KML coordinates node with the given geometry
     * <coordinates>...</coordinates>
     * 
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement}
     */     
    buildCoordinatesNode: function(geometry) {
        var coordinatesNode = this.createElementNS(this.kmlns, "coordinates");
        
        var path;
        var points = geometry.components;
        if(points) {
            // LineString or LinearRing
            var point;
            var numPoints = points.length;
            var parts = new Array(numPoints);
            for(var i=0; i<numPoints; ++i) {
                point = points[i];
                parts[i] = this.buildCoordinates(point);
            }
            path = parts.join(" ");
        } else {
            // Point
            path = this.buildCoordinates(geometry);
        }
        
        var txtNode = this.createTextNode(path);
        coordinatesNode.appendChild(txtNode);
        
        return coordinatesNode;
    },    
    
    /**
     * Method: buildCoordinates
     *
     * Parameters:
     * point - {<HGIS.Geometry.Point>}
     *
     * Returns
     * {String} a coordinate pair
     */
    buildCoordinates: function(point) {
        if (this.internalProjection && this.externalProjection) {
            point = point.clone();
            point.transform(this.internalProjection, 
                               this.externalProjection);
        }
        return point.x + "," + point.y;                     
    },

    /**
     * Method: buildExtendedData
     *
     * Parameters:
     * attributes - {Object}
     *
     * Returns
     * {DOMElement} A KML ExtendedData node or {null} if no attributes.
     */
    buildExtendedData: function(attributes) {
        var extendedData = this.createElementNS(this.kmlns, "ExtendedData");
        for (var attributeName in attributes) {
            // empty, name, description, styleUrl attributes ignored
            if (attributes[attributeName] && attributeName != "name" && attributeName != "description" && attributeName != "styleUrl") {
                var data = this.createElementNS(this.kmlns, "Data");
                data.setAttribute("name", attributeName);
                var value = this.createElementNS(this.kmlns, "value");
                if (typeof attributes[attributeName] == "object") {
                    // cater for object attributes with 'value' properties
                    // other object properties will output an empty node
                    if (attributes[attributeName].value) {
                        value.appendChild(this.createTextNode(attributes[attributeName].value));
                    }
                    if (attributes[attributeName].displayName) {
                        var displayName = this.createElementNS(this.kmlns, "displayName");
                        // displayName always written as CDATA
                        displayName.appendChild(this.getXMLDoc().createCDATASection(attributes[attributeName].displayName));
                        data.appendChild(displayName);
                    }
                } else {
                    value.appendChild(this.createTextNode(attributes[attributeName]));
                }
                data.appendChild(value);
                extendedData.appendChild(data);
            }
        }
        if (this.isSimpleContent(extendedData)) {
            return null;
        } else {
            return extendedData;
        }
    },
    
    CLASS_NAME: "HGIS.Format.KML" 
});
/* ======================================================================
    HGIS/Format/WMSCapabilities.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML/VersionedOGC.js
 */

/**
 * Class: HGIS.Format.WMSCapabilities
 * Read WMS Capabilities.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML.VersionedOGC>
 */
HGIS.Format.WMSCapabilities = HGIS.Class(HGIS.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.1.1".
     */
    defaultVersion: "1.1.1",
    
    /**
     * APIProperty: profile
     * {String} If provided, use a custom profile.
     *
     * Currently supported profiles:
     * - WMSC - parses vendor specific capabilities for WMS-C.
     */
    profile: null,
    
    /**
     * Constructor: HGIS.Format.WMSCapabilities
     * Create a new parser for WMS capabilities.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return a list of layers. 
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array} List of named layers.
     */
    
    CLASS_NAME: "HGIS.Format.WMSCapabilities" 

});
/* ======================================================================
    HGIS/Format/WMSCapabilities/v1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WMSCapabilities.js
 * @requires HGIS/Format/OGCExceptionReport.js
 * @requires HGIS/Format/XML.js
 */

/**
 * Class: HGIS.Format.WMSCapabilities.v1
 * Abstract class not to be instantiated directly. Creates
 * the common parts for both WMS 1.1.X and WMS 1.3.X.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.WMSCapabilities.v1 = HGIS.Class(
    HGIS.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        wms: "http://www.opengis.net/wms",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "wms",
    
    /**
     * Constructor: HGIS.Format.WMSCapabilities.v1
     * Create an instance of one of the subclasses.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return a list of layers. 
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array} List of named layers.
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        var raw = data;
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        if (capabilities.service === undefined) {
            // an exception must have occurred, so parse it
            var parser = new HGIS.Format.OGCExceptionReport();
            capabilities.error = parser.read(raw);
        }
        return capabilities;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wms": {
            "Service": function(node, obj) {
                obj.service = {};
                this.readChildNodes(node, obj.service);
            },
            "Name": function(node, obj) {
                obj.name = this.getChildValue(node);
            },
            "Title": function(node, obj) {
                obj.title = this.getChildValue(node);
            },
            "Abstract": function(node, obj) {
                obj["abstract"] = this.getChildValue(node);
            },
            "BoundingBox": function(node, obj) {
                var bbox = {};
                bbox.bbox = [
                    parseFloat(node.getAttribute("minx")),
                    parseFloat(node.getAttribute("miny")),
                    parseFloat(node.getAttribute("maxx")),
                    parseFloat(node.getAttribute("maxy"))
                ];
                var res = {
                    x: parseFloat(node.getAttribute("resx")),
                    y: parseFloat(node.getAttribute("resy"))
                };

                if (! (isNaN(res.x) && isNaN(res.y))) {
                    bbox.res = res;
                }
                // return the bbox so that descendant classes can set the
                // CRS and SRS and add it to the obj
                return bbox;
            },
            "OnlineResource": function(node, obj) {
                obj.href = this.getAttributeNS(node, this.namespaces.xlink, 
                    "href");
            },
            "ContactInformation": function(node, obj) {
                obj.contactInformation = {};
                this.readChildNodes(node, obj.contactInformation);
            },
            "ContactPersonPrimary": function(node, obj) {
                obj.personPrimary = {};
                this.readChildNodes(node, obj.personPrimary);
            },
            "ContactPerson": function(node, obj) {
                obj.person = this.getChildValue(node);
            },
            "ContactOrganization": function(node, obj) {
                obj.organization = this.getChildValue(node);
            },
            "ContactPosition": function(node, obj) {
                obj.position = this.getChildValue(node);
            },
            "ContactAddress": function(node, obj) {
                obj.contactAddress = {};
                this.readChildNodes(node, obj.contactAddress);
            },
            "AddressType": function(node, obj) {
                obj.type = this.getChildValue(node);
            },
            "Address": function(node, obj) {
                obj.address = this.getChildValue(node);
            },
            "City": function(node, obj) {
                obj.city = this.getChildValue(node);
            },
            "StateOrProvince": function(node, obj) {
                obj.stateOrProvince = this.getChildValue(node);
            },
            "PostCode": function(node, obj) {
                obj.postcode = this.getChildValue(node);
            },
            "Country": function(node, obj) {
                obj.country = this.getChildValue(node);
            },
            "ContactVoiceTelephone": function(node, obj) {
                obj.phone = this.getChildValue(node);
            },
            "ContactFacsimileTelephone": function(node, obj) {
                obj.fax = this.getChildValue(node);
            },
            "ContactElectronicMailAddress": function(node, obj) {
                obj.email = this.getChildValue(node);
            },
            "Fees": function(node, obj) {
                var fees = this.getChildValue(node);
                if (fees && fees.toLowerCase() != "none") {
                    obj.fees = fees;
                }
            },
            "AccessConstraints": function(node, obj) {
                var constraints = this.getChildValue(node);
                if (constraints && constraints.toLowerCase() != "none") {
                    obj.accessConstraints = constraints;
                }
            },
            "Capability": function(node, obj) {
                obj.capability = {
                    nestedLayers: [],
                    layers: []
                };
                this.readChildNodes(node, obj.capability);
            },
            "Request": function(node, obj) {
                obj.request = {};
                this.readChildNodes(node, obj.request);
            },
            "GetCapabilities": function(node, obj) {
                obj.getcapabilities = {formats: []};
                this.readChildNodes(node, obj.getcapabilities);
            },
            "Format": function(node, obj) {
                if (HGIS.Util.isArray(obj.formats)) {
                    obj.formats.push(this.getChildValue(node));
                } else {
                    obj.format = this.getChildValue(node);
                }
            },
            "DCPType": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "HTTP": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Get": function(node, obj) {
                obj.get = {};
                this.readChildNodes(node, obj.get);
                // backwards compatibility
                if (!obj.href) {
                    obj.href = obj.get.href;
                }
            },
            "Post": function(node, obj) {
                obj.post = {};
                this.readChildNodes(node, obj.post);
                // backwards compatibility
                if (!obj.href) {
                    obj.href = obj.get.href;
                }
            },
            "GetMap": function(node, obj) {
                obj.getmap = {formats: []};
                this.readChildNodes(node, obj.getmap);
            },
            "GetFeatureInfo": function(node, obj) {
                obj.getfeatureinfo = {formats: []};
                this.readChildNodes(node, obj.getfeatureinfo);
            },
            "Exception": function(node, obj) {
                obj.exception = {formats: []};
                this.readChildNodes(node, obj.exception);
            },
            "Layer": function(node, obj) {
                var parentLayer, capability;
                if (obj.capability) {
                    capability = obj.capability;
                    parentLayer = obj;
                } else {
                    capability = obj;
                }
                var attrNode = node.getAttributeNode("queryable");
                var queryable = (attrNode && attrNode.specified) ? 
                    node.getAttribute("queryable") : null;
                attrNode = node.getAttributeNode("cascaded");
                var cascaded = (attrNode && attrNode.specified) ?
                    node.getAttribute("cascaded") : null;
                attrNode = node.getAttributeNode("opaque");
                var opaque = (attrNode && attrNode.specified) ?
                    node.getAttribute('opaque') : null;
                var noSubsets = node.getAttribute('noSubsets');
                var fixedWidth = node.getAttribute('fixedWidth');
                var fixedHeight = node.getAttribute('fixedHeight');
                var parent = parentLayer || {},
                    extend = HGIS.Util.extend;
                var layer = {
                    nestedLayers: [],
                    styles: parentLayer ? [].concat(parentLayer.styles) : [],
                    srs: parentLayer ? extend({}, parent.srs) : {}, 
                    metadataURLs: [],
                    bbox: parentLayer ? extend({}, parent.bbox) : {},
                    llbbox: parent.llbbox,
                    dimensions: parentLayer ? extend({}, parent.dimensions) : {},
                    authorityURLs: parentLayer ? extend({}, parent.authorityURLs) : {},
                    identifiers: {},
                    keywords: [],
                    queryable: (queryable && queryable !== "") ? 
                        (queryable === "1" || queryable === "true" ) :
                        (parent.queryable || false),
                    cascaded: (cascaded !== null) ? parseInt(cascaded) :
                        (parent.cascaded || 0),
                    opaque: opaque ? 
                        (opaque === "1" || opaque === "true" ) :
                        (parent.opaque || false),
                    noSubsets: (noSubsets !== null) ? 
                        (noSubsets === "1" || noSubsets === "true" ) :
                        (parent.noSubsets || false),
                    fixedWidth: (fixedWidth != null) ? 
                        parseInt(fixedWidth) : (parent.fixedWidth || 0),
                    fixedHeight: (fixedHeight != null) ? 
                        parseInt(fixedHeight) : (parent.fixedHeight || 0),
                    minScale: parent.minScale,
                    maxScale: parent.maxScale,
                    attribution: parent.attribution
                };
                obj.nestedLayers.push(layer);
                layer.capability = capability;
                this.readChildNodes(node, layer);
                delete layer.capability;
                if(layer.name) {
                    var parts = layer.name.split(":"),
                        request = capability.request,
                        gfi = request.getfeatureinfo;
                    if(parts.length > 0) {
                        layer.prefix = parts[0];
                    }
                    capability.layers.push(layer);
                    if (layer.formats === undefined) {
                        layer.formats = request.getmap.formats;
                    }
                    if (layer.infoFormats === undefined && gfi) {
                        layer.infoFormats = gfi.formats;
                    }
                }
            },
            "Attribution": function(node, obj) {
                obj.attribution = {};
                this.readChildNodes(node, obj.attribution);
            },
            "LogoURL": function(node, obj) {
                obj.logo = {
                    width: node.getAttribute("width"),
                    height: node.getAttribute("height")
                };
                this.readChildNodes(node, obj.logo);
            },
            "Style": function(node, obj) {
                var style = {};
                obj.styles.push(style);
                this.readChildNodes(node, style);
            },
            "LegendURL": function(node, obj) {
                var legend = {
                    width: node.getAttribute("width"),
                    height: node.getAttribute("height")
                };
                obj.legend = legend;
                this.readChildNodes(node, legend);
            },
            "MetadataURL": function(node, obj) {
                var metadataURL = {type: node.getAttribute("type")};
                obj.metadataURLs.push(metadataURL);
                this.readChildNodes(node, metadataURL);
            },
            "DataURL": function(node, obj) {
                obj.dataURL = {};
                this.readChildNodes(node, obj.dataURL);
            },
            "FeatureListURL": function(node, obj) {
                obj.featureListURL = {};
                this.readChildNodes(node, obj.featureListURL);
            },
            "AuthorityURL": function(node, obj) {
                var name = node.getAttribute("name");
                var authority = {};
                this.readChildNodes(node, authority);
                obj.authorityURLs[name] = authority.href;
            },
            "Identifier": function(node, obj) {
                var authority = node.getAttribute("authority");
                obj.identifiers[authority] = this.getChildValue(node);
            },
            "KeywordList": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "SRS": function(node, obj) {
                obj.srs[this.getChildValue(node)] = true;
            }
        }
    },

    CLASS_NAME: "HGIS.Format.WMSCapabilities.v1" 

});
/* ======================================================================
    HGIS/Format/WMSCapabilities/v1_1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WMSCapabilities/v1.js
 */

/**
 * Class: HGIS.Format.WMSCapabilities.v1_1
 * Abstract class not to be instantiated directly.
 * 
 * Inherits from:
 *  - <HGIS.Format.WMSCapabilities.v1>
 */
HGIS.Format.WMSCapabilities.v1_1 = HGIS.Class(
    HGIS.Format.WMSCapabilities.v1, {
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wms": HGIS.Util.applyDefaults({
            "WMT_MS_Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Keyword": function(node, obj) {
                if (obj.keywords) {
                    obj.keywords.push(this.getChildValue(node));
                }
            },
            "DescribeLayer": function(node, obj) {
                obj.describelayer = {formats: []};
                this.readChildNodes(node, obj.describelayer);
            },
            "GetLegendGraphic": function(node, obj) {
                obj.getlegendgraphic = {formats: []};
                this.readChildNodes(node, obj.getlegendgraphic);
            },
            "GetStyles": function(node, obj) {
                obj.getstyles = {formats: []};
                this.readChildNodes(node, obj.getstyles);
            },
            "PutStyles": function(node, obj) {
                obj.putstyles = {formats: []};
                this.readChildNodes(node, obj.putstyles);
            },
            "UserDefinedSymbolization": function(node, obj) {
                var userSymbols = {
                    supportSLD: parseInt(node.getAttribute("SupportSLD")) == 1,
                    userLayer: parseInt(node.getAttribute("UserLayer")) == 1,
                    userStyle: parseInt(node.getAttribute("UserStyle")) == 1,
                    remoteWFS: parseInt(node.getAttribute("RemoteWFS")) == 1
                };
                obj.userSymbols = userSymbols;
            },
            "LatLonBoundingBox": function(node, obj) {
                obj.llbbox = [
                    parseFloat(node.getAttribute("minx")),
                    parseFloat(node.getAttribute("miny")),
                    parseFloat(node.getAttribute("maxx")),
                    parseFloat(node.getAttribute("maxy"))
                ];
            },
            "BoundingBox": function(node, obj) {
                var bbox = HGIS.Format.WMSCapabilities.v1.prototype.readers["wms"].BoundingBox.apply(this, [node, obj]);
                bbox.srs  = node.getAttribute("SRS");
                obj.bbox[bbox.srs] = bbox;
            },
            "ScaleHint": function(node, obj) {
                var min = node.getAttribute("min");
                var max = node.getAttribute("max");
                var rad2 = Math.pow(2, 0.5);
                var ipm = HGIS.INCHES_PER_UNIT["m"];
                if (min != 0) {
                    obj.maxScale = parseFloat(
                        ((min / rad2) * ipm * 
                            HGIS.DOTS_PER_INCH).toPrecision(13)
                    );
                }
                if (max != Number.POSITIVE_INFINITY) {
                    obj.minScale = parseFloat(
                        ((max / rad2) * ipm * 
                            HGIS.DOTS_PER_INCH).toPrecision(13)
                    );
                }
            },
            "Dimension": function(node, obj) {
                var name = node.getAttribute("name").toLowerCase();
                var dim = {
                    name: name,
                    units: node.getAttribute("units"),
                    unitsymbol: node.getAttribute("unitSymbol")
                };
                obj.dimensions[dim.name] = dim;
            },
            "Extent": function(node, obj) {
                var name = node.getAttribute("name").toLowerCase();
                if (name in obj["dimensions"]) {
                    var extent = obj.dimensions[name];
                    extent.nearestVal = 
                        node.getAttribute("nearestValue") === "1";
                    extent.multipleVal = 
                        node.getAttribute("multipleValues") === "1";
                    extent.current = node.getAttribute("current") === "1";
                    extent["default"] = node.getAttribute("default") || "";
                    var values = this.getChildValue(node);
                    extent.values = values.split(",");
                }
                }
        }, HGIS.Format.WMSCapabilities.v1.prototype.readers["wms"])
    },

    CLASS_NAME: "HGIS.Format.WMSCapabilities.v1_1" 

});
/* ======================================================================
    HGIS/Format/WMSCapabilities/v1_1_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WMSCapabilities/v1_1.js
 */

/**
 * Class: HGIS.Format.WMSCapabilities/v1_1_0
 * Read WMS Capabilities version 1.1.0.
 * 
 * Inherits from:
 *  - <HGIS.Format.WMSCapabilities.v1_1>
 */
HGIS.Format.WMSCapabilities.v1_1_0 = HGIS.Class(
    HGIS.Format.WMSCapabilities.v1_1, {
    
    /**
     * Property: version
     * {String} The specific parser version.
     */
    version: "1.1.0",
    
    /**
     * Constructor: HGIS.Format.WMSCapabilities.v1_1_0
     * Create a new parser for WMS capabilities version 1.1.0.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wms": HGIS.Util.applyDefaults({
            "SRS": function(node, obj) {
                var srs = this.getChildValue(node);
                var values = srs.split(/ +/);
                for (var i=0, len=values.length; i<len; i++) {
                    obj.srs[values[i]] = true;
                }
            }
        }, HGIS.Format.WMSCapabilities.v1_1.prototype.readers["wms"])
    },

    CLASS_NAME: "HGIS.Format.WMSCapabilities.v1_1_0" 

});
/* ======================================================================
    HGIS/Protocol/WFS/v1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Protocol/WFS.js
 */

/**
 * Class: HGIS.Protocol.WFS.v1
 * Abstract class for for v1.0.0 and v1.1.0 protocol.
 *
 * Inherits from:
 *  - <HGIS.Protocol>
 */
HGIS.Protocol.WFS.v1 = HGIS.Class(HGIS.Protocol, {
    
    /**
     * Property: version
     * {String} WFS version number.
     */
    version: null,
    
    /**
     * Property: srsName
     * {String} Name of spatial reference system.  Default is "EPSG:4326".
     */
    srsName: "EPSG:4326",
    
    /**
     * Property: featureType
     * {String} Local feature typeName.
     */
    featureType: null,
    
    /**
     * Property: featureNS
     * {String} Feature namespace.
     */
    featureNS: null,
    
    /**
     * Property: geometryName
     * {String} Name of the geometry attribute for features.  Default is
     *     "the_geom" for WFS <version> 1.0, and null for higher versions.
     */
    geometryName: "the_geom",

    /**
     * Property: maxFeatures
     * {Integer} Optional maximum number of features to retrieve.
     */
    
    /**
     * Property: schema
     * {String} Optional schema location that will be included in the
     *     schemaLocation attribute value.  Note that the feature type schema
     *     is required for a strict XML validator (on transactions with an
     *     insert for example), but is *not* required by the WFS specification
     *     (since the server is supposed to know about feature type schemas).
     */
    schema: null,

    /**
     * Property: featurePrefix
     * {String} Namespace alias for feature type.  Default is "feature".
     */
    featurePrefix: "feature",
    
    /**
     * Property: formatOptions
     * {Object} Optional options for the format.  If a format is not provided,
     *     this property can be used to extend the default format options.
     */
    formatOptions: null,

    /** 
     * Property: readFormat 
     * {<HGIS.Format>} For WFS requests it is possible to get a  
     *     different output format than GML. In that case, we cannot parse  
     *     the response with the default format (WFST) and we need a different 
     *     format for reading. 
     */ 
    readFormat: null,
    
    /**
     * Property: readOptions
     * {Object} Optional object to pass to format's read.
     */
    readOptions: null,
    
    /**
     * Constructor: HGIS.Protocol.WFS
     * A class for giving layers WFS protocol.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties:
     * url - {String} URL to send requests to (required).
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (required, but can be autodetected
     *     during the first query if GML is used as readFormat and
     *     featurePrefix is provided and matches the prefix used by the server
     *     for this featureType).
     * featurePrefix - {String} Feature namespace alias (optional - only used
     *     for writing if featureNS is provided).  Default is 'feature'.
     * geometryName - {String} Name of geometry attribute.  The default is
     *     'the_geom' for WFS <version> 1.0, and null for higher versions. If
     *     null, it will be set to the name of the first geometry found in the
     *     first read operation.
     * multi - {Boolean} If set to true, geometries will be casted to Multi
     *     geometries before they are written in a transaction. No casting will
     *     be done when reading features.
     */
    initialize: function(options) {
        HGIS.Protocol.prototype.initialize.apply(this, [options]);
        if(!options.format) {
            this.format = HGIS.Format.WFST(HGIS.Util.extend({
                version: this.version,
                featureType: this.featureType,
                featureNS: this.featureNS,
                featurePrefix: this.featurePrefix,
                geometryName: this.geometryName,
                srsName: this.srsName,
                schema: this.schema
            }, this.formatOptions));
        }
        if (!options.geometryName && parseFloat(this.format.version) > 1.0) {
            this.setGeometryName(null);
        }
    },
    
    /**
     * APIMethod: destroy
     * Clean up the protocol.
     */
    destroy: function() {
        if(this.options && !this.options.format) {
            this.format.destroy();
        }
        this.format = null;
        HGIS.Protocol.prototype.destroy.apply(this);
    },

    /**
     * APIMethod: read
     * Construct a request for reading new features.  Since WFS splits the
     *     basic CRUD operations into GetFeature requests (for read) and
     *     Transactions (for all others), this method does not make use of the
     *     format's read method (that is only about reading transaction
     *     responses).
     *
     * Parameters:
     * options - {Object} Options for the read operation, in addition to the
     *     options set on the instance (options set here will take precedence).
     *
     * To use a configured protocol to get e.g. a WFS hit count, applications
     * could do the following:
     *
     * (code)
     * protocol.read({
     *     readOptions: {output: "object"},
     *     resultType: "hits",
     *     maxFeatures: null,
     *     callback: function(resp) {
     *         // process resp.numberOfFeatures here
     *     }
     * });
     * (end)
     *
     * To use a configured protocol to use WFS paging (if supported by the
     * server), applications could do the following:
     *
     * (code)
     * protocol.read({
     *     startIndex: 0,
     *     count: 50
     * });
     * (end)
     *
     * To limit the attributes returned by the GetFeature request, applications
     * can use the propertyNames option to specify the properties to include in
     * the response:
     *
     * (code)
     * protocol.read({
     *     propertyNames: ["DURATION", "INTENSITY"]
     * });
     * (end)
     */
    read: function(options) {
        HGIS.Protocol.prototype.read.apply(this, arguments);
        options = HGIS.Util.extend({}, options);
        HGIS.Util.applyDefaults(options, this.options || {});
        var response = new HGIS.Protocol.Response({requestType: "read"});
        
        var data = HGIS.Format.XML.prototype.write.apply(
            this.format, [this.format.writeNode("wfs:GetFeature", options)]
        );

        response.priv = HGIS.Request.POST({
            url: options.url,
            callback: this.createCallback(this.handleRead, response, options),
            params: options.params,
            headers: options.headers,
            data: data
        });

        return response;
    },

    /**
     * APIMethod: setFeatureType
     * Change the feature type on the fly.
     *
     * Parameters:
     * featureType - {String} Local (without prefix) feature typeName.
     */
    setFeatureType: function(featureType) {
        this.featureType = featureType;
        this.format.featureType = featureType;
    },
 
    /**
     * APIMethod: setGeometryName
     * Sets the geometryName option after instantiation.
     *
     * Parameters:
     * geometryName - {String} Name of geometry attribute.
     */
    setGeometryName: function(geometryName) {
        this.geometryName = geometryName;
        this.format.geometryName = geometryName;
    },
    
    /**
     * Method: handleRead
     * Deal with response from the read request.
     *
     * Parameters:
     * response - {<HGIS.Protocol.Response>} The response object to pass
     *     to the user callback.
     * options - {Object} The user options passed to the read call.
     */
    handleRead: function(response, options) {
        options = HGIS.Util.extend({}, options);
        HGIS.Util.applyDefaults(options, this.options);

        if(options.callback) {
            var request = response.priv;
            if(request.status >= 200 && request.status < 300) {
                // success
                var result = this.parseResponse(request, options.readOptions);
                if (result && result.success !== false) { 
                    if (options.readOptions && options.readOptions.output == "object") {
                        HGIS.Util.extend(response, result);
                    } else {
                        response.features = result;
                    }
                    response.code = HGIS.Protocol.Response.SUCCESS;
                } else {
                    // failure (service exception)
                    response.code = HGIS.Protocol.Response.FAILURE;
                    response.error = result;
                }
            } else {
                // failure
                response.code = HGIS.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, response);
        }
    },

    /**
     * Method: parseResponse
     * Read HTTP response body and return features
     *
     * Parameters:
     * request - {XMLHttpRequest} The request object
     * options - {Object} Optional object to pass to format's read
     *
     * Returns:
     * {Object} or {Array({<HGIS.Feature.Vector>})} or
     *     {<HGIS.Feature.Vector>} 
     * An object with a features property, an array of features or a single 
     * feature.
     */
    parseResponse: function(request, options) {
        var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc || doc.length <= 0) {
            return null;
        }
        var result = (this.readFormat !== null) ? this.readFormat.read(doc) : 
            this.format.read(doc, options);
        if (!this.featureNS) {
            var format = this.readFormat || this.format;
            this.featureNS = format.featureNS;
            // no need to auto-configure again on subsequent reads
            format.autoConfig = false;
            if (!this.geometryName) {
                this.setGeometryName(format.geometryName);
            }
        }
        return result;
    },

    /**
     * Method: commit
     * Given a list of feature, assemble a batch request for update, create,
     *     and delete transactions.  A commit call on the prototype amounts
     *     to writing a WFS transaction - so the write method on the format
     *     is used.
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)}
     * options - {Object}
     *
     * Valid options properties:
     * nativeElements - {Array({Object})} Array of objects with information for writing
     * out <Native> elements, these objects have vendorId, safeToIgnore and
     * value properties. The <Native> element is intended to allow access to 
     * vendor specific capabilities of any particular web feature server or 
     * datastore.
     *
     * Returns:
     * {<HGIS.Protocol.Response>} A response object with a features
     *     property containing any insertIds and a priv property referencing
     *     the XMLHttpRequest object.
     */
    commit: function(features, options) {

        options = HGIS.Util.extend({}, options);
        HGIS.Util.applyDefaults(options, this.options);
        
        var response = new HGIS.Protocol.Response({
            requestType: "commit",
            reqFeatures: features
        });
        response.priv = HGIS.Request.POST({
            url: options.url,
            headers: options.headers,
            data: this.format.write(features, options),
            callback: this.createCallback(this.handleCommit, response, options)
        });
        
        return response;
    },
    
    /**
     * Method: handleCommit
     * Called when the commit request returns.
     * 
     * Parameters:
     * response - {<HGIS.Protocol.Response>} The response object to pass
     *     to the user callback.
     * options - {Object} The user options passed to the commit call.
     */
    handleCommit: function(response, options) {
        if(options.callback) {
            var request = response.priv;

            // ensure that we have an xml doc
            var data = request.responseXML;
            if(!data || !data.documentElement) {
                data = request.responseText;
            }
            
            var obj = this.format.read(data) || {};
            
            response.insertIds = obj.insertIds || [];
            if (obj.success) {
                response.code = HGIS.Protocol.Response.SUCCESS;
            } else {
                response.code = HGIS.Protocol.Response.FAILURE;
                response.error = obj;
            }
            options.callback.call(options.scope, response);
        }
    },
    
    /**
     * Method: filterDelete
     * Send a request that deletes all features by their filter.
     * 
     * Parameters:
     * filter - {<HGIS.Filter>} filter
     */
    filterDelete: function(filter, options) {
        options = HGIS.Util.extend({}, options);
        HGIS.Util.applyDefaults(options, this.options);    
        
        var response = new HGIS.Protocol.Response({
            requestType: "commit"
        });    
        
        var root = this.format.createElementNSPlus("wfs:Transaction", {
            attributes: {
                service: "WFS",
                version: this.version
            }
        });
        
        var deleteNode = this.format.createElementNSPlus("wfs:Delete", {
            attributes: {
                typeName: (options.featureNS ? this.featurePrefix + ":" : "") +
                    options.featureType
            }
        });       
        
        if(options.featureNS) {
            deleteNode.setAttribute("xmlns:" + this.featurePrefix, options.featureNS);
        }
        var filterNode = this.format.writeNode("ogc:Filter", filter);
        
        deleteNode.appendChild(filterNode);
        
        root.appendChild(deleteNode);
        
        var data = HGIS.Format.XML.prototype.write.apply(
            this.format, [root]
        );
        
        return HGIS.Request.POST({
            url: this.url,
            callback : options.callback || function(){},
            data: data
        });   
        
    },

    /**
     * Method: abort
     * Abort an ongoing request, the response object passed to
     * this method must come from this protocol (as a result
     * of a read, or commit operation).
     *
     * Parameters:
     * response - {<HGIS.Protocol.Response>}
     */
    abort: function(response) {
        if (response) {
            response.priv.abort();
        }
    },
  
    CLASS_NAME: "HGIS.Protocol.WFS.v1" 
});
/* ======================================================================
    HGIS/Handler/Feature.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Handler.js
 */

/**
 * Class: HGIS.Handler.Feature 
 * Handler to respond to mouse events related to a drawn feature.  Callbacks
 *     with the following keys will be notified of the following events
 *     associated with features: click, clickout, over, out, and dblclick.
 *
 * This handler stops event propagation for mousedown and mouseup if those
 *     browser events target features that can be selected.
 *
 * Inherits from:
 *  - <HGIS.Handler>
 */
HGIS.Handler.Feature = HGIS.Class(HGIS.Handler, {

    /**
     * Property: EVENTMAP
     * {Object} A object mapping the browser events to objects with callback
     *     keys for in and out.
     */
    EVENTMAP: {
        'click': {'in': 'click', 'out': 'clickout'},
        'mousemove': {'in': 'over', 'out': 'out'},
        'dblclick': {'in': 'dblclick', 'out': null},
        'mousedown': {'in': null, 'out': null},
        'mouseup': {'in': null, 'out': null},
        'touchstart': {'in': 'click', 'out': 'clickout'}
    },

    /**
     * Property: feature
     * {<HGIS.Feature.Vector>} The last feature that was hovered.
     */
    feature: null,

    /**
     * Property: lastFeature
     * {<HGIS.Feature.Vector>} The last feature that was handled.
     */
    lastFeature: null,

    /**
     * Property: down
     * {<HGIS.Pixel>} The location of the last mousedown.
     */
    down: null,

    /**
     * Property: up
     * {<HGIS.Pixel>} The location of the last mouseup.
     */
    up: null,
    
    /**
     * Property: clickTolerance
     * {Number} The number of pixels the mouse can move between mousedown
     *     and mouseup for the event to still be considered a click.
     *     Dragging the map should not trigger the click and clickout callbacks
     *     unless the map is moved by less than this tolerance. Defaults to 4.
     */
    clickTolerance: 4,

    /**
     * Property: geometryTypes
     * To restrict dragging to a limited set of geometry types, send a list
     * of strings corresponding to the geometry class names.
     * 
     * @type Array(String)
     */
    geometryTypes: null,

    /**
     * Property: stopClick
     * {Boolean} If stopClick is set to true, handled clicks do not
     *      propagate to other click listeners. Otherwise, handled clicks
     *      do propagate. Unhandled clicks always propagate, whatever the
     *      value of stopClick. Defaults to true.
     */
    stopClick: true,

    /**
     * Property: stopDown
     * {Boolean} If stopDown is set to true, handled mousedowns do not
     *      propagate to other mousedown listeners. Otherwise, handled
     *      mousedowns do propagate. Unhandled mousedowns always propagate,
     *      whatever the value of stopDown. Defaults to true.
     */
    stopDown: true,

    /**
     * Property: stopUp
     * {Boolean} If stopUp is set to true, handled mouseups do not
     *      propagate to other mouseup listeners. Otherwise, handled mouseups
     *      do propagate. Unhandled mouseups always propagate, whatever the
     *      value of stopUp. Defaults to false.
     */
    stopUp: false,
    
    /**
     * Constructor: HGIS.Handler.Feature
     *
     * Parameters:
     * control - {<HGIS.Control>} 
     * layer - {<HGIS.Layer.Vector>}
     * callbacks - {Object} An object with a 'over' property whos value is
     *     a function to be called when the mouse is over a feature. The 
     *     callback should expect to recieve a single argument, the feature.
     * options - {Object} 
     */
    initialize: function(control, layer, callbacks, options) {
        HGIS.Handler.prototype.initialize.apply(this, [control, callbacks, options]);
        this.layer = layer;
    },

    /**
     * Method: touchstart
     * Handle touchstart events
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    touchstart: function(evt) {
        this.startTouch(); 
        return HGIS.Event.isMultiTouch(evt) ?
                true : this.mousedown(evt);
    },

    /**
     * Method: touchmove
     * Handle touchmove events. We just prevent the browser default behavior,
     *    for Android Webkit not to select text when moving the finger after
     *    selecting a feature.
     *
     * Parameters:
     * evt - {Event}
     */
    touchmove: function(evt) {
        HGIS.Event.preventDefault(evt);
    },

    /**
     * Method: mousedown
     * Handle mouse down.  Stop propagation if a feature is targeted by this
     *     event (stops map dragging during feature selection).
     * 
     * Parameters:
     * evt - {Event} 
     */
    mousedown: function(evt) {
        // Feature selection is only done with a left click. Other handlers may stop the
        // propagation of left-click mousedown events but not right-click mousedown events.
        // This mismatch causes problems when comparing the location of the down and up
        // events in the click function so it is important ignore right-clicks.
        if (HGIS.Event.isLeftClick(evt) || HGIS.Event.isSingleTouch(evt)) {
            this.down = evt.xy;
        }
        return this.handle(evt) ? !this.stopDown : true;
    },
    
    /**
     * Method: mouseup
     * Handle mouse up.  Stop propagation if a feature is targeted by this
     *     event.
     * 
     * Parameters:
     * evt - {Event} 
     */
    mouseup: function(evt) {
        this.up = evt.xy;
        return this.handle(evt) ? !this.stopUp : true;
    },

    /**
     * Method: click
     * Handle click.  Call the "click" callback if click on a feature,
     *     or the "clickout" callback if click outside any feature.
     * 
     * Parameters:
     * evt - {Event} 
     *
     * Returns:
     * {Boolean}
     */
    click: function(evt) {
        return this.handle(evt) ? !this.stopClick : true;
    },
        
    /**
     * Method: mousemove
     * Handle mouse moves.  Call the "over" callback if moving in to a feature,
     *     or the "out" callback if moving out of a feature.
     * 
     * Parameters:
     * evt - {Event} 
     *
     * Returns:
     * {Boolean}
     */
    mousemove: function(evt) {
        if (!this.callbacks['over'] && !this.callbacks['out']) {
            return true;
        }     
        this.handle(evt);
        return true;
    },
    
    /**
     * Method: dblclick
     * Handle dblclick.  Call the "dblclick" callback if dblclick on a feature.
     *
     * Parameters:
     * evt - {Event} 
     *
     * Returns:
     * {Boolean}
     */
    dblclick: function(evt) {
        return !this.handle(evt);
    },

    /**
     * Method: geometryTypeMatches
     * Return true if the geometry type of the passed feature matches
     *     one of the geometry types in the geometryTypes array.
     *
     * Parameters:
     * feature - {<HGIS.Vector.Feature>}
     *
     * Returns:
     * {Boolean}
     */
    geometryTypeMatches: function(feature) {
        return this.geometryTypes == null ||
            HGIS.Util.indexOf(this.geometryTypes,
                                    feature.geometry.CLASS_NAME) > -1;
    },

    /**
     * Method: handle
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} The event occurred over a relevant feature.
     */
    handle: function(evt) {
        if(this.feature && !this.feature.layer) {
            // feature has been destroyed
            this.feature = null;
        }
        var type = evt.type;
        var handled = false;
        var previouslyIn = !!(this.feature); // previously in a feature
        var click = (type == "click" || type == "dblclick" || type == "touchstart");
        this.feature = this.layer.getFeatureFromEvent(evt);
        if(this.feature && !this.feature.layer) {
            // feature has been destroyed
            this.feature = null;
        }
        if(this.lastFeature && !this.lastFeature.layer) {
            // last feature has been destroyed
            this.lastFeature = null;
        }
        if(this.feature) {
            if(type === "touchstart") {
                // stop the event to prevent Android Webkit from
                // "flashing" the map div
                HGIS.Event.preventDefault(evt);
            }
            var inNew = (this.feature != this.lastFeature);
            if(this.geometryTypeMatches(this.feature)) {
                // in to a feature
                if(previouslyIn && inNew) {
                    // out of last feature and in to another
                    if(this.lastFeature) {
                        this.triggerCallback(type, 'out', [this.lastFeature]);
                    }
                    this.triggerCallback(type, 'in', [this.feature]);
                } else if(!previouslyIn || click) {
                    // in feature for the first time
                    this.triggerCallback(type, 'in', [this.feature]);
                }
                this.lastFeature = this.feature;
                handled = true;
            } else {
                // not in to a feature
                if(this.lastFeature && (previouslyIn && inNew || click)) {
                    // out of last feature for the first time
                    this.triggerCallback(type, 'out', [this.lastFeature]);
                }
                // next time the mouse goes in a feature whose geometry type
                // doesn't match we don't want to call the 'out' callback
                // again, so let's set this.feature to null so that
                // previouslyIn will evaluate to false the next time
                // we enter handle. Yes, a bit hackish...
                this.feature = null;
            }
        } else if(this.lastFeature && (previouslyIn || click)) {
            this.triggerCallback(type, 'out', [this.lastFeature]);
        }
        return handled;
    },
    
    /**
     * Method: triggerCallback
     * Call the callback keyed in the event map with the supplied arguments.
     *     For click and clickout, the <clickTolerance> is checked first.
     *
     * Parameters:
     * type - {String}
     */
    triggerCallback: function(type, mode, args) {
        var key = this.EVENTMAP[type][mode];
        if(key) {
            if(type == 'click' && this.up && this.down) {
                // for click/clickout, only trigger callback if tolerance is met
                var dpx = Math.sqrt(
                    Math.pow(this.up.x - this.down.x, 2) +
                    Math.pow(this.up.y - this.down.y, 2)
                );
                if(dpx <= this.clickTolerance) {
                    this.callback(key, args);
                }
                // we're done with this set of events now: clear the cached
                // positions so we can't trip over them later (this can occur
                // if one of the up/down events gets eaten before it gets to us
                // but we still get the click)
                this.up = this.down = null;
            } else {
                this.callback(key, args);
            }
        }
    },

    /**
     * Method: activate 
     * Turn on the handler.  Returns false if the handler was already active.
     *
     * Returns:
     * {Boolean}
     */
    activate: function() {
        var activated = false;
        if(HGIS.Handler.prototype.activate.apply(this, arguments)) {
            this.moveLayerToTop();
            this.map.events.on({
                "removelayer": this.handleMapEvents,
                "changelayer": this.handleMapEvents,
                scope: this
            });
            activated = true;
        }
        return activated;
    },
    
    /**
     * Method: deactivate 
     * Turn off the handler.  Returns false if the handler was already active.
     *
     * Returns: 
     * {Boolean}
     */
    deactivate: function() {
        var deactivated = false;
        if(HGIS.Handler.prototype.deactivate.apply(this, arguments)) {
            this.moveLayerBack();
            this.feature = null;
            this.lastFeature = null;
            this.down = null;
            this.up = null;
            this.map.events.un({
                "removelayer": this.handleMapEvents,
                "changelayer": this.handleMapEvents,
                scope: this
            });
            deactivated = true;
        }
        return deactivated;
    },
    
    /**
     * Method: handleMapEvents
     * 
     * Parameters:
     * evt - {Object}
     */
    handleMapEvents: function(evt) {
        if (evt.type == "removelayer" || evt.property == "order") {
            this.moveLayerToTop();
        }
    },
    
    /**
     * Method: moveLayerToTop
     * Moves the layer for this handler to the top, so mouse events can reach
     * it.
     */
    moveLayerToTop: function() {
        var index = Math.max(this.map.Z_INDEX_BASE['Feature'] - 1,
            this.layer.getZIndex()) + 1;
        this.layer.setZIndex(index);
        
    },
    
    /**
     * Method: moveLayerBack
     * Moves the layer back to the position determined by the map's layers
     * array.
     */
    moveLayerBack: function() {
        var index = this.layer.getZIndex() - 1;
        if (index >= this.map.Z_INDEX_BASE['Feature']) {
            this.layer.setZIndex(index);
        } else {
            this.map.setLayerZIndex(this.layer,
                this.map.getLayerIndex(this.layer));
        }
    },

    CLASS_NAME: "HGIS.Handler.Feature"
});
/* ======================================================================
    HGIS/Layer/Vector/RootContainer.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer/Vector.js
 */

/**
 * Class: HGIS.Layer.Vector.RootContainer
 * A special layer type to combine multiple vector layers inside a single
 *     renderer root container. This class is not supposed to be instantiated
 *     from user space, it is a helper class for controls that require event
 *     processing for multiple vector layers.
 *
 * Inherits from:
 *  - <HGIS.Layer.Vector>
 */
HGIS.Layer.Vector.RootContainer = HGIS.Class(HGIS.Layer.Vector, {
    
    /**
     * Property: displayInLayerSwitcher
     * Set to false for this layer type
     */
    displayInLayerSwitcher: false,
    
    /**
     * APIProperty: layers
     * Layers that are attached to this container. Required config option.
     */
    layers: null,
    
    /**
     * Constructor: HGIS.Layer.Vector.RootContainer
     * Create a new root container for multiple vector layer. This constructor
     * is not supposed to be used from user space, it is only to be used by
     * controls that need feature selection across multiple vector layers.
     *
     * Parameters:
     * name - {String} A name for the layer
     * options - {Object} Optional object with non-default properties to set on
     *           the layer.
     * 
     * Required options properties:
     * layers - {Array(<HGIS.Layer.Vector>)} The layers managed by this
     *     container
     *
     * Returns:
     * {<HGIS.Layer.Vector.RootContainer>} A new vector layer root
     *     container
     */
    
    /**
     * Method: display
     */
    display: function() {},
    
    /**
     * Method: getFeatureFromEvent
     * walk through the layers to find the feature returned by the event
     * 
     * Parameters:
     * evt - {Object} event object with a feature property
     * 
     * Returns:
     * {<HGIS.Feature.Vector>}
     */
    getFeatureFromEvent: function(evt) {
        var layers = this.layers;
        var feature;
        for(var i=0; i<layers.length; i++) {
            feature = layers[i].getFeatureFromEvent(evt);
            if(feature) {
                return feature;
            }
        }
    },
    
    /**
     * Method: setMap
     * 
     * Parameters:
     * map - {<HGIS.Map>}
     */
    setMap: function(map) {
        HGIS.Layer.Vector.prototype.setMap.apply(this, arguments);
        this.collectRoots();
        map.events.register("changelayer", this, this.handleChangeLayer);
    },
    
    /**
     * Method: removeMap
     * 
     * Parameters:
     * map - {<HGIS.Map>}
     */
    removeMap: function(map) {
        map.events.unregister("changelayer", this, this.handleChangeLayer);
        this.resetRoots();
        HGIS.Layer.Vector.prototype.removeMap.apply(this, arguments);
    },
    
    /**
     * Method: collectRoots
     * Collects the root nodes of all layers this control is configured with
     * and moveswien the nodes to this control's layer
     */
    collectRoots: function() {
        var layer;
        // walk through all map layers, because we want to keep the order
        for(var i=0; i<this.map.layers.length; ++i) {
            layer = this.map.layers[i];
            if(HGIS.Util.indexOf(this.layers, layer) != -1) {
                layer.renderer.moveRoot(this.renderer);
            }
        }
    },
    
    /**
     * Method: resetRoots
     * Resets the root nodes back into the layers they belong to.
     */
    resetRoots: function() {
        var layer;
        for(var i=0; i<this.layers.length; ++i) {
            layer = this.layers[i];
            if(this.renderer && layer.renderer.getRenderLayerId() == this.id) {
                this.renderer.moveRoot(layer.renderer);
            }
        }
    },
    
    /**
     * Method: handleChangeLayer
     * Event handler for the map's changelayer event. We need to rebuild
     * this container's layer dom if order of one of its layers changes.
     * This handler is added with the setMap method, and removed with the
     * removeMap method.
     * 
     * Parameters:
     * evt - {Object}
     */
    handleChangeLayer: function(evt) {
        var layer = evt.layer;
        if(evt.property == "order" &&
                        HGIS.Util.indexOf(this.layers, layer) != -1) {
            this.resetRoots();
            this.collectRoots();
        }
    },

    CLASS_NAME: "HGIS.Layer.Vector.RootContainer"
});
/* ======================================================================
    HGIS/Control/SelectFeature.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Control.js
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Handler/Feature.js
 * @requires HGIS/Layer/Vector/RootContainer.js
 */

/**
 * Class: HGIS.Control.SelectFeature
 * The SelectFeature control selects vector features from a given layer on 
 * click or hover. 
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.SelectFeature = HGIS.Class(HGIS.Control, {

    /** 
     * APIProperty: events
     * {<HGIS.Events>} Events instance for listeners and triggering
     *     control specific events.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types (in addition to those from <HGIS.Control.events>):
     * beforefeaturehighlighted - Triggered before a feature is highlighted
     * featurehighlighted - Triggered when a feature is highlighted
     * featureunhighlighted - Triggered when a feature is unhighlighted
     * boxselectionstart - Triggered before box selection starts
     * boxselectionend - Triggered after box selection ends
     */
    
    /**
     * Property: multipleKey
     * {String} An event modifier ('altKey' or 'shiftKey') that temporarily sets
     *     the <multiple> property to true.  Default is null.
     */
    multipleKey: null,
    
    /**
     * Property: toggleKey
     * {String} An event modifier ('altKey' or 'shiftKey') that temporarily sets
     *     the <toggle> property to true.  Default is null.
     */
    toggleKey: null,
    
    /**
     * APIProperty: multiple
     * {Boolean} Allow selection of multiple geometries.  Default is false.
     */
    multiple: false, 

    /**
     * APIProperty: clickout
     * {Boolean} Unselect features when clicking outside any feature.
     *     Default is true.
     */
    clickout: true,

    /**
     * APIProperty: toggle
     * {Boolean} Unselect a selected feature on click.  Default is false.  Only
     *     has meaning if hover is false.
     */
    toggle: false,

    /**
     * APIProperty: hover
     * {Boolean} Select on mouse over and deselect on mouse out.  If true, this
     * ignores clicks and only listens to mouse moves.
     */
    hover: false,

    /**
     * APIProperty: highlightOnly
     * {Boolean} If true do not actually select features (that is place them in 
     * the layer's selected features array), just highlight them. This property
     * has no effect if hover is false. Defaults to false.
     */
    highlightOnly: false,
    
    /**
     * APIProperty: box
     * {Boolean} Allow feature selection by drawing a box.
     */
    box: false,
    
    /**
     * Property: onBeforeSelect 
     * {Function} Optional function to be called before a feature is selected.
     *     The function should expect to be called with a feature.
     */
    onBeforeSelect: function() {},
    
    /**
     * APIProperty: onSelect 
     * {Function} Optional function to be called when a feature is selected.
     *     The function should expect to be called with a feature.
     */
    onSelect: function() {},

    /**
     * APIProperty: onUnselect
     * {Function} Optional function to be called when a feature is unselected.
     *     The function should expect to be called with a feature.
     */
    onUnselect: function() {},
    
    /**
     * Property: scope
     * {Object} The scope to use with the onBeforeSelect, onSelect, onUnselect
     *     callbacks. If null the scope will be this control.
     */
    scope: null,

    /**
     * APIProperty: geometryTypes
     * {Array(String)} To restrict selecting to a limited set of geometry types,
     *     send a list of strings corresponding to the geometry class names.
     */
    geometryTypes: null,

    /**
     * Property: layer
     * {<HGIS.Layer.Vector>} The vector layer with a common renderer
     * root for all layers this control is configured with (if an array of
     * layers was passed to the constructor), or the vector layer the control
     * was configured with (if a single layer was passed to the constructor).
     */
    layer: null,
    
    /**
     * Property: layers
     * {Array(<HGIS.Layer.Vector>)} The layers this control will work on,
     * or null if the control was configured with a single layer
     */
    layers: null,
    
    /**
     * APIProperty: callbacks
     * {Object} The functions that are sent to the handlers.feature for callback
     */
    callbacks: null,
    
    /**
     * APIProperty: selectStyle 
     * {Object} Hash of styles
     */
    selectStyle: null,
    
    /**
     * Property: renderIntent
     * {String} key used to retrieve the select style from the layer's
     * style map.
     */
    renderIntent: "select",

    /**
     * Property: handlers
     * {Object} Object with references to multiple <HGIS.Handler>
     *     instances.
     */
    handlers: null,

    /**
     * Constructor: HGIS.Control.SelectFeature
     * Create a new control for selecting features.
     *
     * Parameters:
     * layers - {<HGIS.Layer.Vector>}, or an array of vector layers. The
     *     layer(s) this control will select features from.
     * options - {Object} 
     */
    initialize: function(layers, options) {
        HGIS.Control.prototype.initialize.apply(this, [options]);
        
        if(this.scope === null) {
            this.scope = this;
        }
        this.initLayer(layers);
        var callbacks = {
            click: this.clickFeature,
            clickout: this.clickoutFeature
        };
        if (this.hover) {
            callbacks.over = this.overFeature;
            callbacks.out = this.outFeature;
        }
             
        this.callbacks = HGIS.Util.extend(callbacks, this.callbacks);
        this.handlers = {
            feature: new HGIS.Handler.Feature(
                this, this.layer, this.callbacks,
                {geometryTypes: this.geometryTypes}
            )
        };

        if (this.box) {
            this.handlers.box = new HGIS.Handler.Box(
                this, {done: this.selectBox},
                {boxDivClassName: "olHandlerBoxSelectFeature"}
            ); 
        }
    },

    /**
     * Method: initLayer
     * Assign the layer property. If layers is an array, we need to use
     *     a RootContainer.
     *
     * Parameters:
     * layers - {<HGIS.Layer.Vector>}, or an array of vector layers.
     */
    initLayer: function(layers) {
        if(HGIS.Util.isArray(layers)) {
            this.layers = layers;
            this.layer = new HGIS.Layer.Vector.RootContainer(
                this.id + "_container", {
                    layers: layers
                }
            );
        } else {
            this.layer = layers;
        }
    },
    
    /**
     * Method: destroy
     */
    destroy: function() {
        if(this.active && this.layers) {
            this.map.removeLayer(this.layer);
        }
        HGIS.Control.prototype.destroy.apply(this, arguments);
        if(this.layers) {
            this.layer.destroy();
        }
    },

    /**
     * Method: activate
     * Activates the control.
     * 
     * Returns:
     * {Boolean} The control was effectively activated.
     */
    activate: function () {
        if (!this.active) {
            if(this.layers) {
                this.map.addLayer(this.layer);
            }
            this.handlers.feature.activate();
            if(this.box && this.handlers.box) {
                this.handlers.box.activate();
            }
        }
        return HGIS.Control.prototype.activate.apply(
            this, arguments
        );
    },

    /**
     * Method: deactivate
     * Deactivates the control.
     * 
     * Returns:
     * {Boolean} The control was effectively deactivated.
     */
    deactivate: function () {
        if (this.active) {
            this.handlers.feature.deactivate();
            if(this.handlers.box) {
                this.handlers.box.deactivate();
            }
            if(this.layers) {
                this.map.removeLayer(this.layer);
            }
        }
        return HGIS.Control.prototype.deactivate.apply(
            this, arguments
        );
    },

    /**
     * Method: unselectAll
     * Unselect all selected features.  To unselect all except for a single
     *     feature, set the options.except property to the feature.
     *
     * Parameters:
     * options - {Object} Optional configuration object.
     */
    unselectAll: function(options) {
        // we'll want an option to supress notification here
        var layers = this.layers || [this.layer],
            layer, feature, l, numExcept;
        for(l=0; l<layers.length; ++l) {
            layer = layers[l];
            numExcept = 0;
            //layer.selectedFeatures is null when layer is destroyed and 
            //one of it's preremovelayer listener calls setLayer 
            //with another layer on this control
            if(layer.selectedFeatures != null) {
                while(layer.selectedFeatures.length > numExcept) {
                    feature = layer.selectedFeatures[numExcept];
                    if(!options || options.except != feature) {
                        this.unselect(feature);
                    } else {
                        ++numExcept;
                    }
                }
            }
        }
    },

    /**
     * Method: clickFeature
     * Called on click in a feature
     * Only responds if this.hover is false.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} 
     */
    clickFeature: function(feature) {
        if(!this.hover) {
            var selected = (HGIS.Util.indexOf(
                feature.layer.selectedFeatures, feature) > -1);
            if(selected) {
                if(this.toggleSelect()) {
                    this.unselect(feature);
                } else if(!this.multipleSelect()) {
                    this.unselectAll({except: feature});
                }
            } else {
                if(!this.multipleSelect()) {
                    this.unselectAll({except: feature});
                }
                this.select(feature);
            }
        }
    },

    /**
     * Method: multipleSelect
     * Allow for multiple selected features based on <multiple> property and
     *     <multipleKey> event modifier.
     *
     * Returns:
     * {Boolean} Allow for multiple selected features.
     */
    multipleSelect: function() {
        return this.multiple || (this.handlers.feature.evt &&
                                 this.handlers.feature.evt[this.multipleKey]);
    },
    
    /**
     * Method: toggleSelect
     * Event should toggle the selected state of a feature based on <toggle>
     *     property and <toggleKey> event modifier.
     *
     * Returns:
     * {Boolean} Toggle the selected state of a feature.
     */
    toggleSelect: function() {
        return this.toggle || (this.handlers.feature.evt &&
                               this.handlers.feature.evt[this.toggleKey]);
    },

    /**
     * Method: clickoutFeature
     * Called on click outside a previously clicked (selected) feature.
     * Only responds if this.hover is false.
     *
     * Parameters:
     * feature - {<HGIS.Vector.Feature>} 
     */
    clickoutFeature: function(feature) {
        if(!this.hover && this.clickout) {
            this.unselectAll();
        }
    },

    /**
     * Method: overFeature
     * Called on over a feature.
     * Only responds if this.hover is true.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} 
     */
    overFeature: function(feature) {
        var layer = feature.layer;
        if(this.hover) {
            if(this.highlightOnly) {
                this.highlight(feature);
            } else if(HGIS.Util.indexOf(
                layer.selectedFeatures, feature) == -1) {
                this.select(feature);
            }
        }
    },

    /**
     * Method: outFeature
     * Called on out of a selected feature.
     * Only responds if this.hover is true.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} 
     */
    outFeature: function(feature) {
        if(this.hover) {
            if(this.highlightOnly) {
                // we do nothing if we're not the last highlighter of the
                // feature
                if(feature._lastHighlighter == this.id) {
                    // if another select control had highlighted the feature before
                    // we did it ourself then we use that control to highlight the
                    // feature as it was before we highlighted it, else we just
                    // unhighlight it
                    if(feature._prevHighlighter &&
                       feature._prevHighlighter != this.id) {
                        delete feature._lastHighlighter;
                        var control = this.map.getControl(
                            feature._prevHighlighter);
                        if(control) {
                            control.highlight(feature);
                        }
                    } else {
                        this.unhighlight(feature);
                    }
                }
            } else {
                this.unselect(feature);
            }
        }
    },

    /**
     * Method: highlight
     * Redraw feature with the select style.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} 
     */
    highlight: function(feature) {
        var layer = feature.layer;
        var cont = this.events.triggerEvent("beforefeaturehighlighted", {
            feature : feature
        });
        if(cont !== false) {
            feature._prevHighlighter = feature._lastHighlighter;
            feature._lastHighlighter = this.id;
            var style = this.selectStyle || this.renderIntent;
            layer.drawFeature(feature, style);
            this.events.triggerEvent("featurehighlighted", {feature : feature});
        }
    },

    /**
     * Method: unhighlight
     * Redraw feature with the "default" style
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} 
     */
    unhighlight: function(feature) {
        var layer = feature.layer;
        // three cases:
        // 1. there's no other highlighter, in that case _prev is undefined,
        //    and we just need to undef _last
        // 2. another control highlighted the feature after we did it, in
        //    that case _last references this other control, and we just
        //    need to undef _prev
        // 3. another control highlighted the feature before we did it, in
        //    that case _prev references this other control, and we need to
        //    set _last to _prev and undef _prev
        if(feature._prevHighlighter == undefined) {
            delete feature._lastHighlighter;
        } else if(feature._prevHighlighter == this.id) {
            delete feature._prevHighlighter;
        } else {
            feature._lastHighlighter = feature._prevHighlighter;
            delete feature._prevHighlighter;
        }
        layer.drawFeature(feature, feature.style || feature.layer.style ||
            "default");
        this.events.triggerEvent("featureunhighlighted", {feature : feature});
    },
    
    /**
     * Method: select
     * Add feature to the layer's selectedFeature array, render the feature as
     * selected, and call the onSelect function.
     * 
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} 
     */
    select: function(feature) {
        var cont = this.onBeforeSelect.call(this.scope, feature);
        var layer = feature.layer;
        if(cont !== false) {
            cont = layer.events.triggerEvent("beforefeatureselected", {
                feature: feature
            });
            if(cont !== false) {
                layer.selectedFeatures.push(feature);
                this.highlight(feature);
                // if the feature handler isn't involved in the feature
                // selection (because the box handler is used or the
                // feature is selected programatically) we fake the
                // feature handler to allow unselecting on click
                if(!this.handlers.feature.lastFeature) {
                    this.handlers.feature.lastFeature = layer.selectedFeatures[0];
                }
                layer.events.triggerEvent("featureselected", {feature: feature});
                this.onSelect.call(this.scope, feature);
            }
        }
    },

    /**
     * Method: unselect
     * Remove feature from the layer's selectedFeature array, render the feature as
     * normal, and call the onUnselect function.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     */
    unselect: function(feature) {
        var layer = feature.layer;
        // Store feature style for restoration later
        this.unhighlight(feature);
        HGIS.Util.removeItem(layer.selectedFeatures, feature);
        layer.events.triggerEvent("featureunselected", {feature: feature});
        this.onUnselect.call(this.scope, feature);
    },
    
    /**
     * Method: selectBox
     * Callback from the handlers.box set up when <box> selection is true
     *     on.
     *
     * Parameters:
     * position - {<HGIS.Bounds> || <HGIS.Pixel> }  
     */
    selectBox: function(position) {
        if (position instanceof HGIS.Bounds) {
            var minXY = this.map.getLonLatFromPixel({
                x: position.left,
                y: position.bottom
            });
            var maxXY = this.map.getLonLatFromPixel({
                x: position.right,
                y: position.top
            });
            var bounds = new HGIS.Bounds(
                minXY.lon, minXY.lat, maxXY.lon, maxXY.lat
            );
            
            // if multiple is false, first deselect currently selected features
            if (!this.multipleSelect()) {
                this.unselectAll();
            }
            
            // because we're using a box, we consider we want multiple selection
            var prevMultiple = this.multiple;
            this.multiple = true;
            var layers = this.layers || [this.layer];
            this.events.triggerEvent("boxselectionstart", {layers: layers}); 
            var layer;
            for(var l=0; l<layers.length; ++l) {
                layer = layers[l];
                for(var i=0, len = layer.features.length; i<len; ++i) {
                    var feature = layer.features[i];
                    // check if the feature is displayed
                    if (!feature.getVisibility()) {
                        continue;
                    }

                    if (this.geometryTypes == null || HGIS.Util.indexOf(
                            this.geometryTypes, feature.geometry.CLASS_NAME) > -1) {
                        if (bounds.toGeometry().intersects(feature.geometry)) {
                            if (HGIS.Util.indexOf(layer.selectedFeatures, feature) == -1) {
                                this.select(feature);
                            }
                        }
                    }
                }
            }
            this.multiple = prevMultiple;
            this.events.triggerEvent("boxselectionend", {layers: layers}); 
        }
    },

    /** 
     * Method: setMap
     * Set the map property for the control. 
     * 
     * Parameters:
     * map - {<HGIS.Map>} 
     */
    setMap: function(map) {
        this.handlers.feature.setMap(map);
        if (this.box) {
            this.handlers.box.setMap(map);
        }
        HGIS.Control.prototype.setMap.apply(this, arguments);
    },
    
    /**
     * APIMethod: setLayer
     * Attach a new layer to the control, overriding any existing layers.
     *
     * Parameters:
     * layers - Array of {<HGIS.Layer.Vector>} or a single
     *     {<HGIS.Layer.Vector>}
     */
    setLayer: function(layers) {
        var isActive = this.active;
        this.unselectAll();
        this.deactivate();
        if(this.layers) {
            this.layer.destroy();
            this.layers = null;
        }
        this.initLayer(layers);
        this.handlers.feature.layer = this.layer;
        if (isActive) {
            this.activate();
        }
    },
    
    CLASS_NAME: "HGIS.Control.SelectFeature"
});
/* ======================================================================
    HGIS/Handler/Point.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Handler.js
 * @requires HGIS/Geometry/Point.js
 */

/**
 * Class: HGIS.Handler.Point
 * Handler to draw a point on the map. Point is displayed on activation,
 *     moves on mouse move, and is finished on mouse up. The handler triggers
 *     callbacks for 'done', 'cancel', and 'modify'. The modify callback is
 *     called with each change in the sketch and will receive the latest point
 *     drawn.  Create a new instance with the <HGIS.Handler.Point>
 *     constructor.
 * 
 * Inherits from:
 *  - <HGIS.Handler>
 */
HGIS.Handler.Point = HGIS.Class(HGIS.Handler, {
    
    /**
     * Property: point
     * {<HGIS.Feature.Vector>} The currently drawn point
     */
    point: null,

    /**
     * Property: layer
     * {<HGIS.Layer.Vector>} The temporary drawing layer
     */
    layer: null,
    
    /**
     * APIProperty: multi
     * {Boolean} Cast features to multi-part geometries before passing to the
     *     layer.  Default is false.
     */
    multi: false,
    
    /**
     * APIProperty: citeCompliant
     * {Boolean} If set to true, coordinates of features drawn in a map extent
     * crossing the date line won't exceed the world bounds. Default is false.
     */
    citeCompliant: false,
    
    /**
     * Property: mouseDown
     * {Boolean} The mouse is down
     */
    mouseDown: false,

    /**
     * Property: stoppedDown
     * {Boolean} Indicate whether the last mousedown stopped the event
     * propagation.
     */
    stoppedDown: null,

    /**
     * Property: lastDown
     * {<HGIS.Pixel>} Location of the last mouse down
     */
    lastDown: null,

    /**
     * Property: lastUp
     * {<HGIS.Pixel>}
     */
    lastUp: null,

    /**
     * APIProperty: persist
     * {Boolean} Leave the feature rendered until destroyFeature is called.
     *     Default is false.  If set to true, the feature remains rendered until
     *     destroyFeature is called, typically by deactivating the handler or
     *     starting another drawing.
     */
    persist: false,

    /**
     * APIProperty: stopDown
     * {Boolean} Stop event propagation on mousedown. Must be false to
     *     allow "pan while drawing". Defaults to false.
     */
    stopDown: false,

    /**
     * APIPropery: stopUp
     * {Boolean} Stop event propagation on mouse. Must be false to
     *     allow "pan while dragging". Defaults to fase.
     */
    stopUp: false,

    /**
     * Property: layerOptions
     * {Object} Any optional properties to be set on the sketch layer.
     */
    layerOptions: null,
    
    /**
     * APIProperty: pixelTolerance
     * {Number} Maximum number of pixels between down and up (mousedown
     *     and mouseup, or touchstart and touchend) for the handler to
     *     add a new point. If set to an integer value, if the
     *     displacement between down and up is great to this value
     *     no point will be added. Default value is 5.
     */
    pixelTolerance: 5,

    /**
     * Property: lastTouchPx
     * {<HGIS.Pixel>} The last pixel used to know the distance between
     * two touches (for double touch).
     */
    lastTouchPx: null,

    /**
     * Constructor: HGIS.Handler.Point
     * Create a new point handler.
     *
     * Parameters:
     * control - {<HGIS.Control>} The control that owns this handler
     * callbacks - {Object} An object with a properties whose values are
     *     functions.  Various callbacks described below.
     * options - {Object} An optional object with properties to be set on the
     *           handler
     *
     * Named callbacks:
     * create - Called when a sketch is first created.  Callback called with
     *     the creation point geometry and sketch feature.
     * modify - Called with each move of a vertex with the vertex (point)
     *     geometry and the sketch feature.
     * done - Called when the point drawing is finished.  The callback will
     *     recieve a single argument, the point geometry.
     * cancel - Called when the handler is deactivated while drawing.  The
     *     cancel callback will receive a geometry.
     */
    initialize: function(control, callbacks, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = HGIS.Util.extend(HGIS.Feature.Vector.style['default'], {});
        }

        HGIS.Handler.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: activate
     * turn on the handler
     */
    activate: function() {
        if(!HGIS.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
        // create temporary vector layer for rendering geometry sketch
        // TBD: this could be moved to initialize/destroy - setting visibility here
        var options = HGIS.Util.extend({
            displayInLayerSwitcher: false,
            // indicate that the temp vector layer will never be out of range
            // without this, resolution properties must be specified at the
            // map-level for this temporary layer to init its resolutions
            // correctly
            calculateInRange: HGIS.Function.True,
            wrapDateLine: this.citeCompliant
        }, this.layerOptions);
        this.layer = new HGIS.Layer.Vector(this.CLASS_NAME, options);
        this.map.addLayer(this.layer);
        return true;
    },
    
    /**
     * Method: createFeature
     * Add temporary features
     *
     * Parameters:
     * pixel - {<HGIS.Pixel>} A pixel location on the map.
     */
    createFeature: function(pixel) {
        var lonlat = this.layer.getLonLatFromViewPortPx(pixel); 
        var geometry = new HGIS.Geometry.Point(
            lonlat.lon, lonlat.lat
        );
        this.point = new HGIS.Feature.Vector(geometry);
        this.callback("create", [this.point.geometry, this.point]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.point], {silent: true});
    },

    /**
     * APIMethod: deactivate
     * turn off the handler
     */
    deactivate: function() {
        if(!HGIS.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        this.cancel();
        // If a layer's map property is set to null, it means that that layer
        // isn't added to the map. Since we ourself added the layer to the map
        // in activate(), we can assume that if this.layer.map is null it means
        // that the layer has been destroyed (as a result of map.destroy() for
        // example.
        if (this.layer.map != null) {
            this.destroyFeature(true);
            this.layer.destroy(false);
        }
        this.layer = null;
        return true;
    },
    
    /**
     * Method: destroyFeature
     * Destroy the temporary geometries
     *
     * Parameters:
     * force - {Boolean} Destroy even if persist is true.
     */
    destroyFeature: function(force) {
        if(this.layer && (force || !this.persist)) {
            this.layer.destroyFeatures();
        }
        this.point = null;
    },

    /**
     * Method: destroyPersistedFeature
     * Destroy the persisted feature.
     */
    destroyPersistedFeature: function() {
        var layer = this.layer;
        if(layer && layer.features.length > 1) {
            this.layer.features[0].destroy();
        }
    },

    /**
     * Method: finalize
     * Finish the geometry and call the "done" callback.
     *
     * Parameters:
     * cancel - {Boolean} Call cancel instead of done callback.  Default
     *          is false.
     */
    finalize: function(cancel) {
        var key = cancel ? "cancel" : "done";
        this.mouseDown = false;
        this.lastDown = null;
        this.lastUp = null;
        this.lastTouchPx = null;
        this.callback(key, [this.geometryClone()]);
        this.destroyFeature(cancel);
    },

    /**
     * APIMethod: cancel
     * Finish the geometry and call the "cancel" callback.
     */
    cancel: function() {
        this.finalize(true);
    },

    /**
     * Method: click
     * Handle clicks.  Clicks are stopped from propagating to other listeners
     *     on map.events or other dom elements.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    click: function(evt) {
        HGIS.Event.stop(evt);
        return false;
    },

    /**
     * Method: dblclick
     * Handle double-clicks.  Double-clicks are stopped from propagating to other
     *     listeners on map.events or other dom elements.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    dblclick: function(evt) {
        HGIS.Event.stop(evt);
        return false;
    },
    
    /**
     * Method: modifyFeature
     * Modify the existing geometry given a pixel location.
     *
     * Parameters:
     * pixel - {<HGIS.Pixel>} A pixel location on the map.
     */
    modifyFeature: function(pixel) {
        if(!this.point) {
            this.createFeature(pixel);
        }
        var lonlat = this.layer.getLonLatFromViewPortPx(pixel); 
        this.point.geometry.x = lonlat.lon;
        this.point.geometry.y = lonlat.lat;
        this.callback("modify", [this.point.geometry, this.point, false]);
        this.point.geometry.clearBounds();
        this.drawFeature();
    },

    /**
     * Method: drawFeature
     * Render features on the temporary layer.
     */
    drawFeature: function() {
        this.layer.drawFeature(this.point, this.style);
    },
    
    /**
     * Method: getGeometry
     * Return the sketch geometry.  If <multi> is true, this will return
     *     a multi-part geometry.
     *
     * Returns:
     * {<HGIS.Geometry.Point>}
     */
    getGeometry: function() {
        var geometry = this.point && this.point.geometry;
        if(geometry && this.multi) {
            geometry = new HGIS.Geometry.MultiPoint([geometry]);
        }
        return geometry;
    },

    /**
     * Method: geometryClone
     * Return a clone of the relevant geometry.
     *
     * Returns:
     * {<HGIS.Geometry>}
     */
    geometryClone: function() {
        var geom = this.getGeometry();
        return geom && geom.clone();
    },

    /**
     * Method: mousedown
     * Handle mousedown.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    mousedown: function(evt) {
        return this.down(evt);
    },

    /**
     * Method: touchstart
     * Handle touchstart.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    touchstart: function(evt) {
        this.startTouch();
        this.lastTouchPx = evt.xy;
        return this.down(evt);
    },

    /**
     * Method: mousemove
     * Handle mousemove.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    mousemove: function(evt) {
        return this.move(evt);
    },

    /**
     * Method: touchmove
     * Handle touchmove.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    touchmove: function(evt) {
        this.lastTouchPx = evt.xy;
        return this.move(evt);
    },

    /**
     * Method: mouseup
     * Handle mouseup.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    mouseup: function(evt) {
        return this.up(evt);
    },

    /**
     * Method: touchend
     * Handle touchend.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    touchend: function(evt) {
        evt.xy = this.lastTouchPx;
        return this.up(evt);
    },
  
    /**
     * Method: down
     * Handle mousedown and touchstart.  Adjust the geometry and redraw.
     * Return determines whether to propagate the event on the map.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    down: function(evt) {
        this.mouseDown = true;
        this.lastDown = evt.xy;
        if(!this.touch) { // no point displayed until up on touch devices
            this.modifyFeature(evt.xy);
        }
        this.stoppedDown = this.stopDown;
        return !this.stopDown;
    },

    /**
     * Method: move
     * Handle mousemove and touchmove.  Adjust the geometry and redraw.
     * Return determines whether to propagate the event on the map.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    move: function (evt) {
        if(!this.touch // no point displayed until up on touch devices
           && (!this.mouseDown || this.stoppedDown)) {
            this.modifyFeature(evt.xy);
        }
        return true;
    },

    /**
     * Method: up
     * Handle mouseup and touchend.  Send the latest point in the geometry to the control.
     * Return determines whether to propagate the event on the map.
     *
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    up: function (evt) {
        this.mouseDown = false;
        this.stoppedDown = this.stopDown;

        // check keyboard modifiers
        if(!this.checkModifiers(evt)) {
            return true;
        }
        // ignore double-clicks
        if (this.lastUp && this.lastUp.equals(evt.xy)) {
            return true;
        }
        if (this.lastDown && this.passesTolerance(this.lastDown, evt.xy,
                                                  this.pixelTolerance)) {
            if (this.touch) {
                this.modifyFeature(evt.xy);
            }
            if(this.persist) {
                this.destroyPersistedFeature();
            }
            this.lastUp = evt.xy;
            this.finalize();
            return !this.stopUp;
        } else {
            return true;
        }
    },

    /**
     * Method: mouseout
     * Handle mouse out.  For better user experience reset mouseDown
     * and stoppedDown when the mouse leaves the map viewport.
     *
     * Parameters:
     * evt - {Event} The browser event
     */
    mouseout: function(evt) {
        if(HGIS.Util.mouseLeft(evt, this.map.viewPortDiv)) {
            this.stoppedDown = this.stopDown;
            this.mouseDown = false;
        }
    },

    /**
     * Method: passesTolerance
     * Determine whether the event is within the optional pixel tolerance.
     *
     * Returns:
     * {Boolean} The event is within the pixel tolerance (if specified).
     */
    passesTolerance: function(pixel1, pixel2, tolerance) {
        var passes = true;

        if (tolerance != null && pixel1 && pixel2) {
            var dist = pixel1.distanceTo(pixel2);
            if (dist > tolerance) {
                passes = false;
            }
        }
        return passes;
    },
    
    CLASS_NAME: "HGIS.Handler.Point"
});
/* ======================================================================
    HGIS/Handler/Path.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Handler/Point.js
 * @requires HGIS/Geometry/Point.js
 * @requires HGIS/Geometry/LineString.js
 */

/**
 * Class: HGIS.Handler.Path
 * Handler to draw a path on the map.  Path is displayed on mouse down,
 * moves on mouse move, and is finished on mouse up.
 *
 * Inherits from:
 *  - <HGIS.Handler.Point>
 */
HGIS.Handler.Path = HGIS.Class(HGIS.Handler.Point, {
    
    /**
     * Property: line
     * {<HGIS.Feature.Vector>}
     */
    line: null,

    /**
     * APIProperty: maxVertices
     * {Number} The maximum number of vertices which can be drawn by this
     * handler. When the number of vertices reaches maxVertices, the
     * geometry is automatically finalized. Default is null.
     */
    maxVertices: null,

    /**
     * Property: doubleTouchTolerance
     * {Number} Maximum number of pixels between two touches for
     *     the gesture to be considered a "finalize feature" action.
     *     Default is 20.
     */
    doubleTouchTolerance: 20,

    /**
     * Property: freehand
     * {Boolean} In freehand mode, the handler starts the path on mouse down,
     * adds a point for every mouse move, and finishes the path on mouse up.
     * Outside of freehand mode, a point is added to the path on every mouse
     * click and double-click finishes the path.
     */
    freehand: false,
    
    /**
     * Property: freehandToggle
     * {String} If set, freehandToggle is checked on mouse events and will set
     * the freehand mode to the opposite of this.freehand.  To disallow
     * toggling between freehand and non-freehand mode, set freehandToggle to
     * null.  Acceptable toggle values are 'shiftKey', 'ctrlKey', and 'altKey'.
     */
    freehandToggle: 'shiftKey',

    /**
     * Property: timerId
     * {Integer} The timer used to test the double touch.
     */
    timerId: null,

    /**
     * Property: redoStack
     * {Array} Stack containing points removed with <undo>.
     */
    redoStack: null,

    /**
     * Constructor: HGIS.Handler.Path
     * Create a new path hander
     *
     * Parameters:
     * control - {<HGIS.Control>} The control that owns this handler
     * callbacks - {Object} An object with a properties whose values are
     *     functions.  Various callbacks described below.
     * options - {Object} An optional object with properties to be set on the
     *           handler
     *
     * Named callbacks:
     * create - Called when a sketch is first created.  Callback called with
     *     the creation point geometry and sketch feature.
     * modify - Called with each move of a vertex with the vertex (point)
     *     geometry and the sketch feature.
     * point - Called as each point is added.  Receives the new point geometry.
     * done - Called when the point drawing is finished.  The callback will
     *     recieve a single argument, the linestring geometry.
     * cancel - Called when the handler is deactivated while drawing.  The
     *     cancel callback will receive a geometry.
     */

    /**
     * Method: createFeature
     * Add temporary geometries
     *
     * Parameters:
     * pixel - {<HGIS.Pixel>} The initial pixel location for the new
     *     feature.
     */
    createFeature: function(pixel) {
        var lonlat = this.layer.getLonLatFromViewPortPx(pixel); 
        var geometry = new HGIS.Geometry.Point(
            lonlat.lon, lonlat.lat
        );
        this.point = new HGIS.Feature.Vector(geometry);
        this.line = new HGIS.Feature.Vector(
            new HGIS.Geometry.LineString([this.point.geometry])
        );
        this.callback("create", [this.point.geometry, this.getSketch()]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.line, this.point], {silent: true});
    },
        
    /**
     * Method: destroyFeature
     * Destroy temporary geometries
     *
     * Parameters:
     * force - {Boolean} Destroy even if persist is true.
     */
    destroyFeature: function(force) {
        HGIS.Handler.Point.prototype.destroyFeature.call(
            this, force);
        this.line = null;
    },

    /**
     * Method: destroyPersistedFeature
     * Destroy the persisted feature.
     */
    destroyPersistedFeature: function() {
        var layer = this.layer;
        if(layer && layer.features.length > 2) {
            this.layer.features[0].destroy();
        }
    },

    /**
     * Method: removePoint
     * Destroy the temporary point.
     */
    removePoint: function() {
        if(this.point) {
            this.layer.removeFeatures([this.point]);
        }
    },
    
    /**
     * Method: addPoint
     * Add point to geometry.  Send the point index to override
     * the behavior of LinearRing that disregards adding duplicate points.
     *
     * Parameters:
     * pixel - {<HGIS.Pixel>} The pixel location for the new point.
     */
    addPoint: function(pixel) {
        this.layer.removeFeatures([this.point]);
        var lonlat = this.layer.getLonLatFromViewPortPx(pixel); 
        this.point = new HGIS.Feature.Vector(
            new HGIS.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        this.line.geometry.addComponent(
            this.point.geometry, this.line.geometry.components.length
        );
        this.layer.addFeatures([this.point]);
        this.callback("point", [this.point.geometry, this.getGeometry()]);
        this.callback("modify", [this.point.geometry, this.getSketch()]);
        this.drawFeature();
        delete this.redoStack;
    },
    
    /**
     * Method: insertXY
     * Insert a point in the current sketch given x & y coordinates.  The new
     *     point is inserted immediately before the most recently drawn point.
     *
     * Parameters:
     * x - {Number} The x-coordinate of the point.
     * y - {Number} The y-coordinate of the point.
     */
    insertXY: function(x, y) {
        this.line.geometry.addComponent(
            new HGIS.Geometry.Point(x, y), 
            this.getCurrentPointIndex()
        );
        this.drawFeature();
        delete this.redoStack;
    },

    /**
     * Method: insertDeltaXY
     * Insert a point given offsets from the previously inserted point.
     *
     * Parameters:
     * dx - {Number} The x-coordinate offset of the point.
     * dy - {Number} The y-coordinate offset of the point.
     */
    insertDeltaXY: function(dx, dy) {
        var previousIndex = this.getCurrentPointIndex() - 1;
        var p0 = this.line.geometry.components[previousIndex];
        if (p0 && !isNaN(p0.x) && !isNaN(p0.y)) {
            this.insertXY(p0.x + dx, p0.y + dy);
        }
    },

    /**
     * Method: insertDirectionLength
     * Insert a point in the current sketch given a direction and a length.
     *
     * Parameters:
     * direction - {Number} Degrees clockwise from the positive x-axis.
     * length - {Number} Distance from the previously drawn point.
     */
    insertDirectionLength: function(direction, length) {
        direction *= Math.PI / 180;
        var dx = length * Math.cos(direction);
        var dy = length * Math.sin(direction);
        this.insertDeltaXY(dx, dy);
    },

    /**
     * Method: insertDeflectionLength
     * Insert a point in the current sketch given a deflection and a length.
     *     The deflection should be degrees clockwise from the previously 
     *     digitized segment.
     *
     * Parameters:
     * deflection - {Number} Degrees clockwise from the previous segment.
     * length - {Number} Distance from the previously drawn point.
     */
    insertDeflectionLength: function(deflection, length) {
        var previousIndex = this.getCurrentPointIndex() - 1;
        if (previousIndex > 0) {
            var p1 = this.line.geometry.components[previousIndex];
            var p0 = this.line.geometry.components[previousIndex-1];
            var theta = Math.atan2(p1.y - p0.y, p1.x - p0.x);
            this.insertDirectionLength(
                (theta * 180 / Math.PI) + deflection, length
            );
        }
    },

    /**
     * Method: getCurrentPointIndex
     * 
     * Returns:
     * {Number} The index of the most recently drawn point.
     */
    getCurrentPointIndex: function() {
        return this.line.geometry.components.length - 1;
    },
    
    
    /**
     * Method: undo
     * Remove the most recently added point in the sketch geometry.
     *
     * Returns: 
     * {Boolean} A point was removed.
     */
    undo: function() {
        var geometry = this.line.geometry;
        var components = geometry.components;
        var index = this.getCurrentPointIndex() - 1;
        var target = components[index];
        var undone = geometry.removeComponent(target);
        if (undone) {
            // On touch devices, set the current ("mouse location") point to
            // match the last digitized point.
            if (this.touch && index > 0) {
                components = geometry.components; // safety
                var lastpt = components[index - 1];
                var curptidx = this.getCurrentPointIndex();
                var curpt = components[curptidx];
                curpt.x = lastpt.x;
                curpt.y = lastpt.y;
            }
            if (!this.redoStack) {
                this.redoStack = [];
            }
            this.redoStack.push(target);
            this.drawFeature();
        }
        return undone;
    },
    
    /**
     * Method: redo
     * Reinsert the most recently removed point resulting from an <undo> call.
     *     The undo stack is deleted whenever a point is added by other means.
     *
     * Returns: 
     * {Boolean} A point was added.
     */
    redo: function() {
        var target = this.redoStack && this.redoStack.pop();
        if (target) {
            this.line.geometry.addComponent(target, this.getCurrentPointIndex());
            this.drawFeature();
        }
        return !!target;
    },
    
    /**
     * Method: freehandMode
     * Determine whether to behave in freehand mode or not.
     *
     * Returns:
     * {Boolean}
     */
    freehandMode: function(evt) {
        return (this.freehandToggle && evt[this.freehandToggle]) ?
                    !this.freehand : this.freehand;
    },

    /**
     * Method: modifyFeature
     * Modify the existing geometry given the new point
     *
     * Parameters:
     * pixel - {<HGIS.Pixel>} The updated pixel location for the latest
     *     point.
     * drawing - {Boolean} Indicate if we're currently drawing.
     */
    modifyFeature: function(pixel, drawing) {
        if(!this.line) {
            this.createFeature(pixel);
        }
        var lonlat = this.layer.getLonLatFromViewPortPx(pixel); 
        this.point.geometry.x = lonlat.lon;
        this.point.geometry.y = lonlat.lat;
        this.callback("modify", [this.point.geometry, this.getSketch(), drawing]);
        this.point.geometry.clearBounds();
        this.drawFeature();
    },

    /**
     * Method: drawFeature
     * Render geometries on the temporary layer.
     */
    drawFeature: function() {
        this.layer.drawFeature(this.line, this.style);
        this.layer.drawFeature(this.point, this.style);
    },

    /**
     * Method: getSketch
     * Return the sketch feature.
     *
     * Returns:
     * {<HGIS.Feature.Vector>}
     */
    getSketch: function() {
        return this.line;
    },

    /**
     * Method: getGeometry
     * Return the sketch geometry.  If <multi> is true, this will return
     *     a multi-part geometry.
     *
     * Returns:
     * {<HGIS.Geometry.LineString>}
     */
    getGeometry: function() {
        var geometry = this.line && this.line.geometry;
        if(geometry && this.multi) {
            geometry = new HGIS.Geometry.MultiLineString([geometry]);
        }
        return geometry;
    },

    /**
     * method: touchstart
     * handle touchstart.
     *
     * parameters:
     * evt - {event} the browser event
     *
     * returns:
     * {boolean} allow event propagation
     */
    touchstart: function(evt) {
        if (this.timerId &&
            this.passesTolerance(this.lastTouchPx, evt.xy,
                                 this.doubleTouchTolerance)) {
            // double-tap, finalize the geometry
            this.finishGeometry();
            window.clearTimeout(this.timerId);
            this.timerId = null;
            return false;
        } else {
            if (this.timerId) {
                window.clearTimeout(this.timerId);
                this.timerId = null;
            }
            this.timerId = window.setTimeout(
                HGIS.Function.bind(function() {
                    this.timerId = null;
                }, this), 300);
            return HGIS.Handler.Point.prototype.touchstart.call(this, evt);
        }
    },

    /**
     * Method: down
     * Handle mousedown and touchstart.  Add a new point to the geometry and
     * render it. Return determines whether to propagate the event on the map.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    down: function(evt) {
        var stopDown = this.stopDown;
        if(this.freehandMode(evt)) {
            stopDown = true;
            if (this.touch) {
                this.modifyFeature(evt.xy, !!this.lastUp);
                HGIS.Event.stop(evt);
            }
        }
        if (!this.touch && (!this.lastDown ||
                            !this.passesTolerance(this.lastDown, evt.xy,
                                                  this.pixelTolerance))) {
            this.modifyFeature(evt.xy, !!this.lastUp);
        }
        this.mouseDown = true;
        this.lastDown = evt.xy;
        this.stoppedDown = stopDown;
        return !stopDown;
    },

    /**
     * Method: move
     * Handle mousemove and touchmove.  Adjust the geometry and redraw.
     * Return determines whether to propagate the event on the map.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    move: function (evt) {
        if(this.stoppedDown && this.freehandMode(evt)) {
        	  if(this.persist) {
                  this.destroyPersistedFeature();
              }
              if(this.maxVertices && this.line &&
                      this.line.geometry.components.length === this.maxVertices) {
                  this.removePoint();
                  this.finalize();
                  return false;//add
              } else {
                  this.addPoint(evt.xy);
                  return true;//add
              }  
              //return false;//原来的
        }
        if (!this.touch && (!this.mouseDown || this.stoppedDown)) {
            this.modifyFeature(evt.xy, !!this.lastUp);
        }
        return true;
    },
    
    /**
     * Method: up
     * Handle mouseup and touchend.  Send the latest point in the geometry to
     * the control. Return determines whether to propagate the event on the map.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    up: function (evt) {
        if (this.mouseDown && (!this.lastUp || !this.lastUp.equals(evt.xy))) {
            if(this.stoppedDown && this.freehandMode(evt)) {
                if (this.persist) {
                    this.destroyPersistedFeature();
                }
                this.removePoint();
                this.finalize();
            } else {
                if (this.passesTolerance(this.lastDown, evt.xy,
                                         this.pixelTolerance)) {
                    if (this.touch) {
                        this.modifyFeature(evt.xy);
                    }
                    if(this.lastUp == null && this.persist) {
                        this.destroyPersistedFeature();
                    }
                    this.addPoint(evt.xy);
                    this.lastUp = evt.xy;
                    if(this.line.geometry.components.length === this.maxVertices + 1) {
                        this.finishGeometry();
                    }
                }
            }
        }
        this.stoppedDown = this.stopDown;
        this.mouseDown = false;
        return !this.stopUp;
    },

    /**
     * APIMethod: finishGeometry
     * Finish the geometry and send it back to the control.
     */
    finishGeometry: function() {
        var index = this.line.geometry.components.length - 1;
        this.line.geometry.removeComponent(this.line.geometry.components[index]);
        this.removePoint();
        this.finalize();
    },
  
    /**
     * Method: dblclick 
     * Handle double-clicks.
     * 
     * Parameters:
     * evt - {Event} The browser event
     *
     * Returns: 
     * {Boolean} Allow event propagation
     */
    dblclick: function(evt) {
        if(!this.freehandMode(evt)) {
            this.finishGeometry();
        }
        return false;
    },

    CLASS_NAME: "HGIS.Handler.Path"
});
/* ======================================================================
    HGIS/Spherical.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/SingleFile.js
 */

/**
 * Namespace: Spherical
 * The HGIS.Spherical namespace includes utility functions for
 * calculations on the basis of a spherical earth (ignoring ellipsoidal
 * effects), which is accurate enough for most purposes.
 *
 * Relevant links:
 * * http://www.movable-type.co.uk/scripts/latlong.html
 * * http://code.google.com/apis/maps/documentation/javascript/reference.html#spherical
 */

HGIS.Spherical = HGIS.Spherical || {};

HGIS.Spherical.DEFAULT_RADIUS = 6378137;

/**
 * APIFunction: computeDistanceBetween
 * Computes the distance between two LonLats.
 *
 * Parameters:
 * from   - {<HGIS.LonLat>} or {Object} Starting point. A LonLat or
 *          a JavaScript literal with lon lat properties.
 * to     - {<HGIS.LonLat>} or {Object} Ending point. A LonLat or a
 *          JavaScript literal with lon lat properties.
 * radius - {Float} The radius. Optional. Defaults to 6378137 meters.
 *
 * Returns:
 * {Float} The distance in meters.
 */
HGIS.Spherical.computeDistanceBetween = function(from, to, radius) {
  var R = radius || HGIS.Spherical.DEFAULT_RADIUS;
  var sinHalfDeltaLon = Math.sin(Math.PI * (to.lon - from.lon) / 360);
  var sinHalfDeltaLat = Math.sin(Math.PI * (to.lat - from.lat) / 360);
  var a = sinHalfDeltaLat * sinHalfDeltaLat +
      sinHalfDeltaLon * sinHalfDeltaLon * Math.cos(Math.PI * from.lat / 180) * Math.cos(Math.PI * to.lat / 180); 
  return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); 
};


/**
 * APIFunction: computeHeading
 * Computes the heading from one LonLat to another LonLat.
 *
 * Parameters:
 * from   - {<HGIS.LonLat>} or {Object} Starting point. A LonLat or
 *          a JavaScript literal with lon lat properties.
 * to     - {<HGIS.LonLat>} or {Object} Ending point. A LonLat or a
 *          JavaScript literal with lon lat properties.
 *
 * Returns:
 * {Float} The heading in degrees.
 */
HGIS.Spherical.computeHeading = function(from, to) {
    var y = Math.sin(Math.PI * (from.lon - to.lon) / 180) * Math.cos(Math.PI * to.lat / 180);
    var x = Math.cos(Math.PI * from.lat / 180) * Math.sin(Math.PI * to.lat / 180) -
        Math.sin(Math.PI * from.lat / 180) * Math.cos(Math.PI * to.lat / 180) * Math.cos(Math.PI * (from.lon - to.lon) / 180);
    return 180 * Math.atan2(y, x) / Math.PI;
};
/* ======================================================================
    HGIS/Control/CacheWrite.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Request.js
 * @requires HGIS/Console.js
 */

/**
 * Class: HGIS.Control.CacheWrite
 * A control for caching image tiles in the browser's local storage. The
 * <HGIS.Control.CacheRead> control is used to fetch and use the cached
 * tile images.
 *
 * Note: Before using this control on any layer that is not your own, make sure
 * that the terms of service of the tile provider allow local storage of tiles.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.CacheWrite = HGIS.Class(HGIS.Control, {
    
    /** 
     * APIProperty: events
     * {<HGIS.Events>} Events instance for listeners and triggering
     *     control specific events.
     *
     * To register events in the constructor, configure <eventListeners>.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types (in addition to those from <HGIS.Control.events>):
     * cachefull - Triggered when the cache is full. Listeners receive an
     *     object with a tile property as first argument. The tile references
     *     the tile that couldn't be cached.
     */
    
    /**
     * APIProperty: eventListeners
     * {Object} Object with event listeners, keyed by event name. An optional
     *     scope property defines the scope that listeners will be executed in.
     */

    /**
     * APIProperty: layers
     * {Array(<HGIS.Layer.Grid>)}. Optional. If provided, caching
     *     will be enabled for these layers only, otherwise for all cacheable
     *     layers.
     */
    layers: null,
    
    /**
     * APIProperty: imageFormat
     * {String} The image format used for caching. The default is "image/png".
     *     Supported formats depend on the user agent. If an unsupported
     *     <imageFormat> is provided, "image/png" will be used. For aerial
     *     imagery, "image/jpeg" is recommended.
     */
    imageFormat: "image/png",
    
    /**
     * Property: quotaRegEx
     * {RegExp}
     */
    quotaRegEx: (/quota/i),
    
    /**
     * Constructor: HGIS.Control.CacheWrite
     *
     * Parameters:
     * options - {Object} Object with API properties for this control.
     */

    /** 
     * Method: setMap
     * Set the map property for the control. 
     * 
     * Parameters:
     * map - {<HGIS.Map>} 
     */
    setMap: function(map) {
        HGIS.Control.prototype.setMap.apply(this, arguments);
        var i, layers = this.layers || map.layers;
        for (i=layers.length-1; i>=0; --i) {
            this.addLayer({layer: layers[i]});
        }
        if (!this.layers) {
            map.events.on({
                addlayer: this.addLayer,
                removeLayer: this.removeLayer,
                scope: this
            });
        }
    },
    
    /**
     * Method: addLayer
     * Adds a layer to the control. Once added, tiles requested for this layer
     *     will be cached.
     *
     * Parameters:
     * evt - {Object} Object with a layer property referencing an
     *     <HGIS.Layer> instance
     */
    addLayer: function(evt) {
        evt.layer.events.on({
            tileloadstart: this.makeSameOrigin,
            tileloaded: this.onTileLoaded,
            scope: this
        });        
    },
    
    /**
     * Method: removeLayer
     * Removes a layer from the control. Once removed, tiles requested for this
     *     layer will no longer be cached.
     *
     * Parameters:
     * evt - {Object} Object with a layer property referencing an
     *     <HGIS.Layer> instance
     */
    removeLayer: function(evt) {
        evt.layer.events.un({
            tileloadstart: this.makeSameOrigin,
            tileloaded: this.onTileLoaded,
            scope: this
        });
    },

    /**
     * Method: makeSameOrigin
     * If the tile does not have CORS image loading enabled and is from a
     * different origin, use HGIS.ProxyHost to make it a same origin url.
     *
     * Parameters:
     * evt - {<HGIS.Event>}
     */
    makeSameOrigin: function(evt) {
        if (this.active) {
            var tile = evt.tile;
            if (tile instanceof HGIS.Tile.Image &&
                    !tile.crossOriginKeyword &&
                    tile.url.substr(0, 5) !== "data:") {
                var sameOriginUrl = HGIS.Request.makeSameOrigin(
                    tile.url, HGIS.ProxyHost
                );
                HGIS.Control.CacheWrite.urlMap[sameOriginUrl] = tile.url;
                tile.url = sameOriginUrl;
            }
        }
    },
    
    /**
     * Method: onTileLoaded
     * Decides whether a tile can be cached and calls the cache method.
     *
     * Parameters:
     * evt - {Event}
     */
    onTileLoaded: function(evt) {
        if (this.active && !evt.aborted &&
                evt.tile instanceof HGIS.Tile.Image &&
                evt.tile.url.substr(0, 5) !== 'data:') {
            this.cache({tile: evt.tile});
            delete HGIS.Control.CacheWrite.urlMap[evt.tile.url];
        }
    },
    
    /**
     * Method: cache
     * Adds a tile to the cache. When the cache is full, the "cachefull" event
     * is triggered.
     *
     * Parameters:
     * obj - {Object} Object with a tile property, tile being the
     *     <HGIS.Tile.Image> with the data to add to the cache
     */
    cache: function(obj) {
        if (window.localStorage) {
            var tile = obj.tile;
            try {
                var canvasContext = tile.getCanvasContext();
                if (canvasContext) {
                    var urlMap = HGIS.Control.CacheWrite.urlMap;
                    var url = urlMap[tile.url] || tile.url;
                    window.localStorage.setItem(
                        "olCache_" + url,
                        canvasContext.canvas.toDataURL(this.imageFormat)
                    );
                }
            } catch(e) {
                // local storage full or CORS violation
                var reason = e.name || e.message;
                if (reason && this.quotaRegEx.test(reason)) {
                    this.events.triggerEvent("cachefull", {tile: tile});
                } else {
                    HGIS.Console.error(e.toString());
                }
            }
        }
    },
    
    /**
     * Method: destroy
     * The destroy method is used to perform any clean up before the control
     * is dereferenced.  Typically this is where event listeners are removed
     * to prevent memory leaks.
     */
    destroy: function() {
        if (this.layers || this.map) {
            var i, layers = this.layers || this.map.layers;
            for (i=layers.length-1; i>=0; --i) {
                this.removeLayer({layer: layers[i]});
            }
        }
        if (this.map) {
            this.map.events.un({
                addlayer: this.addLayer,
                removeLayer: this.removeLayer,
                scope: this
            });
        }
        HGIS.Control.prototype.destroy.apply(this, arguments);
    },
    
    CLASS_NAME: "HGIS.Control.CacheWrite"
});

/**
 * APIFunction: HGIS.Control.CacheWrite.clearCache
 * Clears all tiles cached with <HGIS.Control.CacheWrite> from the cache.
 */
HGIS.Control.CacheWrite.clearCache = function() {
    if (!window.localStorage) { return; }
    var i, key;
    for (i=window.localStorage.length-1; i>=0; --i) {
        key = window.localStorage.key(i);
        if (key.substr(0, 8) === "olCache_") {
            window.localStorage.removeItem(key);
        }
    }
};

/**
 * Property: HGIS.Control.CacheWrite.urlMap
 * {Object} Mapping of same origin urls to cache url keys. Entries will be
 *     deleted as soon as a tile was cached.
 */
HGIS.Control.CacheWrite.urlMap = {};


/* ======================================================================
    HGIS/Format/Context.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML/VersionedOGC.js
 */

/**
 * Class: HGIS.Format.Context
 * Base class for both Format.WMC and Format.OWSContext
 *
 * Inherits from:
 *  - <HGIS.Format.XML.VersionedOGC>
 */
HGIS.Format.Context = HGIS.Class(HGIS.Format.XML.VersionedOGC, {

    /**
     * Property: layerOptions
     * {Object} Default options for layers created by the parser. These
     *     options are overridden by the options which are read from the
     *     capabilities document.
     */
    layerOptions: null,

    /**
     * Property: layerParams
     * {Object} Default parameters for layers created by the parser. This
     *     can be used e.g. to override DEFAULT_PARAMS for 
     *     HGIS.Layer.WMS.
     */
    layerParams: null,

    /**
     * Constructor: HGIS.Format.Context
     * Create a new parser for Context documents.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read Context data from a string, and return an object with map
     *     properties and a list of layers.
     *
     * Parameters:
     * data - {String} or {DOMElement} data to read/parse.
     * options - {Object} The options object must contain a map property.  If
     *     the map property is a string, it must be the id of a dom element
     *     where the new map will be placed.  If the map property is an
     *     <HGIS.Map>, the layers from the context document will be added
     *     to the map.
     *
     * Returns:
     * {<HGIS.Map>} A map based on the context.
     */
    read: function(data, options) {
        var context = HGIS.Format.XML.VersionedOGC.prototype.read.apply(this, 
            arguments);
        var map;
        if(options && options.map) {
            this.context = context;
            if(options.map instanceof HGIS.Map) {
                map = this.mergeContextToMap(context, options.map);
            } else {
                var mapOptions = options.map;
                if(HGIS.Util.isElement(mapOptions) ||
                   typeof mapOptions == "string") {
                    // we assume mapOptions references a div
                    // element
                    mapOptions = {div: mapOptions};
                }
                map = this.contextToMap(context, mapOptions);
            }
        } else {
            // not documented as part of the API, provided as a non-API option
            map = context;
        }
        return map;
    },

    /**
     * Method: getLayerFromContext
     * Create a WMS layer from a layerContext object.
     *
     * Parameters:
     * layerContext - {Object} An object representing a WMS layer.
     *
     * Returns:
     * {<HGIS.Layer.WMS>} A WMS layer.
     */
    getLayerFromContext: function(layerContext) {
        var i, len;
        // fill initial options object from layerContext
        var options = {
            queryable: layerContext.queryable, //keep queryable for api compatibility
            visibility: layerContext.visibility,
            maxExtent: layerContext.maxExtent,
            metadata: HGIS.Util.applyDefaults(layerContext.metadata, 
            {styles: layerContext.styles,
             formats: layerContext.formats,
             "abstract": layerContext["abstract"],
             dataURL: layerContext.dataURL
            }),
            numZoomLevels: layerContext.numZoomLevels,
            units: layerContext.units,
            isBaseLayer: layerContext.isBaseLayer,
            opacity: layerContext.opacity,
            displayInLayerSwitcher: layerContext.displayInLayerSwitcher,
            singleTile: layerContext.singleTile,
            tileSize: (layerContext.tileSize) ? 
                new HGIS.Size(
                    layerContext.tileSize.width, 
                    layerContext.tileSize.height
                ) : undefined,
            minScale: layerContext.minScale || layerContext.maxScaleDenominator,
            maxScale: layerContext.maxScale || layerContext.minScaleDenominator,
            srs: layerContext.srs,
            dimensions: layerContext.dimensions,
            metadataURL: layerContext.metadataURL
        };
        if (this.layerOptions) {
            HGIS.Util.applyDefaults(options, this.layerOptions);
        }

        var params = {
            layers: layerContext.name,
            transparent: layerContext.transparent,
            version: layerContext.version
        };
        if (layerContext.formats && layerContext.formats.length>0) {
            // set default value for params if current attribute is not positionned
            params.format = layerContext.formats[0].value;
            for (i=0, len=layerContext.formats.length; i<len; i++) {
                var format = layerContext.formats[i];
                if (format.current == true) {
                    params.format = format.value;
                    break;
                }
            }
        }
        if (layerContext.styles && layerContext.styles.length>0) {
            for (i=0, len=layerContext.styles.length; i<len; i++) {
                var style = layerContext.styles[i];
                if (style.current == true) {
                    // three style types to consider
                    // 1) linked SLD
                    // 2) inline SLD
                    // 3) named style
                    if(style.href) {
                        params.sld = style.href;
                    } else if(style.body) {
                        params.sld_body = style.body;
                    } else {
                        params.styles = style.name;
                    }
                    break;
                }
            }
        }
        if (this.layerParams) {
            HGIS.Util.applyDefaults(params, this.layerParams);
        }

        var layer = null;
        var service = layerContext.service;
        if (service == HGIS.Format.Context.serviceTypes.WFS) {
            options.strategies = [new HGIS.Strategy.BBOX()];
            options.protocol = new HGIS.Protocol.WFS({
                url: layerContext.url,
                // since we do not know featureNS, let the protocol
                // determine it automagically using featurePrefix
                featurePrefix: layerContext.name.split(":")[0],
                featureType: layerContext.name.split(":").pop()
            });
            layer = new HGIS.Layer.Vector(
                layerContext.title || layerContext.name,
                options
            );
        } else if (service == HGIS.Format.Context.serviceTypes.KML) {
            // use a vector layer with an HTTP Protcol and a Fixed strategy
            options.strategies = [new HGIS.Strategy.Fixed()];
            options.protocol = new HGIS.Protocol.HTTP({
                url: layerContext.url, 
                format: new HGIS.Format.KML()
            });
            layer = new HGIS.Layer.Vector(
                layerContext.title || layerContext.name,
                options
            );
        } else if (service == HGIS.Format.Context.serviceTypes.GML) {
            // use a vector layer with a HTTP Protocol and a Fixed strategy
            options.strategies = [new HGIS.Strategy.Fixed()];
            options.protocol = new HGIS.Protocol.HTTP({
                url: layerContext.url, 
                format: new HGIS.Format.GML()
            });
            layer = new HGIS.Layer.Vector(
                layerContext.title || layerContext.name,
                options
            );
        } else if (layerContext.features) {
            // inline GML or KML features
            layer = new HGIS.Layer.Vector(
                layerContext.title || layerContext.name,
                options
            );
            layer.addFeatures(layerContext.features);
        } else if (layerContext.categoryLayer !== true) {
            layer = new HGIS.Layer.WMS(
                layerContext.title || layerContext.name,
                layerContext.url,
                params,
                options
            );
        }
        return layer;
    },

    /**
     * Method: getLayersFromContext
     * Create an array of layers from an array of layerContext objects.
     *
     * Parameters:
     * layersContext - {Array(Object)} An array of objects representing layers.
     *
     * Returns:
     * {Array(<HGIS.Layer>)} An array of layers.
     */
    getLayersFromContext: function(layersContext) {
        var layers = [];
        for (var i=0, len=layersContext.length; i<len; i++) {
            var layer = this.getLayerFromContext(layersContext[i]);
            if (layer !== null) {
                layers.push(layer);
            }
        }
        return layers;
    },

    /**
     * Method: contextToMap
     * Create a map given a context object.
     *
     * Parameters:
     * context - {Object} The context object.
     * options - {Object} Default map options.
     *
     * Returns:
     * {<HGIS.Map>} A map based on the context object.
     */
    contextToMap: function(context, options) {
        options = HGIS.Util.applyDefaults({
            maxExtent:  context.maxExtent,
            projection: context.projection,
            units:      context.units
        }, options);

        if (options.maxExtent) {
            options.maxResolution = 
                options.maxExtent.getWidth() / HGIS.Map.TILE_WIDTH;
        }

        var metadata = {
            contactInformation: context.contactInformation,
            "abstract":         context["abstract"],
            keywords:           context.keywords,
            logo:               context.logo,
            descriptionURL:     context.descriptionURL
        };

        options.metadata = metadata;

        var map = new HGIS.Map(options);
        map.addLayers(this.getLayersFromContext(context.layersContext));
        map.setCenter(
            context.bounds.getCenterLonLat(),
            map.getZoomForExtent(context.bounds, true)
        );
        return map;
    },

    /**
     * Method: mergeContextToMap
     * Add layers from a context object to a map.
     *
     * Parameters:
     * context - {Object} The context object.
     * map - {<HGIS.Map>} The map.
     *
     * Returns:
     * {<HGIS.Map>} The same map with layers added.
     */
    mergeContextToMap: function(context, map) {
        map.addLayers(this.getLayersFromContext(context.layersContext));
        return map;
    },

    /**
     * APIMethod: write
     * Write a context document given a map.
     *
     * Parameters:
     * obj - {<HGIS.Map> | Object} A map or context object.
     * options - {Object} Optional configuration object.
     *
     * Returns:
     * {String} A context document string.
     */
    write: function(obj, options) {
        obj = this.toContext(obj);
        return HGIS.Format.XML.VersionedOGC.prototype.write.apply(this,
            arguments);
    },

    CLASS_NAME: "HGIS.Format.Context"
});

/**
 * Constant: HGIS.Format.Context.serviceTypes
 * Enumeration for service types
 */
HGIS.Format.Context.serviceTypes = {
    "WMS": "urn:ogc:serviceType:WMS",
    "WFS": "urn:ogc:serviceType:WFS",
    "WCS": "urn:ogc:serviceType:WCS",
    "GML": "urn:ogc:serviceType:GML",
    "SLD": "urn:ogc:serviceType:SLD",
    "FES": "urn:ogc:serviceType:FES",
    "KML": "urn:ogc:serviceType:KML"
};
/* ======================================================================
    HGIS/Format/WMC.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/Context.js
 */

/**
 * Class: HGIS.Format.WMC
 * Read and write Web Map Context documents.
 *
 * Inherits from:
 *  - <HGIS.Format.Context>
 */
HGIS.Format.WMC = HGIS.Class(HGIS.Format.Context, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.1.0".
     */
    defaultVersion: "1.1.0",

    /**
     * Constructor: HGIS.Format.WMC
     * Create a new parser for Web Map Context documents.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    
    /**
     * Method: layerToContext
     * Create a layer context object given a wms layer object.
     *
     * Parameters:
     * layer - {<HGIS.Layer.WMS>} The layer.
     *
     * Returns:
     * {Object} A layer context object.
     */
    layerToContext: function(layer) {
        var parser = this.getParser();
        var layerContext = {
            queryable: layer.queryable,
            visibility: layer.visibility,
            name: layer.params["LAYERS"],
            title: layer.name,
            "abstract": layer.metadata["abstract"],
            dataURL: layer.metadata.dataURL,
            metadataURL: layer.metadataURL,
            server: {
            version: layer.params["VERSION"],
                url: layer.url
            },
            maxExtent: layer.maxExtent,
            transparent: layer.params["TRANSPARENT"],
            numZoomLevels: layer.numZoomLevels,
            units: layer.units,
            isBaseLayer: layer.isBaseLayer,
            opacity: layer.opacity == 1 ? undefined : layer.opacity,
            displayInLayerSwitcher: layer.displayInLayerSwitcher,
            singleTile: layer.singleTile,
            tileSize: (layer.singleTile || !layer.tileSize) ? 
                undefined : {width: layer.tileSize.w, height: layer.tileSize.h},
            minScale : (layer.options.resolutions ||
                        layer.options.scales || 
                        layer.options.maxResolution || 
                        layer.options.minScale) ? 
                        layer.minScale : undefined,
            maxScale : (layer.options.resolutions ||
                        layer.options.scales || 
                        layer.options.minResolution || 
                        layer.options.maxScale) ? 
                        layer.maxScale : undefined,
            formats: [],
            styles: [],
            srs: layer.srs,
            dimensions: layer.dimensions
        };


        if (layer.metadata.servertitle) {
            layerContext.server.title = layer.metadata.servertitle;
        }

        if (layer.metadata.formats && layer.metadata.formats.length > 0) {
            for (var i=0, len=layer.metadata.formats.length; i<len; i++) {
                var format = layer.metadata.formats[i];
                layerContext.formats.push({
                    value: format.value,
                    current: (format.value == layer.params["FORMAT"])
                });
            }
        } else {
            layerContext.formats.push({
                value: layer.params["FORMAT"],
                current: true
            });
        }

        if (layer.metadata.styles && layer.metadata.styles.length > 0) {
            for (var i=0, len=layer.metadata.styles.length; i<len; i++) {
                var style = layer.metadata.styles[i];
                if ((style.href == layer.params["SLD"]) ||
                    (style.body == layer.params["SLD_BODY"]) ||
                    (style.name == layer.params["STYLES"])) {
                    style.current = true;
                } else {
                    style.current = false;
                }
                layerContext.styles.push(style);
            }
        } else {
            layerContext.styles.push({
                href: layer.params["SLD"],
                body: layer.params["SLD_BODY"],
                name: layer.params["STYLES"] || parser.defaultStyleName,
                title: parser.defaultStyleTitle,
                current: true
            });
        }

        return layerContext;
    },
    
    /**
     * Method: toContext
     * Create a context object free from layer given a map or a
     * context object.
     *
     * Parameters:
     * obj - {<HGIS.Map> | Object} The map or context.
     *
     * Returns:
     * {Object} A context object.
     */
    toContext: function(obj) {
        var context = {};
        var layers = obj.layers;
        if (obj.CLASS_NAME == "HGIS.Map") {
            var metadata = obj.metadata || {};
            context.size = obj.getSize();
            context.bounds = obj.getExtent();
            context.projection = obj.projection;
            context.title = obj.title;
            context.keywords = metadata.keywords;
            context["abstract"] = metadata["abstract"];
            context.logo = metadata.logo;
            context.descriptionURL = metadata.descriptionURL;
            context.contactInformation = metadata.contactInformation;
            context.maxExtent = obj.maxExtent;
        } else {
            // copy all obj properties except the "layers" property
            HGIS.Util.applyDefaults(context, obj);
            if (context.layers != undefined) {
                delete(context.layers);
            }
        }

        if (context.layersContext == undefined) {
            context.layersContext = [];
        }

        // let's convert layers into layersContext object (if any)
        if (layers != undefined && HGIS.Util.isArray(layers)) {
            for (var i=0, len=layers.length; i<len; i++) {
                var layer = layers[i];
                if (layer instanceof HGIS.Layer.WMS) {
                    context.layersContext.push(this.layerToContext(layer));
                }
            }
        }
        return context;
    },

    CLASS_NAME: "HGIS.Format.WMC" 

});
/* ======================================================================
    HGIS/Format/WMC/v1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WMC.js
 * @requires HGIS/Format/XML.js
 */

/**
 * Class: HGIS.Format.WMC.v1
 * Superclass for WMC version 1 parsers.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.WMC.v1 = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ol: "http://HGIS.org/context",
        wmc: "http://www.opengis.net/context",
        sld: "http://www.opengis.net/sld",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    
    /**
     * Property: schemaLocation
     * {String} Schema location for a particular minor version.
     */
    schemaLocation: "",

    /**
     * Method: getNamespacePrefix
     * Get the namespace prefix for a given uri from the <namespaces> object.
     *
     * Returns:
     * {String} A namespace prefix or null if none found.
     */
    getNamespacePrefix: function(uri) {
        var prefix = null;
        if(uri == null) {
            prefix = this.namespaces[this.defaultPrefix];
        } else {
            for(prefix in this.namespaces) {
                if(this.namespaces[prefix] == uri) {
                    break;
                }
            }
        }
        return prefix;
    },
    
    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "wmc",

    /**
     * Property: rootPrefix
     * {String} Prefix on the root node that maps to the context namespace URI.
     */
    rootPrefix: null,
    
    /**
     * Property: defaultStyleName
     * {String} Style name used if layer has no style param.  Default is "".
     */
    defaultStyleName: "",
    
    /**
     * Property: defaultStyleTitle
     * {String} Default style title.  Default is "Default".
     */
    defaultStyleTitle: "Default",
    
    /**
     * Constructor: HGIS.Format.WMC.v1
     * Instances of this class are not created directly.  Use the
     *     <HGIS.Format.WMC> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     * Method: read
     * Read capabilities data from a string, and return a list of layers. 
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array} List of named layers.
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        var root = data.documentElement;
        this.rootPrefix = root.prefix;
        var context = {
            version: root.getAttribute("version")
        };
        this.runChildNodes(context, root);
        return context;
    },
    
    /**
     * Method: runChildNodes
     */
    runChildNodes: function(obj, node) {
        var children = node.childNodes;
        var childNode, processor, prefix, local;
        for(var i=0, len=children.length; i<len; ++i) {
            childNode = children[i];
            if(childNode.nodeType == 1) {
                prefix = this.getNamespacePrefix(childNode.namespaceURI);
                local = childNode.nodeName.split(":").pop();
                processor = this["read_" + prefix + "_" + local];
                if(processor) {
                    processor.apply(this, [obj, childNode]);
                }
            }
        }
    },
    
    /**
     * Method: read_wmc_General
     */
    read_wmc_General: function(context, node) {
        this.runChildNodes(context, node);
    },
    
    /**
     * Method: read_wmc_BoundingBox
     */
    read_wmc_BoundingBox: function(context, node) {
        context.projection = node.getAttribute("SRS");
        context.bounds = new HGIS.Bounds(
            node.getAttribute("minx"), node.getAttribute("miny"),
            node.getAttribute("maxx"), node.getAttribute("maxy")
        );
    },
    
    /**
     * Method: read_wmc_LayerList
     */
    read_wmc_LayerList: function(context, node) {
        // layersContext is an array containing info for each layer
        context.layersContext = [];
        this.runChildNodes(context, node);
    },
    
    /**
     * Method: read_wmc_Layer
     */
    read_wmc_Layer: function(context, node) {
        var layerContext = {
            visibility: (node.getAttribute("hidden") != "1"),
            queryable: (node.getAttribute("queryable") == "1"),
            formats: [],
             styles: [],
             metadata: {}
        };

        this.runChildNodes(layerContext, node);
        // set properties common to multiple objects on layer options/params
        context.layersContext.push(layerContext);
    },
    
    /**
     * Method: read_wmc_Extension
     */
    read_wmc_Extension: function(obj, node) {
        this.runChildNodes(obj, node);
    },

    /**
     * Method: read_ol_units
     */
    read_ol_units: function(layerContext, node) {
        layerContext.units = this.getChildValue(node);
    },
    
    /**
     * Method: read_ol_maxExtent
     */
    read_ol_maxExtent: function(obj, node) {
        var bounds = new HGIS.Bounds(
            node.getAttribute("minx"), node.getAttribute("miny"),
            node.getAttribute("maxx"), node.getAttribute("maxy")
        );
        obj.maxExtent = bounds;
    },
    
    /**
     * Method: read_ol_transparent
     */
    read_ol_transparent: function(layerContext, node) {
        layerContext.transparent = this.getChildValue(node);
    },

    /**
     * Method: read_ol_numZoomLevels
     */
    read_ol_numZoomLevels: function(layerContext, node) {
        layerContext.numZoomLevels = parseInt(this.getChildValue(node));
    },

    /**
     * Method: read_ol_opacity
     */
    read_ol_opacity: function(layerContext, node) {
        layerContext.opacity = parseFloat(this.getChildValue(node));
    },

    /**
     * Method: read_ol_singleTile
     */
    read_ol_singleTile: function(layerContext, node) {
        layerContext.singleTile = (this.getChildValue(node) == "true");
    },

    /**
     * Method: read_ol_tileSize
     */
    read_ol_tileSize: function(layerContext, node) {
        var obj = {"width": node.getAttribute("width"), "height": node.getAttribute("height")};
        layerContext.tileSize = obj;
    },
    
    /**
     * Method: read_ol_isBaseLayer
     */
    read_ol_isBaseLayer: function(layerContext, node) {
        layerContext.isBaseLayer = (this.getChildValue(node) == "true");
    },

    /**
     * Method: read_ol_displayInLayerSwitcher
     */
    read_ol_displayInLayerSwitcher: function(layerContext, node) {
        layerContext.displayInLayerSwitcher = (this.getChildValue(node) == "true");
    },

    /**
     * Method: read_wmc_Server
     */
    read_wmc_Server: function(layerContext, node) {
        layerContext.version = node.getAttribute("version");
         layerContext.url = this.getOnlineResource_href(node);
         layerContext.metadata.servertitle = node.getAttribute("title");
    },

    /**
     * Method: read_wmc_FormatList
     */
    read_wmc_FormatList: function(layerContext, node) {
        this.runChildNodes(layerContext, node);
    },

    /**
     * Method: read_wmc_Format
     */
    read_wmc_Format: function(layerContext, node) {
        var format = {
            value: this.getChildValue(node)
        };
        if(node.getAttribute("current") == "1") {
            format.current = true;
        }
        layerContext.formats.push(format);
    },
    
    /**
     * Method: read_wmc_StyleList
     */
    read_wmc_StyleList: function(layerContext, node) {
        this.runChildNodes(layerContext, node);
    },

    /**
     * Method: read_wmc_Style
     */
    read_wmc_Style: function(layerContext, node) {
        var style = {};
        this.runChildNodes(style, node);
        if(node.getAttribute("current") == "1") {
            style.current = true;
        }
        layerContext.styles.push(style);
    },
    
    /**
     * Method: read_wmc_SLD
     */
    read_wmc_SLD: function(style, node) {
        this.runChildNodes(style, node);
        // style either comes back with an href or a body property
    },
    
    /**
     * Method: read_sld_StyledLayerDescriptor
     */
    read_sld_StyledLayerDescriptor: function(sld, node) {
        var xml = HGIS.Format.XML.prototype.write.apply(this, [node]);
        sld.body = xml;
    },

    /**
      * Method: read_sld_FeatureTypeStyle
      */
     read_sld_FeatureTypeStyle: function(sld, node) {
         var xml = HGIS.Format.XML.prototype.write.apply(this, [node]);
         sld.body = xml;
     },

     /**
     * Method: read_wmc_OnlineResource
     */
    read_wmc_OnlineResource: function(obj, node) {
        obj.href = this.getAttributeNS(
            node, this.namespaces.xlink, "href"
        );
    },
    
    /**
     * Method: read_wmc_Name
     */
    read_wmc_Name: function(obj, node) {
        var name = this.getChildValue(node);
        if(name) {
            obj.name = name;
        }
    },

    /**
     * Method: read_wmc_Title
     */
    read_wmc_Title: function(obj, node) {
        var title = this.getChildValue(node);
        if(title) {
            obj.title = title;
        }
    },

    /**
     * Method: read_wmc_MetadataURL
     */
    read_wmc_MetadataURL: function(layerContext, node) {
         layerContext.metadataURL = this.getOnlineResource_href(node);
     },

     /**
      * Method: read_wmc_KeywordList
      */
     read_wmc_KeywordList: function(context, node) {
         context.keywords = [];
         this.runChildNodes(context.keywords, node);
    },

    /**
      * Method: read_wmc_Keyword
      */
     read_wmc_Keyword: function(keywords, node) {
         keywords.push(this.getChildValue(node));
     },

     /**
     * Method: read_wmc_Abstract
     */
    read_wmc_Abstract: function(obj, node) {
        var abst = this.getChildValue(node);
        if(abst) {
            obj["abstract"] = abst;
        }
    },
    
    /**
      * Method: read_wmc_LogoURL
      */
     read_wmc_LogoURL: function(context, node) {
         context.logo = {
             width:  node.getAttribute("width"),
             height: node.getAttribute("height"),
             format: node.getAttribute("format"),
             href:   this.getOnlineResource_href(node)
         };
     },

     /**
      * Method: read_wmc_DescriptionURL
      */
     read_wmc_DescriptionURL: function(context, node) {
         context.descriptionURL = this.getOnlineResource_href(node);
     },

     /**
      * Method: read_wmc_ContactInformation
     */
     read_wmc_ContactInformation: function(obj, node) {
         var contact = {};
         this.runChildNodes(contact, node);
         obj.contactInformation = contact;
     },

     /**
      * Method: read_wmc_ContactPersonPrimary
      */
     read_wmc_ContactPersonPrimary: function(contact, node) {
         var personPrimary = {};
         this.runChildNodes(personPrimary, node);
         contact.personPrimary = personPrimary;
     },

     /**
      * Method: read_wmc_ContactPerson
      */
     read_wmc_ContactPerson: function(primaryPerson, node) {
         var person = this.getChildValue(node);
         if (person) {
             primaryPerson.person = person;
         }
     },

     /**
      * Method: read_wmc_ContactOrganization
      */
     read_wmc_ContactOrganization: function(primaryPerson, node) {
         var organization = this.getChildValue(node);
         if (organization) {
             primaryPerson.organization = organization;
         }
     },

     /**
      * Method: read_wmc_ContactPosition
      */
     read_wmc_ContactPosition: function(contact, node) {
         var position = this.getChildValue(node);
         if (position) {
             contact.position = position;
         }
     },

     /**
      * Method: read_wmc_ContactAddress
      */
     read_wmc_ContactAddress: function(contact, node) {
         var contactAddress = {};
         this.runChildNodes(contactAddress, node);
         contact.contactAddress = contactAddress;
     },

     /**
      * Method: read_wmc_AddressType
      */
     read_wmc_AddressType: function(contactAddress, node) {
         var type = this.getChildValue(node);
         if (type) {
             contactAddress.type = type;
         }
     },

     /**
      * Method: read_wmc_Address
      */
     read_wmc_Address: function(contactAddress, node) {
         var address = this.getChildValue(node);
         if (address) {
             contactAddress.address = address;
         }
     },

     /**
      * Method: read_wmc_City
      */
     read_wmc_City: function(contactAddress, node) {
         var city = this.getChildValue(node);
         if (city) {
             contactAddress.city = city;
         }
     },

     /**
      * Method: read_wmc_StateOrProvince
      */
     read_wmc_StateOrProvince: function(contactAddress, node) {
         var stateOrProvince = this.getChildValue(node);
         if (stateOrProvince) {
             contactAddress.stateOrProvince = stateOrProvince;
         }
     },

     /**
      * Method: read_wmc_PostCode
      */
     read_wmc_PostCode: function(contactAddress, node) {
         var postcode = this.getChildValue(node);
         if (postcode) {
             contactAddress.postcode = postcode;
         }
     },

     /**
      * Method: read_wmc_Country
      */
     read_wmc_Country: function(contactAddress, node) {
         var country = this.getChildValue(node);
         if (country) {
             contactAddress.country = country;
         }
     },

     /**
      * Method: read_wmc_ContactVoiceTelephone
      */
     read_wmc_ContactVoiceTelephone: function(contact, node) {
         var phone = this.getChildValue(node);
         if (phone) {
             contact.phone = phone;
         }
     },

     /**
      * Method: read_wmc_ContactFacsimileTelephone
      */
     read_wmc_ContactFacsimileTelephone: function(contact, node) {
         var fax = this.getChildValue(node);
         if (fax) {
             contact.fax = fax;
         }
     },

     /**
      * Method: read_wmc_ContactElectronicMailAddress
      */
     read_wmc_ContactElectronicMailAddress: function(contact, node) {
         var email = this.getChildValue(node);
         if (email) {
             contact.email = email;
         }
     },

     /**
      * Method: read_wmc_DataURL
      */
     read_wmc_DataURL: function(layerContext, node) {
         layerContext.dataURL = this.getOnlineResource_href(node);
     },

     /**
     * Method: read_wmc_LegendURL
     */
    read_wmc_LegendURL: function(style, node) {
        var legend = {
            width: node.getAttribute('width'),
             height: node.getAttribute('height'),
             format: node.getAttribute('format'),
             href:   this.getOnlineResource_href(node)
        };
        style.legend = legend;
    },
    
    /**
      * Method: read_wmc_DimensionList
      */
     read_wmc_DimensionList: function(layerContext, node) {
         layerContext.dimensions = {};
         this.runChildNodes(layerContext.dimensions, node);
     },
     /**
      * Method: read_wmc_Dimension
      */
     read_wmc_Dimension: function(dimensions, node) {
         var name = node.getAttribute("name").toLowerCase();

         var dim = {
             name:           name,
             units:          node.getAttribute("units")          ||  "",
             unitSymbol:     node.getAttribute("unitSymbol")     ||  "",
             userValue:      node.getAttribute("userValue")      ||  "",
             nearestValue:   node.getAttribute("nearestValue")   === "1",
             multipleValues: node.getAttribute("multipleValues") === "1",
             current:        node.getAttribute("current")        === "1",
             "default":      node.getAttribute("default")        ||  ""
         };
         var values = this.getChildValue(node);
         dim.values = values.split(",");

         dimensions[dim.name] = dim;
     },

     /**
     * Method: write
     *
     * Parameters:
     * context - {Object} An object representing the map context.
     * options - {Object} Optional object.
     *
     * Returns:
     * {String} A WMC document string.
     */
    write: function(context, options) {
        var root = this.createElementDefaultNS("ViewContext");
        this.setAttributes(root, {
            version: this.VERSION,
            id: (options && typeof options.id == "string") ?
                    options.id :
                    HGIS.Util.createUniqueID("HGIS_Context_")
        });
        
        // add schemaLocation attribute
        this.setAttributeNS(
            root, this.namespaces.xsi,
            "xsi:schemaLocation", this.schemaLocation
        );
        
        // required General element
        root.appendChild(this.write_wmc_General(context));

        // required LayerList element
        root.appendChild(this.write_wmc_LayerList(context));

        return HGIS.Format.XML.prototype.write.apply(this, [root]);
    },
    
    /**
     * Method: createElementDefaultNS
     * Shorthand for createElementNS with namespace from <defaultPrefix>.
     *     Can optionally be used to set attributes and a text child value.
     *
     * Parameters:
     * name - {String} The qualified node name.
     * childValue - {String} Optional value for text child node.
     * attributes - {Object} Optional object representing attributes.
     *
     * Returns:
     * {Element} An element node.
     */
    createElementDefaultNS: function(name, childValue, attributes) {
        var node = this.createElementNS(
            this.namespaces[this.defaultPrefix],
            name
        );
        if(childValue) {
            node.appendChild(this.createTextNode(childValue));
        }
        if(attributes) {
            this.setAttributes(node, attributes);
        }
        return node;
    },
    
    /**
     * Method: setAttributes
     * Set multiple attributes given key value pairs from an object.
     *
     * Parameters:
     * node - {Element} An element node.
     * obj - {Object} An object whose properties represent attribute names and
     *     values represent attribute values.
     */
    setAttributes: function(node, obj) {
        var value;
        for(var name in obj) {
            value = obj[name].toString();
            if(value.match(/[A-Z]/)) {
                // safari lowercases attributes with setAttribute
                this.setAttributeNS(node, null, name, value);
            } else {
                node.setAttribute(name, value);
            }
        }
    },

    /**
     * Method: write_wmc_General
     * Create a General node given an context object.
     *
     * Parameters:
     * context - {Object} Context object.
     *
     * Returns:
     * {Element} A WMC General element node.
     */
    write_wmc_General: function(context) {
        var node = this.createElementDefaultNS("General");

        // optional Window element
        if(context.size) {
            node.appendChild(this.createElementDefaultNS(
                "Window", null,
                {
                    width: context.size.w,
                    height: context.size.h
                }
            ));
        }
        
        // required BoundingBox element
        var bounds = context.bounds;
        node.appendChild(this.createElementDefaultNS(
            "BoundingBox", null,
            {
                minx: bounds.left.toPrecision(18),
                miny: bounds.bottom.toPrecision(18),
                maxx: bounds.right.toPrecision(18),
                maxy: bounds.top.toPrecision(18),
                SRS: context.projection
            }
        ));

        // required Title element
        node.appendChild(this.createElementDefaultNS(
            "Title", context.title
        ));
        
         // optional KeywordList element
         if (context.keywords) {
             node.appendChild(this.write_wmc_KeywordList(context.keywords));
         }

         // optional Abstract element
         if (context["abstract"]) {
             node.appendChild(this.createElementDefaultNS(
                 "Abstract", context["abstract"]
             ));
         }

         // Optional LogoURL element
         if (context.logo) {
             node.appendChild(this.write_wmc_URLType("LogoURL", context.logo.href, context.logo));
         }

         // Optional DescriptionURL element
         if (context.descriptionURL) {
             node.appendChild(this.write_wmc_URLType("DescriptionURL", context.descriptionURL));
         }

         // Optional ContactInformation element
         if (context.contactInformation) {
             node.appendChild(this.write_wmc_ContactInformation(context.contactInformation));
         }

        // HGIS specific map properties
        node.appendChild(this.write_ol_MapExtension(context));
        
        return node;
    },
    
    /**
      * Method: write_wmc_KeywordList
      */
     write_wmc_KeywordList: function(keywords) {
         var node = this.createElementDefaultNS("KeywordList");

         for (var i=0, len=keywords.length; i<len; i++) {
             node.appendChild(this.createElementDefaultNS(
                 "Keyword", keywords[i]
             ));
         }
         return node;
     },
     /**
      * Method: write_wmc_ContactInformation
      */
     write_wmc_ContactInformation: function(contact) {
         var node = this.createElementDefaultNS("ContactInformation");

         if (contact.personPrimary) {
             node.appendChild(this.write_wmc_ContactPersonPrimary(contact.personPrimary));
         }
         if (contact.position) {
             node.appendChild(this.createElementDefaultNS(
                 "ContactPosition", contact.position
             ));
         }
         if (contact.contactAddress) {
             node.appendChild(this.write_wmc_ContactAddress(contact.contactAddress));
         }
         if (contact.phone) {
             node.appendChild(this.createElementDefaultNS(
                 "ContactVoiceTelephone", contact.phone
             ));
         }
         if (contact.fax) {
             node.appendChild(this.createElementDefaultNS(
                 "ContactFacsimileTelephone", contact.fax
             ));
         }
         if (contact.email) {
             node.appendChild(this.createElementDefaultNS(
                 "ContactElectronicMailAddress", contact.email
             ));
         }
         return node;
     },

     /**
      * Method: write_wmc_ContactPersonPrimary
      */
     write_wmc_ContactPersonPrimary: function(personPrimary) {
         var node = this.createElementDefaultNS("ContactPersonPrimary");
         if (personPrimary.person) {
             node.appendChild(this.createElementDefaultNS(
                 "ContactPerson", personPrimary.person
             ));
         }
         if (personPrimary.organization) {
             node.appendChild(this.createElementDefaultNS(
                 "ContactOrganization", personPrimary.organization
             ));
         }
         return node;
     },

     /**
      * Method: write_wmc_ContactAddress
      */
     write_wmc_ContactAddress: function(contactAddress) {
         var node = this.createElementDefaultNS("ContactAddress");
         if (contactAddress.type) {
             node.appendChild(this.createElementDefaultNS(
                 "AddressType", contactAddress.type
             ));
         }
         if (contactAddress.address) {
             node.appendChild(this.createElementDefaultNS(
                 "Address", contactAddress.address
             ));
         }
         if (contactAddress.city) {
             node.appendChild(this.createElementDefaultNS(
                 "City", contactAddress.city
             ));
         }
         if (contactAddress.stateOrProvince) {
             node.appendChild(this.createElementDefaultNS(
                 "StateOrProvince", contactAddress.stateOrProvince
             ));
         }
         if (contactAddress.postcode) {
             node.appendChild(this.createElementDefaultNS(
                 "PostCode", contactAddress.postcode
             ));
         }
         if (contactAddress.country) {
             node.appendChild(this.createElementDefaultNS(
                 "Country", contactAddress.country
             ));
         }
         return node;
     },

     /**
     * Method: write_ol_MapExtension
     */
    write_ol_MapExtension: function(context) {
        var node = this.createElementDefaultNS("Extension");
        
        var bounds = context.maxExtent;
        if(bounds) {
            var maxExtent = this.createElementNS(
                this.namespaces.ol, "ol:maxExtent"
            );
            this.setAttributes(maxExtent, {
                minx: bounds.left.toPrecision(18),
                miny: bounds.bottom.toPrecision(18),
                maxx: bounds.right.toPrecision(18),
                maxy: bounds.top.toPrecision(18)
            });
            node.appendChild(maxExtent);
        }
        
        return node;
    },
    
    /**
     * Method: write_wmc_LayerList
     * Create a LayerList node given an context object.
     *
     * Parameters:
     * context - {Object} Context object.
     *
     * Returns:
     * {Element} A WMC LayerList element node.
     */
    write_wmc_LayerList: function(context) {
        var list = this.createElementDefaultNS("LayerList");
        
        for(var i=0, len=context.layersContext.length; i<len; ++i) {
            list.appendChild(this.write_wmc_Layer(context.layersContext[i]));
        }
        
        return list;
    },

    /**
     * Method: write_wmc_Layer
     * Create a Layer node given a layer context object.
     *
     * Parameters:
     * context - {Object} A layer context object.}
     *
     * Returns:
     * {Element} A WMC Layer element node.
     */
    write_wmc_Layer: function(context) {
        var node = this.createElementDefaultNS(
            "Layer", null, {
                queryable: context.queryable ? "1" : "0",
                hidden: context.visibility ? "0" : "1"
            }
        );
        
        // required Server element
        node.appendChild(this.write_wmc_Server(context));

        // required Name element
        node.appendChild(this.createElementDefaultNS(
            "Name", context.name
        ));
        
        // required Title element
        node.appendChild(this.createElementDefaultNS(
            "Title", context.title
        ));

         // optional Abstract element
         if (context["abstract"]) {
             node.appendChild(this.createElementDefaultNS(
                 "Abstract", context["abstract"]
             ));
         }

         // optional DataURL element
         if (context.dataURL) {
             node.appendChild(this.write_wmc_URLType("DataURL", context.dataURL));
         }

        // optional MetadataURL element
        if (context.metadataURL) {
             node.appendChild(this.write_wmc_URLType("MetadataURL", context.metadataURL));
        }
        
        return node;
    },
    
    /**
     * Method: write_wmc_LayerExtension
     * Add HGIS specific layer parameters to an Extension element.
     *
     * Parameters:
     * context - {Object} A layer context object.
     *
     * Returns:
     * {Element} A WMC Extension element (for a layer).
     */
    write_wmc_LayerExtension: function(context) {
        var node = this.createElementDefaultNS("Extension");
        
        var bounds = context.maxExtent;
        var maxExtent = this.createElementNS(
            this.namespaces.ol, "ol:maxExtent"
        );
        this.setAttributes(maxExtent, {
            minx: bounds.left.toPrecision(18),
            miny: bounds.bottom.toPrecision(18),
            maxx: bounds.right.toPrecision(18),
            maxy: bounds.top.toPrecision(18)
        });
        node.appendChild(maxExtent);
        
        if (context.tileSize && !context.singleTile) {
            var size = this.createElementNS(
                this.namespaces.ol, "ol:tileSize"
            );
            this.setAttributes(size, context.tileSize);
            node.appendChild(size);
        }
        
        var properties = [
            "transparent", "numZoomLevels", "units", "isBaseLayer",
            "opacity", "displayInLayerSwitcher", "singleTile"
        ];
        var child;
        for(var i=0, len=properties.length; i<len; ++i) {
            child = this.createOLPropertyNode(context, properties[i]);
            if(child) {
                node.appendChild(child);
            }
        }

        return node;
    },
    
    /**
     * Method: createOLPropertyNode
     * Create a node representing an HGIS property.  If the property is
     *     null or undefined, null will be returned.
     *
     * Parameters:
     * obj - {Object} An object.
     * prop - {String} A property.
     *
     * Returns:
     * {Element} A property node.
     */
    createOLPropertyNode: function(obj, prop) {
        var node = null;
        if(obj[prop] != null) {
            node = this.createElementNS(this.namespaces.ol, "ol:" + prop);
            node.appendChild(this.createTextNode(obj[prop].toString()));
        }
        return node;
    },

    /**
     * Method: write_wmc_Server
     * Create a Server node given a layer context object.
     *
     * Parameters:
     * context - {Object} Layer context object.
     *
     * Returns:
     * {Element} A WMC Server element node.
     */
    write_wmc_Server: function(context) {
         var server = context.server;
        var node = this.createElementDefaultNS("Server");
         var attributes = {
            service: "OGC:WMS",
             version: server.version
         };
         if (server.title) {
             attributes.title = server.title;
         }
         this.setAttributes(node, attributes);
        
        // required OnlineResource element
         node.appendChild(this.write_wmc_OnlineResource(server.url));
        
        return node;
    },

    /**
     * Method: write_wmc_URLType
     * Create a LogoURL/DescriptionURL/MetadataURL/DataURL/LegendURL node given a object and elementName.
     *
     * Parameters:
     * elName - {String} Name of element (LogoURL/DescriptionURL/MetadataURL/LegendURL)
     * url - {String} URL string value
     * attr - {Object} Optional attributes (width, height, format)
     *
     * Returns:
     * {Element} A WMC element node.
     */
     write_wmc_URLType: function(elName, url, attr) {
         var node = this.createElementDefaultNS(elName);
         node.appendChild(this.write_wmc_OnlineResource(url));
         if (attr) {
             var optionalAttributes = ["width", "height", "format"];
             for (var i=0; i<optionalAttributes.length; i++) {
                 if (optionalAttributes[i] in attr) {
                     node.setAttribute(optionalAttributes[i], attr[optionalAttributes[i]]);
                 }
             }
         }
         return node;
     },

     /**
      * Method: write_wmc_DimensionList
      */
     write_wmc_DimensionList: function(context) {
         var node = this.createElementDefaultNS("DimensionList");
         var required_attributes = {
             name: true,
             units: true,
             unitSymbol: true,
             userValue: true
         };
         for (var dim in context.dimensions) {
             var attributes = {};
             var dimension = context.dimensions[dim];
             for (var name in dimension) {
                 if (typeof dimension[name] == "boolean") {
                     attributes[name] = Number(dimension[name]);
                 } else {
                     attributes[name] = dimension[name];
                 }
             }
             var values = "";
             if (attributes.values) {
                 values = attributes.values.join(",");
                 delete attributes.values;
             }

             node.appendChild(this.createElementDefaultNS(
                 "Dimension", values, attributes
             ));
         }
        return node;
    },

    /**
     * Method: write_wmc_FormatList
     * Create a FormatList node given a layer context.
     *
     * Parameters:
     * context - {Object} Layer context object.
     *
     * Returns:
     * {Element} A WMC FormatList element node.
     */
    write_wmc_FormatList: function(context) {
        var node = this.createElementDefaultNS("FormatList");
        for (var i=0, len=context.formats.length; i<len; i++) {
            var format = context.formats[i];
            node.appendChild(this.createElementDefaultNS(
                "Format",
                format.value,
                (format.current && format.current == true) ?
                    {current: "1"} : null
            ));
        }

        return node;
    },

    /**
     * Method: write_wmc_StyleList
     * Create a StyleList node given a layer context.
     *
     * Parameters:
     * layer - {Object} Layer context object.
     *
     * Returns:
     * {Element} A WMC StyleList element node.
     */
    write_wmc_StyleList: function(layer) {
        var node = this.createElementDefaultNS("StyleList");

        var styles = layer.styles;
        if (styles && HGIS.Util.isArray(styles)) {
            var sld;
            for (var i=0, len=styles.length; i<len; i++) {
                var s = styles[i];
                // three style types to consider
                // [1] linked SLD
                // [2] inline SLD
                // [3] named style
                // running child nodes always gets name, optionally gets href or body
                var style = this.createElementDefaultNS(
                    "Style",
                    null,
                    (s.current && s.current == true) ?
                    {current: "1"} : null
                );
                if(s.href) { // [1]
                    sld = this.createElementDefaultNS("SLD");
                     // Name is optional.
                     if (s.name) {
                    sld.appendChild(this.createElementDefaultNS("Name", s.name));
                     }
                    // Title is optional.
                    if (s.title) {
                        sld.appendChild(this.createElementDefaultNS("Title", s.title));
                    }
                     // LegendURL is optional
                     if (s.legend) {
                         sld.appendChild(this.write_wmc_URLType("LegendURL", s.legend.href, s.legend));
                     }

                     var link = this.write_wmc_OnlineResource(s.href);
                     sld.appendChild(link);
                    style.appendChild(sld);
                } else if(s.body) { // [2]
                    sld = this.createElementDefaultNS("SLD");
                     // Name is optional.
                     if (s.name) {
                         sld.appendChild(this.createElementDefaultNS("Name", s.name));
                     }
                     // Title is optional.
                     if (s.title) {
                         sld.appendChild(this.createElementDefaultNS("Title", s.title));
                     }
                     // LegendURL is optional
                     if (s.legend) {
                         sld.appendChild(this.write_wmc_URLType("LegendURL", s.legend.href, s.legend));
                     }

                    // read in body as xml doc - assume proper namespace declarations
                    var doc = HGIS.Format.XML.prototype.read.apply(this, [s.body]);
                    // append to StyledLayerDescriptor node
                    var imported = doc.documentElement;
                    if(sld.ownerDocument && sld.ownerDocument.importNode) {
                        imported = sld.ownerDocument.importNode(imported, true);
                    }
                    sld.appendChild(imported);
                    style.appendChild(sld);            
                } else { // [3]
                    // both Name and Title are required.
                    style.appendChild(this.createElementDefaultNS("Name", s.name));
                    style.appendChild(this.createElementDefaultNS("Title", s.title));
                    // Abstract is optional
                    if (s['abstract']) { // abstract is a js keyword
                        style.appendChild(this.createElementDefaultNS(
                            "Abstract", s['abstract']
                        ));
                    }
                     // LegendURL is optional
                     if (s.legend) {
                         style.appendChild(this.write_wmc_URLType("LegendURL", s.legend.href, s.legend));
                }
                 }
                node.appendChild(style);
            }
        }

        return node;
    },

    /**
     * Method: write_wmc_OnlineResource
     * Create an OnlineResource node given a URL.
     *
     * Parameters:
     * href - {String} URL for the resource.
     *
     * Returns:
     * {Element} A WMC OnlineResource element node.
     */
    write_wmc_OnlineResource: function(href) {
        var node = this.createElementDefaultNS("OnlineResource");
        this.setAttributeNS(node, this.namespaces.xlink, "xlink:type", "simple");
        this.setAttributeNS(node, this.namespaces.xlink, "xlink:href", href);
        return node;
    },

     /**
      * Method: getOnlineResource_href
      */
     getOnlineResource_href: function(node) {
         var object = {};
         var links = node.getElementsByTagName("OnlineResource");
         if(links.length > 0) {
             this.read_wmc_OnlineResource(object, links[0]);
         }
         return object.href;
     },


    CLASS_NAME: "HGIS.Format.WMC.v1" 

});
/* ======================================================================
    HGIS/Control/PanPanel.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control/Panel.js
 * @requires HGIS/Control/Pan.js
 */

/**
 * Class: HGIS.Control.PanPanel
 * The PanPanel is visible control for panning the map North, South, East or
 * West in small steps. By default it is drawn in the top left corner of the
 * map.
 *
 * Note: 
 * If you wish to use this class with the default images and you want 
 *       it to look nice in ie6, you should add the following, conditionally
 *       added css stylesheet to your HTML file:
 * 
 * (code)
 * <!--[if lte IE 6]>
 *   <link rel="stylesheet" href="../theme/default/ie6-style.css" type="text/css" />
 * <![endif]-->
 * (end)
 *
 * Inherits from:
 *  - <HGIS.Control.Panel> 
 */
HGIS.Control.PanPanel = HGIS.Class(HGIS.Control.Panel, {

    /** 
     * APIProperty: slideFactor
     * {Integer} Number of pixels by which we'll pan the map in any direction 
     *     on clicking the arrow buttons, defaults to 50.  If you want to pan
     *     by some ratio of the map dimensions, use <slideRatio> instead.
     */
    slideFactor: 50,

    /** 
     * APIProperty: slideRatio
     * {Number} The fraction of map width/height by which we'll pan the map            
     *     on clicking the arrow buttons.  Default is null.  If set, will
     *     override <slideFactor>. E.g. if slideRatio is .5, then Pan Up will
     *     pan up half the map height. 
     */
    slideRatio: null,

    /**
     * Constructor: HGIS.Control.PanPanel 
     * Add the four directional pan buttons.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be used
     *     to extend the control.
     */
    initialize: function(options) {
        HGIS.Control.Panel.prototype.initialize.apply(this, [options]);
        var options = {
            slideFactor: this.slideFactor,
            slideRatio: this.slideRatio
        };
        this.addControls([
            new HGIS.Control.Pan(HGIS.Control.Pan.NORTH, options),
            new HGIS.Control.Pan(HGIS.Control.Pan.SOUTH, options),
            new HGIS.Control.Pan(HGIS.Control.Pan.EAST, options),
            new HGIS.Control.Pan(HGIS.Control.Pan.WEST, options)
        ]);
    },

    CLASS_NAME: "HGIS.Control.PanPanel"
});
/* ======================================================================
    HGIS/Control/Attribution.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 */

/**
 * Class: HGIS.Control.Attribution
 * The attribution control adds attribution from layers to the map display. 
 * It uses 'attribution' property of each layer.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.Attribution = 
  HGIS.Class(HGIS.Control, {
    
    /**
     * APIProperty: separator
     * {String} String used to separate layers.
     */
    separator: ", ",
    
    /**
     * APIProperty: template
     * {String} Template for the attribution. This has to include the substring
     *     "${layers}", which will be replaced by the layer specific
     *     attributions, separated by <separator>. The default is "${layers}".
     */
    template: "${layers}",
    
    /**
     * Constructor: HGIS.Control.Attribution 
     * 
     * Parameters:
     * options - {Object} Options for control.
     */

    /** 
     * Method: destroy
     * Destroy control.
     */
    destroy: function() {
        this.map.events.un({
            "removelayer": this.updateAttribution,
            "addlayer": this.updateAttribution,
            "changelayer": this.updateAttribution,
            "changebaselayer": this.updateAttribution,
            scope: this
        });
        
        HGIS.Control.prototype.destroy.apply(this, arguments);
    },    
    
    /**
     * Method: draw
     * Initialize control.
     * 
     * Returns: 
     * {DOMElement} A reference to the DIV DOMElement containing the control
     */    
    draw: function() {
        HGIS.Control.prototype.draw.apply(this, arguments);
        
        this.map.events.on({
            'changebaselayer': this.updateAttribution,
            'changelayer': this.updateAttribution,
            'addlayer': this.updateAttribution,
            'removelayer': this.updateAttribution,
            scope: this
        });
        this.updateAttribution();
        
        return this.div;    
    },

    /**
     * Method: updateAttribution
     * Update attribution string.
     */
    updateAttribution: function() {
        var attributions = [];
        if (this.map && this.map.layers) {
            for(var i=0, len=this.map.layers.length; i<len; i++) {
                var layer = this.map.layers[i];
                if (layer.attribution && layer.getVisibility()) {
                    // add attribution only if attribution text is unique
                    if (HGIS.Util.indexOf(
                                    attributions, layer.attribution) === -1) {
                        attributions.push( layer.attribution );
                    }
                }
            } 
            this.div.innerHTML = HGIS.String.format(this.template, {
                layers: attributions.join(this.separator)
            });
        }
    },

    CLASS_NAME: "HGIS.Control.Attribution"
});
/* ======================================================================
    HGIS/Kinetic.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Animation.js
 */

HGIS.Kinetic = HGIS.Class({

    /**
     * Property: threshold
     * In most cases changing the threshold isn't needed.
     * In px/ms, default to 0.
     */
    threshold: 0,

    /**
     * Property: deceleration
     * {Float} the deseleration in px/ms², default to 0.0035.
     */
    deceleration: 0.0035,

    /**
     * Property: nbPoints
     * {Integer} the number of points we use to calculate the kinetic
     * initial values.
     */
    nbPoints: 100,

    /**
     * Property: delay
     * {Float} time to consider to calculate the kinetic initial values.
     * In ms, default to 200.
     */
    delay: 200,

    /**
     * Property: points
     * List of points use to calculate the kinetic initial values.
     */
    points: undefined,

    /**
     * Property: timerId
     * ID of the timer.
     */
    timerId: undefined,

    /**
     * Constructor: HGIS.Kinetic
     *
     * Parameters:
     * options - {Object}
     */
    initialize: function(options) {
        HGIS.Util.extend(this, options);
    },

    /**
     * Method: begin
     * Begins the dragging.
     */
    begin: function() {
        HGIS.Animation.stop(this.timerId);
        this.timerId = undefined;
        this.points = [];
    },

    /**
     * Method: update
     * Updates during the dragging.
     *
     * Parameters:
     * xy - {<HGIS.Pixel>} The new position.
     */
    update: function(xy) {
        this.points.unshift({xy: xy, tick: new Date().getTime()});
        if (this.points.length > this.nbPoints) {
            this.points.pop();
        }
    },

    /**
     * Method: end
     * Ends the dragging, start the kinetic.
     *
     * Parameters:
     * xy - {<HGIS.Pixel>} The last position.
     *
     * Returns:
     * {Object} An object with two properties: "speed", and "theta". The
     *     "speed" and "theta" values are to be passed to the move 
     *     function when starting the animation.
     */
    end: function(xy) {
        var last, now = new Date().getTime();
        for (var i = 0, l = this.points.length, point; i < l; i++) {
            point = this.points[i];
            if (now - point.tick > this.delay) {
                break;
            }
            last = point;
        }
        if (!last) {
            return;
        }
        var time = new Date().getTime() - last.tick;
        var dist = Math.sqrt(Math.pow(xy.x - last.xy.x, 2) +
                             Math.pow(xy.y - last.xy.y, 2));
        var speed = dist / time;
        if (speed == 0 || speed < this.threshold) {
            return;
        }
        var theta = Math.asin((xy.y - last.xy.y) / dist);
        if (last.xy.x <= xy.x) {
            theta = Math.PI - theta;
        }
        return {speed: speed, theta: theta};
    },

    /**
     * Method: move
     * Launch the kinetic move pan.
     *
     * Parameters:
     * info - {Object} An object with two properties, "speed", and "theta".
     *     These values are those returned from the "end" call.
     * callback - {Function} Function called on every step of the animation,
     *     receives x, y (values to pan), end (is the last point).
     */
    move: function(info, callback) {
        var v0 = info.speed;
        var fx = Math.cos(info.theta);
        var fy = -Math.sin(info.theta);

        var initialTime = new Date().getTime();

        var lastX = 0;
        var lastY = 0;

        var timerCallback = function() {
            if (this.timerId == null) {
                return;
            }

            var t = new Date().getTime() - initialTime;

            var p = (-this.deceleration * Math.pow(t, 2)) / 2.0 + v0 * t;
            var x = p * fx;
            var y = p * fy;

            var args = {};
            args.end = false;
            var v = -this.deceleration * t + v0;

            if (v <= 0) {
                HGIS.Animation.stop(this.timerId);
                this.timerId = null;
                args.end = true;
            }

            args.x = x - lastX;
            args.y = y - lastY;
            lastX = x;
            lastY = y;
            callback(args.x, args.y, args.end);
        };

        this.timerId = HGIS.Animation.start(
            HGIS.Function.bind(timerCallback, this)
        );
    },

    CLASS_NAME: "HGIS.Kinetic"
});
/* ======================================================================
    HGIS/Format/WPSExecute.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/OWSCommon/v1_1_0.js
 * @requires HGIS/Format/WCSGetCoverage.js
 * @requires HGIS/Format/WFST/v1_1_0.js
 */

/**
 * Class: HGIS.Format.WPSExecute version 1.0.0
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.WPSExecute = HGIS.Class(HGIS.Format.XML,
                                            HGIS.Format.Filter.v1_1_0, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        gml: "http://www.opengis.net/gml",
        wps: "http://www.opengis.net/wps/1.0.0",
        wfs: "http://www.opengis.net/wfs",
        ogc: "http://www.opengis.net/ogc",
        wcs: "http://www.opengis.net/wcs",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * Constant: VERSION
     * {String} 1.0.0
     */
    VERSION: "1.0.0",

    /**
     * Property: schemaLocation
     * {String} Schema location
     */
    schemaLocation: "http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd",

    schemaLocationAttr: function(options) {
        return undefined;
    },

    /**
     * Constructor: HGIS.Format.WPSExecute
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Method: write
     *
     * Parameters:
     * options - {Object} Optional object.
     *
     * Returns:
     * {String} An WPS Execute request XML string.
     */
    write: function(options) {
        var doc;
        if (window.ActiveXObject) {
            doc = new ActiveXObject("Microsoft.XMLDOM");
            this.xmldom = doc;
        } else {
            doc = document.implementation.createDocument("", "", null);
        }
        var node = this.writeNode("wps:Execute", options, doc);
        this.setAttributeNS(
            node, this.namespaces.xsi,
            "xsi:schemaLocation", this.schemaLocation
        );
        return HGIS.Format.XML.prototype.write.apply(this, [node]);
    }, 

    /**
     * APIMethod: read
     * Parse a WPS Execute and return an object with its information.
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object}
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var info = {};
        this.readNode(data, info);
        return info;
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "wps": {
            "Execute": function(options) {
                var node = this.createElementNSPlus("wps:Execute", {
                    attributes: {
                        version: this.VERSION,
                        service: 'WPS'
                    } 
                }); 
                this.writeNode("ows:Identifier", options.identifier, node);
                this.writeNode("wps:DataInputs", options.dataInputs, node);
                this.writeNode("wps:ResponseForm", options.responseForm, node);
                return node; 
            },
            "ResponseForm": function(responseForm) {
                var node = this.createElementNSPlus("wps:ResponseForm", {});
                if (responseForm.rawDataOutput) {
                    this.writeNode("wps:RawDataOutput", responseForm.rawDataOutput, node);
                }
                if (responseForm.responseDocument) {
                    this.writeNode("wps:ResponseDocument", responseForm.responseDocument, node);
                }
                return node;
            },
            "ResponseDocument": function(responseDocument) {
                var node = this.createElementNSPlus("wps:ResponseDocument", {
                    attributes: {
                        storeExecuteResponse: responseDocument.storeExecuteResponse,
                        lineage: responseDocument.lineage,
                        status: responseDocument.status
                    }
                });
                if (responseDocument.outputs) {
                    for (var i = 0, len = responseDocument.outputs.length; i < len; i++) {
                        this.writeNode("wps:Output", responseDocument.outputs[i], node);
                    }
                }
                return node;
            },
            "Output": function(output) {
                var node = this.createElementNSPlus("wps:Output", {
                    attributes: {
                        asReference: output.asReference,
                        mimeType: output.mimeType,
                        encoding: output.encoding,
                        schema: output.schema
                    }
                });
                this.writeNode("ows:Identifier", output.identifier, node);
                this.writeNode("ows:Title", output.title, node);
                this.writeNode("ows:Abstract", output["abstract"], node);
                return node;
            },
            "RawDataOutput": function(rawDataOutput) {
                var node = this.createElementNSPlus("wps:RawDataOutput", {
                    attributes: {
                        mimeType: rawDataOutput.mimeType,
                        encoding: rawDataOutput.encoding,
                        schema: rawDataOutput.schema
                    }
                });
                this.writeNode("ows:Identifier", rawDataOutput.identifier, node);
                return node;
            },
            "DataInputs": function(dataInputs) {
                var node = this.createElementNSPlus("wps:DataInputs", {});
                for (var i=0, ii=dataInputs.length; i<ii; ++i) {
                    this.writeNode("wps:Input", dataInputs[i], node);
                }
                return node;
            },
            "Input": function(input) {
                var node = this.createElementNSPlus("wps:Input", {});
                this.writeNode("ows:Identifier", input.identifier, node);
                if (input.title) {
                    this.writeNode("ows:Title", input.title, node);
                }
                if (input.data) {
                    this.writeNode("wps:Data", input.data, node);
                }
                if (input.reference) {
                    this.writeNode("wps:Reference", input.reference, node);
                }
                if (input.boundingBoxData) {
                    this.writeNode("wps:BoundingBoxData", input.boundingBoxData, node);
                }
                return node;
            },
            "Data": function(data) {
                var node = this.createElementNSPlus("wps:Data", {});
                if (data.literalData) {
                    this.writeNode("wps:LiteralData", data.literalData, node);
                } else if (data.complexData) {
                    this.writeNode("wps:ComplexData", data.complexData, node);
                } else if (data.boundingBoxData) {
                    this.writeNode("ows:BoundingBox", data.boundingBoxData, node);
                }
                return node;
            },
            "LiteralData": function(literalData) {
                var node = this.createElementNSPlus("wps:LiteralData", {
                    attributes: {
                        uom: literalData.uom
                    },
                    value: literalData.value
                });
                return node;
            },
            "ComplexData": function(complexData) {
                var node = this.createElementNSPlus("wps:ComplexData", {
                    attributes: {
                        mimeType: complexData.mimeType,
                        encoding: complexData.encoding,
                        schema: complexData.schema
                    } 
                });
                var data = complexData.value;
                if (typeof data === "string") {
                    node.appendChild(
                        this.getXMLDoc().createCDATASection(complexData.value)
                    );
                } else {
                    node.appendChild(data);
                }
                return node;
            },
            "Reference": function(reference) {
                var node = this.createElementNSPlus("wps:Reference", {
                    attributes: {
                        mimeType: reference.mimeType,
                        "xlink:href": reference.href,
                        method: reference.method,
                        encoding: reference.encoding,
                        schema: reference.schema
                    }
                });
                if (reference.body) {
                    this.writeNode("wps:Body", reference.body, node);
                }
                return node;
            },
            "BoundingBoxData": function(node, obj) {
                this.writers['ows']['BoundingBox'].apply(this, [node, obj, "wps:BoundingBoxData"]);
            },
            "Body": function(body) {
                var node = this.createElementNSPlus("wps:Body", {});
                if (body.wcs) {
                    this.writeNode("wcs:GetCoverage", body.wcs, node);
                }
                else if (body.wfs) {
                    // HGIS.Format.WFST expects these to be on the 
                    // instance and not in the options
                    this.featureType = body.wfs.featureType;
                    this.version = body.wfs.version;
                    this.writeNode("wfs:GetFeature", body.wfs, node);
                } else {
                    this.writeNode("wps:Execute", body, node);
                }
                return node;                
            }
        },
        "wcs": HGIS.Format.WCSGetCoverage.prototype.writers.wcs,
        "wfs": HGIS.Format.WFST.v1_1_0.prototype.writers.wfs,
        "ogc": HGIS.Format.Filter.v1_1_0.prototype.writers.ogc,
        "ows": HGIS.Format.OWSCommon.v1_1_0.prototype.writers.ows
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wps": {
            "ExecuteResponse": function(node, obj) {
                obj.executeResponse = {
                    lang: node.getAttribute("lang"),
                    statusLocation: node.getAttribute("statusLocation"),
                    serviceInstance: node.getAttribute("serviceInstance"),
                    service: node.getAttribute("service")
                };
                this.readChildNodes(node, obj.executeResponse);
            },
            "Process":function(node,obj) {
                obj.process = {};
                this.readChildNodes(node, obj.process);
            },
            "Status":function(node,obj) {
                obj.status = {
                    creationTime: node.getAttribute("creationTime")
                };
                this.readChildNodes(node, obj.status);
            },
            "ProcessSucceeded": function(node,obj) {
                obj.processSucceeded = true;
            },
            "ProcessOutputs": function(node, processDescription) {
                processDescription.processOutputs = [];
                this.readChildNodes(node, processDescription.processOutputs);
            },
            "Output": function(node, processOutputs) {
                var output = {};
                this.readChildNodes(node, output);
                processOutputs.push(output);
            },
            "Reference": function(node, output) {
                output.reference = {
                    href: node.getAttribute("href"),
                    mimeType: node.getAttribute("mimeType"),
                    encoding: node.getAttribute("encoding"),
                    schema: node.getAttribute("schema")
                };
            },
            "Data": function(node, output) {
                output.data = {};
                this.readChildNodes(node, output);
            },
            "LiteralData": function(node, output) {
                output.literalData = {
                    dataType: node.getAttribute("dataType"),
                    uom: node.getAttribute("uom"),
                    value: this.getChildValue(node)
                };
            },
            "ComplexData": function(node, output) {
                output.complexData = {
                    mimeType: node.getAttribute("mimeType"),
                    schema: node.getAttribute("schema"),
                    encoding: node.getAttribute("encoding"),
                    value: ""
                };
                
                // try to get *some* value, ignore the empty text values
                if (this.isSimpleContent(node)) {
                    var child;
                    for(child=node.firstChild; child; child=child.nextSibling) {
                        switch(child.nodeType) {
                            case 3: // text node
                            case 4: // cdata section
                                output.complexData.value += child.nodeValue;
                        }
                    }
                }
                else {
                    for(child=node.firstChild; child; child=child.nextSibling) {
                        if (child.nodeType == 1) {
                            output.complexData.value = child;
                        }
                    }
                }

            },
            "BoundingBox": function(node, output) {
                output.boundingBoxData = {
                    dimensions: node.getAttribute("dimensions"),
                    crs: node.getAttribute("crs")
                };
                this.readChildNodes(node, output.boundingBoxData);
            }
        },

        // TODO: we should add Exception parsing here
        "ows": HGIS.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },
    
    CLASS_NAME: "HGIS.Format.WPSExecute" 

});
/* ======================================================================
    HGIS/Layer/GeoRSS.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer/Markers.js
 * @requires HGIS/Request/XMLHttpRequest.js
 */

/**
 * Class: HGIS.Layer.GeoRSS
 * Add GeoRSS Point features to your map. 
 * 
 * Inherits from:
 *  - <HGIS.Layer.Markers>
 */
HGIS.Layer.GeoRSS = HGIS.Class(HGIS.Layer.Markers, {

    /** 
     * Property: location 
     * {String} store url of text file 
     */
    location: null,

    /** 
     * Property: features 
     * {Array(<HGIS.Feature>)} 
     */
    features: null,
    
    /**
     * APIProperty: formatOptions
     * {Object} Hash of options which should be passed to the format when it is
     * created. Must be passed in the constructor.
     */
    formatOptions: null, 

    /** 
     * Property: selectedFeature 
     * {<HGIS.Feature>} 
     */
    selectedFeature: null,

    /** 
     * APIProperty: icon 
     * {<HGIS.Icon>}. This determines the Icon to be used on the map
     * for this GeoRSS layer.
     */
    icon: null,

    /**
     * APIProperty: popupSize
     * {<HGIS.Size>} This determines the size of GeoRSS popups. If 
     * not provided, defaults to 250px by 120px. 
     */
    popupSize: null, 
    
    /** 
     * APIProperty: useFeedTitle 
     * {Boolean} Set layer.name to the first <title> element in the feed. Default is true. 
     */
    useFeedTitle: true,
    
    /**
    * Constructor: HGIS.Layer.GeoRSS
    * Create a GeoRSS Layer.
    *
    * Parameters:
    * name - {String} 
    * location - {String} 
    * options - {Object}
    */
    initialize: function(name, location, options) {
        HGIS.Layer.Markers.prototype.initialize.apply(this, [name, options]);
        this.location = location;
        this.features = [];
    },

    /**
     * Method: destroy 
     */
    destroy: function() {
        // Warning: Layer.Markers.destroy() must be called prior to calling
        // clearFeatures() here, otherwise we leak memory. Indeed, if
        // Layer.Markers.destroy() is called after clearFeatures(), it won't be
        // able to remove the marker image elements from the layer's div since
        // the markers will have been destroyed by clearFeatures().
        HGIS.Layer.Markers.prototype.destroy.apply(this, arguments);
        this.clearFeatures();
        this.features = null;
    },

    /**
     * Method: loadRSS
     * Start the load of the RSS data. Don't do this when we first add the layer,
     * since we may not be visible at any point, and it would therefore be a waste.
     */
    loadRSS: function() {
        if (!this.loaded) {
            this.events.triggerEvent("loadstart");
            HGIS.Request.GET({
                url: this.location,
                success: this.parseData,
                scope: this
            });
            this.loaded = true;
        }    
    },    
    
    /**
     * Method: moveTo
     * If layer is visible and RSS has not been loaded, load RSS. 
     * 
     * Parameters:
     * bounds - {Object} 
     * zoomChanged - {Object} 
     * minor - {Object} 
     */
    moveTo:function(bounds, zoomChanged, minor) {
        HGIS.Layer.Markers.prototype.moveTo.apply(this, arguments);
        if(this.visibility && !this.loaded){
            this.loadRSS();
        }
    },
        
    /**
     * Method: parseData
     * Parse the data returned from the Events call.
     *
     * Parameters:
     * ajaxRequest - {<HGIS.Request.XMLHttpRequest>} 
     */
    parseData: function(ajaxRequest) {
        var doc = ajaxRequest.responseXML;
        if (!doc || !doc.documentElement) {
            doc = HGIS.Format.XML.prototype.read(ajaxRequest.responseText);
        }
        
        if (this.useFeedTitle) {
            var name = null;
            try {
                name = doc.getElementsByTagNameNS('*', 'title')[0].firstChild.nodeValue;
            }
            catch (e) {
                name = doc.getElementsByTagName('title')[0].firstChild.nodeValue;
            }
            if (name) {
                this.setName(name);
            }    
        }
       
        var options = {};
        
        HGIS.Util.extend(options, this.formatOptions);
        
        if (this.map && !this.projection.equals(this.map.getProjectionObject())) {
            options.externalProjection = this.projection;
            options.internalProjection = this.map.getProjectionObject();
        }    
        
        var format = new HGIS.Format.GeoRSS(options);
        var features = format.read(doc);
        
        for (var i=0, len=features.length; i<len; i++) {
            var data = {};
            var feature = features[i];
            
            // we don't support features with no geometry in the GeoRSS
            // layer at this time. 
            if (!feature.geometry) {
                continue;
            }    
            
            var title = feature.attributes.title ? 
                         feature.attributes.title : "Untitled";
            
            var description = feature.attributes.description ? 
                         feature.attributes.description : "No description.";
            
            var link = feature.attributes.link ? feature.attributes.link : "";

            var location = feature.geometry.getBounds().getCenterLonLat();
            
            
            data.icon = this.icon == null ? 
                                     HGIS.Marker.defaultIcon() : 
                                     this.icon.clone();
            
            data.popupSize = this.popupSize ? 
                             this.popupSize.clone() :
                             new HGIS.Size(250, 120);
            
            if (title || description) {
                // we have supplemental data, store them.
                data.title = title;
                data.description = description;
            
                var contentHTML = '<div class="olLayerGeoRSSClose">[x]</div>'; 
                contentHTML += '<div class="olLayerGeoRSSTitle">';
                if (link) {
                    contentHTML += '<a class="link" href="'+link+'" target="_blank">';
                }
                contentHTML += title;
                if (link) {
                    contentHTML += '</a>';
                }
                contentHTML += '</div>';
                contentHTML += '<div style="" class="olLayerGeoRSSDescription">';
                contentHTML += description;
                contentHTML += '</div>';
                data['popupContentHTML'] = contentHTML;                
            }
            var feature = new HGIS.Feature(this, location, data);
            this.features.push(feature);
            var marker = feature.createMarker();
            marker.events.register('click', feature, this.markerClick);
            this.addMarker(marker);
        }
        this.events.triggerEvent("loadend");
    },
    
    /**
     * Method: markerClick
     *
     * Parameters:
     * evt - {Event} 
     */
    markerClick: function(evt) {
        var sameMarkerClicked = (this == this.layer.selectedFeature);
        this.layer.selectedFeature = (!sameMarkerClicked) ? this : null;
        for(var i=0, len=this.layer.map.popups.length; i<len; i++) {
            this.layer.map.removePopup(this.layer.map.popups[i]);
        }
        if (!sameMarkerClicked) {
            var popup = this.createPopup();
            HGIS.Event.observe(popup.div, "click",
                HGIS.Function.bind(function() { 
                    for(var i=0, len=this.layer.map.popups.length; i<len; i++) { 
                        this.layer.map.removePopup(this.layer.map.popups[i]); 
                    }
                }, this)
            );
            this.layer.map.addPopup(popup); 
        }
        HGIS.Event.stop(evt);
    },

    /**
     * Method: clearFeatures
     * Destroy all features in this layer.
     */
    clearFeatures: function() {
        if (this.features != null) {
            while(this.features.length > 0) {
                var feature = this.features[0];
                HGIS.Util.removeItem(this.features, feature);
                feature.destroy();
            }
        }        
    },
    
    CLASS_NAME: "HGIS.Layer.GeoRSS"
});
/* ======================================================================
    HGIS/Symbolizer/Point.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Symbolizer.js
 */

/**
 * Class: HGIS.Symbolizer.Point
 * A symbolizer used to render point features.
 */
HGIS.Symbolizer.Point = HGIS.Class(HGIS.Symbolizer, {
    
    /**
     * APIProperty: strokeColor
     * {String} Color for line stroke.  This is a RGB hex value (e.g. "#ff0000"
     *     for red).
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: strokeOpacity
     * {Number} Stroke opacity (0-1).
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: strokeWidth
     * {Number} Pixel stroke width.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: strokeLinecap
     * {String} Stroke cap type ("butt", "round", or "square").
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * Property: strokeDashstyle
     * {String} Stroke dash style according to the SLD spec. Note that the
     *     HGIS values for strokeDashstyle ("dot", "dash", "dashdot",
     *     "longdash", "longdashdot", or "solid") will not work in SLD, but
     *     most SLD patterns will render correctly in HGIS.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */

    /**
     * APIProperty: fillColor
     * {String} RGB hex fill color (e.g. "#ff0000" for red).
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: fillOpacity
     * {Number} Fill opacity (0-1).
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */

    /**
     * APIProperty: pointRadius
     * {Number} Pixel point radius.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */

    /**
     * APIProperty: externalGraphic
     * {String} Url to an external graphic that will be used for rendering 
     *     points.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: graphicWidth
     * {Number} Pixel width for sizing an external graphic.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: graphicHeight
     * {Number} Pixel height for sizing an external graphic.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: graphicOpacity
     * {Number} Opacity (0-1) for an external graphic.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: graphicXOffset
     * {Number} Pixel offset along the positive x axis for displacing an 
     *     external graphic.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: graphicYOffset
     * {Number} Pixel offset along the positive y axis for displacing an 
     *     external graphic.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */

    /**
     * APIProperty: rotation
     * {Number} The rotation of a graphic in the clockwise direction about its 
     *     center point (or any point off center as specified by 
     *     <graphicXOffset> and <graphicYOffset>).
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: graphicName
     * {String} Named graphic to use when rendering points.  Supported values 
     *     include "circle", "square", "star", "x", "cross", and "triangle".
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * Constructor: HGIS.Symbolizer.Point
     * Create a symbolizer for rendering points.
     *
     * Parameters:
     * config - {Object} An object containing properties to be set on the 
     *     symbolizer.  Any documented symbolizer property can be set at 
     *     construction.
     *
     * Returns:
     * A new point symbolizer.
     */
    initialize: function(config) {
        HGIS.Symbolizer.prototype.initialize.apply(this, arguments);
    },
    
    CLASS_NAME: "HGIS.Symbolizer.Point"
    
});

/* ======================================================================
    HGIS/Symbolizer/Line.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Symbolizer.js
 */

/**
 * Class: HGIS.Symbolizer.Line
 * A symbolizer used to render line features.
 */
HGIS.Symbolizer.Line = HGIS.Class(HGIS.Symbolizer, {

    /**
     * APIProperty: strokeColor
     * {String} Color for line stroke.  This is a RGB hex value (e.g. "#ff0000"
     *     for red).  
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: strokeOpacity
     * {Number} Stroke opacity (0-1).
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: strokeWidth
     * {Number} Pixel stroke width.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * APIProperty: strokeLinecap
     * {String} Stroke cap type ("butt", "round", or "square").
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * Property: strokeDashstyle
     * {String} Stroke dash style according to the SLD spec. Note that the
     *     HGIS values for strokeDashstyle ("dot", "dash", "dashdot",
     *     "longdash", "longdashdot", or "solid") will not work in SLD, but
     *     most SLD patterns will render correctly in HGIS.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */

    /**
     * Constructor: HGIS.Symbolizer.Line
     * Create a symbolizer for rendering lines.
     *
     * Parameters:
     * config - {Object} An object containing properties to be set on the 
     *     symbolizer.  Any documented symbolizer property can be set at 
     *     construction.
     *
     * Returns:
     * A new line symbolizer.
     */
    initialize: function(config) {
        HGIS.Symbolizer.prototype.initialize.apply(this, arguments);
    },
    
    CLASS_NAME: "HGIS.Symbolizer.Line"
    
});

/* ======================================================================
    HGIS/Symbolizer/Text.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Symbolizer.js
 */

/**
 * Class: HGIS.Symbolizer.Text
 * A symbolizer used to render text labels for features.
 */
HGIS.Symbolizer.Text = HGIS.Class(HGIS.Symbolizer, {
    
    /** 
     * APIProperty: label
     * {String} The text for the label.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /** 
     * APIProperty: fontFamily
     * {String} The font family for the label.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */

    /** 
     * APIProperty: fontSize
     * {String} The font size for the label.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */

    /** 
     * APIProperty: fontWeight
     * {String} The font weight for the label.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */
    
    /**
     * Property: fontStyle
     * {String} The font style for the label.
     * 
     * No default set here.  Use HGIS.Renderer.defaultRenderer for defaults.
     */

    /**
     * Constructor: HGIS.Symbolizer.Text
     * Create a symbolizer for rendering text labels.
     *
     * Parameters:
     * config - {Object} An object containing properties to be set on the 
     *     symbolizer.  Any documented symbolizer property can be set at 
     *     construction.
     *
     * Returns:
     * A new text symbolizer.
     */
    initialize: function(config) {
        HGIS.Symbolizer.prototype.initialize.apply(this, arguments);
    },
    
    CLASS_NAME: "HGIS.Symbolizer.Text"
    
});

/* ======================================================================
    HGIS/Format/SLD/v1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Rule.js
 * @requires HGIS/Format/SLD.js
 * @requires HGIS/Format/Filter/v1_0_0.js
 * @requires HGIS/Symbolizer/Point.js
 * @requires HGIS/Symbolizer/Line.js
 * @requires HGIS/Symbolizer/Polygon.js
 * @requires HGIS/Symbolizer/Text.js
 * @requires HGIS/Symbolizer/Raster.js
 */

/**
 * Class: HGIS.Format.SLD.v1
 * Superclass for SLD version 1 parsers.
 *
 * Inherits from:
 *  - <HGIS.Format.Filter.v1_0_0>
 */
HGIS.Format.SLD.v1 = HGIS.Class(HGIS.Format.Filter.v1_0_0, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        sld: "http://www.opengis.net/sld",
        ogc: "http://www.opengis.net/ogc",
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    
    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "sld",

    /**
     * Property: schemaLocation
     * {String} Schema location for a particular minor version.
     */
    schemaLocation: null,
    
    /** 
     * APIProperty: multipleSymbolizers
     * {Boolean} Support multiple symbolizers per rule.  Default is false.  if
     *     true, an HGIS.Style2 instance will be created to represent 
     *     user styles instead of an HGIS.Style instace.  The 
     *     HGIS.Style2 class allows collections of rules with multiple
     *     symbolizers, but is not currently useful for client side rendering.
     *     If multiple symbolizers is true, multiple FeatureTypeStyle elements
     *     are preserved in reading/writing by setting symbolizer zIndex values.
     *     In addition, the <defaultSymbolizer> property is ignored if 
     *     multiple symbolizers are supported (defaults should be applied
     *     when rendering).
     */
    multipleSymbolizers: false,

    /**
     * Property: featureTypeCounter
     * {Number} Private counter for multiple feature type styles.
     */
    featureTypeCounter: null,

    /**
     * APIProperty: defaultSymbolizer.
     * {Object} A symbolizer with the SLD defaults.
     */
    defaultSymbolizer: {
        fillColor: "#808080",
        fillOpacity: 1,
        strokeColor: "#000000",
        strokeOpacity: 1,
        strokeWidth: 1,
        strokeDashstyle: "solid",
        pointRadius: 3,
        graphicName: "square"
    },
    
    /**
     * Constructor: HGIS.Format.SLD.v1
     * Instances of this class are not created directly.  Use the
     *     <HGIS.Format.SLD> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    
    /**
     * Method: read
     *
     * Parameters:
     * data - {DOMElement} An SLD document element.
     * options - {Object} Options for the reader.
     *
     * Valid options:
     * namedLayersAsArray - {Boolean}  Generate a namedLayers array.  If false,
     *     the namedLayers property value will be an object keyed by layer name.
     *     Default is false.
     *
     * Returns:
     * {Object} An object representing the SLD.
     */
    read: function(data, options) {
        options = HGIS.Util.applyDefaults(options, this.options);
        var sld = {
            namedLayers: options.namedLayersAsArray === true ? [] : {}
        };
        this.readChildNodes(data, sld);
        return sld;
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: HGIS.Util.applyDefaults({
        "sld": {
            "StyledLayerDescriptor": function(node, sld) {
                sld.version = node.getAttribute("version");
                this.readChildNodes(node, sld);
            },
            "Name": function(node, obj) {
                obj.name = this.getChildValue(node);
            },
            "Title": function(node, obj) {
                obj.title = this.getChildValue(node);
            },
            "Abstract": function(node, obj) {
                obj.description = this.getChildValue(node);
            },
            "NamedLayer": function(node, sld) {
                var layer = {
                    userStyles: [],
                    namedStyles: []
                };
                this.readChildNodes(node, layer);
                // give each of the user styles this layer name
                for(var i=0, len=layer.userStyles.length; i<len; ++i) {
                    layer.userStyles[i].layerName = layer.name;
                }
                if(HGIS.Util.isArray(sld.namedLayers)) {
                    sld.namedLayers.push(layer);                
                } else {
                    sld.namedLayers[layer.name] = layer;
                }
            },
            "NamedStyle": function(node, layer) {
                layer.namedStyles.push(
                    this.getChildName(node.firstChild)
                );
            },
            "UserStyle": function(node, layer) {
                var obj = {defaultsPerSymbolizer: true, rules: []};
                this.featureTypeCounter = -1;
                this.readChildNodes(node, obj);
                var style;
                if (this.multipleSymbolizers) {
                    delete obj.defaultsPerSymbolizer;
                    style = new HGIS.Style2(obj);
                } else {
                    style = new HGIS.Style(this.defaultSymbolizer, obj);
                }
                layer.userStyles.push(style);
            },
            "IsDefault": function(node, style) {
                if(this.getChildValue(node) == "1") {
                    style.isDefault = true;
                }
            },
            "FeatureTypeStyle": function(node, style) {
                ++this.featureTypeCounter;
                var obj = {
                    rules: this.multipleSymbolizers ? style.rules : []
                };
                this.readChildNodes(node, obj);
                if (!this.multipleSymbolizers) {
                    style.rules = obj.rules;
                }
            },
            "Rule": function(node, obj) {
                var config;
                if (this.multipleSymbolizers) {
                    config = {symbolizers: []};
                }
                var rule = new HGIS.Rule(config);
                this.readChildNodes(node, rule);
                obj.rules.push(rule);
            },
            "ElseFilter": function(node, rule) {
                rule.elseFilter = true;
            },
            "MinScaleDenominator": function(node, rule) {
                rule.minScaleDenominator = parseFloat(this.getChildValue(node));
            },
            "MaxScaleDenominator": function(node, rule) {
                rule.maxScaleDenominator = parseFloat(this.getChildValue(node));
            },
            "TextSymbolizer": function(node, rule) {
                var config = {};
                this.readChildNodes(node, config);
                if (this.multipleSymbolizers) {
                    config.zIndex = this.featureTypeCounter;
                    rule.symbolizers.push(
                        new HGIS.Symbolizer.Text(config)
                    );
                } else {
                    rule.symbolizer["Text"] = HGIS.Util.applyDefaults(
                        config, rule.symbolizer["Text"]
                    );
                }
            },
            "LabelPlacement": function(node, symbolizer) {
                this.readChildNodes(node, symbolizer);
            },
            "PointPlacement": function(node, symbolizer) {
                var config = {};
                this.readChildNodes(node, config);
                config.labelRotation = config.rotation;
                delete config.rotation;
                var labelAlign,
                    x = symbolizer.labelAnchorPointX,
                    y = symbolizer.labelAnchorPointY;
                if (x <= 1/3) {
                    labelAlign = 'l';
                } else if (x > 1/3 && x < 2/3) {
                    labelAlign = 'c';
                } else if (x >= 2/3) {
                    labelAlign = 'r';
                }
                if (y <= 1/3) {
                    labelAlign += 'b';
                } else if (y > 1/3 && y < 2/3) {
                    labelAlign += 'm';
                } else if (y >= 2/3) {
                    labelAlign += 't';
                }
                config.labelAlign = labelAlign;
                HGIS.Util.applyDefaults(symbolizer, config);
            },
            "AnchorPoint": function(node, symbolizer) {
                this.readChildNodes(node, symbolizer);
            },
            "AnchorPointX": function(node, symbolizer) {
                var labelAnchorPointX = this.readers.ogc._expression.call(this, node);
                // always string, could be empty string
                if(labelAnchorPointX) {
                    symbolizer.labelAnchorPointX = labelAnchorPointX;
                }
            },
            "AnchorPointY": function(node, symbolizer) {
                var labelAnchorPointY = this.readers.ogc._expression.call(this, node);
                // always string, could be empty string
                if(labelAnchorPointY) {
                    symbolizer.labelAnchorPointY = labelAnchorPointY;
                }
            },
            "Displacement": function(node, symbolizer) {
                this.readChildNodes(node, symbolizer);
            },
            "DisplacementX": function(node, symbolizer) {
                var labelXOffset = this.readers.ogc._expression.call(this, node);
                // always string, could be empty string
                if(labelXOffset) {
                    symbolizer.labelXOffset = labelXOffset;
                }
            },
            "DisplacementY": function(node, symbolizer) {
                var labelYOffset = this.readers.ogc._expression.call(this, node);
                // always string, could be empty string
                if(labelYOffset) {
                    symbolizer.labelYOffset = labelYOffset;
                }
            },
            "LinePlacement": function(node, symbolizer) {
                this.readChildNodes(node, symbolizer);
            },
            "PerpendicularOffset": function(node, symbolizer) {
                var labelPerpendicularOffset = this.readers.ogc._expression.call(this, node);
                // always string, could be empty string
                if(labelPerpendicularOffset) {
                    symbolizer.labelPerpendicularOffset = labelPerpendicularOffset;
                }
            },
            "Label": function(node, symbolizer) {
                var value = this.readers.ogc._expression.call(this, node);
                if (value) {
                    symbolizer.label = value;
                }
            },
            "Font": function(node, symbolizer) {
                this.readChildNodes(node, symbolizer);
            },
            "Halo": function(node, symbolizer) {
                // halo has a fill, so send fresh object
                var obj = {};
                this.readChildNodes(node, obj);
                symbolizer.haloRadius = obj.haloRadius;
                symbolizer.haloColor = obj.fillColor;
                symbolizer.haloOpacity = obj.fillOpacity;
            },
            "Radius": function(node, symbolizer) {
                var radius = this.readers.ogc._expression.call(this, node);
                if(radius != null) {
                    // radius is only used for halo
                    symbolizer.haloRadius = radius;
                }
            },
            "RasterSymbolizer": function(node, rule) {
                var config = {};
                this.readChildNodes(node, config);
                if (this.multipleSymbolizers) {
                    config.zIndex = this.featureTypeCounter;
                    rule.symbolizers.push(
                        new HGIS.Symbolizer.Raster(config)
                    );
                } else {
                    rule.symbolizer["Raster"] = HGIS.Util.applyDefaults(
                        config, rule.symbolizer["Raster"]
                    );
                }
            },
            "Geometry": function(node, obj) {
                obj.geometry = {};
                this.readChildNodes(node, obj.geometry);
            },
            "ColorMap": function(node, symbolizer) {
                symbolizer.colorMap = [];
                this.readChildNodes(node, symbolizer.colorMap);
            },
            "ColorMapEntry": function(node, colorMap) {
                var q = node.getAttribute("quantity");
                var o = node.getAttribute("opacity");
                colorMap.push({
                    color: node.getAttribute("color"),
                    quantity: q !== null ? parseFloat(q) : undefined,
                    label: node.getAttribute("label") || undefined,
                    opacity: o !== null ? parseFloat(o) : undefined
                });
            },
            "LineSymbolizer": function(node, rule) {
                var config = {};
                this.readChildNodes(node, config);
                if (this.multipleSymbolizers) {
                    config.zIndex = this.featureTypeCounter;
                    rule.symbolizers.push(
                        new HGIS.Symbolizer.Line(config)
                    );
                } else {
                    rule.symbolizer["Line"] = HGIS.Util.applyDefaults(
                        config, rule.symbolizer["Line"]
                    );
                }
            },
            "PolygonSymbolizer": function(node, rule) {
                var config = {
                    fill: false,
                    stroke: false
                };
                if (!this.multipleSymbolizers) {
                    config = rule.symbolizer["Polygon"] || config;
                }
                this.readChildNodes(node, config);
                if (this.multipleSymbolizers) {
                    config.zIndex = this.featureTypeCounter;
                    rule.symbolizers.push(
                        new HGIS.Symbolizer.Polygon(config)
                    );
                } else {
                    rule.symbolizer["Polygon"] = config;
                }
            },
            "PointSymbolizer": function(node, rule) {
                var config = {
                    fill: false,
                    stroke: false,
                    graphic: false
                };
                if (!this.multipleSymbolizers) {
                    config = rule.symbolizer["Point"] || config;
                }
                this.readChildNodes(node, config);
                if (this.multipleSymbolizers) {
                    config.zIndex = this.featureTypeCounter;
                    rule.symbolizers.push(
                        new HGIS.Symbolizer.Point(config)
                    );
                } else {
                    rule.symbolizer["Point"] = config;
                }
            },
            "Stroke": function(node, symbolizer) {
                symbolizer.stroke = true;
                this.readChildNodes(node, symbolizer);
            },
            "Fill": function(node, symbolizer) {
                symbolizer.fill = true;
                this.readChildNodes(node, symbolizer);
            },
            "CssParameter": function(node, symbolizer) {
                var cssProperty = node.getAttribute("name");
                var symProperty = this.cssMap[cssProperty];
                // for labels, fill should map to fontColor and fill-opacity 
                // to fontOpacity
                if (symbolizer.label) {
                    if (cssProperty === 'fill') {
                        symProperty = "fontColor";
                    } else if (cssProperty === 'fill-opacity') {
                        symProperty = "fontOpacity";
                    }
                }
                if(symProperty) {
                    // Limited support for parsing of OGC expressions
                    var value = this.readers.ogc._expression.call(this, node);
                    // always string, could be an empty string
                    if(value) {
                        symbolizer[symProperty] = value;
                    }
                }
            },
            "Graphic": function(node, symbolizer) {
                symbolizer.graphic = true;
                var graphic = {};
                // painter's order not respected here, clobber previous with next
                this.readChildNodes(node, graphic);
                // directly properties with names that match symbolizer properties
                var properties = [
                    "stroke", "strokeColor", "strokeWidth", "strokeOpacity",
                    "strokeLinecap", "fill", "fillColor", "fillOpacity",
                    "graphicName", "rotation", "graphicFormat"
                ];
                var prop, value;
                for(var i=0, len=properties.length; i<len; ++i) {
                    prop = properties[i];
                    value = graphic[prop];
                    if(value != undefined) {
                        symbolizer[prop] = value;
                    }
                }
                // set other generic properties with specific graphic property names
                if(graphic.opacity != undefined) {
                    symbolizer.graphicOpacity = graphic.opacity;
                }
                if(graphic.size != undefined) {
                    var pointRadius = graphic.size / 2;
                    if (isNaN(pointRadius)) {
                        // likely a property name
                        symbolizer.graphicWidth = graphic.size;
                    } else {
                        symbolizer.pointRadius = graphic.size / 2;
                    }
                }
                if(graphic.href != undefined) {
                    symbolizer.externalGraphic = graphic.href;
                }
                if(graphic.rotation != undefined) {
                    symbolizer.rotation = graphic.rotation;
                }
            },
            "ExternalGraphic": function(node, graphic) {
                this.readChildNodes(node, graphic);
            },
            "Mark": function(node, graphic) {
                this.readChildNodes(node, graphic);
            },
            "WellKnownName": function(node, graphic) {
                graphic.graphicName = this.getChildValue(node);
            },
            "Opacity": function(node, obj) {
                var opacity = this.readers.ogc._expression.call(this, node);
                // always string, could be empty string
                if(opacity) {
                    obj.opacity = opacity;
                }
            },
            "Size": function(node, obj) {
                var size = this.readers.ogc._expression.call(this, node);
                // always string, could be empty string
                if(size) {
                    obj.size = size;
                }
            },
            "Rotation": function(node, obj) {
                var rotation = this.readers.ogc._expression.call(this, node);
                // always string, could be empty string
                if(rotation) {
                    obj.rotation = rotation;
                }
            },
            "OnlineResource": function(node, obj) {
                obj.href = this.getAttributeNS(
                    node, this.namespaces.xlink, "href"
                );
            },
            "Format": function(node, graphic) {
                graphic.graphicFormat = this.getChildValue(node);
            }
        }
    }, HGIS.Format.Filter.v1_0_0.prototype.readers),
    
    /**
     * Property: cssMap
     * {Object} Object mapping supported css property names to HGIS
     *     symbolizer property names.
     */
    cssMap: {
        "stroke": "strokeColor",
        "stroke-opacity": "strokeOpacity",
        "stroke-width": "strokeWidth",
        "stroke-linecap": "strokeLinecap",
        "stroke-dasharray": "strokeDashstyle",
        "fill": "fillColor",
        "fill-opacity": "fillOpacity",
        "font-family": "fontFamily",
        "font-size": "fontSize",
        "font-weight": "fontWeight",
        "font-style": "fontStyle"
    },
    
    /**
     * Method: getCssProperty
     * Given a symbolizer property, get the corresponding CSS property
     *     from the <cssMap>.
     *
     * Parameters:
     * sym - {String} A symbolizer property name.
     *
     * Returns:
     * {String} A CSS property name or null if none found.
     */
    getCssProperty: function(sym) {
        var css = null;
        for(var prop in this.cssMap) {
            if(this.cssMap[prop] == sym) {
                css = prop;
                break;
            }
        }
        return css;
    },
    
    /**
     * Method: getGraphicFormat
     * Given a href for an external graphic, try to determine the mime-type.
     *     This method doesn't try too hard, and will fall back to
     *     <defaultGraphicFormat> if one of the known <graphicFormats> is not
     *     the file extension of the provided href.
     *
     * Parameters:
     * href - {String}
     *
     * Returns:
     * {String} The graphic format.
     */
    getGraphicFormat: function(href) {
        var format, regex;
        for(var key in this.graphicFormats) {
            if(this.graphicFormats[key].test(href)) {
                format = key;
                break;
            }
        }
        return format || this.defaultGraphicFormat;
    },
    
    /**
     * Property: defaultGraphicFormat
     * {String} If none other can be determined from <getGraphicFormat>, this
     *     default will be returned.
     */
    defaultGraphicFormat: "image/png",
    
    /**
     * Property: graphicFormats
     * {Object} Mapping of image mime-types to regular extensions matching 
     *     well-known file extensions.
     */
    graphicFormats: {
        "image/jpeg": /\.jpe?g$/i,
        "image/gif": /\.gif$/i,
        "image/png": /\.png$/i
    },

    /**
     * Method: write
     *
     * Parameters:
     * sld - {Object} An object representing the SLD.
     *
     * Returns:
     * {DOMElement} The root of an SLD document.
     */
    write: function(sld) {
        return this.writers.sld.StyledLayerDescriptor.apply(this, [sld]);
    },
    
    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: HGIS.Util.applyDefaults({
        "sld": {
            "_OGCExpression": function(nodeName, value) {
                // only the simplest of ogc:expression handled
                // {label: "some text and a ${propertyName}"}
                var node = this.createElementNSPlus(nodeName);
                var tokens = typeof value == "string" ?
                    value.split("${") :
                    [value];
                node.appendChild(this.createTextNode(tokens[0]));
                var item, last;
                for(var i=1, len=tokens.length; i<len; i++) {
                    item = tokens[i];
                    last = item.indexOf("}"); 
                    if(last > 0) {
                        this.writeNode(
                            "ogc:PropertyName",
                            {property: item.substring(0, last)},
                            node
                        );
                        node.appendChild(
                            this.createTextNode(item.substring(++last))
                        );
                    } else {
                        // no ending }, so this is a literal ${
                        node.appendChild(
                            this.createTextNode("${" + item)
                        );
                    }
                }
                return node;
            },
            "StyledLayerDescriptor": function(sld) {
                var root = this.createElementNSPlus(
                    "sld:StyledLayerDescriptor",
                    {attributes: {
                        "version": this.VERSION,
                        "xsi:schemaLocation": this.schemaLocation
                    }}
                );

                // For ArcGIS Server it is necessary to define this
                // at the root level (see ticket:2166).
                root.setAttribute("xmlns:ogc", this.namespaces.ogc);
                root.setAttribute("xmlns:gml", this.namespaces.gml);

                // add in optional name
                if(sld.name) {
                    this.writeNode("Name", sld.name, root);
                }
                // add in optional title
                if(sld.title) {
                    this.writeNode("Title", sld.title, root);
                }
                // add in optional description
                if(sld.description) {
                    this.writeNode("Abstract", sld.description, root);
                }
                // add in named layers
                // allow namedLayers to be an array
                if(HGIS.Util.isArray(sld.namedLayers)) {
                    for(var i=0, len=sld.namedLayers.length; i<len; ++i) {
                        this.writeNode("NamedLayer", sld.namedLayers[i], root);
                    }
                } else {
                    for(var name in sld.namedLayers) {
                        this.writeNode("NamedLayer", sld.namedLayers[name], root);
                    }
                }
                return root;
            },
            "Name": function(name) {
                return this.createElementNSPlus("sld:Name", {value: name});
            },
            "Title": function(title) {
                return this.createElementNSPlus("sld:Title", {value: title});
            },
            "Abstract": function(description) {
                return this.createElementNSPlus(
                    "sld:Abstract", {value: description}
                );
            },
            "NamedLayer": function(layer) {
                var node = this.createElementNSPlus("sld:NamedLayer");

                // add in required name
                this.writeNode("Name", layer.name, node);

                // optional sld:LayerFeatureConstraints here

                // add in named styles
                if(layer.namedStyles) {
                    for(var i=0, len=layer.namedStyles.length; i<len; ++i) {
                        this.writeNode(
                            "NamedStyle", layer.namedStyles[i], node
                        );
                    }
                }
                
                // add in user styles
                if(layer.userStyles) {
                    for(var i=0, len=layer.userStyles.length; i<len; ++i) {
                        this.writeNode(
                            "UserStyle", layer.userStyles[i], node
                        );
                    }
                }
                
                return node;
            },
            "NamedStyle": function(name) {
                var node = this.createElementNSPlus("sld:NamedStyle");
                this.writeNode("Name", name, node);
                return node;
            },
            "UserStyle": function(style) {
                var node = this.createElementNSPlus("sld:UserStyle");

                // add in optional name
                if(style.name) {
                    this.writeNode("Name", style.name, node);
                }
                // add in optional title
                if(style.title) {
                    this.writeNode("Title", style.title, node);
                }
                // add in optional description
                if(style.description) {
                    this.writeNode("Abstract", style.description, node);
                }
                
                // add isdefault
                if(style.isDefault) {
                    this.writeNode("IsDefault", style.isDefault, node);
                }
                
                // add FeatureTypeStyles
                if (this.multipleSymbolizers && style.rules) {
                    // group style objects by symbolizer zIndex
                    var rulesByZ = {
                        0: []
                    };
                    var zValues = [0];
                    var rule, ruleMap, symbolizer, zIndex, clone;
                    for (var i=0, ii=style.rules.length; i<ii; ++i) {
                        rule = style.rules[i];
                        if (rule.symbolizers) {
                            ruleMap = {};
                            for (var j=0, jj=rule.symbolizers.length; j<jj; ++j) {
                                symbolizer = rule.symbolizers[j];
                                zIndex = symbolizer.zIndex;
                                if (!(zIndex in ruleMap)) {
                                    clone = rule.clone();
                                    clone.symbolizers = [];
                                    ruleMap[zIndex] = clone;
                                }
                                ruleMap[zIndex].symbolizers.push(symbolizer.clone());
                            }
                            for (zIndex in ruleMap) {
                                if (!(zIndex in rulesByZ)) {
                                    zValues.push(zIndex);
                                    rulesByZ[zIndex] = [];
                                }
                                rulesByZ[zIndex].push(ruleMap[zIndex]);
                            }
                        } else {
                            // no symbolizers in rule
                            rulesByZ[0].push(rule.clone());
                        }
                    }
                    // write one FeatureTypeStyle per zIndex
                    zValues.sort();
                    var rules;
                    for (var i=0, ii=zValues.length; i<ii; ++i) {
                        rules = rulesByZ[zValues[i]];
                        if (rules.length > 0) {
                            clone = style.clone();
                            clone.rules = rulesByZ[zValues[i]];
                            this.writeNode("FeatureTypeStyle", clone, node);
                        }
                    }                    
                } else {
                    this.writeNode("FeatureTypeStyle", style, node);
                }
                
                return node;
            },
            "IsDefault": function(bool) {
                return this.createElementNSPlus(
                    "sld:IsDefault", {value: (bool) ? "1" : "0"}
                );
            },
            "FeatureTypeStyle": function(style) {
                var node = this.createElementNSPlus("sld:FeatureTypeStyle");
                
                // HGIS currently stores no Name, Title, Abstract,
                // FeatureTypeName, or SemanticTypeIdentifier information
                // related to FeatureTypeStyle
                
                // add in rules
                for(var i=0, len=style.rules.length; i<len; ++i) {
                    this.writeNode("Rule", style.rules[i], node);
                }
                
                return node;
            },
            "Rule": function(rule) {
                var node = this.createElementNSPlus("sld:Rule");

                // add in optional name
                if(rule.name) {
                    this.writeNode("Name", rule.name, node);
                }
                // add in optional title
                if(rule.title) {
                    this.writeNode("Title", rule.title, node);
                }
                // add in optional description
                if(rule.description) {
                    this.writeNode("Abstract", rule.description, node);
                }
                
                // add in LegendGraphic here
                
                // add in optional filters
                if(rule.elseFilter) {
                    this.writeNode("ElseFilter", null, node);
                } else if(rule.filter) {
                    this.writeNode("ogc:Filter", rule.filter, node);
                }
                
                // add in scale limits
                if(rule.minScaleDenominator != undefined) {
                    this.writeNode(
                        "MinScaleDenominator", rule.minScaleDenominator, node
                    );
                }
                if(rule.maxScaleDenominator != undefined) {
                    this.writeNode(
                        "MaxScaleDenominator", rule.maxScaleDenominator, node
                    );
                }
                
                var type, symbolizer;
                if (this.multipleSymbolizers && rule.symbolizers) {
                    var symbolizer;
                    for (var i=0, ii=rule.symbolizers.length; i<ii; ++i) {
                        symbolizer = rule.symbolizers[i];
                        type = symbolizer.CLASS_NAME.split(".").pop();
                        this.writeNode(
                            type + "Symbolizer", symbolizer, node
                        );
                    }
                } else {
                    // add in symbolizers (relies on geometry type keys)
                    var types = HGIS.Style.SYMBOLIZER_PREFIXES;
                    for(var i=0, len=types.length; i<len; ++i) {
                        type = types[i];
                        symbolizer = rule.symbolizer[type];
                        if(symbolizer) {
                            this.writeNode(
                                type + "Symbolizer", symbolizer, node
                            );
                        }
                    }
                }
                return node;

            },
            "ElseFilter": function() {
                return this.createElementNSPlus("sld:ElseFilter");
            },
            "MinScaleDenominator": function(scale) {
                return this.createElementNSPlus(
                    "sld:MinScaleDenominator", {value: scale}
                );
            },
            "MaxScaleDenominator": function(scale) {
                return this.createElementNSPlus(
                    "sld:MaxScaleDenominator", {value: scale}
                );
            },
            "LineSymbolizer": function(symbolizer) {
                var node = this.createElementNSPlus("sld:LineSymbolizer");
                this.writeNode("Stroke", symbolizer, node);
                return node;
            },
            "Stroke": function(symbolizer) {
                var node = this.createElementNSPlus("sld:Stroke");

                // GraphicFill here
                // GraphicStroke here

                // add in CssParameters
                if(symbolizer.strokeColor != undefined) {
                    this.writeNode(
                        "CssParameter",
                        {symbolizer: symbolizer, key: "strokeColor"},
                        node
                    );
                }
                if(symbolizer.strokeOpacity != undefined) {
                    this.writeNode(
                        "CssParameter",
                        {symbolizer: symbolizer, key: "strokeOpacity"},
                        node
                    );
                }
                if(symbolizer.strokeWidth != undefined) {
                    this.writeNode(
                        "CssParameter",
                        {symbolizer: symbolizer, key: "strokeWidth"},
                        node
                    );
                }
                if(symbolizer.strokeDashstyle != undefined && symbolizer.strokeDashstyle !== "solid") {
                    // assumes valid stroke-dasharray value
                    this.writeNode(
                        "CssParameter", 
                        {symbolizer: symbolizer, key: "strokeDashstyle"},
                        node
                    );
                }
                if(symbolizer.strokeLinecap != undefined) {
                    this.writeNode(
                        "CssParameter", 
                        {symbolizer: symbolizer, key: "strokeLinecap"},
                        node
                    );
                }
                return node;
            },
            "CssParameter": function(obj) {
                // not handling ogc:expressions for now
                return this.createElementNSPlus("sld:CssParameter", {
                    attributes: {name: this.getCssProperty(obj.key)},
                    value: obj.symbolizer[obj.key]
                });
            },
            "TextSymbolizer": function(symbolizer) {
                var node = this.createElementNSPlus("sld:TextSymbolizer");
                // add in optional Label
                if(symbolizer.label != null) {
                    this.writeNode("Label", symbolizer.label, node);
                }
                // add in optional Font
                if(symbolizer.fontFamily != null ||
                    symbolizer.fontSize != null ||
                    symbolizer.fontWeight != null ||
                    symbolizer.fontStyle != null) {
                        this.writeNode("Font", symbolizer, node);
                }
                // add in optional LabelPlacement
                if (symbolizer.labelAnchorPointX != null ||
                    symbolizer.labelAnchorPointY != null || 
                    symbolizer.labelAlign != null ||
                    symbolizer.labelXOffset != null ||
                    symbolizer.labelYOffset != null ||
                    symbolizer.labelRotation != null ||
                    symbolizer.labelPerpendicularOffset != null) {
                        this.writeNode("LabelPlacement", symbolizer, node);
                }
                // add in optional Halo
                if(symbolizer.haloRadius != null ||
                    symbolizer.haloColor != null ||
                    symbolizer.haloOpacity != null) {
                        this.writeNode("Halo", symbolizer, node);
                }
                // add in optional Fill
                if(symbolizer.fontColor != null ||
                   symbolizer.fontOpacity != null) {
                    this.writeNode("Fill", {
                        fillColor: symbolizer.fontColor,
                        fillOpacity: symbolizer.fontOpacity
                    }, node);
                }
                return node;
            },
            "LabelPlacement": function(symbolizer) {
                var node = this.createElementNSPlus("sld:LabelPlacement");
                // PointPlacement and LinePlacement are choices, so don't output both
                if ((symbolizer.labelAnchorPointX != null ||
                    symbolizer.labelAnchorPointY != null ||
                    symbolizer.labelAlign != null ||
                    symbolizer.labelXOffset != null ||
                    symbolizer.labelYOffset != null ||
                    symbolizer.labelRotation != null) && 
                    symbolizer.labelPerpendicularOffset == null) {
                        this.writeNode("PointPlacement", symbolizer, node);
                }
                if (symbolizer.labelPerpendicularOffset != null) {
                    this.writeNode("LinePlacement", symbolizer, node);
                }
                return node;
            },
            "LinePlacement": function(symbolizer) {
                var node = this.createElementNSPlus("sld:LinePlacement");
                this.writeNode("PerpendicularOffset", symbolizer.labelPerpendicularOffset, node);
                return node;
            },
            "PerpendicularOffset": function(value) {
                return this.createElementNSPlus("sld:PerpendicularOffset", {
                    value: value
                });
            },
            "PointPlacement": function(symbolizer) {
                var node = this.createElementNSPlus("sld:PointPlacement");
                if (symbolizer.labelAnchorPointX != null ||
                    symbolizer.labelAnchorPointY != null ||
                    symbolizer.labelAlign != null) {
                        this.writeNode("AnchorPoint", symbolizer, node);
                }
                if (symbolizer.labelXOffset != null ||
                    symbolizer.labelYOffset != null) {
                        this.writeNode("Displacement", symbolizer, node);
                }
                if (symbolizer.labelRotation != null) {
                    this.writeNode("Rotation", symbolizer.labelRotation, node);
                }
                return node;
            },
            "AnchorPoint": function(symbolizer) {
                var node = this.createElementNSPlus("sld:AnchorPoint");
                var x = symbolizer.labelAnchorPointX,
                    y = symbolizer.labelAnchorPointY;
                if (x != null) {
                    this.writeNode("AnchorPointX", x, node);
                }
                if (y != null) {
                    this.writeNode("AnchorPointY", y, node);
                }
                if (x == null && y == null) {
                    var xAlign = symbolizer.labelAlign.substr(0, 1),
                        yAlign = symbolizer.labelAlign.substr(1, 1);
                    if (xAlign === "l") {
                        x = 0;
                    } else if (xAlign === "c") {
                        x = 0.5;
                    } else if (xAlign === "r") {
                        x = 1;
                    }
                    if (yAlign === "b") {
                        y = 0;
                    } else if (yAlign === "m") {
                        y = 0.5;
                    } else if (yAlign === "t") {
                        y = 1;
                    }
                    this.writeNode("AnchorPointX", x, node);
                    this.writeNode("AnchorPointY", y, node);
                }
                return node;
            },
            "AnchorPointX": function(value) {
                return this.createElementNSPlus("sld:AnchorPointX", {
                    value: value
                }); 
            },
            "AnchorPointY": function(value) {
                return this.createElementNSPlus("sld:AnchorPointY", {
                    value: value
                });
            },
            "Displacement": function(symbolizer) {
                var node = this.createElementNSPlus("sld:Displacement");
                if (symbolizer.labelXOffset != null) {
                    this.writeNode("DisplacementX", symbolizer.labelXOffset, node);
                }
                if (symbolizer.labelYOffset != null) {
                    this.writeNode("DisplacementY", symbolizer.labelYOffset, node);
                }
                return node;
            },
            "DisplacementX": function(value) {
                return this.createElementNSPlus("sld:DisplacementX", {
                    value: value
                });
            },
            "DisplacementY": function(value) {
                return this.createElementNSPlus("sld:DisplacementY", {
                    value: value
                });
            },
            "Font": function(symbolizer) {
                var node = this.createElementNSPlus("sld:Font");
                // add in CssParameters
                if(symbolizer.fontFamily) {
                    this.writeNode(
                        "CssParameter",
                        {symbolizer: symbolizer, key: "fontFamily"},
                        node
                    );
                }
                if(symbolizer.fontSize) {
                    this.writeNode(
                        "CssParameter",
                        {symbolizer: symbolizer, key: "fontSize"},
                        node
                    );
                }
                if(symbolizer.fontWeight) {
                    this.writeNode(
                        "CssParameter",
                        {symbolizer: symbolizer, key: "fontWeight"},
                        node
                    );
                }
                if(symbolizer.fontStyle) {
                    this.writeNode(
                        "CssParameter",
                        {symbolizer: symbolizer, key: "fontStyle"},
                        node
                    );
                }
                return node;
            },
            "Label": function(label) {
                return this.writers.sld._OGCExpression.call(
                    this, "sld:Label", label
                );
            },
            "Halo": function(symbolizer) {
                var node = this.createElementNSPlus("sld:Halo");
                if(symbolizer.haloRadius) {
                    this.writeNode("Radius", symbolizer.haloRadius, node);
                }
                if(symbolizer.haloColor || symbolizer.haloOpacity) {
                    this.writeNode("Fill", {
                        fillColor: symbolizer.haloColor,
                        fillOpacity: symbolizer.haloOpacity
                    }, node);
                }
                return node;
            },
            "Radius": function(value) {
                return this.createElementNSPlus("sld:Radius", {
                    value: value
                });
            },
            "RasterSymbolizer": function(symbolizer) {
                var node = this.createElementNSPlus("sld:RasterSymbolizer");
                if (symbolizer.geometry) {
                    this.writeNode("Geometry", symbolizer.geometry, node);
                }
                if (symbolizer.opacity) {
                    this.writeNode("Opacity", symbolizer.opacity, node);
                }
                if (symbolizer.colorMap) {
                    this.writeNode("ColorMap", symbolizer.colorMap, node);
                }
                return node;
            },
            "Geometry": function(geometry) {
                var node = this.createElementNSPlus("sld:Geometry");
                if (geometry.property) {
                    this.writeNode("ogc:PropertyName", geometry, node);
                }
                return node;
            },
            "ColorMap": function(colorMap) {
                var node = this.createElementNSPlus("sld:ColorMap");
                for (var i=0, len=colorMap.length; i<len; ++i) {
                    this.writeNode("ColorMapEntry", colorMap[i], node);
                }
                return node;
            },
            "ColorMapEntry": function(colorMapEntry) {
                var node = this.createElementNSPlus("sld:ColorMapEntry");
                var a = colorMapEntry;
                node.setAttribute("color", a.color);
                a.opacity !== undefined && node.setAttribute("opacity",
                    parseFloat(a.opacity));
                a.quantity !== undefined && node.setAttribute("quantity",
                    parseFloat(a.quantity));
                a.label !== undefined && node.setAttribute("label", a.label);
                return node;
            },
            "PolygonSymbolizer": function(symbolizer) {
                var node = this.createElementNSPlus("sld:PolygonSymbolizer");
                if(symbolizer.fill !== false) {
                    this.writeNode("Fill", symbolizer, node);
                }
                if(symbolizer.stroke !== false) {
                    this.writeNode("Stroke", symbolizer, node);
                }
                return node;
            },
            "Fill": function(symbolizer) {
                var node = this.createElementNSPlus("sld:Fill");
                
                // GraphicFill here
                
                // add in CssParameters
                if(symbolizer.fillColor) {
                    this.writeNode(
                        "CssParameter",
                        {symbolizer: symbolizer, key: "fillColor"},
                        node
                    );
                }
                if(symbolizer.fillOpacity != null) {
                    this.writeNode(
                        "CssParameter",
                        {symbolizer: symbolizer, key: "fillOpacity"},
                        node
                    );
                }
                return node;
            },
            "PointSymbolizer": function(symbolizer) {
                var node = this.createElementNSPlus("sld:PointSymbolizer");
                this.writeNode("Graphic", symbolizer, node);
                return node;
            },
            "Graphic": function(symbolizer) {
                var node = this.createElementNSPlus("sld:Graphic");
                if(symbolizer.externalGraphic != undefined) {
                    this.writeNode("ExternalGraphic", symbolizer, node);
                } else {
                    this.writeNode("Mark", symbolizer, node);
                }
                
                if(symbolizer.graphicOpacity != undefined) {
                    this.writeNode("Opacity", symbolizer.graphicOpacity, node);
                }
                if(symbolizer.pointRadius != undefined) {
                    this.writeNode("Size", symbolizer.pointRadius * 2, node);
                } else if (symbolizer.graphicWidth != undefined) {
                    this.writeNode("Size", symbolizer.graphicWidth, node);
                }
                if(symbolizer.rotation != undefined) {
                    this.writeNode("Rotation", symbolizer.rotation, node);
                }
                return node;
            },
            "ExternalGraphic": function(symbolizer) {
                var node = this.createElementNSPlus("sld:ExternalGraphic");
                this.writeNode(
                    "OnlineResource", symbolizer.externalGraphic, node
                );
                var format = symbolizer.graphicFormat ||
                             this.getGraphicFormat(symbolizer.externalGraphic);
                this.writeNode("Format", format, node);
                return node;
            },
            "Mark": function(symbolizer) {
                var node = this.createElementNSPlus("sld:Mark");
                if(symbolizer.graphicName) {
                    this.writeNode("WellKnownName", symbolizer.graphicName, node);
                }
                if (symbolizer.fill !== false) {
                    this.writeNode("Fill", symbolizer, node);
                }
                if (symbolizer.stroke !== false) {
                    this.writeNode("Stroke", symbolizer, node);
                }
                return node;
            },
            "WellKnownName": function(name) {
                return this.createElementNSPlus("sld:WellKnownName", {
                    value: name
                });
            },
            "Opacity": function(value) {
                return this.createElementNSPlus("sld:Opacity", {
                    value: value
                });
            },
            "Size": function(value) {
                return this.writers.sld._OGCExpression.call(
                    this, "sld:Size", value
                );
            },
            "Rotation": function(value) {
                return this.createElementNSPlus("sld:Rotation", {
                    value: value
                });
            },
            "OnlineResource": function(href) {
                return this.createElementNSPlus("sld:OnlineResource", {
                    attributes: {
                        "xlink:type": "simple",
                        "xlink:href": href
                    }
                });
            },
            "Format": function(format) {
                return this.createElementNSPlus("sld:Format", {
                    value: format
                });
            }
        }
    }, HGIS.Format.Filter.v1_0_0.prototype.writers),
    
    CLASS_NAME: "HGIS.Format.SLD.v1" 

});
/* ======================================================================
    HGIS/Layer/WMS.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer/Grid.js
 */

/**
 * Class: HGIS.Layer.WMS
 * Instances of HGIS.Layer.WMS are used to display data from OGC Web
 *     Mapping Services. Create a new WMS layer with the <HGIS.Layer.WMS>
 *     constructor.
 * 
 * Inherits from:
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.WMS = HGIS.Class(HGIS.Layer.Grid, {

    /**
     * Constant: DEFAULT_PARAMS
     * {Object} Hashtable of default parameter key/value pairs 
     */
    DEFAULT_PARAMS: { service: "WMS",
                      version: "1.1.1",
                      request: "GetMap",
                      styles: "",
                      format: "image/jpeg"
                     },
    
    /**
     * APIProperty: isBaseLayer
     * {Boolean} Default is true for WMS layer
     */
    isBaseLayer: true,
    
    /**
     * APIProperty: encodeBBOX
     * {Boolean} Should the BBOX commas be encoded? The WMS spec says 'no', 
     * but some services want it that way. Default false.
     */
    encodeBBOX: false,
    
    /** 
     * APIProperty: noMagic 
     * {Boolean} If true, the image format will not be automagicaly switched 
     *     from image/jpeg to image/png or image/gif when using 
     *     TRANSPARENT=TRUE. Also isBaseLayer will not changed by the  
     *     constructor. Default false. 
     */ 
    noMagic: false,
    
    /**
     * Property: yx
     * {Object} Keys in this object are EPSG codes for which the axis order
     *     is to be reversed (yx instead of xy, LatLon instead of LonLat), with
     *     true as value. This is only relevant for WMS versions >= 1.3.0, and
     *     only if yx is not set in <HGIS.Projection.defaults> for the
     *     used projection.
     */
    yx: {},
    
    /**
     * Constructor: HGIS.Layer.WMS
     * Create a new WMS layer object
     *
     * Examples:
     *
     * The code below creates a simple WMS layer using the image/jpeg format.
     * (code)
     * var wms = new HGIS.Layer.WMS("NASA Global Mosaic",
     *                                    "http://wms.jpl.nasa.gov/wms.cgi", 
     *                                    {layers: "modis,global_mosaic"});
     * (end)
     * Note the 3rd argument (params). Properties added to this object will be
     * added to the WMS GetMap requests used for this layer's tiles. The only
     * mandatory parameter is "layers". Other common WMS params include
     * "transparent", "styles" and "format". Note that the "srs" param will
     * always be ignored. Instead, it will be derived from the baseLayer's or
     * map's projection.
     *
     * The code below creates a transparent WMS layer with additional options.
     * (code)
     * var wms = new HGIS.Layer.WMS("NASA Global Mosaic",
     *                                    "http://wms.jpl.nasa.gov/wms.cgi", 
     *                                    {
     *                                        layers: "modis,global_mosaic",
     *                                        transparent: true
     *                                    }, {
     *                                        opacity: 0.5,
     *                                        singleTile: true
     *                                    });
     * (end)
     * Note that by default, a WMS layer is configured as baseLayer. Setting
     * the "transparent" param to true will apply some magic (see <noMagic>).
     * The default image format changes from image/jpeg to image/png, and the
     * layer is not configured as baseLayer.
     *
     * Parameters:
     * name - {String} A name for the layer
     * url - {String} Base url for the WMS
     *                (e.g. http://wms.jpl.nasa.gov/wms.cgi)
     * params - {Object} An object with key/value pairs representing the
     *                   GetMap query string parameters and parameter values.
     * options - {Object} Hashtable of extra options to tag onto the layer.
     *     These options include all properties listed above, plus the ones
     *     inherited from superclasses.
     */
    initialize: function(name, url, params, options) {
        var newArguments = [];
        //uppercase params
        params = HGIS.Util.upperCaseObject(params);
        if (parseFloat(params.VERSION) >= 1.3 && !params.EXCEPTIONS) {
            params.EXCEPTIONS = "INIMAGE";
        } 
        newArguments.push(name, url, params, options);
        HGIS.Layer.Grid.prototype.initialize.apply(this, newArguments);
        HGIS.Util.applyDefaults(
                       this.params, 
                       HGIS.Util.upperCaseObject(this.DEFAULT_PARAMS)
                       );


        //layer is transparent        
        if (!this.noMagic && this.params.TRANSPARENT && 
            this.params.TRANSPARENT.toString().toLowerCase() == "true") {
            
            // unless explicitly set in options, make layer an overlay
            if ( (options == null) || (!options.isBaseLayer) ) {
                this.isBaseLayer = false;
            } 
            
            // jpegs can never be transparent, so intelligently switch the 
            //  format, depending on the browser's capabilities
            if (this.params.FORMAT == "image/jpeg") {
                this.params.FORMAT = HGIS.Util.alphaHack() ? "image/gif"
                                                                 : "image/png";
            }
        }

    },    

    /**
     * Method: clone
     * Create a clone of this layer
     *
     * Returns:
     * {<HGIS.Layer.WMS>} An exact clone of this layer
     */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new HGIS.Layer.WMS(this.name,
                                           this.url,
                                           this.params,
                                           this.getOptions());
        }

        //get all additions from superclasses
        obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },    
    
    /**
     * APIMethod: reverseAxisOrder
     * Returns true if the axis order is reversed for the WMS version and
     * projection of the layer.
     * 
     * Returns:
     * {Boolean} true if the axis order is reversed, false otherwise.
     */
    reverseAxisOrder: function() {
        var projCode = this.projection.getCode();
        return parseFloat(this.params.VERSION) >= 1.3 && 
            !!(this.yx[projCode] || (HGIS.Projection.defaults[projCode] && 
            HGIS.Projection.defaults[projCode].yx));
    },
    
    /**
     * Method: getURL
     * Return a GetMap query string for this layer
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>} A bounds representing the bbox for the
     *                                request.
     *
     * Returns:
     * {String} A string with the layer's url and parameters and also the
     *          passed-in bounds and appropriate tile size specified as 
     *          parameters.
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);
        
        var imageSize = this.getImageSize();
        var newParams = {};
        // WMS 1.3 introduced axis order
        var reverseAxisOrder = this.reverseAxisOrder();
        newParams.BBOX = this.encodeBBOX ?
            bounds.toBBOX(null, reverseAxisOrder) :
            bounds.toArray(reverseAxisOrder);
        newParams.WIDTH = imageSize.w;
        newParams.HEIGHT = imageSize.h;
        //outedit增加wms参数
        newParams.ZOOM = this.map.getZoom();
        var requestString = this.getFullRequestString(newParams);
        return requestString;
    },

    /**
     * APIMethod: mergeNewParams
     * Catch changeParams and uppercase the new params to be merged in
     *     before calling changeParams on the super class.
     * 
     *     Once params have been changed, the tiles will be reloaded with
     *     the new parameters.
     * 
     * Parameters:
     * newParams - {Object} Hashtable of new params to use
     */
    mergeNewParams:function(newParams) {
        var upperParams = HGIS.Util.upperCaseObject(newParams);
        var newArguments = [upperParams];
        return HGIS.Layer.Grid.prototype.mergeNewParams.apply(this, 
                                                             newArguments);
    },

    /** 
     * APIMethod: getFullRequestString
     * Combine the layer's url with its params and these newParams. 
     *   
     *     Add the SRS parameter from projection -- this is probably
     *     more eloquently done via a setProjection() method, but this 
     *     works for now and always.
     *
     * Parameters:
     * newParams - {Object}
     * altUrl - {String} Use this as the url instead of the layer's url
     * 
     * Returns:
     * {String} 
     */
    getFullRequestString:function(newParams, altUrl) {
        var mapProjection = this.map.getProjectionObject();
        var projectionCode = this.projection && this.projection.equals(mapProjection) ?
            this.projection.getCode() :
            mapProjection.getCode();
        var value = (projectionCode == "none") ? null : projectionCode;
        if (parseFloat(this.params.VERSION) >= 1.3) {
            this.params.CRS = value;
        } else {
            this.params.SRS = value;
        }
        
        if (typeof this.params.TRANSPARENT == "boolean") {
            newParams.TRANSPARENT = this.params.TRANSPARENT ? "TRUE" : "FALSE";
        }

        return HGIS.Layer.Grid.prototype.getFullRequestString.apply(
                                                    this, arguments);
    },

    CLASS_NAME: "HGIS.Layer.WMS"
});
/* ======================================================================
    HGIS/Layer/KaMap.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer/Grid.js
 */

/**
 * Class: HGIS.Layer.KaMap
 * 
 * Inherits from:
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.KaMap = HGIS.Class(HGIS.Layer.Grid, {

    /** 
     * APIProperty: isBaseLayer
     * {Boolean} KaMap Layer is always a base layer 
     */    
    isBaseLayer: true,

    /**
     * Constant: DEFAULT_PARAMS
     * {Object} parameters set by default. The default parameters set 
     * the format via the 'i' parameter to 'jpeg'.    
     */
    DEFAULT_PARAMS: {
        i: 'jpeg',
        map: ''
    },
        
    /**
     * Constructor: HGIS.Layer.KaMap
     * 
     * Parameters:
     * name - {String}
     * url - {String}
     * params - {Object} Parameters to be sent to the HTTP server in the
     *    query string for the tile. The format can be set via the 'i'
     *    parameter (defaults to jpg) , and the map should be set via 
     *    the 'map' parameter. It has been reported that ka-Map may behave
     *    inconsistently if your format parameter does not match the format
     *    parameter configured in your config.php. (See ticket #327 for more
     *    information.)
     * options - {Object} Additional options for the layer. Any of the 
     *     APIProperties listed on this layer, and any layer types it
     *     extends, can be overridden through the options parameter. 
     */
    initialize: function(name, url, params, options) {
        HGIS.Layer.Grid.prototype.initialize.apply(this, arguments);
        this.params = HGIS.Util.applyDefaults(
            this.params, this.DEFAULT_PARAMS
        );
    },

    /**
     * Method: getURL
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>} 
     * 
     * Returns:
     * {String} A string with the layer's url and parameters and also the 
     *          passed-in bounds and appropriate tile size specified as 
     *          parameters
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);
        var mapRes = this.map.getResolution();
        var scale = Math.round((this.map.getScale() * 10000)) / 10000;
        var pX = Math.round(bounds.left / mapRes);
        var pY = -Math.round(bounds.top / mapRes);
        return this.getFullRequestString(
                      { t: pY, 
                        l: pX,
                        s: scale
                      });
    },

    /** 
     * Method: calculateGridLayout
     * ka-Map uses the center point of the map as an origin for 
     * its tiles. Override calculateGridLayout to center tiles 
     * correctly for this case.
     *
     * Parameters:
     * bounds - {<HGIS.Bound>}
     * origin - {<HGIS.LonLat>}
     * resolution - {Number}
     *
     * Returns:
     * {Object} Object containing properties tilelon, tilelat, startcol,
     * startrow
     */
    calculateGridLayout: function(bounds, origin, resolution) {
        var tilelon = resolution*this.tileSize.w;
        var tilelat = resolution*this.tileSize.h;
        
        var offsetlon = bounds.left;
        var tilecol = Math.floor(offsetlon/tilelon) - this.buffer;
        
        var offsetlat = bounds.top;  
        var tilerow = Math.floor(offsetlat/tilelat) + this.buffer;
        
        return { 
          tilelon: tilelon, tilelat: tilelat,
          startcol: tilecol, startrow: tilerow
        };
    },    

    /**
     * Method: getTileBoundsForGridIndex
     *
     * Parameters:
     * row - {Number} The row of the grid
     * col - {Number} The column of the grid
     *
     * Returns:
     * {<HGIS.Bounds>} The bounds for the tile at (row, col)
     */
    getTileBoundsForGridIndex: function(row, col) {
        var origin = this.getTileOrigin();
        var tileLayout = this.gridLayout;
        var tilelon = tileLayout.tilelon;
        var tilelat = tileLayout.tilelat;
        var minX = (tileLayout.startcol + col) * tilelon;
        var minY = (tileLayout.startrow - row) * tilelat;
        return new HGIS.Bounds(
            minX, minY,
            minX + tilelon, minY + tilelat
        );
    },

    /**
     * APIMethod: clone
     * 
     * Parameters: 
     * obj - {Object}
     * 
     * Returns:
     * {<HGIS.Layer.Kamap>} An exact clone of this HGIS.Layer.KaMap
     */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new HGIS.Layer.KaMap(this.name,
                                            this.url,
                                            this.params,
                                            this.getOptions());
        }

        //get all additions from superclasses
        obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here
        if (this.tileSize != null) {
            obj.tileSize = this.tileSize.clone();
        }
        
        // we do not want to copy reference to grid, so we make a new array
        obj.grid = [];

        return obj;
    },    
    
    /**
     * APIMethod: getTileBounds
     * Returns The tile bounds for a layer given a pixel location.
     *
     * Parameters:
     * viewPortPx - {<HGIS.Pixel>} The location in the viewport.
     *
     * Returns:
     * {<HGIS.Bounds>} Bounds of the tile at the given pixel location.
     */
    getTileBounds: function(viewPortPx) {
        var resolution = this.getResolution();
        var tileMapWidth = resolution * this.tileSize.w;
        var tileMapHeight = resolution * this.tileSize.h;
        var mapPoint = this.getLonLatFromViewPortPx(viewPortPx);
        var tileLeft = tileMapWidth * Math.floor(mapPoint.lon / tileMapWidth);
        var tileBottom = tileMapHeight * Math.floor(mapPoint.lat / tileMapHeight);
        return new HGIS.Bounds(tileLeft, tileBottom,
                                     tileLeft + tileMapWidth,
                                     tileBottom + tileMapHeight);
    },

    CLASS_NAME: "HGIS.Layer.KaMap"
});
/* ======================================================================
    HGIS/Format/WMC/v1_1_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WMC/v1.js
 */

/**
 * Class: HGIS.Format.WMC.v1_1_0
 * Read and write WMC version 1.1.0.
 *
 * Differences between 1.1.0 and 1.0.0:
 *     - 1.1.0 Layers have optional sld:MinScaleDenominator and
 *       sld:MaxScaleDenominator
 * 
 * Inherits from:
 *  - <HGIS.Format.WMC.v1>
 */
HGIS.Format.WMC.v1_1_0 = HGIS.Class(
    HGIS.Format.WMC.v1, {
    
    /**
     * Constant: VERSION
     * {String} 1.1.0
     */
    VERSION: "1.1.0",

    /**
     * Property: schemaLocation
     * {String} http://www.opengis.net/context
     *     http://schemas.opengis.net/context/1.1.0/context.xsd
     */
    schemaLocation: "http://www.opengis.net/context http://schemas.opengis.net/context/1.1.0/context.xsd",

    /**
     * Constructor: HGIS.Format.WMC.v1_1_0
     * Instances of this class are not created directly.  Use the
     *     <HGIS.Format.WMC> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        HGIS.Format.WMC.v1.prototype.initialize.apply(
            this, [options]
        );
    },

    /**
     * Method: read_sld_MinScaleDenominator
     * Read a sld:MinScaleDenominator node.
     *
     * Parameters:
     * layerContext - {Object} An object representing a layer.
     * node - {Element} An element node.
     */
    read_sld_MinScaleDenominator: function(layerContext, node) {
        var minScaleDenominator = parseFloat(this.getChildValue(node));
        if (minScaleDenominator > 0) {
            layerContext.maxScale = minScaleDenominator;
        }
    },

    /**
     * Method: read_sld_MaxScaleDenominator
     * Read a sld:MaxScaleDenominator node.
     *
     * Parameters:
     * layerContext - {Object} An object representing a layer.
     * node - {Element} An element node.
     */
    read_sld_MaxScaleDenominator: function(layerContext, node) {
        layerContext.minScale = parseFloat(this.getChildValue(node));
    },

    /**
     * Method: read_wmc_SRS
     */
    read_wmc_SRS: function(layerContext, node) {
        if (! ("srs" in layerContext)) {
            layerContext.srs = {};
        }
        layerContext.srs[this.getChildValue(node)] = true;
    },

    /**
     * Method: write_wmc_Layer
     * Create a Layer node given a layer context object. This method adds
     *     elements specific to version 1.1.0.
     *
     * Parameters:
     * context - {Object} A layer context object.}
     *
     * Returns:
     * {Element} A WMC Layer element node.
     */
    write_wmc_Layer: function(context) {
        var node = HGIS.Format.WMC.v1.prototype.write_wmc_Layer.apply(
            this, [context]
        );
        
        // min/max scale denominator elements go before the 4th element in v1
        if(context.maxScale) {
            var minSD = this.createElementNS(
                this.namespaces.sld, "sld:MinScaleDenominator"
            );
            minSD.appendChild(this.createTextNode(context.maxScale.toPrecision(16)));
            node.appendChild(minSD);
        }
        
        if(context.minScale) {
            var maxSD = this.createElementNS(
                this.namespaces.sld, "sld:MaxScaleDenominator"
            );
            maxSD.appendChild(this.createTextNode(context.minScale.toPrecision(16)));
            node.appendChild(maxSD);
        }

        // optional SRS element(s)
        if (context.srs) {
            for(var name in context.srs) {
                node.appendChild(this.createElementDefaultNS("SRS", name));
            }
        }

        // optional FormatList element
        node.appendChild(this.write_wmc_FormatList(context));

        // optional StyleList element
        node.appendChild(this.write_wmc_StyleList(context));
        
        // optional DimensionList element
        if (context.dimensions) {
            node.appendChild(this.write_wmc_DimensionList(context));
        }

        // HGIS specific properties go in an Extension element
        node.appendChild(this.write_wmc_LayerExtension(context));
        
        return node;
        
    },

    CLASS_NAME: "HGIS.Format.WMC.v1_1_0" 

});
/* ======================================================================
    HGIS/Format/XLS.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML/VersionedOGC.js
 */

/**
 * Class: HGIS.Format.XLS
 * Read/Write XLS (OpenLS). Create a new instance with the <HGIS.Format.XLS>
 *     constructor. Currently only implemented for Location Utility Services, more
 *     specifically only for Geocoding. No support for Reverse Geocoding as yet.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML.VersionedOGC>
 */
HGIS.Format.XLS = HGIS.Class(HGIS.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.1.0".
     */
    defaultVersion: "1.1.0",
 
    /**
     * APIProperty: stringifyOutput
     * {Boolean} If true, write will return a string otherwise a DOMElement.
     * Default is true.
     */
    stringifyOutput: true,
    
    /**
     * Constructor: HGIS.Format.XLS
     * Create a new parser for XLS.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: write
     * Write out an XLS request.
     *
     * Parameters:
     * request - {Object} An object representing the LUS request.
     * options - {Object} Optional configuration object.
     *
     * Returns:
     * {String} An XLS document string.
     */
    
    /**
     * APIMethod: read
     * Read an XLS doc and return an object representing the result.
     *
     * Parameters:
     * data - {String | DOMElement} Data to read.
     * options - {Object} Options for the reader.
     *
     * Returns:
     * {Object} An object representing the GeocodeResponse.
     */

    CLASS_NAME: "HGIS.Format.XLS" 
});
/* ======================================================================
    HGIS/Format/XLS/v1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XLS.js
 * @requires HGIS/Format/GML/v3.js
 */

/**
 * Class: HGIS.Format.XLS.v1
 * Superclass for XLS version 1 parsers. Only supports GeocodeRequest for now.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.XLS.v1 = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        xls: "http://www.opengis.net/xls",
        gml: "http://www.opengis.net/gml",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * APIProperty: xy
     * {Boolean} Order of the GML coordinate true:(x,y) or false:(y,x)
     * Changing is not recommended, a new Format should be instantiated.
     */
    xy: true,
    
    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "xls",

    /**
     * Property: schemaLocation
     * {String} Schema location for a particular minor version.
     */
    schemaLocation: null,
    
    /**
     * Constructor: HGIS.Format.XLS.v1
     * Instances of this class are not created directly.  Use the
     *     <HGIS.Format.XLS> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    
    /**
     * Method: read
     *
     * Parameters:
     * data - {DOMElement} An XLS document element.
     * options - {Object} Options for the reader.
     *
     * Returns:
     * {Object} An object representing the XLSResponse.
     */
    read: function(data, options) {
        options = HGIS.Util.applyDefaults(options, this.options);
        var xls = {};
        this.readChildNodes(data, xls);
        return xls;
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "xls": {
            "XLS": function(node, xls) {
                xls.version = node.getAttribute("version");
                this.readChildNodes(node, xls);
            },
            "Response": function(node, xls) {
               this.readChildNodes(node, xls);
            },
            "GeocodeResponse": function(node, xls) {
               xls.responseLists = [];
               this.readChildNodes(node, xls);
            },
            "GeocodeResponseList": function(node, xls) {
                var responseList = {
                    features: [], 
                    numberOfGeocodedAddresses: 
                        parseInt(node.getAttribute("numberOfGeocodedAddresses"))
                };
                xls.responseLists.push(responseList);
                this.readChildNodes(node, responseList);
            },
            "GeocodedAddress": function(node, responseList) {
                var feature = new HGIS.Feature.Vector();
                responseList.features.push(feature);
                this.readChildNodes(node, feature);
                // post-process geometry
                feature.geometry = feature.components[0];
            },
            "GeocodeMatchCode": function(node, feature) {
                feature.attributes.matchCode = {
                    accuracy: parseFloat(node.getAttribute("accuracy")),
                    matchType: node.getAttribute("matchType")
                };
            },
            "Address": function(node, feature) {
                var address = {
                    countryCode: node.getAttribute("countryCode"),
                    addressee: node.getAttribute("addressee"),
                    street: [],
                    place: []
                };
                feature.attributes.address = address;
                this.readChildNodes(node, address);
            },
            "freeFormAddress": function(node, address) {
                address.freeFormAddress = this.getChildValue(node);
            },
            "StreetAddress": function(node, address) {
                this.readChildNodes(node, address);
            },
            "Building": function(node, address) {
                address.building = {
                    'number': node.getAttribute("number"),
                    subdivision: node.getAttribute("subdivision"),
                    buildingName: node.getAttribute("buildingName")
                };
            },
            "Street": function(node, address) {
                // only support the built-in primitive type for now
                address.street.push(this.getChildValue(node));
            },
            "Place": function(node, address) {
                // type is one of CountrySubdivision, 
                // CountrySecondarySubdivision, Municipality or
                // MunicipalitySubdivision
                address.place[node.getAttribute("type")] = 
                    this.getChildValue(node);
            },
            "PostalCode": function(node, address) {
                address.postalCode = this.getChildValue(node);
            }
        },
        "gml": HGIS.Format.GML.v3.prototype.readers.gml
    },
    
    /**
     * Method: write
     *
     * Parameters:
     * request - {Object} An object representing the geocode request.
     *
     * Returns:
     * {DOMElement} The root of an XLS document.
     */
    write: function(request) {
        return this.writers.xls.XLS.apply(this, [request]);
    },
    
    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "xls": {
            "XLS": function(request) {
                var root = this.createElementNSPlus(
                    "xls:XLS",
                    {attributes: {
                        "version": this.VERSION,
                        "xsi:schemaLocation": this.schemaLocation
                    }}
                );
                this.writeNode("RequestHeader", request.header, root);
                this.writeNode("Request", request, root);
                return root;
            },
            "RequestHeader": function(header) {
                return this.createElementNSPlus("xls:RequestHeader");
            },
            "Request": function(request) {
                var node = this.createElementNSPlus("xls:Request", {
                    attributes: {
                        methodName: "GeocodeRequest",
                        requestID: request.requestID || "",
                        version: this.VERSION
                    }
                });
                this.writeNode("GeocodeRequest", request.addresses, node);
                return node;
            },
            "GeocodeRequest": function(addresses) {
                var node = this.createElementNSPlus("xls:GeocodeRequest");
                for (var i=0, len=addresses.length; i<len; i++) {
                    this.writeNode("Address", addresses[i], node);
                }
                return node;
            },
            "Address": function(address) {
                var node = this.createElementNSPlus("xls:Address", {
                    attributes: {
                        countryCode: address.countryCode
                    }
                });
                if (address.freeFormAddress) {
                    this.writeNode("freeFormAddress", address.freeFormAddress, node);
                } else {
                    if (address.street) {
                        this.writeNode("StreetAddress", address, node);
                    }
                    if (address.municipality) {
                        this.writeNode("Municipality", address.municipality, node);
                    }
                    if (address.countrySubdivision) {
                        this.writeNode("CountrySubdivision", address.countrySubdivision, node);
                    }
                    if (address.postalCode) {
                        this.writeNode("PostalCode", address.postalCode, node);
                    }
                }
                return node;
            },
            "freeFormAddress": function(freeFormAddress) {
                return this.createElementNSPlus("freeFormAddress", 
                    {value: freeFormAddress});
            },
            "StreetAddress": function(address) {
                var node = this.createElementNSPlus("xls:StreetAddress");
                if (address.building) {
                    this.writeNode(node, "Building", address.building);
                }
                var street = address.street;
                if (!(HGIS.Util.isArray(street))) {
                    street = [street];
                }
                for (var i=0, len=street.length; i < len; i++) {
                    this.writeNode("Street", street[i], node);
                }
                return node;
            },
            "Building": function(building) {
                return this.createElementNSPlus("xls:Building", {
                    attributes: {
                        "number": building["number"],
                        "subdivision": building.subdivision,
                        "buildingName": building.buildingName
                    }
                });
            },
            "Street": function(street) {
                return this.createElementNSPlus("xls:Street", {value: street});
            },
            "Municipality": function(municipality) {
                return this.createElementNSPlus("xls:Place", {
                    attributes: {
                        type: "Municipality"
                    },
                    value: municipality
                });
            },
            "CountrySubdivision": function(countrySubdivision) {
                return this.createElementNSPlus("xls:Place", {
                    attributes: {
                        type: "CountrySubdivision"
                    },
                    value: countrySubdivision
                });
            },
            "PostalCode": function(postalCode) {
                return this.createElementNSPlus("xls:PostalCode", {
                    value: postalCode
                });
            }
        }
    },
    
    CLASS_NAME: "HGIS.Format.XLS.v1" 

});
/* ======================================================================
    HGIS/Format/XLS/v1_1_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XLS/v1.js
 */

/**
 * Class: HGIS.Format.XLS.v1_1_0
 * Read / write XLS version 1.1.0.
 * 
 * Inherits from:
 *  - <HGIS.Format.XLS.v1>
 */
HGIS.Format.XLS.v1_1_0 = HGIS.Class(
    HGIS.Format.XLS.v1, {
    
    /**
     * Constant: VERSION
     * {String} 1.1
     */
    VERSION: "1.1",
    
    /**
     * Property: schemaLocation
     * {String} http://www.opengis.net/xls
     *   http://schemas.opengis.net/ols/1.1.0/LocationUtilityService.xsd
     */
    schemaLocation: "http://www.opengis.net/xls http://schemas.opengis.net/ols/1.1.0/LocationUtilityService.xsd",

    /**
     * Constructor: HGIS.Format.XLS.v1_1_0
     * Instances of this class are not created directly.  Use the
     *     <HGIS.Format.XLS> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    CLASS_NAME: "HGIS.Format.XLS.v1_1_0"

});

// Support non standard implementation
HGIS.Format.XLS.v1_1 = HGIS.Format.XLS.v1_1_0;
/* ======================================================================
    HGIS/Renderer/SVG.js
   ====================================================================== */
/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Renderer/Elements.js
 */

/**
 * Class: HGIS.Renderer.SVG
 * 
 * Inherits:
 *  - <HGIS.Renderer.Elements>
 */
HGIS.Renderer.SVG = HGIS.Class(HGIS.Renderer.Elements, {

    /** 
     * Property: xmlns
     * {String}
     */
    xmlns: "http://www.w3.org/2000/svg",
    
    /**
     * Property: xlinkns
     * {String}
     */
    xlinkns: "http://www.w3.org/1999/xlink",

    /**
     * Constant: MAX_PIXEL
     * {Integer} Firefox有一个限制值大于或小于15000的SVG文档中锁定浏览器.
     */
    MAX_PIXEL: 15000,

    /**
     * Property: translationParameters
     * {Object} Hash with "x" and "y" properties
     */
    translationParameters: null,
    
    /**
     * Property: symbolMetrics
     * {Object} Cache for symbol metrics according to their svg coordinate
     *     space. This is an object keyed by the symbol's id, and values are
     *     an array of [width, centerX, centerY].
     */
    symbolMetrics: null,
    
    /**
     * Constructor: HGIS.Renderer.SVG
     * 
     * Parameters:
     * containerID - {String}
     */
    initialize: function(containerID) {
        if (!this.supported()) { 
            return; 
        }
        HGIS.Renderer.Elements.prototype.initialize.apply(this, 
                                                                arguments);
        this.translationParameters = {x: 0, y: 0};
        
        this.symbolMetrics = {};
    },

    /**
     * APIMethod: supported
     * 浏览器是否支持SVG渲染器
     * 
     * Returns:
     * {Boolean} 如果支持，返回true,否则返回false
     */
    supported: function() {
        var svgFeature = "http://www.w3.org/TR/SVG11/feature#";
        return (document.implementation && 
           (document.implementation.hasFeature("org.w3c.svg", "1.0") || 
            document.implementation.hasFeature(svgFeature + "SVG", "1.1") || 
            document.implementation.hasFeature(svgFeature + "BasicStructure", "1.1") ));
    },    

    /**
     * Method: inValidRange
     * See #669 for more information
     *
     * Parameters:
     * x      - {Integer}
     * y      - {Integer}
     * xyOnly - {Boolean} whether or not to just check for x and y, which means
     *     to not take the current translation parameters into account if true.
     * 
     * Returns:
     * {Boolean} Whether or not the 'x' and 'y' coordinates are in the  
     *           valid range.
     */ 
    inValidRange: function(x, y, xyOnly) {
        var left = x + (xyOnly ? 0 : this.translationParameters.x);
        var top = y + (xyOnly ? 0 : this.translationParameters.y);
        return (left >= -this.MAX_PIXEL && left <= this.MAX_PIXEL &&
                top >= -this.MAX_PIXEL && top <= this.MAX_PIXEL);
    },

    /**
     * Method: setExtent
     * 
     * Parameters:
     * extent - {<HGIS.Bounds>}
     * resolutionChanged - {Boolean}
     * 
     * Returns:
     * {Boolean} true to notify the layer that the new extent does not exceed
     *     the coordinate range, and the features will not need to be redrawn.
     *     False otherwise.
     */
    setExtent: function(extent, resolutionChanged) {
        var coordSysUnchanged = HGIS.Renderer.Elements.prototype.setExtent.apply(this, arguments);
        
        var resolution = this.getResolution(),
            left = -extent.left / resolution,
            top = extent.top / resolution;

        // If the resolution has changed, start over changing the corner, because
        // the features will redraw.
        if (resolutionChanged) {
            this.left = left;
            this.top = top;
            // Set the viewbox
            var extentString = "0 0 " + this.size.w + " " + this.size.h;

            this.rendererRoot.setAttributeNS(null, "viewBox", extentString);
            this.translate(this.xOffset, 0);
            return true;
        } else {
            var inRange = this.translate(left - this.left + this.xOffset, top - this.top);
            if (!inRange) {
                // recenter the coordinate system
                this.setExtent(extent, true);
            }
            return coordSysUnchanged && inRange;
        }
    },
    
    /**
     * Method: translate
     * Transforms the SVG coordinate system
     * 
     * Parameters:
     * x - {Float}
     * y - {Float}
     * 
     * Returns:
     * {Boolean} true if the translation parameters are in the valid coordinates
     *     range, false otherwise.
     */
    translate: function(x, y) {
        if (!this.inValidRange(x, y, true)) {
            return false;
        } else {
            var transformString = "";
            if (x || y) {
                transformString = "translate(" + x + "," + y + ")";
            }
            this.root.setAttributeNS(null, "transform", transformString);
            this.translationParameters = {x: x, y: y};
            return true;
        }
    },

    /**
     * Method: setSize
     * Sets the size of the drawing surface.
     * 
     * Parameters:
     * size - {<HGIS.Size>} The size of the drawing surface
     */
    setSize: function(size) {
        HGIS.Renderer.prototype.setSize.apply(this, arguments);
        
        this.rendererRoot.setAttributeNS(null, "width", this.size.w);
        this.rendererRoot.setAttributeNS(null, "height", this.size.h);
    },

    /** 
     * Method: getNodeType 
     * 
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * style - {Object}
     * 
     * Returns:
     * {String} The corresponding node type for the specified geometry
     */
    getNodeType: function(geometry, style) {
        var nodeType = null;
        switch (geometry.CLASS_NAME) {
            case "HGIS.Geometry.Point":
                if (style.externalGraphic) {
                    nodeType = "image";
                } else if (this.isComplexSymbol(style.graphicName)) {
                    nodeType = "svg";
                } else {
                    nodeType = "circle";
                }
                break;
            case "HGIS.Geometry.Rectangle":
                nodeType = "rect";
                break;
            case "HGIS.Geometry.LineString":
                nodeType = "polyline";
                break;
            case "HGIS.Geometry.LinearRing":
                nodeType = "polygon";
                break;
            case "HGIS.Geometry.Polygon":
            case "HGIS.Geometry.Curve":
                nodeType = "path";
                break;
            default:
                break;
        }
        return nodeType;
    },

    /** 
     * Method: setStyle
     * Use to set all the style attributes to a SVG node.
     * 
     * Takes care to adjust stroke width and point radius to be
     * resolution-relative
     *
     * Parameters:
     * node - {SVGDomElement} An SVG element to decorate
     * style - {Object}
     * options - {Object} Currently supported options include 
     *                              'isFilled' {Boolean} and
     *                              'isStroked' {Boolean}
     */
    setStyle: function(node, style, options) {
        style = style  || node._style;
        options = options || node._options;

        var title = style.title || style.graphicTitle;
        if (title) {
            node.setAttributeNS(null, "title", title);
            //Standards-conformant SVG
            // Prevent duplicate nodes. See issue https://github.com/HGIS/HGIS/issues/92 
            var titleNode = node.getElementsByTagName("title");
            if (titleNode.length > 0) {
                titleNode[0].firstChild.textContent = title;
            } else {
                var label = this.nodeFactory(null, "title");
                label.textContent = title;
                node.appendChild(label);
            }
        }

        var r = parseFloat(node.getAttributeNS(null, "r"));
        var widthFactor = 1;
        var pos;
        if (node._geometryClass == "HGIS.Geometry.Point" && r) {
            node.style.visibility = "";
            if (style.graphic === false) {
                node.style.visibility = "hidden";
            } else if (style.externalGraphic) {
                pos = this.getPosition(node);
                if (style.graphicWidth && style.graphicHeight) {
                  node.setAttributeNS(null, "preserveAspectRatio", "none");
                }
                var width = style.graphicWidth || style.graphicHeight;
                var height = style.graphicHeight || style.graphicWidth;
                width = width ? width : style.pointRadius*2;
                height = height ? height : style.pointRadius*2;
                var xOffset = (style.graphicXOffset != undefined) ?
                    style.graphicXOffset : -(0.5 * width);
                var yOffset = (style.graphicYOffset != undefined) ?
                    style.graphicYOffset : -(0.5 * height);

                var opacity = style.graphicOpacity || style.fillOpacity;
                
                node.setAttributeNS(null, "x", (pos.x + xOffset).toFixed());
                node.setAttributeNS(null, "y", (pos.y + yOffset).toFixed());
                node.setAttributeNS(null, "width", width);
                node.setAttributeNS(null, "height", height);
                node.setAttributeNS(this.xlinkns, "xlink:href", style.externalGraphic);
                node.setAttributeNS(null, "style", "opacity: "+opacity);
                node.onclick = HGIS.Event.preventDefault;
            } else if (this.isComplexSymbol(style.graphicName)) {
                // the symbol viewBox is three times as large as the symbol
                var offset = style.pointRadius * 3;
                var size = offset * 2;
                var src = this.importSymbol(style.graphicName);
                pos = this.getPosition(node);
                widthFactor = this.symbolMetrics[src.id][0] * 3 / size;
                
                // remove the node from the dom before we modify it. This
                // prevents various rendering issues in Safari and FF
                var parent = node.parentNode;
                var nextSibling = node.nextSibling;
                if(parent) {
                    parent.removeChild(node);
                }
                
                // The more appropriate way to implement this would be use/defs,
                // but due to various issues in several browsers, it is safer to
                // copy the symbols instead of referencing them. 
                // See e.g. ticket http://trac.osgeo.org/HGIS/ticket/2985 
                // and this email thread
                // http://osgeo-org.1803224.n2.nabble.com/Select-Control-Ctrl-click-on-Feature-with-a-graphicName-opens-new-browser-window-tc5846039.html
                node.firstChild && node.removeChild(node.firstChild);
                node.appendChild(src.firstChild.cloneNode(true));
                node.setAttributeNS(null, "viewBox", src.getAttributeNS(null, "viewBox"));
                
                node.setAttributeNS(null, "width", size);
                node.setAttributeNS(null, "height", size);
                node.setAttributeNS(null, "x", pos.x - offset);
                node.setAttributeNS(null, "y", pos.y - offset);
                
                // now that the node has all its new properties, insert it
                // back into the dom where it was
                if(nextSibling) {
                    parent.insertBefore(node, nextSibling);
                } else if(parent) {
                    parent.appendChild(node);
                }
            } else {
            	//解决style.pointRadius为负数或null、undefined时js报错的问题
            	if(style.pointRadius!=null && style.pointRadius!=undefined && style.pointRadius>=0)
            		node.setAttributeNS(null, "r", style.pointRadius);            	 
            }

            var rotation = style.rotation;
            
            if ((rotation !== undefined || node._rotation !== undefined) && pos) {
                node._rotation = rotation;
                rotation |= 0;
                if (node.nodeName !== "svg") { 
                    node.setAttributeNS(null, "transform", 
                        "rotate(" + rotation + " " + pos.x + " " + 
                        pos.y + ")"); 
                } else {
                    var metrics = this.symbolMetrics[src.id];
                    node.firstChild.setAttributeNS(null, "transform", "rotate(" 
                        + rotation + " " 
                        + metrics[1] + " "
                        + metrics[2] + ")");
                }
            }
        }
        
        if (options.isFilled) {
            node.setAttributeNS(null, "fill", style.fillColor);
            node.setAttributeNS(null, "fill-opacity", style.fillOpacity);
        } else {
            node.setAttributeNS(null, "fill", "none");
        }

        if (options.isStroked) {
            node.setAttributeNS(null, "stroke", style.strokeColor);
            node.setAttributeNS(null, "stroke-opacity", style.strokeOpacity);
            node.setAttributeNS(null, "stroke-width", style.strokeWidth * widthFactor);
            //增加判断语句解决strokeLinecap为其他不为butt和square的值时，默认线头不为圆形的问题。
            if(style.strokeLinecap && style.strokeLinecap!='butt' && style.strokeLinecap!='square'){
            	style.strokeLinecap =null;
            }
            
            node.setAttributeNS(null, "stroke-linecap", style.strokeLinecap || "round");
            // Hard-coded linejoin for now, to make it look the same as in VML.
            // There is no strokeLinejoin property yet for symbolizers.
            node.setAttributeNS(null, "stroke-linejoin", "round");
            style.strokeDashstyle && node.setAttributeNS(null,
                "stroke-dasharray", this.dashStyle(style, widthFactor));
        } else {
            node.setAttributeNS(null, "stroke", "none");
        }
        
        if (style.pointerEvents) {
            node.setAttributeNS(null, "pointer-events", style.pointerEvents);
        }
                
        if (style.cursor != null) {
            node.setAttributeNS(null, "cursor", style.cursor);
        }
        
        return node;
    },

    /** 
     * Method: dashStyle
     * 
     * Parameters:
     * style - {Object}
     * widthFactor - {Number}
     * 
     * Returns:
     * {String} A SVG compliant 'stroke-dasharray' value
     */
    dashStyle: function(style, widthFactor) {
        var w = style.strokeWidth * widthFactor;
        var str = style.strokeDashstyle;
        switch (str) {
            case 'solid':
                return 'none';
            case 'dot':
                return [1, 4 * w].join();
            case 'dash':
                return [4 * w, 4 * w].join();
            case 'dashdot':
                return [4 * w, 4 * w, 1, 4 * w].join();
            case 'longdash':
                return [8 * w, 4 * w].join();
            case 'longdashdot':
                return [8 * w, 4 * w, 1, 4 * w].join();
            default:
                return HGIS.String.trim(str).replace(/\s+/g, ",");
        }
    },
    
    /** 
     * Method: createNode
     * 
     * Parameters:
     * type - {String} Kind of node to draw
     * id - {String} Id for node
     * 
     * Returns:
     * {DOMElement} A new node of the given type and id
     */
    createNode: function(type, id) {
        var node = document.createElementNS(this.xmlns, type);
        if (id) {
            node.setAttributeNS(null, "id", id);
        }
        return node;    
    },
    
    /** 
     * Method: nodeTypeCompare
     * 
     * Parameters:
     * node - {SVGDomElement} An SVG element
     * type - {String} Kind of node
     * 
     * Returns:
     * {Boolean} Whether or not the specified node is of the specified type
     */
    nodeTypeCompare: function(node, type) {
        return (type == node.nodeName);
    },
   
    /**
     * Method: createRenderRoot
     * 
     * Returns:
     * {DOMElement} The specific render engine's root element
     */
    createRenderRoot: function() {
        var svg = this.nodeFactory(this.container.id + "_svgRoot", "svg");
        svg.style.display = "block";
        return svg;
    },

    /**
     * Method: createRoot
     * 
     * Parameters:
     * suffix - {String} suffix to append to the id
     * 
     * Returns:
     * {DOMElement}
     */
    createRoot: function(suffix) {
        return this.nodeFactory(this.container.id + suffix, "g");
    },

    /**
     * Method: createDefs
     *
     * Returns:
     * {DOMElement} The element to which we'll add the symbol definitions
     */
    createDefs: function() {
        var defs = this.nodeFactory(this.container.id + "_defs", "defs");
        this.rendererRoot.appendChild(defs);
        return defs;
    },

    /**************************************
     *                                    *
     *     GEOMETRY DRAWING FUNCTIONS     *
     *                                    *
     **************************************/

    /**
     * Method: drawPoint
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement} or false if the renderer could not draw the point
     */ 
    drawPoint: function(node, geometry) {
        return this.drawCircle(node, geometry, 1);
    },

    /**
     * Method: drawCircle
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * radius - {Float}
     * 
     * Returns:
     * {DOMElement} or false if the renderer could not draw the circle
     */
    drawCircle: function(node, geometry, radius) {
        var resolution = this.getResolution();
        var x = ((geometry.x - this.featureDx) / resolution + this.left);
        var y = (this.top - geometry.y / resolution);

        if (this.inValidRange(x, y)) { 
            node.setAttributeNS(null, "cx", x);
            node.setAttributeNS(null, "cy", y);
            node.setAttributeNS(null, "r", radius);
            return node;
        } else {
            return false;
        }    
            
    },
    
    /**
     * Method: drawLineString
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement} or null if the renderer could not draw all components of
     *     the linestring, or false if nothing could be drawn
     */ 
    drawLineString: function(node, geometry) {
        var componentsResult = this.getComponentsString(geometry.components);
        if (componentsResult.path) {
            node.setAttributeNS(null, "points", componentsResult.path);
            return (componentsResult.complete ? node : null);  
        } else {
            return false;
        }
    },
    
    /**
     * Method: drawLinearRing
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement} or null if the renderer could not draw all components
     *     of the linear ring, or false if nothing could be drawn
     */ 
    drawLinearRing: function(node, geometry) {
        var componentsResult = this.getComponentsString(geometry.components);
        if (componentsResult.path) {
            node.setAttributeNS(null, "points", componentsResult.path);
            return (componentsResult.complete ? node : null);  
        } else {
            return false;
        }
    },
    
    /**
     * Method: drawPolygon
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement} or null if the renderer could not draw all components
     *     of the polygon, or false if nothing could be drawn
     */ 
    drawPolygon: function(node, geometry) {
        var d = "";
        var draw = true;
        var complete = true;
        var linearRingResult, path;
        for (var j=0, len=geometry.components.length; j<len; j++) {
            d += " M";
            linearRingResult = this.getComponentsString(
                geometry.components[j].components, " ");
            path = linearRingResult.path;
            if (path) {
                d += " " + path;
                complete = linearRingResult.complete && complete;
            } else {
                draw = false;
            }
        }
        d += " z";
        if (draw) {
            node.setAttributeNS(null, "d", d);
            node.setAttributeNS(null, "fill-rule", "evenodd");
            return complete ? node : null;
        } else {
            return false;
        }    
    },
    
    /**
     * Method: drawRectangle
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement} or false if the renderer could not draw the rectangle
     */ 
    drawRectangle: function(node, geometry) {
        var resolution = this.getResolution();
        var x = ((geometry.x - this.featureDx) / resolution + this.left);
        var y = (this.top - geometry.y / resolution);

        if (this.inValidRange(x, y)) { 
            node.setAttributeNS(null, "x", x);
            node.setAttributeNS(null, "y", y);
            node.setAttributeNS(null, "width", geometry.width / resolution);
            node.setAttributeNS(null, "height", geometry.height / resolution);
            return node;
        } else {
            return false;
        }
    },
    
    /**
     * Method: drawText
     * This method is only called by the renderer itself.
     *
     * Parameters:
     * featureId - {String}
     * style -
     * location - {<HGIS.Geometry.Point>}
     */
    drawText: function(featureId, style, location) {
    	var drawOutline = (!!style.labelOutlineWidth);
        // First draw text in halo color and size and overlay the
        // normal text afterwards
        if (drawOutline) {
            var outlineStyle = HGIS.Util.extend({}, style);
            outlineStyle.fontColor = outlineStyle.labelOutlineColor;
            outlineStyle.fontStrokeColor = outlineStyle.labelOutlineColor;
            outlineStyle.fontStrokeWidth = style.labelOutlineWidth;
            //之前为if (style.labelOutlineOpacity) 
            if (!isNaN(style.labelOutlineOpacity)) {
                outlineStyle.fontOpacity = style.labelOutlineOpacity;            	 
            }
            delete outlineStyle.labelOutlineWidth;
            this.drawText(featureId, outlineStyle, location);
        }

        var resolution = this.getResolution();

        var x = ((location.x - this.featureDx) / resolution + this.left);
        var y = (location.y / resolution - this.top);

        var suffix = (drawOutline)?this.LABEL_OUTLINE_SUFFIX:this.LABEL_ID_SUFFIX;
        var label = this.nodeFactory(featureId + suffix, "text");

        label.setAttributeNS(null, "x", x);
        label.setAttributeNS(null, "y", -y);

        if (style.fontColor) {
            label.setAttributeNS(null, "fill", style.fontColor);
        }
        if (style.fontStrokeColor) {
            label.setAttributeNS(null, "stroke", style.fontStrokeColor);
        }
        if (style.fontStrokeWidth) {
            label.setAttributeNS(null, "stroke-width", style.fontStrokeWidth);
        }
        //之前为if (style.fontOpacity) 
        if (!isNaN(style.fontOpacity)) {
            label.setAttributeNS(null, "opacity", style.fontOpacity);
        }
        if (style.fontFamily) {
            label.setAttributeNS(null, "font-family", style.fontFamily);
        }
        if (style.fontSize) {
            label.setAttributeNS(null, "font-size", style.fontSize);
        }
        if (style.fontWeight) {
            label.setAttributeNS(null, "font-weight", style.fontWeight);
        }
        if (style.fontStyle) {
            label.setAttributeNS(null, "font-style", style.fontStyle);
        }
        if (style.labelSelect === true) {
            label.setAttributeNS(null, "pointer-events", "visible");
            label._featureId = featureId;
        } else {
            label.setAttributeNS(null, "pointer-events", "none");
        }
        var align = style.labelAlign || HGIS.Renderer.defaultSymbolizer.labelAlign;
        label.setAttributeNS(null, "text-anchor",
            HGIS.Renderer.SVG.LABEL_ALIGN[align[0]] || "middle");

        if (HGIS.IS_GECKO === true) {
            label.setAttributeNS(null, "dominant-baseline",
                HGIS.Renderer.SVG.LABEL_ALIGN[align[1]] || "central");
        }

        var labelRows = style.label.split('\n');
        var numRows = labelRows.length;
        while (label.childNodes.length > numRows) {
            label.removeChild(label.lastChild);
        }
        for (var i = 0; i < numRows; i++) {
            var tspan = this.nodeFactory(featureId + suffix + "_tspan_" + i, "tspan");
            if (style.labelSelect === true) {
                tspan._featureId = featureId;
                tspan._geometry = location;
                tspan._geometryClass = location.CLASS_NAME;
            }
            if (HGIS.IS_GECKO === false) {
                tspan.setAttributeNS(null, "baseline-shift",
                    HGIS.Renderer.SVG.LABEL_VSHIFT[align[1]] || "-35%");
            }
            tspan.setAttribute("x", x);
            if (i == 0) {
                var vfactor = HGIS.Renderer.SVG.LABEL_VFACTOR[align[1]];
                if (vfactor == null) {
                     vfactor = -.5;
                }
                tspan.setAttribute("dy", (vfactor*(numRows-1)) + "em");
            } else {
                tspan.setAttribute("dy", "1em");
            }
            tspan.textContent = (labelRows[i] === '') ? ' ' : labelRows[i];
            if (!tspan.parentNode) {
                label.appendChild(tspan);
            }
        }

        if (!label.parentNode) { 
        	//this.textRoot.appendChild(label);
        	this.vectorRoot.appendChild(label);//2018年8月6日修改，将textRoot改为vectorRoot           
        }
        
        //显示文本背景
		if(style.labelBackgroundColor||style.labelBorderColor||style.labelBorderSize){
			var bg = this.nodeFactory(featureId + this.LABEL_ID_SUFFIX + "_bg","rect");
			if(style.labelBackgroundColor){
			  bg.setAttributeNS(null,"fill",style.labelBackgroundColor);			  
			}
			if(style.labelBorderColor|| style.labelBorderSize){
			  bg.setAttributeNS(null,"stroke",(style.labelBorderColor?style.labelBorderColor:"#000000"));
			  bg.setAttributeNS(null,"stroke-width",(style.labelBorderSize?style.labelBorderSize:"0.5"));
			}
			var bbox = label.getBBox();
			var labelWidth = bbox.width;
			var labelHeight = bbox.height;
			var padding = 2;
			
			if(style.labelPadding){
			   var pos = style.labelPadding.indexOf("px");
			   if(pos==-1){
			     padding = style.labelPadding;
			   }else{
			     padding = parseInt(style.labelPadding.substr(0,pos));
			   }
			}
			bg.setAttributeNS(null,"x",bbox.x - padding);
			bg.setAttributeNS(null,"y",bbox.y - padding);
			bg.setAttributeNS(null,"height",(labelHeight + padding*2) + "px");
			bg.setAttributeNS(null,"width",(labelWidth + padding*2) + "px");
			//this.textRoot.insertBefore(bg,label);
			this.vectorRoot.insertBefore(bg,label);//2018年8月6日修改，将textRoot改为vectorRoot
		}
    },
    
    /** 
     * Method: getComponentString
     * 
     * Parameters:
     * components - {Array(<HGIS.Geometry.Point>)} Array of points
     * separator - {String} character between coordinate pairs. Defaults to ","
     * 
     * Returns:
     * {Object} hash with properties "path" (the string created from the
     *     components and "complete" (false if the renderer was unable to
     *     draw all components)
     */
    getComponentsString: function(components, separator) {
        var renderCmp = [];
        var complete = true;
        var len = components.length;
        var strings = [];
        var str, component;
        for(var i=0; i<len; i++) {
            component = components[i];
            renderCmp.push(component);
            str = this.getShortString(component);
            if (str) {
                strings.push(str);
            } else {
                // The current component is outside the valid range. Let's
                // see if the previous or next component is inside the range.
                // If so, add the coordinate of the intersection with the
                // valid range bounds.
                if (i > 0) {
                    if (this.getShortString(components[i - 1])) {
                        strings.push(this.clipLine(components[i],
                            components[i-1]));
                    }
                }
                if (i < len - 1) {
                    if (this.getShortString(components[i + 1])) {
                        strings.push(this.clipLine(components[i],
                            components[i+1]));
                    }
                }
                complete = false;
            }
        }

        return {
            path: strings.join(separator || ","),
            complete: complete
        };
    },
    
    /**
     * Method: clipLine
     * Given two points (one inside the valid range, and one outside),
     * clips the line betweeen the two points so that the new points are both
     * inside the valid range.
     * 
     * Parameters:
     * badComponent - {<HGIS.Geometry.Point>} original geometry of the
     *     invalid point
     * goodComponent - {<HGIS.Geometry.Point>} original geometry of the
     *     valid point
     * Returns
     * {String} the SVG coordinate pair of the clipped point (like
     *     getShortString), or an empty string if both passed componets are at
     *     the same point.
     */
    clipLine: function(badComponent, goodComponent) {
        if (goodComponent.equals(badComponent)) {
            return "";
        }
        var resolution = this.getResolution();
        var maxX = this.MAX_PIXEL - this.translationParameters.x;
        var maxY = this.MAX_PIXEL - this.translationParameters.y;
        var x1 = (goodComponent.x - this.featureDx) / resolution + this.left;
        var y1 = this.top - goodComponent.y / resolution;
        var x2 = (badComponent.x - this.featureDx) / resolution + this.left;
        var y2 = this.top - badComponent.y / resolution;
        var k;
        if (x2 < -maxX || x2 > maxX) {
            k = (y2 - y1) / (x2 - x1);
            x2 = x2 < 0 ? -maxX : maxX;
            y2 = y1 + (x2 - x1) * k;
        }
        if (y2 < -maxY || y2 > maxY) {
            k = (x2 - x1) / (y2 - y1);
            y2 = y2 < 0 ? -maxY : maxY;
            x2 = x1 + (y2 - y1) * k;
        }
        return x2 + "," + y2;
    },

    /** 
     * 
     * Method: getShortString
     * 
     * Parameters:
     * point - {<HGIS.Geometry.Point>}
     * 
     * Returns:
     * {String} or false if point is outside the valid range
     */
    getShortString: function(point) {
        var resolution = this.getResolution();
        var x = ((point.x - this.featureDx) / resolution + this.left);
        var y = (this.top - point.y / resolution);
        //不做渲染压力判断,直接返回
        return x + "," + y;
//        if (this.inValidRange(x, y)) { 
//            return x + "," + y;
//        } else {
//            return false;
//        }
    },
    
    /**
     * Method: getPosition
     * Finds the position of an svg node.
     * 
     * Parameters:
     * node - {DOMElement}
     * 
     * Returns:
     * {Object} hash with x and y properties, representing the coordinates
     *     within the svg coordinate system
     */
    getPosition: function(node) {
        return({
            x: parseFloat(node.getAttributeNS(null, "cx")),
            y: parseFloat(node.getAttributeNS(null, "cy"))
        });
    },

    /**
     * Method: importSymbol
     * add a new symbol definition from the rendererer's symbol hash
     * 
     * Parameters:
     * graphicName - {String} name of the symbol to import
     * 
     * Returns:
     * {DOMElement} - the imported symbol
     */      
    importSymbol: function (graphicName)  {
        if (!this.defs) {
            // create svg defs tag
            this.defs = this.createDefs();
        }
        var id = this.container.id + "-" + graphicName;
        
        // check if symbol already exists in the defs
        var existing = document.getElementById(id);
        if (existing != null) {
            return existing;
        }
        
        var symbol = HGIS.Renderer.symbol[graphicName];
        if (!symbol) {
            throw new Error(graphicName + ' is not a valid symbol name');
        }

        var symbolNode = this.nodeFactory(id, "symbol");
        var node = this.nodeFactory(null, "polygon");
        symbolNode.appendChild(node);
        var symbolExtent = new HGIS.Bounds(
                                    Number.MAX_VALUE, Number.MAX_VALUE, 0, 0);

        var points = [];
        var x,y;
        for (var i=0; i<symbol.length; i=i+2) {
            x = symbol[i];
            y = symbol[i+1];
            symbolExtent.left = Math.min(symbolExtent.left, x);
            symbolExtent.bottom = Math.min(symbolExtent.bottom, y);
            symbolExtent.right = Math.max(symbolExtent.right, x);
            symbolExtent.top = Math.max(symbolExtent.top, y);
            points.push(x, ",", y);
        }
        
        node.setAttributeNS(null, "points", points.join(" "));
        
        var width = symbolExtent.getWidth();
        var height = symbolExtent.getHeight();
        // create a viewBox three times as large as the symbol itself,
        // to allow for strokeWidth being displayed correctly at the corners.
        var viewBox = [symbolExtent.left - width,
                        symbolExtent.bottom - height, width * 3, height * 3];
        symbolNode.setAttributeNS(null, "viewBox", viewBox.join(" "));
        this.symbolMetrics[id] = [
            Math.max(width, height),
            symbolExtent.getCenterLonLat().lon,
            symbolExtent.getCenterLonLat().lat
        ];
        
        this.defs.appendChild(symbolNode);
        return symbolNode;
    },
    
    /**
     * Method: getFeatureIdFromEvent
     * 
     * Parameters:
     * evt - {Object} An <HGIS.Event> object
     *
     * Returns:
     * {String} A feature id or undefined.
     */
    getFeatureIdFromEvent: function(evt) {
        var featureId = HGIS.Renderer.Elements.prototype.getFeatureIdFromEvent.apply(this, arguments);
        if(!featureId) {
            var target = evt.target;
            featureId = target.parentNode && target != this.rendererRoot ?
                target.parentNode._featureId : undefined;
        }
        return featureId;
    },

    CLASS_NAME: "HGIS.Renderer.SVG"
});

/**
 * Constant: HGIS.Renderer.SVG.LABEL_ALIGN
 * {Object}
 */
HGIS.Renderer.SVG.LABEL_ALIGN = {
    "l": "start",
    "r": "end",
    "b": "bottom",
    "t": "hanging"
};

/**
 * Constant: HGIS.Renderer.SVG.LABEL_VSHIFT
 * {Object}
 */
HGIS.Renderer.SVG.LABEL_VSHIFT = {
    // according to
    // http://www.w3.org/Graphics/SVG/Test/20061213/htmlObjectHarness/full-text-align-02-b.html
    // a baseline-shift of -70% shifts the text exactly from the
    // bottom to the top of the baseline, so -35% moves the text to
    // the center of the baseline.
    "t": "-70%",
    "b": "0"    
};

/**
 * Constant: HGIS.Renderer.SVG.LABEL_VFACTOR
 * {Object}
 */
HGIS.Renderer.SVG.LABEL_VFACTOR = {
    "t": 0,
    "b": -1
};

/**
 * Function: HGIS.Renderer.SVG.preventDefault
 * *Deprecated*.  Use <HGIS.Event.preventDefault> method instead.
 * Used to prevent default events (especially opening images in a new tab on
 * ctrl-click) from being executed for externalGraphic symbols
 */
HGIS.Renderer.SVG.preventDefault = function(e) {
    HGIS.Event.preventDefault(e);
};
/* ======================================================================
    HGIS/Format/SLD/v1_0_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/SLD/v1.js
 * @requires HGIS/Format/Filter/v1_0_0.js
 */

/**
 * Class: HGIS.Format.SLD.v1_0_0
 * Write SLD version 1.0.0.
 * 
 * Inherits from:
 *  - <HGIS.Format.SLD.v1>
 */
HGIS.Format.SLD.v1_0_0 = HGIS.Class(
    HGIS.Format.SLD.v1, {
    
    /**
     * Constant: VERSION
     * {String} 1.0.0
     */
    VERSION: "1.0.0",
    
    /**
     * Property: schemaLocation
     * {String} http://www.opengis.net/sld
     *   http://schemas.opengis.net/sld/1.0.0/StyledLayerDescriptor.xsd
     */
    schemaLocation: "http://www.opengis.net/sld http://schemas.opengis.net/sld/1.0.0/StyledLayerDescriptor.xsd",

    /**
     * Constructor: HGIS.Format.SLD.v1_0_0
     * Instances of this class are not created directly.  Use the
     *     <HGIS.Format.SLD> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    CLASS_NAME: "HGIS.Format.SLD.v1_0_0" 

});
/* ======================================================================
    HGIS/Format/OWSContext.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/Context.js
 */

/**
 * Class: HGIS.Format.OWSContext
 * Read and write OWS Context documents. OWS Context documents are a 
 * preliminary OGC (Open Geospatial Consortium) standard for storing the 
 * state of a web mapping application. In a way it is the successor to
 * Web Map Context (WMC), since it is more generic and more types of layers
 * can be stored. Also, nesting of layers is supported since version 0.3.1.
 * For more information see: http://www.ogcnetwork.net/context
 *
 * Inherits from:
 *  - <HGIS.Format.Context>
 */
HGIS.Format.OWSContext = HGIS.Class(HGIS.Format.Context,{
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "0.3.1".
     */
    defaultVersion: "0.3.1",

    /**
     * Constructor: HGIS.Format.OWSContext
     * Create a new parser for OWS Context documents.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    
    /**
     * Method: getVersion
     * Returns the version to use. Subclasses can override this function
     * if a different version detection is needed.
     *
     * Parameters:
     * root - {DOMElement}
     * options - {Object} Optional configuration object.
     *
     * Returns:
     * {String} The version to use.
     */
    getVersion: function(root, options) {
        var version = HGIS.Format.XML.VersionedOGC.prototype.getVersion.apply(
            this, arguments);
        // 0.3.1 is backwards compatible with 0.3.0
        if (version === "0.3.0") {
            version = this.defaultVersion;
        }
        return version;
    },

    /**
     * Method: toContext
     * Create a context object free from layer given a map or a
     * context object.
     *
     * Parameters:
     * obj - {<HGIS.Map> | Object} The map or context.
     *
     * Returns:
     * {Object} A context object.
     */
    toContext: function(obj) {
        var context = {};
        if(obj.CLASS_NAME == "HGIS.Map") {
            context.bounds = obj.getExtent();
            context.maxExtent = obj.maxExtent;
            context.projection = obj.projection;
            context.size = obj.getSize();
            context.layers = obj.layers;
        }
        return context;
    },

    CLASS_NAME: "HGIS.Format.OWSContext" 

});
/* ======================================================================
    HGIS/Format/OWSContext/v0_3_1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/KML.js
 * @requires HGIS/Format/GML.js
 * @requires HGIS/Format/GML/v2.js
 * @requires HGIS/Format/SLD/v1_0_0.js
 * @requires HGIS/Format/OWSContext.js
 * @requires HGIS/Format/OWSCommon/v1_0_0.js
 */

/**
 * Class: HGIS.Format.OWSContext.v0_3_1
 * Read and write OWSContext version 0.3.1.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.OWSContext.v0_3_1 = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        owc: "http://www.opengis.net/ows-context",
        gml: "http://www.opengis.net/gml",
        kml: "http://www.opengis.net/kml/2.2",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows",
        sld: "http://www.opengis.net/sld",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Constant: VERSION
     * {String} 0.3.1
     */
    VERSION: "0.3.1", 

    /**
     * Property: schemaLocation
     * {String} Schema location
     */
    schemaLocation: "http://www.opengis.net/ows-context http://www.ogcnetwork.net/schemas/owc/0.3.1/owsContext.xsd",

    /**
     * Property: defaultPrefix
     * {String} Default namespace prefix to use.
     */
    defaultPrefix: "owc",

    /**
     * APIProperty: extractAttributes
     * {Boolean} Extract attributes from GML.  Default is true.
     */
    extractAttributes: true,
    
    /**
     * APIProperty: xy
     * {Boolean} Order of the GML coordinate true:(x,y) or false:(y,x)
     * Changing is not recommended, a new Format should be instantiated.
     */ 
    xy: true, 

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * Property: featureNS
     * {String} The namespace uri to use for writing InlineGeometry
     */
    featureNS: "http://mapserver.gis.umn.edu/mapserver",

    /**
     * Property: featureType
     * {String} The name to use as the feature type when writing out
     *     InlineGeometry
     */
    featureType: 'vector',
              
    /**
     * Property: geometryName
     * {String} The name to use for the geometry attribute when writing out
     *     InlineGeometry
     */
    geometryName: 'geometry',

    /**
     * Property: nestingLayerLookup
     * {Object} Hashtable lookup for nesting layer nodes. Used while writing 
     *     the OWS context document. It is necessary to keep track of the 
     *     nestingPaths for which nesting layer nodes have already been 
     *     created, so (nesting) layer nodes are added to those nodes.
     *
     * For example:
     *
     *     If there are three layers with nestingPaths:
     *         layer1.metadata.nestingPath = "a/b/"
     *         layer2.metadata.nestingPath = "a/b/"
     *         layer2.metadata.nestingPath = "a/c"
     *
     *     then a nesting layer node "a" should be created once and added 
     *     to the resource list, a nesting layer node "b" should be created 
     *     once and added under "a", and a nesting layer node "c" should be 
     *     created and added under "a". The lookup paths for these nodes 
     *     will be "a", "a/b", and "a/c" respectively.
     */
    nestingLayerLookup: null,

    /**
     * Constructor: HGIS.Format.OWSContext.v0_3_1
     * Instances of this class are not created directly.  Use the
     *     <HGIS.Format.OWSContext> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
        HGIS.Format.GML.v2.prototype.setGeometryTypes.call(this);
    },

    /**
     * Method: setNestingPath
     * Set the nestingPath property of the layer depending on the position
     *     of the layer in hierarchy of layers.
     *
     * Parameters:
     * l - {Object} An object that may have a layersContext array property.
     * 
     */
    setNestingPath : function(l){
        if(l.layersContext){
            for (var i = 0, len = l.layersContext.length; i < len; i++) {
                var layerContext = l.layersContext[i];
                var nPath = [];
                var nTitle = l.title || "";
                if(l.metadata && l.metadata.nestingPath){
                    nPath = l.metadata.nestingPath.slice();
                }
                if (nTitle != "") {
                    nPath.push(nTitle);
                }
                layerContext.metadata.nestingPath = nPath;
                if(layerContext.layersContext){
                    this.setNestingPath(layerContext);
                }
            }
        }
    },

    /**
     * Function: decomposeNestingPath
     * Takes a nestingPath like "a/b/c" and decomposes it into subpaths:
     * "a", "a/b", "a/b/c"
     *
     * Parameters:
     * nPath  - {Array} the nesting path
     *
     * Returns:
     * Array({String}) Array with subpaths, or empty array if there is nothing
     *     to decompose
     */
    decomposeNestingPath: function(nPath){
        var a = [];
        if (HGIS.Util.isArray(nPath)) {
            var path = nPath.slice();
            while (path.length > 0) {
                a.push(path.slice());
                path.pop();
            }
            a.reverse();
        }
        return a;
    },

    /**
     * APIMethod: read
     * Read OWS context data from a string or DOMElement, and return a list 
     *     of layers. 
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} The context object with a flat layer list as a property named
     *     layersContext.
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var context = {};
        this.readNode(data, context);
        // since an OWSContext can be nested we need to go through this
        // structure recursively      
        this.setNestingPath({layersContext : context.layersContext});
        // after nesting path has been set, create a flat list of layers
        var layers = [];
        this.processLayer(layers, context);
        delete context.layersContext;
        context.layersContext = layers;
        return context;
    },

    /**
     * Method: processLayer
     * Recursive function to get back a flat list of layers from the hierarchic
     *     layer structure.
     *
     * Parameters:
     * layerArray - {Array({Object})} Array of layerContext objects
     * layer - {Object} layerContext object
     */
    processLayer: function(layerArray, layer) {
        if (layer.layersContext) {
            for (var i=0, len = layer.layersContext.length; i<len; i++) {
                var l = layer.layersContext[i];
                layerArray.push(l);
                if (l.layersContext) {
                    this.processLayer(layerArray, l);
                }
            }
        }
    },

    /**
     * APIMethod: write
     *
     * Parameters:
     * context - {Object} An object representing the map context.
     * options - {Object} Optional object.
     *
     * Returns:
     * {String} An OWS Context document string.
     */
    write: function(context, options) {
        var name = "OWSContext";
        this.nestingLayerLookup = {}; //start with empty lookup
        options = options || {};
        HGIS.Util.applyDefaults(options, context);
        var root = this.writeNode(name, options);
        this.nestingLayerLookup = null; //clear lookup
        this.setAttributeNS(
            root, this.namespaces["xsi"],
            "xsi:schemaLocation", this.schemaLocation
        );
        return HGIS.Format.XML.prototype.write.apply(this, [root]);
    }, 

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "kml": {
            "Document": function(node, obj) {
                obj.features = new HGIS.Format.KML(
                    {kmlns: this.namespaces.kml, 
                        extractStyles: true}).read(node);
            }
        },
        "owc": { 
            "OWSContext": function(node, obj) {
                this.readChildNodes(node, obj);
            }, 
            "General": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "ResourceList": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Layer": function(node, obj) {
                var layerContext = {
                    metadata: {},
                    visibility: (node.getAttribute("hidden") != "1"),
                    queryable: (node.getAttribute("queryable") == "1"),
                    opacity: ((node.getAttribute("opacity") != null) ? 
                        parseFloat(node.getAttribute("opacity")) : null),
                    name: node.getAttribute("name"),
                    /* A category layer is a dummy layer meant for creating
                       hierarchies. It is not a physical layer in the 
                       HGIS sense. The assumption we make here is that
                       category layers do not have a name attribute */
                    categoryLayer: (node.getAttribute("name") == null),
                    formats: [],
                    styles: []
                };
                if (!obj.layersContext) {
                    obj.layersContext = [];
                }
                obj.layersContext.push(layerContext);
                this.readChildNodes(node, layerContext);
            },
            "InlineGeometry": function(node, obj) {
                obj.features = [];
                var elements = this.getElementsByTagNameNS(node, 
                    this.namespaces.gml, "featureMember");
                var el;
                if (elements.length >= 1) {
                    el = elements[0];
                }
                if (el && el.firstChild) {
                    var featurenode = (el.firstChild.nextSibling) ? 
                        el.firstChild.nextSibling : el.firstChild;
                    this.setNamespace("feature", featurenode.namespaceURI);
                    this.featureType = featurenode.localName || 
                        featurenode.nodeName.split(":").pop();
                    this.readChildNodes(node, obj);
                }
            },
            "Server": function(node, obj) {
                // when having multiple Server types, we prefer WMS
                if ((!obj.service && !obj.version) || 
                    (obj.service != 
                        HGIS.Format.Context.serviceTypes.WMS)) {
                            obj.service = node.getAttribute("service");
                            obj.version = node.getAttribute("version");
                            this.readChildNodes(node, obj);
                }
            },
            "Name": function(node, obj) {
                obj.name = this.getChildValue(node);
                this.readChildNodes(node, obj);
            },
            "Title": function(node, obj) {
                obj.title = this.getChildValue(node);
                this.readChildNodes(node, obj);
            },
            "StyleList": function(node, obj) {
                this.readChildNodes(node, obj.styles);
            },
            "Style": function(node, obj) {
                var style = {};
                obj.push(style);
                this.readChildNodes(node, style);
            },
            "LegendURL": function(node, obj) {
                var legend = {};
                obj.legend = legend;
                this.readChildNodes(node, legend);
            },
            "OnlineResource": function(node, obj) {
                obj.url = this.getAttributeNS(node, this.namespaces.xlink, 
                    "href");
                this.readChildNodes(node, obj);
            }
        },
        "ows": HGIS.Format.OWSCommon.v1_0_0.prototype.readers.ows,
        "gml": HGIS.Format.GML.v2.prototype.readers.gml,
        "sld": HGIS.Format.SLD.v1_0_0.prototype.readers.sld,
        "feature": HGIS.Format.GML.v2.prototype.readers.feature
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "owc": {
            "OWSContext": function(options) {
                var node = this.createElementNSPlus("OWSContext", {
                    attributes: {
                        version: this.VERSION,
                        id: options.id || HGIS.Util.createUniqueID("HGIS_OWSContext_")
                    } 
                }); 
                this.writeNode("General", options, node);
                this.writeNode("ResourceList", options, node);
                return node; 
            },
            "General": function(options) {
                var node = this.createElementNSPlus("General");
                this.writeNode("ows:BoundingBox", options, node);
                this.writeNode("ows:Title", options.title || 'HGIS OWSContext', node);
                return node;
            },
            "ResourceList": function(options) {
                var node = this.createElementNSPlus("ResourceList");
                for (var i=0, len=options.layers.length; i<len; i++) {
                    var layer = options.layers[i];
                    var decomposedPath = this.decomposeNestingPath(layer.metadata.nestingPath);
                    this.writeNode("_Layer", {layer: layer, subPaths: decomposedPath}, node);
                }
                return node;
            },
            "Server": function(options) {
                var node = this.createElementNSPlus("Server", {attributes: {
                    version: options.version,
                    service: options.service }
                });
                this.writeNode("OnlineResource", options, node);
                return node;
            },
            "OnlineResource": function(options) {
                var node = this.createElementNSPlus("OnlineResource", {attributes: {
                    "xlink:href": options.url }
                });
                return node;
            },
            "InlineGeometry": function(layer) {
                var node = this.createElementNSPlus("InlineGeometry"),
                    dataExtent = layer.getDataExtent();
                if (dataExtent !== null) {
                    this.writeNode("gml:boundedBy", dataExtent, node);
                }
                for (var i=0, len=layer.features.length; i<len; i++) {
                    this.writeNode("gml:featureMember", layer.features[i], node);
                }
                return node;
            },
            "StyleList": function(styles) {
                var node = this.createElementNSPlus("StyleList");
                for (var i=0, len=styles.length; i<len; i++) {
                    this.writeNode("Style", styles[i], node);
                }
                return node;
            },
            "Style": function(style) {
                var node = this.createElementNSPlus("Style");
                this.writeNode("Name", style, node);
                this.writeNode("Title", style, node);
                if (style.legend) {
                    this.writeNode("LegendURL", style, node);
                }
                return node;
            },
            "Name": function(obj) {
                var node = this.createElementNSPlus("Name", {
                    value: obj.name });
                return node;
            },
            "Title": function(obj) {
                var node = this.createElementNSPlus("Title", {
                    value: obj.title });
                return node;
            },
            "LegendURL": function(style) {
                var node = this.createElementNSPlus("LegendURL");
                this.writeNode("OnlineResource", style.legend, node);
                return node;
            },
            "_WMS": function(layer) {
                var node = this.createElementNSPlus("Layer", {attributes: {
                    name: layer.params.LAYERS,
                    queryable: layer.queryable ? "1" : "0",
                    hidden: layer.visibility ? "0" : "1",
                    opacity: layer.hasOwnProperty("opacity") ? layer.opacity : null}
                });
                this.writeNode("ows:Title", layer.name, node);
                this.writeNode("ows:OutputFormat", layer.params.FORMAT, node);
                this.writeNode("Server", {service: 
                    HGIS.Format.Context.serviceTypes.WMS,
                    version: layer.params.VERSION, url: layer.url}, node);
                if (layer.metadata.styles && layer.metadata.styles.length > 0) {
                    this.writeNode("StyleList", layer.metadata.styles, node);
                }
                return node;
            },
            "_Layer": function(options) {
                var layer, subPaths, node, title;
                layer = options.layer;
                subPaths = options.subPaths;
                node = null;
                title = null;
                // subPaths is an array of an array
                // recursively calling _Layer writer eats up subPaths, until a 
                // real writer is called and nodes are returned.
                if(subPaths.length > 0){
                    var path = subPaths[0].join("/");
                    var index = path.lastIndexOf("/");
                    node = this.nestingLayerLookup[path];
                    title = (index > 0)?path.substring(index + 1, path.length):path;
                    if(!node){
                        // category layer
                        node = this.createElementNSPlus("Layer");
                        this.writeNode("ows:Title", title, node);
                        this.nestingLayerLookup[path] = node;
                    }
                    options.subPaths.shift();//remove a path after each call
                    this.writeNode("_Layer", options, node);
                    return node;
                } else {
                    // write out the actual layer
                    if (layer instanceof HGIS.Layer.WMS) {
                        node = this.writeNode("_WMS", layer);
                    } else if (layer instanceof HGIS.Layer.Vector) {
                        if (layer.protocol instanceof HGIS.Protocol.WFS.v1) {
                            node = this.writeNode("_WFS", layer);
                        } else if (layer.protocol instanceof HGIS.Protocol.HTTP) {
                            if (layer.protocol.format instanceof HGIS.Format.GML) {
                                layer.protocol.format.version = "2.1.2";
                                node = this.writeNode("_GML", layer);
                            } else if (layer.protocol.format instanceof HGIS.Format.KML) {
                                layer.protocol.format.version = "2.2";
                                node = this.writeNode("_KML", layer);
                            }
                        } else {
                            // write out as inline GML since we have no idea
                            // about the original Format
                            this.setNamespace("feature", this.featureNS);
                            node = this.writeNode("_InlineGeometry", layer);
                        }
                    }
                    if (layer.options.maxScale) {
                        this.writeNode("sld:MinScaleDenominator", 
                            layer.options.maxScale, node);
                    }
                    if (layer.options.minScale) {
                        this.writeNode("sld:MaxScaleDenominator", 
                            layer.options.minScale, node);
                    }
                    this.nestingLayerLookup[layer.name] = node;
                    return node;
                }
            },
            "_WFS": function(layer) {
                var node = this.createElementNSPlus("Layer", {attributes: {
                    name: layer.protocol.featurePrefix + ":" + layer.protocol.featureType,
                    hidden: layer.visibility ? "0" : "1" }
                });
                this.writeNode("ows:Title", layer.name, node);
                this.writeNode("Server", {service: 
                    HGIS.Format.Context.serviceTypes.WFS, 
                    version: layer.protocol.version, 
                    url: layer.protocol.url}, node);
                return node;
            },
            "_InlineGeometry": function(layer) {
                var node = this.createElementNSPlus("Layer", {attributes: {
                    name: this.featureType,
                    hidden: layer.visibility ? "0" : "1" }
                });
                this.writeNode("ows:Title", layer.name, node);
                this.writeNode("InlineGeometry", layer, node);
                return node;
            },
            "_GML": function(layer) {
                var node = this.createElementNSPlus("Layer");
                this.writeNode("ows:Title", layer.name, node);
                this.writeNode("Server", {service: 
                    HGIS.Format.Context.serviceTypes.GML, 
                    url: layer.protocol.url, version: 
                    layer.protocol.format.version}, node);
                return node;
            },
            "_KML": function(layer) {
                var node = this.createElementNSPlus("Layer");
                this.writeNode("ows:Title", layer.name, node);
                this.writeNode("Server", {service: 
                    HGIS.Format.Context.serviceTypes.KML,
                    version: layer.protocol.format.version, url: 
                    layer.protocol.url}, node);
                return node;
            }
        },
        "gml": HGIS.Util.applyDefaults({
            "boundedBy": function(bounds) {
                var node = this.createElementNSPlus("gml:boundedBy");
                this.writeNode("gml:Box", bounds, node);
                return node;
            }
        }, HGIS.Format.GML.v2.prototype.writers.gml),
        "ows": HGIS.Format.OWSCommon.v1_0_0.prototype.writers.ows,
        "sld": HGIS.Format.SLD.v1_0_0.prototype.writers.sld,
        "feature": HGIS.Format.GML.v2.prototype.writers.feature
    },
    
    CLASS_NAME: "HGIS.Format.OWSContext.v0_3_1" 

});
/* ======================================================================
    HGIS/Popup.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 */


/**
 * Class: HGIS.Popup
 * A popup is a small div that can opened and closed on the map.
 * Typically opened in response to clicking on a marker.  
 * See <HGIS.Marker>.  Popup's don't require their own
 * layer and are added the the map using the <HGIS.Map.addPopup>
 * method.
 *
 * Example:
 * (code)
 * popup = new HGIS.Popup("chicken", 
 *                    new HGIS.LonLat(5,40),
 *                    new HGIS.Size(200,200),
 *                    "example popup",
 *                    true);
 *       
 * map.addPopup(popup);
 * (end)
 */
HGIS.Popup = HGIS.Class({

    /** 
     * Property: events  
     * {<HGIS.Events>} custom event manager 
     */
    events: null,
    
    /** Property: id
     * {String} the unique identifier assigned to this popup.
     */
    id: "",

    /** 
     * Property: lonlat 
     * {<HGIS.LonLat>} the position of this popup on the map
     */
    lonlat: null,

    /** 
     * Property: div 
     * {DOMElement} the div that contains this popup.
     */
    div: null,

    /** 
     * Property: contentSize 
     * {<HGIS.Size>} the width and height of the content.
     */
    contentSize: null,    

    /** 
     * Property: size 
     * {<HGIS.Size>} the width and height of the popup.
     */
    size: null,    

    /** 
     * Property: contentHTML 
     * {String} An HTML string for this popup to display.
     */
    contentHTML: null,
    
    /** 
     * Property: backgroundColor 
     * {String} the background color used by the popup.
     */
    backgroundColor: "",
    
    /** 
     * Property: opacity 
     * {float} the opacity of this popup (between 0.0 and 1.0)
     */
    opacity: "",

    /** 
     * Property: border 
     * {String} the border size of the popup.  (eg 2px)
     */
    border: "",
    
    /** 
     * Property: contentDiv 
     * {DOMElement} a reference to the element that holds the content of
     *              the div.
     */
    contentDiv: null,
    
    /** 
     * Property: groupDiv 
     * {DOMElement} First and only child of 'div'. The group Div contains the
     *     'contentDiv' and the 'closeDiv'.
     */
    groupDiv: null,

    /** 
     * Property: closeDiv
     * {DOMElement} the optional closer image
     */
    closeDiv: null,

    /** 
     * APIProperty: autoSize
     * {Boolean} Resize the popup to auto-fit the contents.
     *     Default is false.
     */
    autoSize: false,

    /**
     * APIProperty: minSize
     * {<HGIS.Size>} Minimum size allowed for the popup's contents.
     */
    minSize: null,

    /**
     * APIProperty: maxSize
     * {<HGIS.Size>} Maximum size allowed for the popup's contents.
     */
    maxSize: null,

    /** 
     * Property: displayClass
     * {String} The CSS class of the popup.
     */
    displayClass: "olPopup",

    /** 
     * Property: contentDisplayClass
     * {String} The CSS class of the popup content div.
     */
    contentDisplayClass: "olPopupContent",

    /** 
     * Property: padding 
     * {int or <HGIS.Bounds>} An extra opportunity to specify internal 
     *     padding of the content div inside the popup. This was originally
     *     confused with the css padding as specified in style.css's 
     *     'olPopupContent' class. We would like to get rid of this altogether,
     *     except that it does come in handy for the framed and anchoredbubble
     *     popups, who need to maintain yet another barrier between their 
     *     content and the outer border of the popup itself. 
     * 
     *     Note that in order to not break API, we must continue to support 
     *     this property being set as an integer. Really, though, we'd like to 
     *     have this specified as a Bounds object so that user can specify
     *     distinct left, top, right, bottom paddings. With the 3.0 release
     *     we can make this only a bounds.
     */
    padding: 0,

    /** 
     * Property: disableFirefoxOverflowHack
     * {Boolean} The hack for overflow in Firefox causes all elements 
     *     to be re-drawn, which causes Flash elements to be 
     *     re-initialized, which is troublesome.
     *     With this property the hack can be disabled.
     */
    disableFirefoxOverflowHack: false,

    /**
     * Method: fixPadding
     * To be removed in 3.0, this function merely helps us to deal with the 
     *     case where the user may have set an integer value for padding, 
     *     instead of an <HGIS.Bounds> object.
     */
    fixPadding: function() {
        if (typeof this.padding == "number") {
            this.padding = new HGIS.Bounds(
                this.padding, this.padding, this.padding, this.padding
            );
        }
    },

    /**
     * APIProperty: panMapIfOutOfView
     * {Boolean} When drawn, pan map such that the entire popup is visible in
     *     the current viewport (if necessary).
     *     Default is false.
     */
    panMapIfOutOfView: false,
    
    /**
     * APIProperty: keepInMap 
     * {Boolean} If panMapIfOutOfView is false, and this property is true, 
     *     contrain the popup such that it always fits in the available map
     *     space. By default, this is not set on the base class. If you are
     *     creating popups that are near map edges and not allowing pannning,
     *     and especially if you have a popup which has a
     *     fixedRelativePosition, setting this to false may be a smart thing to
     *     do. Subclasses may want to override this setting.
     *   
     *     Default is false.
     */
    keepInMap: false,

    /**
     * APIProperty: closeOnMove
     * {Boolean} When map pans, close the popup.
     *     Default is false.
     */
    closeOnMove: false,
    
    /** 
     * Property: map 
     * {<HGIS.Map>} this gets set in Map.js when the popup is added to the map
     */
    map: null,

    /** 
    * Constructor: HGIS.Popup
    * Create a popup.
    * 
    * Parameters: 
    * id - {String} a unqiue identifier for this popup.  If null is passed
    *               an identifier will be automatically generated. 
    * lonlat - {<HGIS.LonLat>}  The position on the map the popup will
    *                                 be shown.
    * contentSize - {<HGIS.Size>} The size of the content.
    * contentHTML - {String}          An HTML string to display inside the   
    *                                 popup.
    * closeBox - {Boolean}            Whether to display a close box inside
    *                                 the popup.
    * closeBoxCallback - {Function}   Function to be called on closeBox click.
    */
    initialize:function(id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback) {
        if (id == null) {
            id = HGIS.Util.createUniqueID(this.CLASS_NAME + "_");
        }

        this.id = id;
        this.lonlat = lonlat;

        this.contentSize = (contentSize != null) ? contentSize 
                                  : new HGIS.Size(
                                                   HGIS.Popup.WIDTH,
                                                   HGIS.Popup.HEIGHT);
        if (contentHTML != null) { 
        	if(contentHTML != undefined ){
                this.contentHTML = contentHTML;
        	}else{
        		this.contentHTML = "";
        	}
        }
        this.backgroundColor = HGIS.Popup.COLOR;
        this.opacity = HGIS.Popup.OPACITY;
        this.border = HGIS.Popup.BORDER;

        this.div = HGIS.Util.createDiv(this.id, null, null, 
                                             null, null, null, "hidden");
        this.div.className = this.displayClass;
        
        var groupDivId = this.id + "_GroupDiv";
        this.groupDiv = HGIS.Util.createDiv(groupDivId, null, null, 
                                                    null, "relative", null,
                                                    "hidden");

        var id = this.div.id + "_contentDiv";
        this.contentDiv = HGIS.Util.createDiv(id, null, this.contentSize.clone(), 
                                                    null, "relative");
        this.contentDiv.className = this.contentDisplayClass;
        this.groupDiv.appendChild(this.contentDiv);
        this.div.appendChild(this.groupDiv);

        if (closeBox) {
            this.addCloseBox(closeBoxCallback);
        } 

        this.registerEvents();
    },

    /** 
     * Method: destroy
     * nullify references to prevent circular references and memory leaks
     */
    destroy: function() {

        this.id = null;
        this.lonlat = null;
        this.size = null;
        this.contentHTML = null;
        
        this.backgroundColor = null;
        this.opacity = null;
        this.border = null;
        
        if (this.closeOnMove && this.map) {
            this.map.events.unregister("movestart", this, this.hide);
        }

        this.events.destroy();
        this.events = null;
        
        if (this.closeDiv) {
            HGIS.Event.stopObservingElement(this.closeDiv); 
            this.groupDiv.removeChild(this.closeDiv);
        }
        this.closeDiv = null;
        
        this.div.removeChild(this.groupDiv);
        this.groupDiv = null;

        if (this.map != null) {
            this.map.removePopup(this);
        }
        this.map = null;
        this.div = null;
        
        this.autoSize = null;
        this.minSize = null;
        this.maxSize = null;
        this.padding = null;
        this.panMapIfOutOfView = null;
    },

    /** 
    * Method: draw
    * Constructs the elements that make up the popup.
    *
    * Parameters:
    * px - {<HGIS.Pixel>} the position the popup in pixels.
    * 
    * Returns:
    * {DOMElement} Reference to a div that contains the drawn popup
    */
    draw: function(px) {
        if (px == null) {
            if ((this.lonlat != null) && (this.map != null)) {
                px = this.map.getLayerPxFromLonLat(this.lonlat);
            }
        }

        // this assumes that this.map already exists, which is okay because 
        // this.draw is only called once the popup has been added to the map.
        if (this.closeOnMove) {
            this.map.events.register("movestart", this, this.hide);
        }
        
        //listen to movestart, moveend to disable overflow (FF bug)
        if (!this.disableFirefoxOverflowHack && HGIS.BROWSER_NAME == 'firefox') {
            this.map.events.register("movestart", this, function() {
                var style = document.defaultView.getComputedStyle(
                    this.contentDiv, null
                );
                var currentOverflow = style.getPropertyValue("overflow");
                if (currentOverflow != "hidden") {
                    this.contentDiv._oldOverflow = currentOverflow;
                    this.contentDiv.style.overflow = "hidden";
                }
            });
            this.map.events.register("moveend", this, function() {
                var oldOverflow = this.contentDiv._oldOverflow;
                if (oldOverflow) {
                    this.contentDiv.style.overflow = oldOverflow;
                    this.contentDiv._oldOverflow = null;
                }
            });
        }

        this.moveTo(px);
        if (!this.autoSize && !this.size) {
            this.setSize(this.contentSize);
        }
        this.setBackgroundColor();
        this.setOpacity();
        this.setBorder();
        this.setContentHTML();
        
        if (this.panMapIfOutOfView) {
            this.panIntoView();
        }    

        return this.div;
    },

    /** 
     * Method: updatePosition
     * if the popup has a lonlat and its map members set, 
     * then have it move itself to its proper position
     */
    updatePosition: function() {
        if ((this.lonlat) && (this.map)) {
            var px = this.map.getLayerPxFromLonLat(this.lonlat);
            if (px) {
                this.moveTo(px);           
            }    
        }
    },

    /**
     * Method: moveTo
     * 
     * Parameters:
     * px - {<HGIS.Pixel>} the top and left position of the popup div. 
     */
    moveTo: function(px) {
        if ((px != null) && (this.div != null)) {
            this.div.style.left = px.x + "px";
            this.div.style.top = px.y + "px";
        }
    },

    /**
     * Method: visible
     *
     * Returns:      
     * {Boolean} Boolean indicating whether or not the popup is visible
     */
    visible: function() {
        return HGIS.Element.visible(this.div);
    },

    /**
     * Method: toggle
     * Toggles visibility of the popup.
     */
    toggle: function() {
        if (this.visible()) {
            this.hide();
        } else {
            this.show();
        }
    },

    /**
     * Method: show
     * Makes the popup visible.
     */
    show: function() {
        this.div.style.display = '';

        if (this.panMapIfOutOfView) {
            this.panIntoView();
        }    
    },

    /**
     * Method: hide
     * Makes the popup invisible.
     */
    hide: function() {
        this.div.style.display = 'none';
    },

    /**
     * Method: setSize
     * Used to adjust the size of the popup. 
     *
     * Parameters:
     * contentSize - {<HGIS.Size>} the new size for the popup's 
     *     contents div (in pixels).
     */
    setSize:function(contentSize) { 
        this.size = contentSize.clone(); 
        
        // if our contentDiv has a css 'padding' set on it by a stylesheet, we 
        //  must add that to the desired "size". 
        var contentDivPadding = this.getContentDivPadding();
        var wPadding = contentDivPadding.left + contentDivPadding.right;
        var hPadding = contentDivPadding.top + contentDivPadding.bottom;

        // take into account the popup's 'padding' property
        this.fixPadding();
        wPadding += this.padding.left + this.padding.right;
        hPadding += this.padding.top + this.padding.bottom;

        // make extra space for the close div
        if (this.closeDiv) {
            var closeDivWidth = parseInt(this.closeDiv.style.width);
            wPadding += closeDivWidth + contentDivPadding.right;
        }

        //increase size of the main popup div to take into account the 
        // users's desired padding and close div.        
        this.size.w += wPadding;
        this.size.h += hPadding;

        //now if our browser is IE, we need to actually make the contents 
        // div itself bigger to take its own padding into effect. this makes 
        // me want to shoot someone, but so it goes.
        if (HGIS.BROWSER_NAME == "msie") {
            this.contentSize.w += 
                contentDivPadding.left + contentDivPadding.right;
            this.contentSize.h += 
                contentDivPadding.bottom + contentDivPadding.top;
        }

        if (this.div != null) {
            this.div.style.width = this.size.w + "px";
            this.div.style.height = this.size.h + "px";
        }
        if (this.contentDiv != null){
            this.contentDiv.style.width = contentSize.w + "px";
            this.contentDiv.style.height = contentSize.h + "px";
        }
    },  

    /**
     * APIMethod: updateSize
     * Auto size the popup so that it precisely fits its contents (as 
     *     determined by this.contentDiv.innerHTML). Popup size will, of
     *     course, be limited by the available space on the current map
     */
    updateSize: function() {
        
        // determine actual render dimensions of the contents by putting its
        // contents into a fake contentDiv (for the CSS) and then measuring it
        var preparedHTML = "<div class='" + this.contentDisplayClass+ "'>" + 
            this.contentDiv.innerHTML + 
            "</div>";
 
        var containerElement = (this.map) ? this.map.div : document.body;
        var realSize = HGIS.Util.getRenderedDimensions(
            preparedHTML, null, {
                displayClass: this.displayClass,
                containerElement: containerElement
            }
        );

        // is the "real" size of the div is safe to display in our map?
        var safeSize = this.getSafeContentSize(realSize);

        var newSize = null;
        if (safeSize.equals(realSize)) {
            //real size of content is small enough to fit on the map, 
            // so we use real size.
            newSize = realSize;

        } else {

            // make a new 'size' object with the clipped dimensions 
            // set or null if not clipped.
            var fixedSize = {
                w: (safeSize.w < realSize.w) ? safeSize.w : null,
                h: (safeSize.h < realSize.h) ? safeSize.h : null
            };
        
            if (fixedSize.w && fixedSize.h) {
                //content is too big in both directions, so we will use 
                // max popup size (safeSize), knowing well that it will 
                // overflow both ways.                
                newSize = safeSize;
            } else {
                //content is clipped in only one direction, so we need to 
                // run getRenderedDimensions() again with a fixed dimension
                var clippedSize = HGIS.Util.getRenderedDimensions(
                    preparedHTML, fixedSize, {
                        displayClass: this.contentDisplayClass,
                        containerElement: containerElement
                    }
                );
                
                //if the clipped size is still the same as the safeSize, 
                // that means that our content must be fixed in the 
                // offending direction. If overflow is 'auto', this means 
                // we are going to have a scrollbar for sure, so we must 
                // adjust for that.
                //
                var currentOverflow = HGIS.Element.getStyle(
                    this.contentDiv, "overflow"
                );
                if ( (currentOverflow != "hidden") && 
                     (clippedSize.equals(safeSize)) ) {
                    var scrollBar = HGIS.Util.getScrollbarWidth();
                    if (fixedSize.w) {
                        clippedSize.h += scrollBar;
                    } else {
                        clippedSize.w += scrollBar;
                    }
                }
                
                newSize = this.getSafeContentSize(clippedSize);
            }
        }                        
        this.setSize(newSize);     
    },    

    /**
     * Method: setBackgroundColor
     * Sets the background color of the popup.
     *
     * Parameters:
     * color - {String} the background color.  eg "#FFBBBB"
     */
    setBackgroundColor:function(color) { 
        if (color != undefined) {
            this.backgroundColor = color; 
        }
        
        if (this.div != null) {
            this.div.style.backgroundColor = this.backgroundColor;
        }
    },  
    
    /**
     * Method: setOpacity
     * Sets the opacity of the popup.
     * 
     * Parameters:
     * opacity - {float} A value between 0.0 (transparent) and 1.0 (solid).   
     */
    setOpacity:function(opacity) { 
        if (opacity != undefined) {
            this.opacity = opacity; 
        }
        
        if (this.div != null) {
            // for Mozilla and Safari
            this.div.style.opacity = this.opacity;

            // for IE
            this.div.style.filter = 'alpha(opacity=' + this.opacity*100 + ')';
        }
    },  
    
    /**
     * Method: setBorder
     * Sets the border style of the popup.
     *
     * Parameters:
     * border - {String} The border style value. eg 2px 
     */
    setBorder:function(border) { 
        if (border != undefined) {
            this.border = border;
        }
        
        if (this.div != null) {
            this.div.style.border = this.border;
        }
    },      
    
    /**
     * Method: setContentHTML
     * Allows the user to set the HTML content of the popup.
     *
     * Parameters:
     * contentHTML - {String} HTML for the div.
     */
    setContentHTML:function(contentHTML) {

        if (contentHTML != null) {
            this.contentHTML = contentHTML;
        }
       
        if ((this.contentDiv != null) && 
            (this.contentHTML != null) &&
            (this.contentHTML != this.contentDiv.innerHTML)) {
       
            this.contentDiv.innerHTML = this.contentHTML;
       
            if (this.autoSize) {
                
                //if popup has images, listen for when they finish
                // loading and resize accordingly
                this.registerImageListeners();

                //auto size the popup to its current contents
                this.updateSize();
            }
        }    

    },
    
    /**
     * Method: registerImageListeners
     * Called when an image contained by the popup loaded. this function
     *     updates the popup size, then unregisters the image load listener.
     */   
    registerImageListeners: function() { 

        // As the images load, this function will call updateSize() to 
        // resize the popup to fit the content div (which presumably is now
        // bigger than when the image was not loaded).
        // 
        // If the 'panMapIfOutOfView' property is set, we will pan the newly
        // resized popup back into view.
        // 
        // Note that this function, when called, will have 'popup' and 
        // 'img' properties in the context.
        //
        var onImgLoad = function() {
            if (this.popup.id === null) { // this.popup has been destroyed!
                return;
            }
            this.popup.updateSize();
     
            if ( this.popup.visible() && this.popup.panMapIfOutOfView ) {
                this.popup.panIntoView();
            }

            HGIS.Event.stopObserving(
                this.img, "load", this.img._onImgLoad
            );
    
        };

        //cycle through the images and if their size is 0x0, that means that 
        // they haven't been loaded yet, so we attach the listener, which 
        // will fire when the images finish loading and will resize the 
        // popup accordingly to its new size.
        var images = this.contentDiv.getElementsByTagName("img");
        for (var i = 0, len = images.length; i < len; i++) {
            var img = images[i];
            if (img.width == 0 || img.height == 0) {

                var context = {
                    'popup': this,
                    'img': img
                };

                //expando this function to the image itself before registering
                // it. This way we can easily and properly unregister it.
                img._onImgLoad = HGIS.Function.bind(onImgLoad, context);

                HGIS.Event.observe(img, 'load', img._onImgLoad);
            }    
        } 
    },

    /**
     * APIMethod: getSafeContentSize
     * 
     * Parameters:
     * size - {<HGIS.Size>} Desired size to make the popup.
     * 
     * Returns:
     * {<HGIS.Size>} A size to make the popup which is neither smaller
     *     than the specified minimum size, nor bigger than the maximum 
     *     size (which is calculated relative to the size of the viewport).
     */
    getSafeContentSize: function(size) {

        var safeContentSize = size.clone();

        // if our contentDiv has a css 'padding' set on it by a stylesheet, we 
        //  must add that to the desired "size". 
        var contentDivPadding = this.getContentDivPadding();
        var wPadding = contentDivPadding.left + contentDivPadding.right;
        var hPadding = contentDivPadding.top + contentDivPadding.bottom;

        // take into account the popup's 'padding' property
        this.fixPadding();
        wPadding += this.padding.left + this.padding.right;
        hPadding += this.padding.top + this.padding.bottom;

        if (this.closeDiv) {
            var closeDivWidth = parseInt(this.closeDiv.style.width);
            wPadding += closeDivWidth + contentDivPadding.right;
        }

        // prevent the popup from being smaller than a specified minimal size
        if (this.minSize) {
            safeContentSize.w = Math.max(safeContentSize.w, 
                (this.minSize.w - wPadding));
            safeContentSize.h = Math.max(safeContentSize.h, 
                (this.minSize.h - hPadding));
        }

        // prevent the popup from being bigger than a specified maximum size
        if (this.maxSize) {
            safeContentSize.w = Math.min(safeContentSize.w, 
                (this.maxSize.w - wPadding));
            safeContentSize.h = Math.min(safeContentSize.h, 
                (this.maxSize.h - hPadding));
        }
        
        //make sure the desired size to set doesn't result in a popup that 
        // is bigger than the map's viewport.
        //
        if (this.map && this.map.size) {
            
            var extraX = 0, extraY = 0;
            if (this.keepInMap && !this.panMapIfOutOfView) {
                var px = this.map.getPixelFromLonLat(this.lonlat);
                switch (this.relativePosition) {
                    case "tr":
                        extraX = px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                    case "tl":
                        extraX = this.map.size.w - px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                    case "bl":
                        extraX = this.map.size.w - px.x;
                        extraY = px.y;
                        break;
                    case "br":
                        extraX = px.x;
                        extraY = px.y;
                        break;
                    default:    
                        extraX = px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                }
            }    
          
            var maxY = this.map.size.h - 
                this.map.paddingForPopups.top - 
                this.map.paddingForPopups.bottom - 
                hPadding - extraY;
            
            var maxX = this.map.size.w - 
                this.map.paddingForPopups.left - 
                this.map.paddingForPopups.right - 
                wPadding - extraX;
            
            safeContentSize.w = Math.min(safeContentSize.w, maxX);
            safeContentSize.h = Math.min(safeContentSize.h, maxY);
        }
        
        return safeContentSize;
    },
    
    /**
     * Method: getContentDivPadding
     * Glorious, oh glorious hack in order to determine the css 'padding' of 
     *     the contentDiv. IE/Opera return null here unless we actually add the 
     *     popup's main 'div' element (which contains contentDiv) to the DOM. 
     *     So we make it invisible and then add it to the document temporarily. 
     *
     *     Once we've taken the padding readings we need, we then remove it 
     *     from the DOM (it will actually get added to the DOM in 
     *     Map.js's addPopup)
     *
     * Returns:
     * {<HGIS.Bounds>}
     */
    getContentDivPadding: function() {

        //use cached value if we have it
        var contentDivPadding = this._contentDivPadding;
        if (!contentDivPadding) {

            if (this.div.parentNode == null) {
                //make the div invisible and add it to the page        
                this.div.style.display = "none";
                document.body.appendChild(this.div);
            }
                    
            //read the padding settings from css, put them in an OL.Bounds        
            contentDivPadding = new HGIS.Bounds(
                HGIS.Element.getStyle(this.contentDiv, "padding-left"),
                HGIS.Element.getStyle(this.contentDiv, "padding-bottom"),
                HGIS.Element.getStyle(this.contentDiv, "padding-right"),
                HGIS.Element.getStyle(this.contentDiv, "padding-top")
            );
    
            //cache the value
            this._contentDivPadding = contentDivPadding;

            if (this.div.parentNode == document.body) {
                //remove the div from the page and make it visible again
                document.body.removeChild(this.div);
                this.div.style.display = "";
            }
        }
        return contentDivPadding;
    },

    /**
     * Method: addCloseBox
     * 
     * Parameters:
     * callback - {Function} The callback to be called when the close button
     *     is clicked.
     */
    addCloseBox: function(callback) {

        this.closeDiv = HGIS.Util.createDiv(
            this.id + "_close", null, {w: 17, h: 17}
        );
        this.closeDiv.className = "olPopupCloseBox"; 
        
        // use the content div's css padding to determine if we should
        //  padd the close div
        var contentDivPadding = this.getContentDivPadding();
         
        this.closeDiv.style.right = contentDivPadding.right + "px";
        this.closeDiv.style.top = contentDivPadding.top + "px";
        this.groupDiv.appendChild(this.closeDiv);

        var closePopup=function(e) {
            this.hide();
            HGIS.Event.stop(e);
        };
        if(callback){
        	 var me=this;
    		 closePopup= function(e) {
    			 me.hide();
                 HGIS.Event.stop(e);
                 callback();
             };
        }
        HGIS.Event.observe(this.closeDiv, "touchend", 
                HGIS.Function.bindAsEventListener(closePopup, this));
        HGIS.Event.observe(this.closeDiv, "click", 
                HGIS.Function.bindAsEventListener(closePopup, this));
    },

    /**
     * Method: panIntoView
     * Pans the map such that the popup is totaly viewable (if necessary)
     */
    panIntoView: function() {
    	var arr = this.calculateOffset();
        this.map.pan(arr[0], arr[1]);
    },
    /**
     * Method: calculateOffset
     *  参考以上的panIntoView 的方法，计算地图应该平移的值，取其值 进行计算
     */
    calculateOffset: function() {
        
        var mapSize = this.map.getSize();
    
        //start with the top left corner of the popup, in px, 
        // relative to the viewport
        var origTL = this.map.getViewPortPxFromLayerPx( new HGIS.Pixel(
            parseInt(this.div.style.left),
            parseInt(this.div.style.top)
        ));
        var newTL = origTL.clone();
    
        //new left (compare to margins, using this.size to calculate right)
        if (origTL.x < this.map.paddingForPopups.left) {
            newTL.x = this.map.paddingForPopups.left;
        } else 
        if ( (origTL.x + this.size.w) > (mapSize.w - this.map.paddingForPopups.right)) {
            newTL.x = mapSize.w - this.map.paddingForPopups.right - this.size.w;
        }
        
        //new top (compare to margins, using this.size to calculate bottom)
        if (origTL.y < this.map.paddingForPopups.top) {
            newTL.y = this.map.paddingForPopups.top;
        } else 
        if ( (origTL.y + this.size.h) > (mapSize.h - this.map.paddingForPopups.bottom)) {
            newTL.y = mapSize.h - this.map.paddingForPopups.bottom - this.size.h;
        }
        
        var dx = origTL.x - newTL.x;
        var dy = origTL.y - newTL.y
        var arr=new Array(dx,dy)
        return arr;
    },

    /** 
     * Method: registerEvents
     * Registers events on the popup.
     *
     * Do this in a separate function so that subclasses can 
     *   choose to override it if they wish to deal differently
     *   with mouse events
     * 
     *   Note in the following handler functions that some special
     *    care is needed to deal correctly with mousing and popups. 
     *   
     *   Because the user might select the zoom-rectangle option and
     *    then drag it over a popup, we need a safe way to allow the
     *    mousemove and mouseup events to pass through the popup when
     *    they are initiated from outside. The same procedure is needed for
     *    touchmove and touchend events.
     * 
     *   Otherwise, we want to essentially kill the event propagation
     *    for all other events, though we have to do so carefully, 
     *    without disabling basic html functionality, like clicking on 
     *    hyperlinks or drag-selecting text.
     */
     registerEvents:function() {
        this.events = new HGIS.Events(this, this.div, null, true);

        function onTouchstart(evt) {
            HGIS.Event.stop(evt, true);
        }
        this.events.on({
            "mousedown": this.onmousedown,
            "mousemove": this.onmousemove,
            "mouseup": this.onmouseup,
            "click": this.onclick,
            "mouseout": this.onmouseout,
            "dblclick": this.ondblclick,
            "touchstart": onTouchstart,
            scope: this
        });
        
     },

    /** 
     * Method: onmousedown 
     * When mouse goes down within the popup, make a note of
     *   it locally, and then do not propagate the mousedown 
     *   (but do so safely so that user can select text inside)
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmousedown: function (evt) {
        this.mousedown = true;
        HGIS.Event.stop(evt, true);
    },

    /** 
     * Method: onmousemove
     * If the drag was started within the popup, then 
     *   do not propagate the mousemove (but do so safely
     *   so that user can select text inside)
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmousemove: function (evt) {
        if (this.mousedown) {
            HGIS.Event.stop(evt, true);
        }
    },

    /** 
     * Method: onmouseup
     * When mouse comes up within the popup, after going down 
     *   in it, reset the flag, and then (once again) do not 
     *   propagate the event, but do so safely so that user can 
     *   select text inside
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmouseup: function (evt) {
        if (this.mousedown) {
            this.mousedown = false;
            HGIS.Event.stop(evt, true);
        }
    },

    /**
     * Method: onclick
     * Ignore clicks, but allowing default browser handling
     * 
     * Parameters:
     * evt - {Event} 
     */
    onclick: function (evt) {
        HGIS.Event.stop(evt, true);
    },

    /** 
     * Method: onmouseout
     * When mouse goes out of the popup set the flag to false so that
     *   if they let go and then drag back in, we won't be confused.
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmouseout: function (evt) {
        this.mousedown = false;
    },
    
    /** 
     * Method: ondblclick
     * Ignore double-clicks, but allowing default browser handling
     * 
     * Parameters:
     * evt - {Event} 
     */
    ondblclick: function (evt) {
        HGIS.Event.stop(evt, true);
    },

    CLASS_NAME: "HGIS.Popup"
});

HGIS.Popup.WIDTH = 200;
HGIS.Popup.HEIGHT = 200;
HGIS.Popup.COLOR = "white";
HGIS.Popup.OPACITY = 1;
HGIS.Popup.BORDER = "0px";
/* ======================================================================
    HGIS/Control/ScaleLine.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 */

/**
 * Class: HGIS.Control.ScaleLine
 * The ScaleLine displays a small line indicator representing the current 
 * map scale on the map. By default it is drawn in the lower left corner of
 * the map.
 * 
 * Inherits from:
 *  - <HGIS.Control>
 *  
 * Is a very close copy of:
 *  - <HGIS.Control.Scale>
 */
HGIS.Control.ScaleLine = HGIS.Class(HGIS.Control, {

    /**
     * Property: maxWidth
     * {Integer} Maximum width of the scale line in pixels.  Default is 100.
     */
    maxWidth: 100,

    /**
     * Property: topOutUnits
     * {String} Units for zoomed out on top bar.  Default is km.
     */
    topOutUnits: "km",
    
    /**
     * Property: topInUnits
     * {String} Units for zoomed in on top bar.  Default is m.
     */
    topInUnits: "m",

    /**
     * Property: bottomOutUnits
     * {String} Units for zoomed out on bottom bar.  Default is mi.
     */
    bottomOutUnits: "mi",

    /**
     * Property: bottomInUnits
     * {String} Units for zoomed in on bottom bar.  Default is ft.
     */
    bottomInUnits: "ft",
    
    /**
     * Property: eTop
     * {DOMElement}
     */
    eTop: null,

    /**
     * Property: eBottom
     * {DOMElement}
     */
    eBottom:null,
    
    /**
     * APIProperty: geodesic
     * {Boolean} Use geodesic measurement. Default is false. The recommended
     * setting for maps in EPSG:4326 is false, and true EPSG:900913. If set to
     * true, the scale will be calculated based on the horizontal size of the
     * pixel in the center of the map viewport.
     */
    geodesic: false,

    /**
     * Constructor: HGIS.Control.ScaleLine
     * Create a new scale line control.
     * 
     * Parameters:
     * options - {Object} An optional object whose properties will be used
     *     to extend the control.
     */

    /**
     * Method: draw
     * 
     * Returns:
     * {DOMElement}
     */
    draw: function() {
        HGIS.Control.prototype.draw.apply(this, arguments);
        if (!this.eTop) {
            // stick in the top bar
            this.eTop = document.createElement("div");
            this.eTop.className = this.displayClass + "Top";
            var theLen = this.topInUnits.length;
            this.div.appendChild(this.eTop);
            if((this.topOutUnits == "") || (this.topInUnits == "")) {
                this.eTop.style.visibility = "hidden";
            } else {
                this.eTop.style.visibility = "visible";
            }

            // and the bottom bar
            this.eBottom = document.createElement("div");
            this.eBottom.className = this.displayClass + "Bottom";
            this.div.appendChild(this.eBottom);
            if((this.bottomOutUnits == "") || (this.bottomInUnits == "")) {
                this.eBottom.style.visibility = "hidden";
            } else {
                this.eBottom.style.visibility = "visible";
            }
        }
        this.map.events.register('moveend', this, this.update);
        this.update();
        return this.div;
    },

    /** 
     * Method: getBarLen
     * Given a number, round it down to the nearest 1,2,5 times a power of 10.
     * That seems a fairly useful set of number groups to use.
     * 
     * Parameters:
     * maxLen - {float}  the number we're rounding down from
     * 
     * Returns:
     * {Float} the rounded number (less than or equal to maxLen)
     */
    getBarLen: function(maxLen) {
        // nearest power of 10 lower than maxLen
        var digits = parseInt(Math.log(maxLen) / Math.log(10));
        var pow10 = Math.pow(10, digits);
        
        // ok, find first character
        var firstChar = parseInt(maxLen / pow10);

        // right, put it into the correct bracket
        var barLen;
        if(firstChar > 5) {
            barLen = 5;
        } else if(firstChar > 2) {
            barLen = 2;
        } else {
            barLen = 1;
        }

        // scale it up the correct power of 10
        return barLen * pow10;
    },

    /**
     * Method: update
     * Update the size of the bars, and the labels they contain.
     */
    update: function() {
        var res = this.map.getResolution();
        if (!res) {
            return;
        }

        var curMapUnits = this.map.getUnits();
        var inches = HGIS.INCHES_PER_UNIT;

        // convert maxWidth to map units
        var maxSizeData = this.maxWidth * res * inches[curMapUnits];
        var geodesicRatio = 1;
        if(this.geodesic === true) {
            var maxSizeGeodesic = (this.map.getGeodesicPixelSize().w ||
                0.000001) * this.maxWidth;
            var maxSizeKilometers = maxSizeData / inches["km"];
            geodesicRatio = maxSizeGeodesic / maxSizeKilometers;
            maxSizeData *= geodesicRatio;
        }

        // decide whether to use large or small scale units     
        var topUnits;
        var bottomUnits;
        if(maxSizeData > 100000) {
            topUnits = this.topOutUnits;
            bottomUnits = this.bottomOutUnits;
        } else {
            topUnits = this.topInUnits;
            bottomUnits = this.bottomInUnits;
        }

        // and to map units units
        var topMax = maxSizeData / inches[topUnits];
        var bottomMax = maxSizeData / inches[bottomUnits];

        // now trim this down to useful block length
        var topRounded = this.getBarLen(topMax);
        var bottomRounded = this.getBarLen(bottomMax);

        // and back to display units
        topMax = topRounded / inches[curMapUnits] * inches[topUnits];
        bottomMax = bottomRounded / inches[curMapUnits] * inches[bottomUnits];

        // and to pixel units
        var topPx = topMax / res / geodesicRatio;
        var bottomPx = bottomMax / res / geodesicRatio;
        
        // now set the pixel widths
        // and the values inside them
        
        if (this.eBottom.style.visibility == "visible"){
            this.eBottom.style.width = Math.round(bottomPx) + "px"; 
            this.eBottom.innerHTML = bottomRounded + " " + bottomUnits ;
        }
            
        if (this.eTop.style.visibility == "visible"){
            this.eTop.style.width = Math.round(topPx) + "px";
            this.eTop.innerHTML = topRounded + " " + topUnits;
        }
        
    }, 

    CLASS_NAME: "HGIS.Control.ScaleLine"
});

/* ======================================================================
    HGIS/Icon.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 */

/**
 * Class: HGIS.Icon
 * 
 * The icon represents a graphical icon on the screen.  Typically used in
 * conjunction with a <HGIS.Marker> to represent markers on a screen.
 *
 * An icon has a url, size and position.  It also contains an offset which 
 * allows the center point to be represented correctly.  This can be
 * provided either as a fixed offset or a function provided to calculate
 * the desired offset. 
 * 
 */
HGIS.Icon = HGIS.Class({
    
    /** 
     * Property: url 
     * {String}  image url
     */
    url: null,
    
    /** 
     * Property: size 
     * {<HGIS.Size>|Object} An HGIS.Size or
     * an object with a 'w' and 'h' properties.
     */
    size: null,

    /** 
     * Property: offset 
     * {<HGIS.Pixel>|Object} distance in pixels to offset the
     * image when being rendered. An HGIS.Pixel or an object
     * with a 'x' and 'y' properties.
     */
    offset: null,    
    
    /** 
     * Property: calculateOffset 
     * {Function} Function to calculate the offset (based on the size)
     */
    calculateOffset: null,    
    
    /** 
     * Property: imageDiv 
     * {DOMElement} 
     */
    imageDiv: null,

    /** 
     * Property: px 
     * {<HGIS.Pixel>|Object} An HGIS.Pixel or an object
     * with a 'x' and 'y' properties.
     */
    px: null,
    
    /** 
     * Constructor: HGIS.Icon
     * Creates an icon, which is an image tag in a div.  
     *
     * url - {String} 
     * size - {<HGIS.Size>|Object} An HGIS.Size or an
     *                                   object with a 'w' and 'h'
     *                                   properties.
     * offset - {<HGIS.Pixel>|Object} An HGIS.Pixel or an
     *                                      object with a 'x' and 'y'
     *                                      properties.
     * calculateOffset - {Function} 
     */
    initialize: function(url, size, offset, calculateOffset) {
        this.url = url;
        this.size = size || {w: 20, h: 20};
        this.offset = offset || {x: -(this.size.w/2), y: -(this.size.h/2)};
        this.calculateOffset = calculateOffset;

        var id = HGIS.Util.createUniqueID("OL_Icon_");
        this.imageDiv = HGIS.Util.createAlphaImageDiv(id);
    },
    
    /** 
     * Method: destroy
     * Nullify references and remove event listeners to prevent circular 
     * references and memory leaks
     */
    destroy: function() {
        // erase any drawn elements
        this.erase();

        HGIS.Event.stopObservingElement(this.imageDiv.firstChild); 
        this.imageDiv.innerHTML = "";
        this.imageDiv = null;
    },

    /** 
     * Method: clone
     * 
     * Returns:
     * {<HGIS.Icon>} A fresh copy of the icon.
     */
    clone: function() {
        return new HGIS.Icon(this.url, 
                                   this.size, 
                                   this.offset, 
                                   this.calculateOffset);
    },
    
    /**
     * Method: setSize
     * 
     * Parameters:
     * size - {<HGIS.Size>|Object} An HGIS.Size or
     * an object with a 'w' and 'h' properties.
     */
    setSize: function(size) {
        if (size != null) {
            this.size = size;
        }
        this.draw();
    },
    
    /**
     * Method: setUrl
     * 
     * Parameters:
     * url - {String} 
     */
    setUrl: function(url) {
        if (url != null) {
            this.url = url;
        }
        this.draw();
    },

    /** 
     * Method: draw
     * Move the div to the given pixel.
     * 
     * Parameters:
     * px - {<HGIS.Pixel>|Object} An HGIS.Pixel or an
     *                                  object with a 'x' and 'y' properties.
     * 
     * Returns:
     * {DOMElement} A new DOM Image of this icon set at the location passed-in
     */
    draw: function(px) {
        HGIS.Util.modifyAlphaImageDiv(this.imageDiv, 
                                            null, 
                                            null, 
                                            this.size, 
                                            this.url, 
                                            "absolute");
        this.moveTo(px);
        return this.imageDiv;
    }, 

    /** 
     * Method: erase
     * Erase the underlying image element.
     */
    erase: function() {
        if (this.imageDiv != null && this.imageDiv.parentNode != null) {
            HGIS.Element.remove(this.imageDiv);
        }
    }, 
    
    /** 
     * Method: setOpacity
     * Change the icon's opacity
     *
     * Parameters:
     * opacity - {float} 
     */
    setOpacity: function(opacity) {
        HGIS.Util.modifyAlphaImageDiv(this.imageDiv, null, null, null, 
                                            null, null, null, null, opacity);

    },
    
    /**
     * Method: moveTo
     * move icon to passed in px.
     *
     * Parameters:
     * px - {<HGIS.Pixel>|Object} the pixel position to move to.
     * An HGIS.Pixel or an object with a 'x' and 'y' properties.
     */
    moveTo: function (px) {
        //if no px passed in, use stored location
        if (px != null) {
            this.px = px;
        }

        if (this.imageDiv != null) {
            if (this.px == null) {
                this.display(false);
            } else {
                if (this.calculateOffset) {
                    this.offset = this.calculateOffset(this.size);  
                }
                HGIS.Util.modifyAlphaImageDiv(this.imageDiv, null, {
                    x: this.px.x + this.offset.x,
                    y: this.px.y + this.offset.y
                });
            }
        }
    },
    
    /** 
     * Method: display
     * Hide or show the icon
     *
     * Parameters:
     * display - {Boolean} 
     */
    display: function(display) {
        this.imageDiv.style.display = (display) ? "" : "none"; 
    },
    

    /**
     * APIMethod: isDrawn
     * 
     * Returns:
     * {Boolean} Whether or not the icon is drawn.
     */
    isDrawn: function() {
        // nodeType 11 for ie, whose nodes *always* have a parentNode
        // (of type document fragment)
        var isDrawn = (this.imageDiv && this.imageDiv.parentNode && 
                       (this.imageDiv.parentNode.nodeType != 11));    

        return isDrawn;   
    },

    CLASS_NAME: "HGIS.Icon"
});
/* ======================================================================
    HGIS/Marker.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Events.js
 * @requires HGIS/Icon.js
 */

/**
 * Class: HGIS.Marker
 * Instances of HGIS.Marker are a combination of a 
 * <HGIS.LonLat> and an <HGIS.Icon>.  
 *
 * Markers are generally added to a special layer called
 * <HGIS.Layer.Markers>.
 *
 * Example:
 * (code)
 * var markers = new HGIS.Layer.Markers( "Markers" );
 * map.addLayer(markers);
 *
 * var size = new HGIS.Size(21,25);
 * var offset = new HGIS.Pixel(-(size.w/2), -size.h);
 * var icon = new HGIS.Icon('http://www.HGIS.org/dev/img/marker.png', size, offset);
 * markers.addMarker(new HGIS.Marker(new HGIS.LonLat(0,0),icon));
 * markers.addMarker(new HGIS.Marker(new HGIS.LonLat(0,0),icon.clone()));
 *
 * (end)
 *
 * Note that if you pass an icon into the Marker constructor, it will take
 * that icon and use it. This means that you should not share icons between
 * markers -- you use them once, but you should clone() for any additional
 * markers using that same icon.
 */
HGIS.Marker = HGIS.Class({
    
    /** 
     * Property: icon 
     * {<HGIS.Icon>} The icon used by this marker.
     */
    icon: null,

    /** 
     * Property: lonlat 
     * {<HGIS.LonLat>} location of object
     */
    lonlat: null,
    
    /** 
     * Property: events 
     * {<HGIS.Events>} the event handler.
     */
    events: null,
    
    /** 
     * Property: map 
     * {<HGIS.Map>} the map this marker is attached to
     */
    map: null,
    
    /** 
     * Constructor: HGIS.Marker
     *
     * Parameters:
     * lonlat - {<HGIS.LonLat>} the position of this marker
     * icon - {<HGIS.Icon>}  the icon for this marker
     */
    initialize: function(lonlat, icon) {
        this.lonlat = lonlat;
        
        var newIcon = (icon) ? icon : HGIS.Marker.defaultIcon();
        if (this.icon == null) {
            this.icon = newIcon;
        } else {
            this.icon.url = newIcon.url;
            this.icon.size = newIcon.size;
            this.icon.offset = newIcon.offset;
            this.icon.calculateOffset = newIcon.calculateOffset;
        }
        this.events = new HGIS.Events(this, this.icon.imageDiv);
    },
    
    /**
     * APIMethod: destroy
     * Destroy the marker. You must first remove the marker from any 
     * layer which it has been added to, or you will get buggy behavior.
     * (This can not be done within the marker since the marker does not
     * know which layer it is attached to.)
     */
    destroy: function() {
        // erase any drawn features
        this.erase();

        this.map = null;

        this.events.destroy();
        this.events = null;

        if (this.icon != null) {
            this.icon.destroy();
            this.icon = null;
        }
    },
    
    /** 
    * Method: draw
    * Calls draw on the icon, and returns that output.
    * 
    * Parameters:
    * px - {<HGIS.Pixel>}
    * 
    * Returns:
    * {DOMElement} A new DOM Image with this marker's icon set at the 
    * location passed-in
    */
    draw: function(px) {
        return this.icon.draw(px);
    }, 

    /** 
    * Method: erase
    * Erases any drawn elements for this marker.
    */
    erase: function() {
        if (this.icon != null) {
            this.icon.erase();
        }
    }, 

    /**
    * Method: moveTo
    * Move the marker to the new location.
    *
    * Parameters:
    * px - {<HGIS.Pixel>|Object} the pixel position to move to.
    * An HGIS.Pixel or an object with a 'x' and 'y' properties.
    */
    moveTo: function (px) {
        if ((px != null) && (this.icon != null)) {
            this.icon.moveTo(px);
        }           
        this.lonlat = this.map.getLonLatFromLayerPx(px);
    },

    /**
     * APIMethod: isDrawn
     * 
     * Returns:
     * {Boolean} Whether or not the marker is drawn.
     */
    isDrawn: function() {
        var isDrawn = (this.icon && this.icon.isDrawn());
        return isDrawn;   
    },

    /**
     * Method: onScreen
     *
     * Returns:
     * {Boolean} Whether or not the marker is currently visible on screen.
     */
    onScreen:function() {
        
        var onScreen = false;
        if (this.map) {
            var screenBounds = this.map.getExtent();
            onScreen = screenBounds.containsLonLat(this.lonlat);
        }    
        return onScreen;
    },
    
    /**
     * Method: inflate
     * Englarges the markers icon by the specified ratio.
     *
     * Parameters:
     * inflate - {float} the ratio to enlarge the marker by (passing 2
     *                   will double the size).
     */
    inflate: function(inflate) {
        if (this.icon) {
            this.icon.setSize({
                w: this.icon.size.w * inflate,
                h: this.icon.size.h * inflate
            });
        }        
    },
    
    /** 
     * Method: setOpacity
     * Change the opacity of the marker by changin the opacity of 
     *   its icon
     * 
     * Parameters:
     * opacity - {float}  Specified as fraction (0.4, etc)
     */
    setOpacity: function(opacity) {
        this.icon.setOpacity(opacity);
    },

    /**
     * Method: setUrl
     * Change URL of the Icon Image.
     * 
     * url - {String} 
     */
    setUrl: function(url) {
        this.icon.setUrl(url);
    },    

    /** 
     * Method: display
     * Hide or show the icon
     * 
     * display - {Boolean} 
     */
    display: function(display) {
        this.icon.display(display);
    },

    CLASS_NAME: "HGIS.Marker"
});


/**
 * Function: defaultIcon
 * Creates a default <HGIS.Icon>.
 * 
 * Returns:
 * {<HGIS.Icon>} A default HGIS.Icon to use for a marker
 */
HGIS.Marker.defaultIcon = function() {
    return new HGIS.Icon(HGIS.Util.getImageLocation("marker.png"),
                               {w: 21, h: 25}, {x: -10.5, y: -25});
};
    

/* ======================================================================
    HGIS/Layer/TileCache.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer/Grid.js
 */

/**
 * Class: HGIS.Layer.TileCache
 * A read only TileCache layer.  Used to requests tiles cached by TileCache in
 *     a web accessible cache.  This means that you have to pre-populate your
 *     cache before this layer can be used.  It is meant only to read tiles
 *     created by TileCache, and not to make calls to TileCache for tile
 *     creation.  Create a new instance with the
 *     <HGIS.Layer.TileCache> constructor.
 *
 * Inherits from:
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.TileCache = HGIS.Class(HGIS.Layer.Grid, {

    /** 
     * APIProperty: isBaseLayer
     * {Boolean} Treat this layer as a base layer.  Default is true.
     */
    isBaseLayer: true,
    
    /** 
     * APIProperty: format
     * {String} Mime type of the images returned.  Default is image/png.
     */
    format: 'image/png',

    /**
     * APIProperty: serverResolutions
     * {Array} A list of all resolutions available on the server.  Only set this
     *     property if the map resolutions differ from the server. This
     *     property serves two purposes. (a) <serverResolutions> can include
     *     resolutions that the server supports and that you don't want to
     *     provide with this layer. (b) The map can work with resolutions
     *     that aren't supported by the server, i.e. that aren't in
     *     <serverResolutions>. When the map is displayed in such a resolution
     *     data for the closest server-supported resolution is loaded and the
     *     layer div is stretched as necessary.
     */
    serverResolutions: null,

    /**
     * Constructor: HGIS.Layer.TileCache
     * Create a new read only TileCache layer.
     *
     * Parameters:
     * name - {String} Name of the layer displayed in the interface
     * url - {String} Location of the web accessible cache (not the location of
     *     your tilecache script!)
     * layername - {String} Layer name as defined in the TileCache 
     *     configuration
     * options - {Object} Optional object with properties to be set on the
     *     layer.  Note that you should speficy your resolutions to match
     *     your TileCache configuration.  This can be done by setting
     *     the resolutions array directly (here or on the map), by setting
     *     maxResolution and numZoomLevels, or by using scale based properties.
     */
    initialize: function(name, url, layername, options) {
        this.layername = layername;
        HGIS.Layer.Grid.prototype.initialize.apply(this,
                                                         [name, url, {}, options]);
        this.extension = this.format.split('/')[1].toLowerCase();
        this.extension = (this.extension == 'jpg') ? 'jpeg' : this.extension;
    },    

    /**
     * APIMethod: clone
     * obj - {Object} 
     * 
     * Returns:
     * {<HGIS.Layer.TileCache>} An exact clone of this 
     *     <HGIS.Layer.TileCache>
     */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new HGIS.Layer.TileCache(this.name,
                                                 this.url,
                                                 this.layername,
                                                 this.getOptions());
        }

        //get all additions from superclasses
        obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },    
    
    /**
     * Method: getURL
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>} 
     * 
     * Returns:
     * {String} A string with the layer's url and parameters and also the 
     *     passed-in bounds and appropriate tile size specified as parameters.
     */
    getURL: function(bounds) {
        var res = this.getServerResolution();
        var bbox = this.maxExtent;
        var size = this.tileSize;
        var tileX = Math.round((bounds.left - bbox.left) / (res * size.w));
        var tileY = Math.round((bounds.bottom - bbox.bottom) / (res * size.h));
        var tileZ = this.serverResolutions != null ?
            HGIS.Util.indexOf(this.serverResolutions, res) :
            this.map.getZoom();

        var components = [
            this.layername,
            HGIS.Number.zeroPad(tileZ, 2),
            HGIS.Number.zeroPad(parseInt(tileX / 1000000), 3),
            HGIS.Number.zeroPad((parseInt(tileX / 1000) % 1000), 3),
            HGIS.Number.zeroPad((parseInt(tileX) % 1000), 3),
            HGIS.Number.zeroPad(parseInt(tileY / 1000000), 3),
            HGIS.Number.zeroPad((parseInt(tileY / 1000) % 1000), 3),
            HGIS.Number.zeroPad((parseInt(tileY) % 1000), 3) + '.' + this.extension
        ];
        var path = components.join('/'); 
        var url = this.url;
        if (HGIS.Util.isArray(url)) {
            url = this.selectUrl(path, url);
        }
        url = (url.charAt(url.length - 1) == '/') ? url : url + '/';
        return url + path;
    },
    
    CLASS_NAME: "HGIS.Layer.TileCache"
});
/* ======================================================================
    HGIS/Strategy/Paging.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Strategy.js
 */

/**
 * Class: HGIS.Strategy.Paging
 * Strategy for vector feature paging
 *
 * Inherits from:
 *  - <HGIS.Strategy>
 */
HGIS.Strategy.Paging = HGIS.Class(HGIS.Strategy, {
    
    /**
     * Property: features
     * {Array(<HGIS.Feature.Vector>)} Cached features.
     */
    features: null,
    
    /**
     * Property: length
     * {Integer} Number of features per page.  Default is 10.
     */
    length: 10,
    
    /**
     * Property: num
     * {Integer} The currently displayed page number.
     */
    num: null,
    
    /**
     * Property: paging
     * {Boolean} The strategy is currently changing pages.
     */
    paging: false,

    /**
     * Constructor: HGIS.Strategy.Paging
     * Create a new paging strategy.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
    
    /**
     * APIMethod: activate
     * Activate the strategy.  Register any listeners, do appropriate setup.
     * 
     * Returns:
     * {Boolean} The strategy was successfully activated.
     */
    activate: function() {
        var activated = HGIS.Strategy.prototype.activate.call(this);
        if(activated) {
            this.layer.events.on({
                "beforefeaturesadded": this.cacheFeatures,
                scope: this
            });
        }
        return activated;
    },
    
    /**
     * APIMethod: deactivate
     * Deactivate the strategy.  Unregister any listeners, do appropriate
     *     tear-down.
     * 
     * Returns:
     * {Boolean} The strategy was successfully deactivated.
     */
    deactivate: function() {
        var deactivated = HGIS.Strategy.prototype.deactivate.call(this);
        if(deactivated) {
            this.clearCache();
            this.layer.events.un({
                "beforefeaturesadded": this.cacheFeatures,
                scope: this
            });
        }
        return deactivated;
    },
    
    /**
     * Method: cacheFeatures
     * Cache features before they are added to the layer.
     *
     * Parameters:
     * event - {Object} The event that this was listening for.  This will come
     *     with a batch of features to be paged.
     */
    cacheFeatures: function(event) {
        if(!this.paging) {
            this.clearCache();
            this.features = event.features;
            this.pageNext(event);
        }
    },
    
    /**
     * Method: clearCache
     * Clear out the cached features.  This destroys features, assuming
     *     nothing else has a reference.
     */
    clearCache: function() {
        if(this.features) {
            for(var i=0; i<this.features.length; ++i) {
                this.features[i].destroy();
            }
        }
        this.features = null;
        this.num = null;
    },
    
    /**
     * APIMethod: pageCount
     * Get the total count of pages given the current cache of features.
     *
     * Returns:
     * {Integer} The page count.
     */
    pageCount: function() {
        var numFeatures = this.features ? this.features.length : 0;
        return Math.ceil(numFeatures / this.length);
    },

    /**
     * APIMethod: pageNum
     * Get the zero based page number.
     *
     * Returns:
     * {Integer} The current page number being displayed.
     */
    pageNum: function() {
        return this.num;
    },

    /**
     * APIMethod: pageLength
     * Gets or sets page length.
     *
     * Parameters:
     * newLength - {Integer} Optional length to be set.
     *
     * Returns:
     * {Integer} The length of a page (number of features per page).
     */
    pageLength: function(newLength) {
        if(newLength && newLength > 0) {
            this.length = newLength;
        }
        return this.length;
    },

    /**
     * APIMethod: pageNext
     * Display the next page of features.
     *
     * Returns:
     * {Boolean} A new page was displayed.
     */
    pageNext: function(event) {
        var changed = false;
        if(this.features) {
            if(this.num === null) {
                this.num = -1;
            }
            var start = (this.num + 1) * this.length;
            changed = this.page(start, event);
        }
        return changed;
    },

    /**
     * APIMethod: pagePrevious
     * Display the previous page of features.
     *
     * Returns:
     * {Boolean} A new page was displayed.
     */
    pagePrevious: function() {
        var changed = false;
        if(this.features) {
            if(this.num === null) {
                this.num = this.pageCount();
            }
            var start = (this.num - 1) * this.length;
            changed = this.page(start);
        }
        return changed;
    },
    
    /**
     * Method: page
     * Display the page starting at the given index from the cache.
     *
     * Returns:
     * {Boolean} A new page was displayed.
     */
    page: function(start, event) {
        var changed = false;
        if(this.features) {
            if(start >= 0 && start < this.features.length) {
                var num = Math.floor(start / this.length);
                if(num != this.num) {
                    this.paging = true;
                    var features = this.features.slice(start, start + this.length);
                    this.layer.removeFeatures(this.layer.features);
                    this.num = num;
                    // modify the event if any
                    if(event && event.features) {
                        // this.was called by an event listener
                        event.features = features;
                    } else {
                        // this was called directly on the strategy
                        this.layer.addFeatures(features);
                    }
                    this.paging = false;
                    changed = true;
                }
            }
        }
        return changed;
    },
    
    CLASS_NAME: "HGIS.Strategy.Paging" 
});
/* ======================================================================
    HGIS/Control/DragFeature.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Control.js
 * @requires HGIS/Handler/Drag.js
 * @requires HGIS/Handler/Feature.js
 */

/**
 * Class: HGIS.Control.DragFeature
 * The DragFeature control moves a feature with a drag of the mouse. Create a
 * new control with the <HGIS.Control.DragFeature> constructor.
 *
 * Inherits From:
 *  - <HGIS.Control>
 */
HGIS.Control.DragFeature = HGIS.Class(HGIS.Control, {

    /**
     * APIProperty: geometryTypes
     * {Array(String)} To restrict dragging to a limited set of geometry types,
     *     send a list of strings corresponding to the geometry class names.
     */
    geometryTypes: null,
    
    /**
     * APIProperty: onStart
     * {Function} Define this function if you want to know when a drag starts.
     *     The function should expect to receive two arguments: the feature
     *     that is about to be dragged and the pixel location of the mouse.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} The feature that is about to be
     *     dragged.
     * pixel - {<HGIS.Pixel>} The pixel location of the mouse.
     */
    onStart: function(feature, pixel) {},

    /**
     * APIProperty: onDrag
     * {Function} Define this function if you want to know about each move of a
     *     feature. The function should expect to receive two arguments: the
     *     feature that is being dragged and the pixel location of the mouse.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} The feature that was dragged.
     * pixel - {<HGIS.Pixel>} The pixel location of the mouse.
     */
    onDrag: function(feature, pixel) {},

    /**
     * APIProperty: onComplete
     * {Function} Define this function if you want to know when a feature is
     *     done dragging. The function should expect to receive two arguments:
     *     the feature that is being dragged and the pixel location of the
     *     mouse.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} The feature that was dragged.
     * pixel - {<HGIS.Pixel>} The pixel location of the mouse.
     */
    onComplete: function(feature, pixel) {},

    /**
     * APIProperty: onEnter
     * {Function} Define this function if you want to know when the mouse
     *     goes over a feature and thereby makes this feature a candidate
     *     for dragging.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} The feature that is ready
     *     to be dragged.
     */
    onEnter: function(feature) {},

    /**
     * APIProperty: onLeave
     * {Function} Define this function if you want to know when the mouse
     *     goes out of the feature that was dragged.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} The feature that was dragged.
     */
    onLeave: function(feature) {},

    /**
     * APIProperty: documentDrag
     * {Boolean} If set to true, mouse dragging will continue even if the
     *     mouse cursor leaves the map viewport. Default is false.
     */
    documentDrag: false,
    
    /**
     * Property: layer
     * {<HGIS.Layer.Vector>}
     */
    layer: null,
    
    /**
     * Property: feature
     * {<HGIS.Feature.Vector>}
     */
    feature: null,

    /**
     * Property: dragCallbacks
     * {Object} The functions that are sent to the drag handler for callback.
     */
    dragCallbacks: {},

    /**
     * Property: featureCallbacks
     * {Object} The functions that are sent to the feature handler for callback.
     */
    featureCallbacks: {},
    
    /**
     * Property: lastPixel
     * {<HGIS.Pixel>}
     */
    lastPixel: null,

    /**
     * Constructor: HGIS.Control.DragFeature
     * Create a new control to drag features.
     *
     * Parameters:
     * layer - {<HGIS.Layer.Vector>} The layer containing features to be
     *     dragged.
     * options - {Object} Optional object whose properties will be set on the
     *     control.
     */
    initialize: function(layer, options) {
        HGIS.Control.prototype.initialize.apply(this, [options]);
        this.layer = layer;
        this.handlers = {
            drag: new HGIS.Handler.Drag(
                this, HGIS.Util.extend({
                    down: this.downFeature,
                    move: this.moveFeature,
                    up: this.upFeature,
                    out: this.cancel,
                    done: this.doneDragging
                }, this.dragCallbacks), {
                    documentDrag: this.documentDrag
                }
            ),
            feature: new HGIS.Handler.Feature(
                this, this.layer, HGIS.Util.extend({
                    // 'click' and 'clickout' callback are for the mobile
                    // support: no 'over' or 'out' in touch based browsers.
                    click: this.clickFeature,
                    clickout: this.clickoutFeature,
                    over: this.overFeature,
                    out: this.outFeature
                }, this.featureCallbacks),
                {geometryTypes: this.geometryTypes}
            )
        };
    },

    /**
     * Method: clickFeature
     * Called when the feature handler detects a click-in on a feature.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     */
    clickFeature: function(feature) {
        if (this.handlers.feature.touch && !this.over && this.overFeature(feature)) {
            this.handlers.drag.dragstart(this.handlers.feature.evt);
            // to let the events propagate to the feature handler (click callback)
            this.handlers.drag.stopDown = false;
        }
    },

    /**
     * Method: clickoutFeature
     * Called when the feature handler detects a click-out on a feature.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     */
    clickoutFeature: function(feature) {
        if (this.handlers.feature.touch && this.over) {
            this.outFeature(feature);
            this.handlers.drag.stopDown = true;
        }
    },

    /**
     * APIMethod: destroy
     * Take care of things that are not handled in superclass
     */
    destroy: function() {
        this.layer = null;
        HGIS.Control.prototype.destroy.apply(this, []);
    },

    /**
     * APIMethod: activate
     * Activate the control and the feature handler.
     * 
     * Returns:
     * {Boolean} Successfully activated the control and feature handler.
     */
    activate: function() {
        return (this.handlers.feature.activate() &&
                HGIS.Control.prototype.activate.apply(this, arguments));
    },

    /**
     * APIMethod: deactivate
     * Deactivate the control and all handlers.
     * 
     * Returns:
     * {Boolean} Successfully deactivated the control.
     */
    deactivate: function() {
        // the return from the handlers is unimportant in this case
        this.handlers.drag.deactivate();
        this.handlers.feature.deactivate();
        this.feature = null;
        this.dragging = false;
        this.lastPixel = null;
        HGIS.Element.removeClass(
            this.map.viewPortDiv, this.displayClass + "Over"
        );
        return HGIS.Control.prototype.deactivate.apply(this, arguments);
    },

    /**
     * Method: overFeature
     * Called when the feature handler detects a mouse-over on a feature.
     *     This activates the drag handler.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} The selected feature.
     *
     * Returns:
     * {Boolean} Successfully activated the drag handler.
     */
    overFeature: function(feature) {
        var activated = false;
        if(!this.handlers.drag.dragging) {
            this.feature = feature;
            this.handlers.drag.activate();
            activated = true;
            this.over = true;
            HGIS.Element.addClass(this.map.viewPortDiv, this.displayClass + "Over");
            this.onEnter(feature);
        } else {
            if(this.feature.id == feature.id) {
                this.over = true;
            } else {
                this.over = false;
            }
        }
        return activated;
    },

    /**
     * Method: downFeature
     * Called when the drag handler detects a mouse-down.
     *
     * Parameters:
     * pixel - {<HGIS.Pixel>} Location of the mouse event.
     */
    downFeature: function(pixel) {
        this.lastPixel = pixel;
        this.onStart(this.feature, pixel);
    },

    /**
     * Method: moveFeature
     * Called when the drag handler detects a mouse-move.  Also calls the
     *     optional onDrag method.
     * 
     * Parameters:
     * pixel - {<HGIS.Pixel>} Location of the mouse event.
     */
    moveFeature: function(pixel) {
        var res = this.map.getResolution();
        this.feature.geometry.move(res * (pixel.x - this.lastPixel.x),
                                   res * (this.lastPixel.y - pixel.y));
        this.layer.drawFeature(this.feature);
        this.lastPixel = pixel;
        this.onDrag(this.feature, pixel);
    },

    /**
     * Method: upFeature
     * Called when the drag handler detects a mouse-up.
     * 
     * Parameters:
     * pixel - {<HGIS.Pixel>} Location of the mouse event.
     */
    upFeature: function(pixel) {
        if(!this.over) {
            this.handlers.drag.deactivate();
        }
    },

    /**
     * Method: doneDragging
     * Called when the drag handler is done dragging.
     *
     * Parameters:
     * pixel - {<HGIS.Pixel>} The last event pixel location.  If this event
     *     came from a mouseout, this may not be in the map viewport.
     */
    doneDragging: function(pixel) {
        this.onComplete(this.feature, pixel);
    },

    /**
     * Method: outFeature
     * Called when the feature handler detects a mouse-out on a feature.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} The feature that the mouse left.
     */
    outFeature: function(feature) {
        if(!this.handlers.drag.dragging) {
            this.over = false;
            this.handlers.drag.deactivate();
            HGIS.Element.removeClass(
                this.map.viewPortDiv, this.displayClass + "Over"
            );
            this.onLeave(feature);
            this.feature = null;
        } else {
            if(this.feature.id == feature.id) {
                this.over = false;
            }
        }
    },
        
    /**
     * Method: cancel
     * Called when the drag handler detects a mouse-out (from the map viewport).
     */
    cancel: function() {
        this.handlers.drag.deactivate();
        this.over = false;
    },

    /**
     * Method: setMap
     * Set the map property for the control and all handlers.
     *
     * Parameters: 
     * map - {<HGIS.Map>} The control's map.
     */
    setMap: function(map) {
        this.handlers.drag.setMap(map);
        this.handlers.feature.setMap(map);
        HGIS.Control.prototype.setMap.apply(this, arguments);
    },

    CLASS_NAME: "HGIS.Control.DragFeature"
});
/* ======================================================================
    HGIS/Control/TransformFeature.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Control.js
 * @requires HGIS/Control/DragFeature.js
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Geometry/LineString.js
 * @requires HGIS/Geometry/Point.js
 */

/**
 * Class: HGIS.Control.TransformFeature
 * Control to transform features with a standard transformation box.
 *
 * Inherits From:
 *  - <HGIS.Control>
 */
HGIS.Control.TransformFeature = HGIS.Class(HGIS.Control, {

    /** 
     * APIProperty: events
     * {<HGIS.Events>} Events instance for listeners and triggering
     *     control specific events.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types (in addition to those from <HGIS.Control.events>):
     * beforesetfeature - Triggered before a feature is set for
     *     tranformation. The feature will not be set if a listener returns
     *     false. Listeners receive a *feature* property, with the feature
     *     that will be set for transformation. Listeners are allowed to
     *     set the control's *scale*, *ratio* and *rotation* properties,
     *     which will set the initial scale, ratio and rotation of the
     *     feature, like the <setFeature> method's initialParams argument.
     * setfeature - Triggered when a feature is set for tranformation.
     *     Listeners receive a *feature* property, with the feature that
     *     is now set for transformation.
     * beforetransform - Triggered while dragging, before a feature is
     *     transformed. The feature will not be transformed if a listener
     *     returns false (but the box still will). Listeners receive one or
     *     more of *center*, *scale*, *ratio* and *rotation*. The *center*
     *     property is an <HGIS.Geometry.Point> object with the new
     *     center of the transformed feature, the others are Floats with the
     *     scale, ratio or rotation change since the last transformation.
     * transform - Triggered while dragging, when a feature is transformed.
     *     Listeners receive an event object with one or more of *center*,
     *     scale*, *ratio* and *rotation*. The *center* property is an
     *     <HGIS.Geometry.Point> object with the new center of the
     *     transformed feature, the others are Floats with the scale, ratio
     *     or rotation change of the feature since the last transformation.
     * transformcomplete - Triggered after dragging. Listeners receive
     *     an event object with the transformed *feature*.
     */

    /**
     * APIProperty: geometryTypes
     * {Array(String)} To restrict transformation to a limited set of geometry
     *     types, send a list of strings corresponding to the geometry class
     *     names.
     */
    geometryTypes: null,

    /**
     * Property: layer
     * {<HGIS.Layer.Vector>}
     */
    layer: null,
    
    /**
     * APIProperty: preserveAspectRatio
     * {Boolean} set to true to not change the feature's aspect ratio.
     */
    preserveAspectRatio: false,
    
    /**
     * APIProperty: rotate
     * {Boolean} set to false if rotation should be disabled. Default is true.
     *     To be passed with the constructor or set when the control is not
     *     active.
     */
    rotate: true,
    
    /**
     * APIProperty: feature
     * {<HGIS.Feature.Vector>} Feature currently available for
     *     transformation. Read-only, use <setFeature> to set it manually.
     */
    feature: null,
    
    /**
     * APIProperty: renderIntent
     * {String|Object} Render intent for the transformation box and
     *     handles. A symbolizer object can also be provided here.
     */
    renderIntent: "temporary",
    
    /**
     * APIProperty: rotationHandleSymbolizer
     * {Object|String} Optional. A custom symbolizer for the rotation handles.
     *     A render intent can also be provided here. Defaults to
     *     (code)
     *     {
     *         stroke: false,
     *         pointRadius: 10,
     *         fillOpacity: 0,
     *         cursor: "pointer"
     *     }
     *     (end)
     */
    rotationHandleSymbolizer: null,
    
    /**
     * APIProperty: box
     * {<HGIS.Feature.Vector>} The transformation box rectangle.
     *     Read-only.
     */
    box: null,
    
    /**
     * APIProperty: center
     * {<HGIS.Geometry.Point>} The center of the feature bounds.
     * Read-only.
     */
    center: null,
    
    /**
     * APIProperty: scale
     * {Float} The scale of the feature, relative to the scale the time the
     *     feature was set. Read-only, except for *beforesetfeature*
     *     listeners.
     */
    scale: 1,
    
    /**
     * APIProperty: ratio
     * {Float} The ratio of the feature relative to the ratio the time the
     *     feature was set. Read-only, except for *beforesetfeature*
     *     listeners.
     */
    ratio: 1,
    
    /**
     * Property: rotation
     * {Integer} the current rotation angle of the box. Read-only, except for
     *     *beforesetfeature* listeners.
     */
    rotation: 0,
    
    /**
     * APIProperty: handles
     * {Array(<HGIS.Feature.Vector>)} The 8 handles currently available
     *     for scaling/resizing. Numbered counterclockwise, starting from the
     *     southwest corner. Read-only.
     */
    handles: null,
    
    /**
     * APIProperty: rotationHandles
     * {Array(<HGIS.Feature.Vector>)} The 4 rotation handles currently
     *     available for rotating. Numbered counterclockwise, starting from
     *     the southwest corner. Read-only.
     */
    rotationHandles: null,
    
    /**
     * Property: dragControl
     * {<HGIS.Control.DragFeature>}
     */
    dragControl: null,
    
    /**
     * APIProperty: irregular
     * {Boolean} Make scaling/resizing work irregularly. If true then
     *     dragging a handle causes the feature to resize in the direction
     *     of movement. If false then the feature resizes symetrically
     *     about it's center.
     */
    irregular: false,
    
    /**
     * Constructor: HGIS.Control.TransformFeature
     * Create a new transform feature control.
     *
     * Parameters:
     * layer - {<HGIS.Layer.Vector>} Layer that contains features that
     *     will be transformed.
     * options - {Object} Optional object whose properties will be set on the
     *     control.
     */
    initialize: function(layer, options) {
        HGIS.Control.prototype.initialize.apply(this, [options]);

        this.layer = layer;

        if(!this.rotationHandleSymbolizer) {
            this.rotationHandleSymbolizer = {
                stroke: false,
                pointRadius: 10,
                fillOpacity: 0,
                cursor: "pointer"
            };
        }

        this.createBox();
        this.createControl();        
    },
    
    /**
     * APIMethod: activate
     * Activates the control.
     */
    activate: function() {
        var activated = false;
        if(HGIS.Control.prototype.activate.apply(this, arguments)) {
            this.dragControl.activate();
            this.layer.addFeatures([this.box]);
            this.rotate && this.layer.addFeatures(this.rotationHandles);
            this.layer.addFeatures(this.handles);        
            activated = true;
        }
        return activated;
    },
    
    /**
     * APIMethod: deactivate
     * Deactivates the control.
     */
    deactivate: function() {
        var deactivated = false;
        if(HGIS.Control.prototype.deactivate.apply(this, arguments)) {
            this.layer.removeFeatures(this.handles);
            this.rotate && this.layer.removeFeatures(this.rotationHandles);
            this.layer.removeFeatures([this.box]);
            this.dragControl.deactivate();
            deactivated = true;
        }
        return deactivated;
    },
    
    /**
     * Method: setMap
     * 
     * Parameters:
     * map - {<HGIS.Map>}
     */
    setMap: function(map) {
        this.dragControl.setMap(map);
        HGIS.Control.prototype.setMap.apply(this, arguments);
    },

    /**
     * APIMethod: setFeature
     * Place the transformation box on a feature and start transforming it.
     * If the control is not active, it will be activated.
     * 
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     * initialParams - {Object} Initial values for rotation, scale or ratio.
     *     Setting a rotation value here will cause the transformation box to
     *     start rotated. Setting a scale or ratio will not affect the
     *     transormation box, but applications may use this to keep track of
     *     scale and ratio of a feature across multiple transforms.
     */
    setFeature: function(feature, initialParams) {
        initialParams = HGIS.Util.applyDefaults(initialParams, {
            rotation: 0,
            scale: 1,
            ratio: 1
        });

        var oldRotation = this.rotation;
        var oldCenter = this.center;
        HGIS.Util.extend(this, initialParams);

        var cont = this.events.triggerEvent("beforesetfeature",
            {feature: feature}
        );
        if (cont === false) {
            return;
        }

        this.feature = feature;
        this.activate();

        this._setfeature = true;

        var featureBounds = this.feature.geometry.getBounds();
        this.box.move(featureBounds.getCenterLonLat());
        this.box.geometry.rotate(-oldRotation, oldCenter);
        this._angle = 0;

        var ll;
        if(this.rotation) {
            var geom = feature.geometry.clone();
            geom.rotate(-this.rotation, this.center);
            var box = new HGIS.Feature.Vector(
                geom.getBounds().toGeometry());
            box.geometry.rotate(this.rotation, this.center);
            this.box.geometry.rotate(this.rotation, this.center);
            this.box.move(box.geometry.getBounds().getCenterLonLat());
            var llGeom = box.geometry.components[0].components[0];
            ll = llGeom.getBounds().getCenterLonLat();
        } else {
            ll = new HGIS.LonLat(featureBounds.left, featureBounds.bottom);
        }
        this.handles[0].move(ll);
        
        delete this._setfeature;

        this.events.triggerEvent("setfeature", {feature: feature});
    },
    
    /**
     * APIMethod: unsetFeature
     * Remove the transformation box off any feature.
     * If the control is active, it will be deactivated first.
     */
    unsetFeature: function() {
        if (this.active) {
            this.deactivate();
        } else {
            this.feature = null;
            this.rotation = 0;
            this.scale = 1;
            this.ratio = 1;
        }
    },
    
    /**
     * Method: createBox
     * Creates the box with all handles and transformation handles.
     */
    createBox: function() {
        var control = this;
        
        this.center = new HGIS.Geometry.Point(0, 0);
        this.box = new HGIS.Feature.Vector(
            new HGIS.Geometry.LineString([
                new HGIS.Geometry.Point(-1, -1),
                new HGIS.Geometry.Point(0, -1),
                new HGIS.Geometry.Point(1, -1),
                new HGIS.Geometry.Point(1, 0),
                new HGIS.Geometry.Point(1, 1),
                new HGIS.Geometry.Point(0, 1),
                new HGIS.Geometry.Point(-1, 1),
                new HGIS.Geometry.Point(-1, 0),
                new HGIS.Geometry.Point(-1, -1)
            ]), null,
            typeof this.renderIntent == "string" ? null : this.renderIntent
        );
        
        // Override for box move - make sure that the center gets updated
        this.box.geometry.move = function(x, y) {
            control._moving = true;
            HGIS.Geometry.LineString.prototype.move.apply(this, arguments);
            control.center.move(x, y);
            delete control._moving;
        };

        // Overrides for vertex move, resize and rotate - make sure that
        // handle and rotationHandle geometries are also moved, resized and
        // rotated.
        var vertexMoveFn = function(x, y) {
            HGIS.Geometry.Point.prototype.move.apply(this, arguments);
            this._rotationHandle && this._rotationHandle.geometry.move(x, y);
            this._handle.geometry.move(x, y);
        };
        var vertexResizeFn = function(scale, center, ratio) {
            HGIS.Geometry.Point.prototype.resize.apply(this, arguments);
            this._rotationHandle && this._rotationHandle.geometry.resize(
                scale, center, ratio);
            this._handle.geometry.resize(scale, center, ratio);
        };
        var vertexRotateFn = function(angle, center) {
            HGIS.Geometry.Point.prototype.rotate.apply(this, arguments);
            this._rotationHandle && this._rotationHandle.geometry.rotate(
                angle, center);
            this._handle.geometry.rotate(angle, center);
        };
        
        // Override for handle move - make sure that the box and other handles
        // are updated, and finally transform the feature.
        var handleMoveFn = function(x, y) {
            var oldX = this.x, oldY = this.y;
            HGIS.Geometry.Point.prototype.move.call(this, x, y);
            if(control._moving) {
                return;
            }
            var evt = control.dragControl.handlers.drag.evt;
            var preserveAspectRatio = !control._setfeature &&
                control.preserveAspectRatio;
            var reshape = !preserveAspectRatio && !(evt && evt.shiftKey);
            var oldGeom = new HGIS.Geometry.Point(oldX, oldY);
            var centerGeometry = control.center;
            this.rotate(-control.rotation, centerGeometry);
            oldGeom.rotate(-control.rotation, centerGeometry);
            var dx1 = this.x - centerGeometry.x;
            var dy1 = this.y - centerGeometry.y;
            var dx0 = dx1 - (this.x - oldGeom.x);
            var dy0 = dy1 - (this.y - oldGeom.y);
            if (control.irregular && !control._setfeature) {
               dx1 -= (this.x - oldGeom.x) / 2;
               dy1 -= (this.y - oldGeom.y) / 2;
            }
            this.x = oldX;
            this.y = oldY;
            var scale, ratio = 1;
            if (reshape) {
                scale = Math.abs(dy0) < 0.00001 ? 1 : dy1 / dy0;
                ratio = (Math.abs(dx0) < 0.00001 ? 1 : (dx1 / dx0)) / scale;
            } else {
                var l0 = Math.sqrt((dx0 * dx0) + (dy0 * dy0));
                var l1 = Math.sqrt((dx1 * dx1) + (dy1 * dy1));
                scale = l1 / l0;
            }

            // rotate the box to 0 before resizing - saves us some
            // calculations and is inexpensive because we don't drawFeature.
            control._moving = true;
            control.box.geometry.rotate(-control.rotation, centerGeometry);
            delete control._moving;

            control.box.geometry.resize(scale, centerGeometry, ratio);
            control.box.geometry.rotate(control.rotation, centerGeometry);
            control.transformFeature({scale: scale, ratio: ratio});
            if (control.irregular && !control._setfeature) {
               var newCenter = centerGeometry.clone();
               newCenter.x += Math.abs(oldX - centerGeometry.x) < 0.00001 ? 0 : (this.x - oldX);
               newCenter.y += Math.abs(oldY - centerGeometry.y) < 0.00001 ? 0 : (this.y - oldY);
               control.box.geometry.move(this.x - oldX, this.y - oldY);
               control.transformFeature({center: newCenter});
            }
        };
        
        // Override for rotation handle move - make sure that the box and
        // other handles are updated, and finally transform the feature.
        var rotationHandleMoveFn = function(x, y){
            var oldX = this.x, oldY = this.y;
            HGIS.Geometry.Point.prototype.move.call(this, x, y);
            if(control._moving) {
                return;
            }
            var evt = control.dragControl.handlers.drag.evt;
            var constrain = (evt && evt.shiftKey) ? 45 : 1;
            var centerGeometry = control.center;
            var dx1 = this.x - centerGeometry.x;
            var dy1 = this.y - centerGeometry.y;
            var dx0 = dx1 - x;
            var dy0 = dy1 - y;
            this.x = oldX;
            this.y = oldY;
            var a0 = Math.atan2(dy0, dx0);
            var a1 = Math.atan2(dy1, dx1);
            var angle = a1 - a0;
            angle *= 180 / Math.PI;
            control._angle = (control._angle + angle) % 360;
            var diff = control.rotation % constrain;
            if(Math.abs(control._angle) >= constrain || diff !== 0) {
                angle = Math.round(control._angle / constrain) * constrain -
                    diff;
                control._angle = 0;
                control.box.geometry.rotate(angle, centerGeometry);
                control.transformFeature({rotation: angle});
            } 
        };

        var handles = new Array(8);
        var rotationHandles = new Array(4);
        var geom, handle, rotationHandle;
        var positions = ["sw", "s", "se", "e", "ne", "n", "nw", "w"];
        for(var i=0; i<8; ++i) {
            geom = this.box.geometry.components[i];
            handle = new HGIS.Feature.Vector(geom.clone(), {
                role: positions[i] + "-resize"
            }, typeof this.renderIntent == "string" ? null :
                this.renderIntent);
            if(i % 2 == 0) {
                rotationHandle = new HGIS.Feature.Vector(geom.clone(), {
                    role: positions[i] + "-rotate"
                }, typeof this.rotationHandleSymbolizer == "string" ?
                    null : this.rotationHandleSymbolizer);
                rotationHandle.geometry.move = rotationHandleMoveFn;
                geom._rotationHandle = rotationHandle;
                rotationHandles[i/2] = rotationHandle;
            }
            geom.move = vertexMoveFn;
            geom.resize = vertexResizeFn;
            geom.rotate = vertexRotateFn;
            handle.geometry.move = handleMoveFn;
            geom._handle = handle;
            handles[i] = handle;
        }
        
        this.rotationHandles = rotationHandles;
        this.handles = handles;
    },
    
    /**
     * Method: createControl
     * Creates a DragFeature control for this control.
     */
    createControl: function() {
        var control = this;
        this.dragControl = new HGIS.Control.DragFeature(this.layer, {
            documentDrag: true,
            // avoid moving the feature itself - move the box instead
            moveFeature: function(pixel) {
                if(this.feature === control.feature) {
                    this.feature = control.box;
                }
                HGIS.Control.DragFeature.prototype.moveFeature.apply(this,
                    arguments);
            },
            // transform while dragging
            onDrag: function(feature, pixel) {
                if(feature === control.box) {
                    control.transformFeature({center: control.center});
                }
            },
            // set a new feature
            onStart: function(feature, pixel) {
                var eligible = !control.geometryTypes ||
                    HGIS.Util.indexOf(control.geometryTypes,
                        feature.geometry.CLASS_NAME) !== -1;
                var i = HGIS.Util.indexOf(control.handles, feature);
                i += HGIS.Util.indexOf(control.rotationHandles,
                    feature);
                if(feature !== control.feature && feature !== control.box &&
                                                        i == -2 && eligible) {
                    control.setFeature(feature);
                }
            },
            onComplete: function(feature, pixel) {
                control.events.triggerEvent("transformcomplete",
                    {feature: control.feature});
            }
        });
    },
    
    /**
     * Method: drawHandles
     * Draws the handles to match the box.
     */
    drawHandles: function() {
        var layer = this.layer;
        for(var i=0; i<8; ++i) {
            if(this.rotate && i % 2 === 0) {
                layer.drawFeature(this.rotationHandles[i/2],
                    this.rotationHandleSymbolizer);
            }
            layer.drawFeature(this.handles[i], this.renderIntent);
        }
    },
    
    /**
     * Method: transformFeature
     * Transforms the feature.
     * 
     * Parameters:
     * mods - {Object} An object with optional scale, ratio, rotation and
     *     center properties.
     */
    transformFeature: function(mods) {
        if(!this._setfeature) {
            this.scale *= (mods.scale || 1);
            this.ratio *= (mods.ratio || 1);
            var oldRotation = this.rotation;
            this.rotation = (this.rotation + (mods.rotation || 0)) % 360;
            
            if(this.events.triggerEvent("beforetransform", mods) !== false) {
                var feature = this.feature;
                var geom = feature.geometry;
                var center = this.center;
                geom.rotate(-oldRotation, center);
                if(mods.scale || mods.ratio) {
                    geom.resize(mods.scale, center, mods.ratio);
                } else if(mods.center) {
                    feature.move(mods.center.getBounds().getCenterLonLat());
                }
                geom.rotate(this.rotation, center);
                this.layer.drawFeature(feature);
                feature.toState(HGIS.State.UPDATE);
                this.events.triggerEvent("transform", mods);
            }
        }
        this.layer.drawFeature(this.box, this.renderIntent);
        this.drawHandles();
    },
        
    /**
     * APIMethod: destroy
     * Take care of things that are not handled in superclass.
     */
    destroy: function() {
        var geom;
        for(var i=0; i<8; ++i) {
            geom = this.box.geometry.components[i];
            geom._handle.destroy();
            geom._handle = null;
            geom._rotationHandle && geom._rotationHandle.destroy();
            geom._rotationHandle = null;
        }
        this.center = null;
        this.feature = null;
        this.handles = null;
        this.rotationHandleSymbolizer = null;
        this.rotationHandles = null;
        this.box.destroy();
        this.box = null;
        this.layer = null;
        this.dragControl.destroy();
        this.dragControl = null;
        HGIS.Control.prototype.destroy.apply(this, arguments);
    },

    CLASS_NAME: "HGIS.Control.TransformFeature"
});
/* ======================================================================
    HGIS/Handler/Box.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Handler.js
 * @requires HGIS/Handler/Drag.js
 */

/**
 * Class: HGIS.Handler.Box
 * Handler for dragging a rectangle across the map.  Box is displayed 
 * on mouse down, moves on mouse move, and is finished on mouse up.
 *
 * Inherits from:
 *  - <HGIS.Handler> 
 */
HGIS.Handler.Box = HGIS.Class(HGIS.Handler, {

    /** 
     * Property: dragHandler 
     * {<HGIS.Handler.Drag>} 
     */
    dragHandler: null,

    /**
     * APIProperty: boxDivClassName
     * {String} The CSS class to use for drawing the box. Default is
     *     olHandlerBoxZoomBox
     */
    boxDivClassName: 'olHandlerBoxZoomBox',
    
    /**
     * Property: boxOffsets
     * {Object} Caches box offsets from css. This is used by the getBoxOffsets
     * method.
     */
    boxOffsets: null,

    /**
     * Constructor: HGIS.Handler.Box
     *
     * Parameters:
     * control - {<HGIS.Control>} 
     * callbacks - {Object} An object with a properties whose values are
     *     functions.  Various callbacks described below.
     * options - {Object} 
     *
     * Named callbacks:
     * start - Called when the box drag operation starts.
     * done - Called when the box drag operation is finished.
     *     The callback should expect to receive a single argument, the box 
     *     bounds or a pixel. If the box dragging didn't span more than a 5 
     *     pixel distance, a pixel will be returned instead of a bounds object.
     */
    initialize: function(control, callbacks, options) {
        HGIS.Handler.prototype.initialize.apply(this, arguments);
        this.dragHandler = new HGIS.Handler.Drag(
            this, 
            {
                down: this.startBox, 
                move: this.moveBox, 
                out: this.removeBox,
                up: this.endBox
            }, 
            {keyMask: this.keyMask}
        );
    },

    /**
     * Method: destroy
     */
    destroy: function() {
        HGIS.Handler.prototype.destroy.apply(this, arguments);
        if (this.dragHandler) {
            this.dragHandler.destroy();
            this.dragHandler = null;
        }            
    },

    /**
     * Method: setMap
     */
    setMap: function (map) {
        HGIS.Handler.prototype.setMap.apply(this, arguments);
        if (this.dragHandler) {
            this.dragHandler.setMap(map);
        }
    },

    /**
    * Method: startBox
    *
    * Parameters:
    * xy - {<HGIS.Pixel>}
    */
    startBox: function (xy) {
        this.callback("start", []);
        this.zoomBox = HGIS.Util.createDiv('zoomBox', {
            x: -9999, y: -9999
        });
        this.zoomBox.className = this.boxDivClassName;                                         
        this.zoomBox.style.zIndex = this.map.Z_INDEX_BASE["Popup"] - 1;
        
        this.map.viewPortDiv.appendChild(this.zoomBox);
        
        HGIS.Element.addClass(
            this.map.viewPortDiv, "olDrawBox"
        );
    },

    /**
    * Method: moveBox
    */
    moveBox: function (xy) {
        var startX = this.dragHandler.start.x;
        var startY = this.dragHandler.start.y;
        var deltaX = Math.abs(startX - xy.x);
        var deltaY = Math.abs(startY - xy.y);

        var offset = this.getBoxOffsets();
        this.zoomBox.style.width = (deltaX + offset.width + 1) + "px";
        this.zoomBox.style.height = (deltaY + offset.height + 1) + "px";
        this.zoomBox.style.left = (xy.x < startX ?
            startX - deltaX - offset.left : startX - offset.left) + "px";
        this.zoomBox.style.top = (xy.y < startY ?
            startY - deltaY - offset.top : startY - offset.top) + "px";
    },

    /**
    * Method: endBox
    */
    endBox: function(end) {
        var result;
        if (Math.abs(this.dragHandler.start.x - end.x) > 5 ||    
            Math.abs(this.dragHandler.start.y - end.y) > 5) {   
            var start = this.dragHandler.start;
            var top = Math.min(start.y, end.y);
            var bottom = Math.max(start.y, end.y);
            var left = Math.min(start.x, end.x);
            var right = Math.max(start.x, end.x);
            result = new HGIS.Bounds(left, bottom, right, top);
        } else {
            result = this.dragHandler.start.clone(); // i.e. OL.Pixel
        } 
        this.removeBox();

        this.callback("done", [result]);
    },

    /**
     * Method: removeBox
     * Remove the zoombox from the screen and nullify our reference to it.
     */
    removeBox: function() {
        this.map.viewPortDiv.removeChild(this.zoomBox);
        this.zoomBox = null;
        this.boxOffsets = null;
        HGIS.Element.removeClass(
            this.map.viewPortDiv, "olDrawBox"
        );

    },

    /**
     * Method: activate
     */
    activate: function () {
        if (HGIS.Handler.prototype.activate.apply(this, arguments)) {
            this.dragHandler.activate();
            return true;
        } else {
            return false;
        }
    },

    /**
     * Method: deactivate
     */
    deactivate: function () {
        if (HGIS.Handler.prototype.deactivate.apply(this, arguments)) {
            if (this.dragHandler.deactivate()) {
                if (this.zoomBox) {
                    this.removeBox();
                }
            }
            return true;
        } else {
            return false;
        }
    },
    
    /**
     * Method: getBoxOffsets
     * Determines border offsets for a box, according to the box model.
     * 
     * Returns:
     * {Object} an object with the following offsets:
     *     - left
     *     - right
     *     - top
     *     - bottom
     *     - width
     *     - height
     */
    getBoxOffsets: function() {
        if (!this.boxOffsets) {
            // Determine the box model. If the testDiv's clientWidth is 3, then
            // the borders are outside and we are dealing with the w3c box
            // model. Otherwise, the browser uses the traditional box model and
            // the borders are inside the box bounds, leaving us with a
            // clientWidth of 1.
            var testDiv = document.createElement("div");
            //testDiv.style.visibility = "hidden";
            testDiv.style.position = "absolute";
            testDiv.style.border = "1px solid black";
            testDiv.style.width = "3px";
            document.body.appendChild(testDiv);
            var w3cBoxModel = testDiv.clientWidth == 3;
            document.body.removeChild(testDiv);
            
            var left = parseInt(HGIS.Element.getStyle(this.zoomBox,
                "border-left-width"));
            var right = parseInt(HGIS.Element.getStyle(
                this.zoomBox, "border-right-width"));
            var top = parseInt(HGIS.Element.getStyle(this.zoomBox,
                "border-top-width"));
            var bottom = parseInt(HGIS.Element.getStyle(
                this.zoomBox, "border-bottom-width"));
            this.boxOffsets = {
                left: left,
                right: right,
                top: top,
                bottom: bottom,
                width: w3cBoxModel === false ? left + right : 0,
                height: w3cBoxModel === false ? top + bottom : 0
            };
        }
        return this.boxOffsets;
    },
  
    CLASS_NAME: "HGIS.Handler.Box"
});
/* ======================================================================
    HGIS/Control/ZoomBox.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Handler/Box.js
 */

/**
 * Class: HGIS.Control.ZoomBox
 * The ZoomBox control enables zooming directly to a given extent, by drawing 
 * a box on the map. The box is drawn by holding down shift, whilst dragging 
 * the mouse.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.ZoomBox = HGIS.Class(HGIS.Control, {
    /**
     * Property: type
     * {HGIS.Control.TYPE}
     */
    type: HGIS.Control.TYPE_TOOL,

    /**
     * Property: out
     * {Boolean} Should the control be used for zooming out?
     */
    out: false,

    /**
     * APIProperty: keyMask
     * {Integer} Zoom only occurs if the keyMask matches the combination of 
     *     keys down. Use bitwise operators and one or more of the
     *     <HGIS.Handler> constants to construct a keyMask. Leave null if 
     *     not used mask. Default is null.
     */
    keyMask: null,

    /**
     * APIProperty: alwaysZoom
     * {Boolean} Always zoom in/out when box drawn, even if the zoom level does
     * not change.
     */
    alwaysZoom: false,
    
    /**
     * APIProperty: zoomOnClick
     * {Boolean} Should we zoom when no box was dragged, i.e. the user only
     * clicked? Default is true.
     */
    zoomOnClick: true,

    /**
     * Method: draw
     */    
    draw: function() {
        this.handler = new HGIS.Handler.Box( this,
                            {done: this.zoomBox}, {keyMask: this.keyMask} );
    },

    /**
     * Method: zoomBox
     *
     * Parameters:
     * position - {<HGIS.Bounds>} or {<HGIS.Pixel>}
     */
    zoomBox: function (position) {
        if (position instanceof HGIS.Bounds) {
            var bounds,
                targetCenterPx = position.getCenterPixel();
            if (!this.out) {
                var minXY = this.map.getLonLatFromPixel({
                    x: position.left,
                    y: position.bottom
                });
                var maxXY = this.map.getLonLatFromPixel({
                    x: position.right,
                    y: position.top
                });
                bounds = new HGIS.Bounds(minXY.lon, minXY.lat,
                                               maxXY.lon, maxXY.lat);
            } else {
                var pixWidth = position.right - position.left;
                var pixHeight = position.bottom - position.top;
                var zoomFactor = Math.min((this.map.size.h / pixHeight),
                    (this.map.size.w / pixWidth));
                var extent = this.map.getExtent();
                var center = this.map.getLonLatFromPixel(targetCenterPx);
                var xmin = center.lon - (extent.getWidth()/2)*zoomFactor;
                var xmax = center.lon + (extent.getWidth()/2)*zoomFactor;
                var ymin = center.lat - (extent.getHeight()/2)*zoomFactor;
                var ymax = center.lat + (extent.getHeight()/2)*zoomFactor;
                bounds = new HGIS.Bounds(xmin, ymin, xmax, ymax);
            }
            // always zoom in/out 
            var lastZoom = this.map.getZoom(),
                size = this.map.getSize(),
                centerPx = {x: size.w / 2, y: size.h / 2},
                zoom = this.map.getZoomForExtent(bounds),
                oldRes = this.map.getResolution(),
                newRes = this.map.getResolutionForZoom(zoom);
            if (oldRes == newRes) {
                this.map.setCenter(this.map.getLonLatFromPixel(targetCenterPx));
            } else {
              var zoomOriginPx = {
                    x: (oldRes * targetCenterPx.x - newRes * centerPx.x) /
                        (oldRes - newRes),
                    y: (oldRes * targetCenterPx.y - newRes * centerPx.y) /
                        (oldRes - newRes)
                };
                this.map.zoomTo(zoom, zoomOriginPx);
            }
            if (lastZoom == this.map.getZoom() && this.alwaysZoom == true){ 
                this.map.zoomTo(lastZoom + (this.out ? -1 : 1)); 
            }
        } else if (this.zoomOnClick) { // it's a pixel
            if (!this.out) {
                this.map.zoomTo(this.map.getZoom() + 1, position);
            } else {
                this.map.zoomTo(this.map.getZoom() - 1, position);
            }
        }
    },

    CLASS_NAME: "HGIS.Control.ZoomBox"
});
/* ======================================================================
    HGIS/Control/DragPan.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Handler/Drag.js
 */

/**
 * Class: HGIS.Control.DragPan
 * The DragPan control pans the map with a drag of the mouse.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.DragPan = HGIS.Class(HGIS.Control, {

    /** 
     * Property: type
     * {HGIS.Control.TYPES}
     */
    type: HGIS.Control.TYPE_TOOL,
    
    /**
     * Property: panned
     * {Boolean} The map moved.
     */
    panned: false,
    
    /**
     * Property: interval
     * {Integer} The number of milliseconds that should ellapse before
     *     panning the map again. Defaults to 0 milliseconds, which means that
     *     no separate cycle is used for panning. In most cases you won't want
     *     to change this value. For slow machines/devices larger values can be
     *     tried out.
     */
    interval: 0,
    
    /**
     * APIProperty: documentDrag
     * {Boolean} If set to true, mouse dragging will continue even if the
     *     mouse cursor leaves the map viewport. Default is false.
     */
    documentDrag: false,

    /**
     * Property: kinetic
     * {<HGIS.Kinetic>} The HGIS.Kinetic object.
     */
    kinetic: null,

    /**
     * APIProperty: enableKinetic
     * {Boolean} Set this option to enable "kinetic dragging". Can be
     *     set to true or to an object. If set to an object this
     *     object will be passed to the {<HGIS.Kinetic>}
     *     constructor. Defaults to true.
     *     To get kinetic dragging, ensure that HGIS/Kinetic.js is
     *     included in your build config.
     */
    enableKinetic: true,

    /**
     * APIProperty: kineticInterval
     * {Integer} Interval in milliseconds between 2 steps in the "kinetic
     *     scrolling". Applies only if enableKinetic is set. Defaults
     *     to 10 milliseconds.
     */
    kineticInterval: 10,


    /**
     * Method: draw
     * Creates a Drag handler, using <panMap> and
     * <panMapDone> as callbacks.
     */    
    draw: function() {
        if (this.enableKinetic && HGIS.Kinetic) {
            var config = {interval: this.kineticInterval};
            if(typeof this.enableKinetic === "object") {
                config = HGIS.Util.extend(config, this.enableKinetic);
            }
            this.kinetic = new HGIS.Kinetic(config);
            this.interval = this.kinetic.interval?this.kinetic.interval:0;
        }
        this.handler = new HGIS.Handler.Drag(this, {
                "move": this.panMap,
                "done": this.panMapDone,
                "down": this.panMapStart
            }, {
                interval: this.interval,
                documentDrag: this.documentDrag
            }
        );
    },

    /**
     * Method: panMapStart
     */
    panMapStart: function() {
        if(this.kinetic) {
            this.kinetic.begin();
        }
    },

    /**
    * Method: panMap
    *
    * Parameters:
    * xy - {<HGIS.Pixel>} Pixel of the mouse position
    */
    panMap: function(xy) {
        if(this.kinetic) {
            this.kinetic.update(xy);
        }
        this.panned = true;
        this.map.pan(
            this.handler.last.x - xy.x,
            this.handler.last.y - xy.y,
            {dragging: true, animate: false}
        );
    },
    
    /**
     * Method: panMapDone
     * Finish the panning operation.  Only call setCenter (through <panMap>)
     *     if the map has actually been moved.
     *
     * Parameters:
     * xy - {<HGIS.Pixel>} Pixel of the mouse position
     */
    panMapDone: function(xy) {
        if(this.panned) {
            var res = null;
            if (this.kinetic) {
                res = this.kinetic.end(xy);
            }
            this.map.pan(
                this.handler.last.x - xy.x,
                this.handler.last.y - xy.y,
                {dragging: !!res, animate: false}
            );
            if (res) {
                var self = this;
                this.kinetic.move(res, function(x, y, end) {
                    self.map.pan(x, y, {dragging: !end, animate: false});
                });
            }
            this.panned = false;
        }
    },

    CLASS_NAME: "HGIS.Control.DragPan"
});
/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
* full list of contributors). Published under the 2-clause BSD license.
* See license.txt in the HGIS distribution or repository for the
* full text of the license. */

/**
 * @requires HGIS/Control/ZoomBox.js
 * @requires HGIS/Control/DragPan.js
 * @requires HGIS/Handler/MouseWheel.js
 * @requires HGIS/Handler/Click.js
 */

/**
 * Class: HGIS.Control.Navigation
 * 此控件处理伴随鼠标事件（拖拽，双击、鼠标滚轮缩放）的地图浏览， 如果创建地图时没有设置任何控件，此控件会默认添加到地图。
 *
 * Inherits:
 *  - <HGIS.Control>
 */
HGIS.Control.Navigation = HGIS.Class(HGIS.Control, {

	/**
	 * Property: dragPan
	 * {<HGIS.Control.DragPan>}
	 */
	dragPan : null,

	/**
	 * APIProperty: dragPanOptions
	 * {Object} 传给 DragPan 控件的属性。
	 */
	dragPanOptions : null,

	/**
	 * Property: pinchZoom
	 * {<HGIS.Control.PinchZoom>}
	 */
	pinchZoom : null,

	/**
	 * APIProperty: pinchZoomOptions
	 * {Object} 传给 PinchZoom 控件的属性。
	 */
	pinchZoomOptions : null,

	/**
	 * APIProperty: documentDrag
	 * {Boolean}  允许拖拽地图，使地图能够平移到视图窗口外。默认为false。
	 */
	documentDrag : false,

	/**
	 * Property: zoomBox
	 * {<HGIS.Control.ZoomBox>}
	 */
	zoomBox : null,

	/**
	 * APIProperty: zoomBoxEnabled
	 * {Boolean} 用户是否可以画一个框缩放
	 */
	zoomBoxEnabled : true,

	/**
	 * APIProperty: zoomWheelEnabled
	 * {Boolean} 是否允许用户滑动鼠标滚轴缩放地图，默认为true。
	 */
	zoomWheelEnabled : true,

	/**
	 * Property: mouseWheelOptions
	 * {Object} Options passed to the MouseWheel control (only useful if
	 *     <zoomWheelEnabled> is set to true). Default is no options for maps
	 *     with fractionalZoom set to true, otherwise
	 *     {cumulative: false, interval: 50, maxDelta: 6}
	 */
	mouseWheelOptions : null,

	/**
	 * APIProperty: handleRightClicks
	 * {Boolean} 是否处理右击事件，默认不处理.
	 */
	handleRightClicks : false,

	/**
	 * APIProperty: zoomBoxKeyMask
	 * {Integer} <HGIS.Handler> 默认为HGIS.Handler.MOD_SHIFT。详见<HGIS.Handler>
	 */
	zoomBoxKeyMask : HGIS.Handler.MOD_SHIFT,

	/**
	 * APIProperty: autoActivate
	 * {Boolean} 控件在加载到地图后自动激活，默认为true。
	 */
	autoActivate : true,

	/**
	 * Constructor: HGIS.Control.Navigation
	 * 创建一个导航条控件。
	 *
	 * Parameters:
	 * options - {Object} 该控件的可选属性
	 */
	initialize : function(options) {
		this.handlers = {};
		HGIS.Control.prototype.initialize.apply(this, arguments);
	},
	/**
	 * Method: destroy
	 * The destroy method is used to perform any clean up before the control
	 * is dereferenced.  Typically this is where event listeners are removed
	 * to prevent memory leaks.
	 */
	destroy : function() {
		this.deactivate();

		if(this.dragPan) {
			this.dragPan.destroy();
		}
		this.dragPan = null;

		if(this.zoomBox) {
			this.zoomBox.destroy();
		}
		this.zoomBox = null;

		if(this.pinchZoom) {
			this.pinchZoom.destroy();
		}
		this.pinchZoom = null;

		HGIS.Control.prototype.destroy.apply(this, arguments);
	},
	/**
	 * Method: activate
	 */
	activate : function() {
		this.dragPan.activate();
		if(this.zoomWheelEnabled) {
			this.handlers.wheel.activate();
		}
		this.handlers.click.activate();
		if(this.zoomBoxEnabled) {
			this.zoomBox.activate();
		}
		if(this.pinchZoom) {
			this.pinchZoom.activate();
		}
		return HGIS.Control.prototype.activate.apply(this, arguments);
	},
	/**
	 * Method: deactivate
	 */
	deactivate : function() {
		if(this.pinchZoom) {
			this.pinchZoom.deactivate();
		}
		this.zoomBox.deactivate();
		this.dragPan.deactivate();
		this.handlers.click.deactivate();
		this.handlers.wheel.deactivate();
		return HGIS.Control.prototype.deactivate.apply(this, arguments);
	},
	/**
	 * Method: draw
	 */
	draw : function() {
		// disable right mouse context menu for support of right click events
		if(this.handleRightClicks) {
			this.map.viewPortDiv.oncontextmenu = HGIS.Function.False;
		}

		var clickCallbacks = {
			'click' : this.defaultClick,
			'dblclick' : this.defaultDblClick,
			'dblrightclick' : this.defaultDblRightClick
		};
		var clickOptions = {
			'double' : true,
			'stopDouble' : true
		};
		this.handlers.click = new HGIS.Handler.Click(this, clickCallbacks, clickOptions);
		this.dragPan = new HGIS.Control.DragPan(HGIS.Util.extend({
			map : this.map,
			documentDrag : this.documentDrag
		}, this.dragPanOptions));
		this.zoomBox = new HGIS.Control.ZoomBox({
			map : this.map,
			keyMask : this.zoomBoxKeyMask
		});
		this.dragPan.draw();
		this.zoomBox.draw();
		var wheelOptions = this.map.fractionalZoom ? {} : {
			cumulative : false,
			interval : 50,
			maxDelta : 6
		};
		this.handlers.wheel = new HGIS.Handler.MouseWheel(this, {
			up : this.wheelUp,
			down : this.wheelDown
		}, HGIS.Util.extend(wheelOptions, this.mouseWheelOptions));
		if(HGIS.Control.PinchZoom) {
			this.pinchZoom = new HGIS.Control.PinchZoom(HGIS.Util.extend({
				map : this.map
			}, this.pinchZoomOptions));
		}
	},
	/**
	 * Method: defaultClick
	 *
	 * Parameters:
	 * evt - {Event}
	 */
	defaultClick : function(evt) {
		if(evt.lastTouches && evt.lastTouches.length == 2) {
			this.map.zoomOut();
		}
	},
	/**
	 * Method: defaultDblClick
	 *
	 * Parameters:
	 * evt - {Event}
	 */
	defaultDblClick : function(evt) {
		this.map.zoomTo(this.map.zoom + 1, evt.xy);
	},
	/**
	 * Method: defaultDblRightClick
	 *
	 * Parameters:
	 * evt - {Event}
	 */
	defaultDblRightClick : function(evt) {
		this.map.zoomTo(this.map.zoom - 1, evt.xy);
	},
	/**
	 * Method: wheelChange
	 *
	 * Parameters:
	 * evt - {Event}
	 * deltaZ - {Integer}
	 */
	wheelChange : function(evt, deltaZ) {
		if(!this.map.fractionalZoom) {
			deltaZ = Math.round(deltaZ);
		}
		var currentZoom = this.map.getZoom(), newZoom = currentZoom + deltaZ;
		  //修改达到最小级别时，不进行操作
		if(HGIS.InitParam.minLevel){
			newZoom = Math.max(newZoom, HGIS.InitParam.minLevel);
		}else{
			newZoom = Math.max(newZoom, 0);
		}
		newZoom = Math.min(newZoom, this.map.getNumZoomLevels());
		if(newZoom === currentZoom) {
			return;
		}
		this.map.zoomTo(newZoom, evt.xy);
	},
	/**
	 * Method: wheelUp
	 * User spun scroll wheel up
	 *
	 * Parameters:
	 * evt - {Event}
	 * delta - {Integer}
	 */
	wheelUp : function(evt, delta) {
		this.wheelChange(evt, delta || 1);
	},
	/**
	 * Method: wheelDown
	 * User spun scroll wheel down
	 *
	 * Parameters:
	 * evt - {Event}
	 * delta - {Integer}
	 */
	wheelDown : function(evt, delta) {
		this.wheelChange(evt, delta || -1);
	},
	/**
	 * Method: disableZoomBox
	 */
	disableZoomBox : function() {
		this.zoomBoxEnabled = false;
		this.zoomBox.deactivate();
	},
	/**
	 * Method: enableZoomBox
	 */
	enableZoomBox : function() {
		this.zoomBoxEnabled = true;
		if(this.active) {
			this.zoomBox.activate();
		}
	},
	/**
	 * Method: disableZoomWheel
	 */

	disableZoomWheel : function() {
		this.zoomWheelEnabled = false;
		this.handlers.wheel.deactivate();
	},
	/**
	 * Method: enableZoomWheel
	 */

	enableZoomWheel : function() {
		this.zoomWheelEnabled = true;
		if(this.active) {
			this.handlers.wheel.activate();
		}
	},
	CLASS_NAME : "HGIS.Control.Navigation"
});
/* ======================================================================
    HGIS/Control/DrawFeature.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Control.js
 * @requires HGIS/Feature/Vector.js
 */

/**
 * Class: HGIS.Control.DrawFeature
 * The DrawFeature control draws point, line or polygon features on a vector
 * layer when active.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.DrawFeature = HGIS.Class(HGIS.Control, {
    
    /**
     * Property: layer
     * {<HGIS.Layer.Vector>}
     */
    layer: null,

    /**
     * Property: callbacks
     * {Object} The functions that are sent to the handler for callback
     */
    callbacks: null,
    
    /** 
     * APIProperty: events
     * {<HGIS.Events>} Events instance for listeners and triggering
     *     control specific events.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types (in addition to those from <HGIS.Control.events>):
     * featureadded - Triggered when a feature is added
     */
    
    /**
     * APIProperty: multi
     * {Boolean} Cast features to multi-part geometries before passing to the
     *     layer.  Default is false.
     */
    multi: false,

    /**
     * APIProperty: featureAdded
     * {Function} Called after each feature is added
     */
    featureAdded: function() {},

    /**
     * APIProperty: handlerOptions
     * {Object} Used to set non-default properties on the control's handler
     */
    
    /**
     * Constructor: HGIS.Control.DrawFeature
     * 
     * Parameters:
     * layer - {<HGIS.Layer.Vector>} 
     * handler - {<HGIS.Handler>} 
     * options - {Object} 
     */
    initialize: function(layer, handler, options) {
        HGIS.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = HGIS.Util.extend(
            {
                done: this.drawFeature,
                modify: function(vertex, feature) {
                    this.layer.events.triggerEvent(
                        "sketchmodified", {vertex: vertex, feature: feature}
                    );
                },
                create: function(vertex, feature) {
                    this.layer.events.triggerEvent(
                        "sketchstarted", {vertex: vertex, feature: feature}
                    );
                }
            },
            this.callbacks
        );
        this.layer = layer;
        this.handlerOptions = this.handlerOptions || {};
        this.handlerOptions.layerOptions = HGIS.Util.applyDefaults(
            this.handlerOptions.layerOptions, {
                renderers: layer.renderers, rendererOptions: layer.rendererOptions
            }
        );
        if (!("multi" in this.handlerOptions)) {
            this.handlerOptions.multi = this.multi;
        }
        var sketchStyle = this.layer.styleMap && this.layer.styleMap.styles.temporary;
        if(sketchStyle) {
            this.handlerOptions.layerOptions = HGIS.Util.applyDefaults(
                this.handlerOptions.layerOptions,
                {styleMap: new HGIS.StyleMap({"default": sketchStyle})}
            );
        }
        this.handler = new handler(this, this.callbacks, this.handlerOptions);
    },

    /**
     * Method: drawFeature
     */
    drawFeature: function(geometry) {
        var feature = new HGIS.Feature.Vector(geometry);
        var proceed = this.layer.events.triggerEvent(
            "sketchcomplete", {feature: feature}
        );
        if(proceed !== false) {
            feature.state = HGIS.State.INSERT;
            this.layer.addFeatures([feature]);
            this.featureAdded(feature);
            this.events.triggerEvent("featureadded",{feature : feature});
        }
    },
    
    /**
     * APIMethod: insertXY
     * Insert a point in the current sketch given x & y coordinates.
     *
     * Parameters:
     * x - {Number} The x-coordinate of the point.
     * y - {Number} The y-coordinate of the point.
     */
    insertXY: function(x, y) {
        if (this.handler && this.handler.line) {
            this.handler.insertXY(x, y);
        }
    },

    /**
     * APIMethod: insertDeltaXY
     * Insert a point given offsets from the previously inserted point.
     *
     * Parameters:
     * dx - {Number} The x-coordinate offset of the point.
     * dy - {Number} The y-coordinate offset of the point.
     */
    insertDeltaXY: function(dx, dy) {
        if (this.handler && this.handler.line) {
            this.handler.insertDeltaXY(dx, dy);
        }
    },

    /**
     * APIMethod: insertDirectionLength
     * Insert a point in the current sketch given a direction and a length.
     *
     * Parameters:
     * direction - {Number} Degrees clockwise from the positive x-axis.
     * length - {Number} Distance from the previously drawn point.
     */
    insertDirectionLength: function(direction, length) {
        if (this.handler && this.handler.line) {
            this.handler.insertDirectionLength(direction, length);
        }
    },

    /**
     * APIMethod: insertDeflectionLength
     * Insert a point in the current sketch given a deflection and a length.
     *     The deflection should be degrees clockwise from the previously 
     *     digitized segment.
     *
     * Parameters:
     * deflection - {Number} Degrees clockwise from the previous segment.
     * length - {Number} Distance from the previously drawn point.
     */
    insertDeflectionLength: function(deflection, length) {
        if (this.handler && this.handler.line) {
            this.handler.insertDeflectionLength(deflection, length);
        }
    },
    
    /**
     * APIMethod: undo
     * Remove the most recently added point in the current sketch geometry.
     *
     * Returns: 
     * {Boolean} An edit was undone.
     */
    undo: function() {
        return this.handler.undo && this.handler.undo();
    },
    
    /**
     * APIMethod: redo
     * Reinsert the most recently removed point resulting from an <undo> call.
     *     The undo stack is deleted whenever a point is added by other means.
     *
     * Returns: 
     * {Boolean} An edit was redone.
     */
    redo: function() {
        return this.handler.redo && this.handler.redo();
    },
    
    /**
     * APIMethod: finishSketch
     * Finishes the sketch without including the currently drawn point.
     *     This method can be called to terminate drawing programmatically
     *     instead of waiting for the user to end the sketch.
     */
    finishSketch: function() {
        this.handler.finishGeometry();
    },

    /**
     * APIMethod: cancel
     * Cancel the current sketch.  This removes the current sketch and keeps
     *     the drawing control active.
     */
    cancel: function() {
        this.handler.cancel();
    },

    CLASS_NAME: "HGIS.Control.DrawFeature"
});
/* ======================================================================
    HGIS/Handler/Polygon.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Handler/Path.js
 * @requires HGIS/Geometry/Polygon.js
 */

/**
 * Class: HGIS.Handler.Polygon
 * Handler to draw a polygon on the map.  Polygon is displayed on mouse down,
 * moves on mouse move, and is finished on mouse up.
 *
 * Inherits from:
 *  - <HGIS.Handler.Path>
 *  - <HGIS.Handler>
 */
HGIS.Handler.Polygon = HGIS.Class(HGIS.Handler.Path, {
    
    /** 
     * APIProperty: holeModifier
     * {String} Key modifier to trigger hole digitizing.  Acceptable values are
     *     "altKey", "shiftKey", or "ctrlKey".  If not set, no hole digitizing
     *     will take place.  Default is null.
     */
    holeModifier: null,
    
    /**
     * Property: drawingHole
     * {Boolean} Currently drawing an interior ring.
     */
    drawingHole: false,
    
    /**
     * Property: polygon
     * {<HGIS.Feature.Vector>}
     */
    polygon: null,

    /**
     * Constructor: HGIS.Handler.Polygon
     * Create a Polygon Handler.
     *
     * Parameters:
     * control - {<HGIS.Control>} The control that owns this handler
     * callbacks - {Object} An object with a properties whose values are
     *     functions.  Various callbacks described below.
     * options - {Object} An optional object with properties to be set on the
     *           handler
     *
     * Named callbacks:
     * create - Called when a sketch is first created.  Callback called with
     *     the creation point geometry and sketch feature.
     * modify - Called with each move of a vertex with the vertex (point)
     *     geometry and the sketch feature.
     * point - Called as each point is added.  Receives the new point geometry.
     * done - Called when the point drawing is finished.  The callback will
     *     recieve a single argument, the polygon geometry.
     * cancel - Called when the handler is deactivated while drawing.  The
     *     cancel callback will receive a geometry.
     */
    
    /**
     * Method: createFeature
     * Add temporary geometries
     *
     * Parameters:
     * pixel - {<HGIS.Pixel>} The initial pixel location for the new
     *     feature.
     */
    createFeature: function(pixel) {
        var lonlat = this.layer.getLonLatFromViewPortPx(pixel);
        var geometry = new HGIS.Geometry.Point(
            lonlat.lon, lonlat.lat
        );
        this.point = new HGIS.Feature.Vector(geometry);
        this.line = new HGIS.Feature.Vector(
            new HGIS.Geometry.LinearRing([this.point.geometry])
        );
        this.polygon = new HGIS.Feature.Vector(
            new HGIS.Geometry.Polygon([this.line.geometry])
        );
        this.callback("create", [this.point.geometry, this.getSketch()]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.polygon, this.point], {silent: true});
    },

    /**
     * Method: addPoint
     * Add point to geometry.
     *
     * Parameters:
     * pixel - {<HGIS.Pixel>} The pixel location for the new point.
     */
    addPoint: function(pixel) {
        if(!this.drawingHole && this.holeModifier &&
           this.evt && this.evt[this.holeModifier]) {
            var geometry = this.point.geometry;
            var features = this.control.layer.features;
            var candidate, polygon;
            // look for intersections, last drawn gets priority
            for (var i=features.length-1; i>=0; --i) {
                candidate = features[i].geometry;
                if ((candidate instanceof HGIS.Geometry.Polygon || 
                    candidate instanceof HGIS.Geometry.MultiPolygon) && 
                    candidate.intersects(geometry)) {
                    polygon = features[i];
                    this.control.layer.removeFeatures([polygon], {silent: true});
                    this.control.layer.events.registerPriority(
                        "sketchcomplete", this, this.finalizeInteriorRing
                    );
                    this.control.layer.events.registerPriority(
                        "sketchmodified", this, this.enforceTopology
                    );
                    polygon.geometry.addComponent(this.line.geometry);
                    this.polygon = polygon;
                    this.drawingHole = true;
                    break;
                }
            }
        }
        HGIS.Handler.Path.prototype.addPoint.apply(this, arguments);
    },

    /**
     * Method: getCurrentPointIndex
     * 
     * Returns:
     * {Number} The index of the most recently drawn point.
     */
    getCurrentPointIndex: function() {
        return this.line.geometry.components.length - 2;
    },

    /**
     * Method: enforceTopology
     * Simple topology enforcement for drawing interior rings.  Ensures vertices
     *     of interior rings are contained by exterior ring.  Other topology 
     *     rules are enforced in <finalizeInteriorRing> to allow drawing of 
     *     rings that intersect only during the sketch (e.g. a "C" shaped ring
     *     that nearly encloses another ring).
     */
    enforceTopology: function(event) {
        var point = event.vertex;
        var components = this.line.geometry.components;
        // ensure that vertices of interior ring are contained by exterior ring
        if (!this.polygon.geometry.intersects(point)) {
            var last = components[components.length-3];
            point.x = last.x;
            point.y = last.y;
        }
    },

    /**
     * Method: finishGeometry
     * Finish the geometry and send it back to the control.
     */
    finishGeometry: function() {
        var index = this.line.geometry.components.length - 2;
        this.line.geometry.removeComponent(this.line.geometry.components[index]);
        this.removePoint();
        this.finalize();
    },

    /**
     * Method: finalizeInteriorRing
     * Enforces that new ring has some area and doesn't contain vertices of any
     *     other rings.
     */
    finalizeInteriorRing: function() {
        var ring = this.line.geometry;
        // ensure that ring has some area
        var modified = (ring.getArea() !== 0);
        if (modified) {
            // ensure that new ring doesn't intersect any other rings
            var rings = this.polygon.geometry.components;
            for (var i=rings.length-2; i>=0; --i) {
                if (ring.intersects(rings[i])) {
                    modified = false;
                    break;
                }
            }
            if (modified) {
                // ensure that new ring doesn't contain any other rings
                var target;
                outer: for (var i=rings.length-2; i>0; --i) {
                    var points = rings[i].components;
                    for (var j=0, jj=points.length; j<jj; ++j) {
                        if (ring.containsPoint(points[j])) {
                            modified = false;
                            break outer;
                        }
                    }
                }
            }
        }
        if (modified) {
            if (this.polygon.state !== HGIS.State.INSERT) {
                this.polygon.state = HGIS.State.UPDATE;
            }
        } else {
            this.polygon.geometry.removeComponent(ring);
        }
        this.restoreFeature();
        return false;
    },

    /**
     * APIMethod: cancel
     * Finish the geometry and call the "cancel" callback.
     */
    cancel: function() {
        if (this.drawingHole) {
            this.polygon.geometry.removeComponent(this.line.geometry);
            this.restoreFeature(true);
        }
        return HGIS.Handler.Path.prototype.cancel.apply(this, arguments);
    },
    
    /**
     * Method: restoreFeature
     * Move the feature from the sketch layer to the target layer.
     *
     * Properties: 
     * cancel - {Boolean} Cancel drawing.  If falsey, the "sketchcomplete" event
     *     will be fired.
     */
    restoreFeature: function(cancel) {
        this.control.layer.events.unregister(
            "sketchcomplete", this, this.finalizeInteriorRing
        );
        this.control.layer.events.unregister(
            "sketchmodified", this, this.enforceTopology
        );
        this.layer.removeFeatures([this.polygon], {silent: true});
        this.control.layer.addFeatures([this.polygon], {silent: true});
        this.drawingHole = false;
        if (!cancel) {
            // Re-trigger "sketchcomplete" so other listeners can do their
            // business.  While this is somewhat sloppy (if a listener is 
            // registered with registerPriority - not common - between the start
            // and end of a single ring drawing - very uncommon - it will be 
            // called twice).
            // TODO: In 3.0, collapse sketch handlers into geometry specific
            // drawing controls.
            this.control.layer.events.triggerEvent(
                "sketchcomplete", {feature : this.polygon}
            );
        }
    },

    /**
     * Method: destroyFeature
     * Destroy temporary geometries
     *
     * Parameters:
     * force - {Boolean} Destroy even if persist is true.
     */
    destroyFeature: function(force) {
        HGIS.Handler.Path.prototype.destroyFeature.call(
            this, force);
        this.polygon = null;
    },

    /**
     * Method: drawFeature
     * Render geometries on the temporary layer.
     */
    drawFeature: function() {
        this.layer.drawFeature(this.polygon, this.style);
        this.layer.drawFeature(this.point, this.style);
    },
    
    /**
     * Method: getSketch
     * Return the sketch feature.
     *
     * Returns:
     * {<HGIS.Feature.Vector>}
     */
    getSketch: function() {
        return this.polygon;
    },

    /**
     * Method: getGeometry
     * Return the sketch geometry.  If <multi> is true, this will return
     *     a multi-part geometry.
     *
     * Returns:
     * {<HGIS.Geometry.Polygon>}
     */
    getGeometry: function() {
        var geometry = this.polygon && this.polygon.geometry;
        if(geometry && this.multi) {
            geometry = new HGIS.Geometry.MultiPolygon([geometry]);
        }
        return geometry;
    },

    CLASS_NAME: "HGIS.Handler.Polygon"
});
/* ======================================================================
    HGIS/Control/EditingToolbar.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control/Panel.js
 * @requires HGIS/Control/Navigation.js
 * @requires HGIS/Control/DrawFeature.js
 * @requires HGIS/Handler/Point.js
 * @requires HGIS/Handler/Path.js
 * @requires HGIS/Handler/Polygon.js
 */

/**
 * Class: HGIS.Control.EditingToolbar 
 * The EditingToolbar is a panel of 4 controls to draw polygons, lines, 
 * points, or to navigate the map by panning. By default it appears in the 
 * upper right corner of the map.
 * 
 * Inherits from:
 *  - <HGIS.Control.Panel>
 */
HGIS.Control.EditingToolbar = HGIS.Class(
  HGIS.Control.Panel, {

    /**
     * APIProperty: citeCompliant
     * {Boolean} If set to true, coordinates of features drawn in a map extent
     * crossing the date line won't exceed the world bounds. Default is false.
     */
    citeCompliant: false,

    /**
     * Constructor: HGIS.Control.EditingToolbar
     * Create an editing toolbar for a given layer. 
     *
     * Parameters:
     * layer - {<HGIS.Layer.Vector>} 
     * options - {Object} 
     */
    initialize: function(layer, options) {
        HGIS.Control.Panel.prototype.initialize.apply(this, [options]);
        
        this.addControls(
          [ new HGIS.Control.Navigation() ]
        );  
        var controls = [
            new HGIS.Control.DrawFeature(layer, HGIS.Handler.Point, {
                displayClass: 'olControlDrawFeaturePoint',
                handlerOptions: {citeCompliant: this.citeCompliant}
            }),
            new HGIS.Control.DrawFeature(layer, HGIS.Handler.Path, {
                displayClass: 'olControlDrawFeaturePath',
                handlerOptions: {citeCompliant: this.citeCompliant}
            }),
            new HGIS.Control.DrawFeature(layer, HGIS.Handler.Polygon, {
                displayClass: 'olControlDrawFeaturePolygon',
                handlerOptions: {citeCompliant: this.citeCompliant}
            })
        ];
        this.addControls(controls);
    },

    /**
     * Method: draw
     * calls the default draw, and then activates mouse defaults.
     *
     * Returns:
     * {DOMElement}
     */
    draw: function() {
        var div = HGIS.Control.Panel.prototype.draw.apply(this, arguments);
        if (this.defaultControl === null) {
            this.defaultControl = this.controls[0];
        }
        return div;
    },

    CLASS_NAME: "HGIS.Control.EditingToolbar"
});    
/* ======================================================================
    HGIS/Strategy/BBOX.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Strategy.js
 * @requires HGIS/Filter/Spatial.js
 */

/**
 * Class: HGIS.Strategy.BBOX
 * A simple strategy that reads new features when the viewport invalidates
 *     some bounds.
 *
 * Inherits from:
 *  - <HGIS.Strategy>
 */
HGIS.Strategy.BBOX = HGIS.Class(HGIS.Strategy, {
    
    /**
     * Property: bounds
     * {<HGIS.Bounds>} The current data bounds (in the same projection
     *     as the layer - not always the same projection as the map).
     */
    bounds: null,
    
    /** 
     * Property: resolution 
     * {Float} The current data resolution. 
     */ 
    resolution: null, 
           
    /**
     * APIProperty: ratio
     * {Float} The ratio of the data bounds to the viewport bounds (in each
     *     dimension).  Default is 2.
     */
    ratio: 2,

    /** 
     * Property: resFactor 
     * {Float} Optional factor used to determine when previously requested 
     *     features are invalid.  If set, the resFactor will be compared to the
     *     resolution of the previous request to the current map resolution.
     *     If resFactor > (old / new) and 1/resFactor < (old / new).  If you
     *     set a resFactor of 1, data will be requested every time the
     *     resolution changes.  If you set a resFactor of 3, data will be
     *     requested if the old resolution is 3 times the new, or if the new is
     *     3 times the old.  If the old bounds do not contain the new bounds
     *     new data will always be requested (with or without considering
     *     resFactor). 
     */ 
    resFactor: null, 
    
    /**
     * Property: response
     * {<HGIS.Protocol.Response>} The protocol response object returned
     *      by the layer protocol.
     */
    response: null,

    /**
     * Constructor: HGIS.Strategy.BBOX
     * Create a new BBOX strategy.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
    
    /**
     * Method: activate
     * Set up strategy with regard to reading new batches of remote data.
     * 
     * Returns:
     * {Boolean} The strategy was successfully activated.
     */
    activate: function() {
        var activated = HGIS.Strategy.prototype.activate.call(this);
        if(activated) {
            this.layer.events.on({
                "moveend": this.update,
                "refresh": this.update,
                "visibilitychanged": this.update,
                scope: this
            });
            this.update();
        }
        return activated;
    },
    
    /**
     * Method: deactivate
     * Tear down strategy with regard to reading new batches of remote data.
     * 
     * Returns:
     * {Boolean} The strategy was successfully deactivated.
     */
    deactivate: function() {
        var deactivated = HGIS.Strategy.prototype.deactivate.call(this);
        if(deactivated) {
            this.layer.events.un({
                "moveend": this.update,
                "refresh": this.update,
                "visibilitychanged": this.update,
                scope: this
            });
        }
        return deactivated;
    },

    /**
     * Method: update
     * Callback function called on "moveend" or "refresh" layer events.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will determine
     *     the behaviour of this Strategy
     *
     * Valid options include:
     * force - {Boolean} if true, new data must be unconditionally read.
     * noAbort - {Boolean} if true, do not abort previous requests.
     */
    update: function(options) {
        var mapBounds = this.getMapBounds();
        if (mapBounds !== null && ((options && options.force) ||
          (this.layer.visibility && this.layer.calculateInRange() && this.invalidBounds(mapBounds)))) {
            this.calculateBounds(mapBounds);
            this.resolution = this.layer.map.getResolution(); 
            this.triggerRead(options);
        }
    },
    
    /**
     * Method: getMapBounds
     * Get the map bounds expressed in the same projection as this layer.
     *
     * Returns:
     * {<HGIS.Bounds>} Map bounds in the projection of the layer.
     */
    getMapBounds: function() {
        if (this.layer.map === null) {
            return null;
        }
        var bounds = this.layer.map.getExtent();
        if(bounds && !this.layer.projection.equals(
                this.layer.map.getProjectionObject())) {
            bounds = bounds.clone().transform(
                this.layer.map.getProjectionObject(), this.layer.projection
            );
        }
        return bounds;
    },

    /**
     * Method: invalidBounds
     * Determine whether the previously requested set of features is invalid. 
     *     This occurs when the new map bounds do not contain the previously 
     *     requested bounds.  In addition, if <resFactor> is set, it will be 
     *     considered.
     *
     * Parameters:
     * mapBounds - {<HGIS.Bounds>} the current map extent, will be
     *      retrieved from the map object if not provided
     *
     * Returns:
     * {Boolean} 
     */
    invalidBounds: function(mapBounds) {
        if(!mapBounds) {
            mapBounds = this.getMapBounds();
        }
        var invalid = !this.bounds || !this.bounds.containsBounds(mapBounds);
        if(!invalid && this.resFactor) {
            var ratio = this.resolution / this.layer.map.getResolution();
            invalid = (ratio >= this.resFactor || ratio <= (1 / this.resFactor));
        }
        return invalid;
    },
 
    /**
     * Method: calculateBounds
     *
     * Parameters:
     * mapBounds - {<HGIS.Bounds>} the current map extent, will be
     *      retrieved from the map object if not provided
     */
    calculateBounds: function(mapBounds) {
        if(!mapBounds) {
            mapBounds = this.getMapBounds();
        }
        var center = mapBounds.getCenterLonLat();
        var dataWidth = mapBounds.getWidth() * this.ratio;
        var dataHeight = mapBounds.getHeight() * this.ratio;
        this.bounds = new HGIS.Bounds(
            center.lon - (dataWidth / 2),
            center.lat - (dataHeight / 2),
            center.lon + (dataWidth / 2),
            center.lat + (dataHeight / 2)
        );
    },
    
    /**
     * Method: triggerRead
     *
     * Parameters:
     * options - {Object} Additional options for the protocol's read method 
     *     (optional)
     *
     * Returns:
     * {<HGIS.Protocol.Response>} The protocol response object
     *      returned by the layer protocol.
     */
    triggerRead: function(options) {
        if (this.response && !(options && options.noAbort === true)) {
            this.layer.protocol.abort(this.response);
            this.layer.events.triggerEvent("loadend");
        }
        var evt = {filter: this.createFilter()};
        this.layer.events.triggerEvent("loadstart", evt);
        this.response = this.layer.protocol.read(
            HGIS.Util.applyDefaults({
                filter: evt.filter,
                callback: this.merge,
                scope: this
        }, options));
    },
 
    /**
     * Method: createFilter
     * Creates a spatial BBOX filter. If the layer that this strategy belongs
     * to has a filter property, this filter will be combined with the BBOX 
     * filter.
     * 
     * Returns
     * {<HGIS.Filter>} The filter object.
     */
    createFilter: function() {
        var filter = new HGIS.Filter.Spatial({
            type: HGIS.Filter.Spatial.BBOX,
            value: this.bounds,
            projection: this.layer.projection
        });
        if (this.layer.filter) {
            filter = new HGIS.Filter.Logical({
                type: HGIS.Filter.Logical.AND,
                filters: [this.layer.filter, filter]
            });
        }
        return filter;
    },
   
    /**
     * Method: merge
     * Given a list of features, determine which ones to add to the layer.
     *     If the layer projection differs from the map projection, features
     *     will be transformed from the layer projection to the map projection.
     *
     * Parameters:
     * resp - {<HGIS.Protocol.Response>} The response object passed
     *      by the protocol.
     */
    merge: function(resp) {
        this.layer.destroyFeatures();
        if (resp.success()) {
            var features = resp.features;
            if(features && features.length > 0) {
                var remote = this.layer.projection;
                var local = this.layer.map.getProjectionObject();
                if(!local.equals(remote)) {
                    var geom;
                    for(var i=0, len=features.length; i<len; ++i) {
                        geom = features[i].geometry;
                        if(geom) {
                            geom.transform(remote, local);
                        }
                    }
                }
                this.layer.addFeatures(features);
            }
        } else {
            this.bounds = null;
        }
        this.response = null;
        this.layer.events.triggerEvent("loadend", {response: resp});
    },
   
    CLASS_NAME: "HGIS.Strategy.BBOX" 
});
/* ======================================================================
    HGIS/Layer/WorldWind.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer/Grid.js
 */

/**
 * Class: HGIS.Layer.WorldWind
 * 
 * Inherits from:
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.WorldWind = HGIS.Class(HGIS.Layer.Grid, {
    
    DEFAULT_PARAMS: {
    },

    /**
     * APIProperty: isBaseLayer
     * {Boolean} WorldWind layer is a base layer by default.
     */
    isBaseLayer: true,

    /** 
     * APIProperty: lzd
     * {Float} LevelZeroTileSizeDegrees
     */
    lzd: null,

    /**
     * APIProperty: zoomLevels
     * {Integer} Number of zoom levels.
     */
    zoomLevels: null,
    
    /**
     * Constructor: HGIS.Layer.WorldWind
     * 
     * Parameters:
     * name - {String} Name of Layer
     * url - {String} Base URL  
     * lzd - {Float} Level zero tile size degrees 
     * zoomLevels - {Integer} number of zoom levels
     * params - {Object} additional parameters
     * options - {Object} additional options
     */
    initialize: function(name, url, lzd, zoomLevels, params, options) {
        this.lzd = lzd;
        this.zoomLevels = zoomLevels;
        var newArguments = [];
        newArguments.push(name, url, params, options);
        HGIS.Layer.Grid.prototype.initialize.apply(this, newArguments);
        this.params = HGIS.Util.applyDefaults(
            this.params, this.DEFAULT_PARAMS
        );
    },

    /**
     * Method: getZoom
     * Convert map zoom to WW zoom.
     */
    getZoom: function () {
        var zoom = this.map.getZoom();
        var extent = this.map.getMaxExtent();
        zoom = zoom - Math.log(this.maxResolution / (this.lzd/512))/Math.log(2);
        return zoom;
    },

    /**
     * Method: getURL
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>} 
     *
     * Returns:
     * {String} A string with the layer's url and parameters and also the 
     *           passed-in bounds and appropriate tile size specified as 
     *           parameters
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);
        var zoom = this.getZoom();
        var extent = this.map.getMaxExtent();
        var deg = this.lzd/Math.pow(2,this.getZoom());
        var x = Math.floor((bounds.left - extent.left)/deg);
        var y = Math.floor((bounds.bottom - extent.bottom)/deg);
        if (this.map.getResolution() <= (this.lzd/512)
            && this.getZoom() <= this.zoomLevels) {
            return this.getFullRequestString(
              { L: zoom, 
                X: x,
                Y: y
              });
        } else {
            return HGIS.Util.getImageLocation("blank.gif");
        }

    },

    CLASS_NAME: "HGIS.Layer.WorldWind"
});
/* ======================================================================
    HGIS/Protocol/CSW.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Protocol.js
 */

/**
 * Class: HGIS.Protocol.CSW
 * Used to create a versioned CSW protocol. Default version is 2.0.2.
 */
HGIS.Protocol.CSW = function(options) {
    options = HGIS.Util.applyDefaults(
        options, HGIS.Protocol.CSW.DEFAULTS
    );
    var cls = HGIS.Protocol.CSW["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported CSW version: " + options.version;
    }
    return new cls(options);
};

/**
 * Constant: HGIS.Protocol.CSW.DEFAULTS
 */
HGIS.Protocol.CSW.DEFAULTS = {
    "version": "2.0.2"
};
/* ======================================================================
    HGIS/Format/WMTSCapabilities.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML/VersionedOGC.js
 */

/**
 * Class: HGIS.Format.WMTSCapabilities
 * Read WMTS Capabilities.
 *
 * Inherits from:
 *  - <HGIS.Format.XML.VersionedOGC>
 */
HGIS.Format.WMTSCapabilities = HGIS.Class(HGIS.Format.XML.VersionedOGC, {

    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.0.0".
     */
    defaultVersion: "1.0.0",

    /**
     * APIProperty: yx
     * {Object} Members in the yx object are used to determine if a CRS URN
     *     corresponds to a CRS with y,x axis order.  Member names are CRS URNs
     *     and values are boolean.  By default, the following CRS URN are
     *     assumed to correspond to a CRS with y,x axis order:
     *
     * * urn:ogc:def:crs:EPSG::4326
     */
    yx: {
        "urn:ogc:def:crs:EPSG::4326": true
    },

    /**
     * Constructor: HGIS.Format.WMTSCapabilities
     * Create a new parser for WMTS capabilities.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return information about
     * the service (offering and observedProperty mostly).
     *
     * Parameters:
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Info about the WMTS Capabilities
     */

    /**
     * APIMethod: createLayer
     * Create a WMTS layer given a capabilities object.
     *
     * Parameters:
     * capabilities - {Object} The object returned from a <read> call to this
     *     format.
     * config - {Object} Configuration properties for the layer.  Defaults for
     *     the layer will apply if not provided.
     *
     * Required config properties:
     * layer - {String} The layer identifier.
     *
     * Optional config properties:
     * matrixSet - {String} The matrix set identifier, required if there is 
     *      more than one matrix set in the layer capabilities.
     * style - {String} The name of the style
     * format - {String} Image format for the layer. Default is the first
     *     format returned in the GetCapabilities response.
     * param - {Object} The dimensions values eg: {"Year": "2012"}
     *
     * Returns:
     * {<HGIS.Layer.WMTS>} A properly configured WMTS layer.  Throws an
     *     error if an incomplete config is provided.  Returns undefined if no
     *     layer could be created with the provided config.
     */
    createLayer: function(capabilities, config) {
        var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;

        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }

        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }

        // get the default style for the layer
        var style;
        for (var i=0, ii=layerDef.styles.length; i<ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;

                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and HGIS use REST.
                    if (!allowedValues.KVP &&
                            (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
                (projection === "EPSG:4326" ? "degrees" : "m");

        var resolutions = [];
        for (var mid in matrixSet.matrixIds) {
            if (matrixSet.matrixIds.hasOwnProperty(mid)) {
                resolutions.push(
                    matrixSet.matrixIds[mid].scaleDenominator * 0.28E-3 /
                        HGIS.METERS_PER_INCH /
                        HGIS.INCHES_PER_UNIT[units]);
            }
        }

        var url;
        if (requestEncoding === "REST" && layerDef.resourceUrls) {
            url = [];
            var resourceUrls = layerDef.resourceUrls,
                resourceUrl;
            for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
                resourceUrl = layerDef.resourceUrls[t];
                if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
                    url.push(resourceUrl.template);
                }
            }
        }
        else {
            var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
            url = [];
            var constraint;
            for (var i = 0, ii = httpGet.length; i < ii; i++) {
                constraint = httpGet[i].constraints;
                if (!constraint || (constraint && constraint.
                        GetEncoding.allowedValues[requestEncoding])) {
                    url.push(httpGet[i].url);
                }
            }
        }
        
        return new HGIS.Layer.WMTS(
            HGIS.Util.applyDefaults(config, {
                url: url,
                requestEncoding: requestEncoding,
                name: layerDef.title,
                style: style.identifier,
                format: format,
                matrixIds: matrixSet.matrixIds,
                matrixSet: matrixSet.identifier,
                projection: projection,
                units: units,
                resolutions: config.isBaseLayer === false ? undefined :
                    resolutions,
                serverResolutions: resolutions,
                tileFullExtent: matrixSet.bounds,
                dimensions: dimensions,
                params: params
            })
        );
    },

    CLASS_NAME: "HGIS.Format.WMTSCapabilities"

});
/* ======================================================================
    HGIS/Layer/Google/v3.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer/Google.js
 */

/**
 * Constant: HGIS.Layer.Google.v3
 * 
 * Mixin providing functionality specific to the Google Maps API v3.
 * 
 * To use this layer, you must include the GMaps v3 API in your html.
 * 
 * Note that this layer configures the google.maps.map object with the
 * "disableDefaultUI" option set to true. Using UI controls that the Google
 * Maps API provides is not supported by the HGIS API.
 */
HGIS.Layer.Google.v3 = {
    
    /**
     * Constant: DEFAULTS
     * {Object} It is not recommended to change the properties set here. Note
     * that Google.v3 layers only work when sphericalMercator is set to true.
     * 
     * (code)
     * {
     *     sphericalMercator: true,
     *     projection: "EPSG:900913"
     * }
     * (end)
     */
    DEFAULTS: {
        sphericalMercator: true,
        projection: "EPSG:900913"
    },

    /**
     * APIProperty: animationEnabled
     * {Boolean} If set to true, the transition between zoom levels will be
     *     animated (if supported by the GMaps API for the device used). Set to
     *     false to match the zooming experience of other layer types. Default
     *     is true. Note that the GMaps API does not give us control over zoom
     *     animation, so if set to false, when zooming, this will make the
     *     layer temporarily invisible, wait until GMaps reports the map being
     *     idle, and make it visible again. The result will be a blank layer
     *     for a few moments while zooming.
     */
    animationEnabled: true, 

    /** 
     * Method: loadMapObject
     * Load the GMap and register appropriate event listeners.
     */
    loadMapObject: function() {
        if (!this.type) {
            this.type = google.maps.MapTypeId.ROADMAP;
        }
        var mapObject;
        var cache = HGIS.Layer.Google.cache[this.map.id];
        if (cache) {
            // there are already Google layers added to this map
            mapObject = cache.mapObject;
            // increment the layer count
            ++cache.count;
        } else {
            // this is the first Google layer for this map
            // create GMap
            var center = this.map.getCenter();
            var container = document.createElement('div');
            container.className = "olForeignContainer";
            container.style.width = '100%';
            container.style.height = '100%';
            mapObject = new google.maps.Map(container, {
                center: center ?
                    new google.maps.LatLng(center.lat, center.lon) :
                    new google.maps.LatLng(0, 0),
                zoom: this.map.getZoom() || 0,
                mapTypeId: this.type,
                disableDefaultUI: true,
                keyboardShortcuts: false,
                draggable: false,
                disableDoubleClickZoom: true,
                scrollwheel: false,
                streetViewControl: false
            });
            var googleControl = document.createElement('div');
            googleControl.style.width = '100%';
            googleControl.style.height = '100%';
            mapObject.controls[google.maps.ControlPosition.TOP_LEFT].push(googleControl);
            
            // cache elements for use by any other google layers added to
            // this same map
            cache = {
                googleControl: googleControl,
                mapObject: mapObject,
                count: 1
            };
            HGIS.Layer.Google.cache[this.map.id] = cache;
        }
        this.mapObject = mapObject;
        this.setGMapVisibility(this.visibility);
    },
    
    /**
     * APIMethod: onMapResize
     */
    onMapResize: function() {
        if (this.visibility) {
            google.maps.event.trigger(this.mapObject, "resize");
        }
    },

    /**
     * Method: setGMapVisibility
     * Display the GMap container and associated elements.
     * 
     * Parameters:
     * visible - {Boolean} Display the GMap elements.
     */
    setGMapVisibility: function(visible) {
        var cache = HGIS.Layer.Google.cache[this.map.id];
        var map = this.map;
        if (cache) {
            var type = this.type;
            var layers = map.layers;
            var layer;
            for (var i=layers.length-1; i>=0; --i) {
                layer = layers[i];
                if (layer instanceof HGIS.Layer.Google &&
                            layer.visibility === true && layer.inRange === true) {
                    type = layer.type;
                    visible = true;
                    break;
                }
            }
            var container = this.mapObject.getDiv();
            if (visible === true) {
                if (container.parentNode !== map.div) {
                    if (!cache.rendered) {
                        var me = this;
                        google.maps.event.addListenerOnce(this.mapObject, 'tilesloaded', function() {
                            cache.rendered = true;
                            me.setGMapVisibility(me.getVisibility());
                            me.moveTo(me.map.getCenter());
                        });
                    } else {
                        map.div.appendChild(container);
                        cache.googleControl.appendChild(map.viewPortDiv);
                        google.maps.event.trigger(this.mapObject, 'resize');
                    }
                }
                this.mapObject.setMapTypeId(type);                
            } else if (cache.googleControl.hasChildNodes()) {
                map.div.appendChild(map.viewPortDiv);
                map.div.removeChild(container);
            }
        }
    },
    
    /**
     * Method: getMapContainer
     * 
     * Returns:
     * {DOMElement} the GMap container's div
     */
    getMapContainer: function() {
        return this.mapObject.getDiv();
    },
    
  //
  // TRANSLATION: MapObject Bounds <-> HGIS.Bounds
  //

    /**
     * APIMethod: getMapObjectBoundsFromOLBounds
     * 
     * Parameters:
     * olBounds - {<HGIS.Bounds>}
     * 
     * Returns:
     * {Object} A MapObject Bounds, translated from olBounds
     *          Returns null if null value is passed in
     */
    getMapObjectBoundsFromOLBounds: function(olBounds) {
        var moBounds = null;
        if (olBounds != null) {
            var sw = this.sphericalMercator ? 
              this.inverseMercator(olBounds.bottom, olBounds.left) : 
              new HGIS.LonLat(olBounds.bottom, olBounds.left);
            var ne = this.sphericalMercator ? 
              this.inverseMercator(olBounds.top, olBounds.right) : 
              new HGIS.LonLat(olBounds.top, olBounds.right);
            moBounds = new google.maps.LatLngBounds(
                new google.maps.LatLng(sw.lat, sw.lon),
                new google.maps.LatLng(ne.lat, ne.lon)
            );
        }
        return moBounds;
    },


    /************************************
     *                                  *
     *   MapObject Interface Controls   *
     *                                  *
     ************************************/


  // LonLat - Pixel Translation
  
    /**
     * APIMethod: getMapObjectLonLatFromMapObjectPixel
     * 
     * Parameters:
     * moPixel - {Object} MapObject Pixel format
     * 
     * Returns:
     * {Object} MapObject LonLat translated from MapObject Pixel
     */
    getMapObjectLonLatFromMapObjectPixel: function(moPixel) {
        var size = this.map.getSize();
        var lon = this.getLongitudeFromMapObjectLonLat(this.mapObject.center);
        var lat = this.getLatitudeFromMapObjectLonLat(this.mapObject.center);
        var res = this.map.getResolution();

        var delta_x = moPixel.x - (size.w / 2);
        var delta_y = moPixel.y - (size.h / 2);
    
        var lonlat = new HGIS.LonLat(
            lon + delta_x * res,
            lat - delta_y * res
        ); 

        if (this.wrapDateLine) {
            lonlat = lonlat.wrapDateLine(this.maxExtent);
        }
        return this.getMapObjectLonLatFromLonLat(lonlat.lon, lonlat.lat);
    },

    /**
     * APIMethod: getMapObjectPixelFromMapObjectLonLat
     * 
     * Parameters:
     * moLonLat - {Object} MapObject LonLat format
     * 
     * Returns:
     * {Object} MapObject Pixel transtlated from MapObject LonLat
     */
    getMapObjectPixelFromMapObjectLonLat: function(moLonLat) {
        var lon = this.getLongitudeFromMapObjectLonLat(moLonLat);
        var lat = this.getLatitudeFromMapObjectLonLat(moLonLat);
        var res = this.map.getResolution();
        var extent = this.map.getExtent();
        return this.getMapObjectPixelFromXY((1/res * (lon - extent.left)),
                                            (1/res * (extent.top - lat)));
    },

  
    /** 
     * APIMethod: setMapObjectCenter
     * Set the mapObject to the specified center and zoom
     * 
     * Parameters:
     * center - {Object} MapObject LonLat format
     * zoom - {int} MapObject zoom format
     */
    setMapObjectCenter: function(center, zoom) {
        if (this.animationEnabled === false && zoom != this.mapObject.zoom) {
            var mapContainer = this.getMapContainer();
            google.maps.event.addListenerOnce(
                this.mapObject, 
                "idle", 
                function() {
                    mapContainer.style.visibility = "";
                }
            );
            mapContainer.style.visibility = "hidden";
        }
        this.mapObject.setOptions({
            center: center,
            zoom: zoom
        });
    },
   
    
  // Bounds
  
    /** 
     * APIMethod: getMapObjectZoomFromMapObjectBounds
     * 
     * Parameters:
     * moBounds - {Object} MapObject Bounds format
     * 
     * Returns:
     * {Object} MapObject Zoom for specified MapObject Bounds
     */
    getMapObjectZoomFromMapObjectBounds: function(moBounds) {
        return this.mapObject.getBoundsZoomLevel(moBounds);
    },

    /************************************
     *                                  *
     *       MapObject Primitives       *
     *                                  *
     ************************************/


  // LonLat
    
    /**
     * APIMethod: getMapObjectLonLatFromLonLat
     * 
     * Parameters:
     * lon - {Float}
     * lat - {Float}
     * 
     * Returns:
     * {Object} MapObject LonLat built from lon and lat params
     */
    getMapObjectLonLatFromLonLat: function(lon, lat) {
        var gLatLng;
        if(this.sphericalMercator) {
            var lonlat = this.inverseMercator(lon, lat);
            gLatLng = new google.maps.LatLng(lonlat.lat, lonlat.lon);
        } else {
            gLatLng = new google.maps.LatLng(lat, lon);
        }
        return gLatLng;
    },
    
  // Pixel
    
    /**
     * APIMethod: getMapObjectPixelFromXY
     * 
     * Parameters:
     * x - {Integer}
     * y - {Integer}
     * 
     * Returns:
     * {Object} MapObject Pixel from x and y parameters
     */
    getMapObjectPixelFromXY: function(x, y) {
        return new google.maps.Point(x, y);
    }
    
};
/* ======================================================================
    HGIS/Format/WPSDescribeProcess.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */
 
/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/OWSCommon/v1_1_0.js
 */

/**
 * Class: HGIS.Format.WPSDescribeProcess
 * Read WPS DescribeProcess responses. 
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.WPSDescribeProcess = HGIS.Class(
    HGIS.Format.XML, {
    
    /**
     * Constant: VERSION
     * {String} 1.0.0
     */
    VERSION: "1.0.0",

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        wps: "http://www.opengis.net/wps/1.0.0",
        ows: "http://www.opengis.net/ows/1.1",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Property: schemaLocation
     * {String} Schema location
     */
    schemaLocation: "http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd",

    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "wps",

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },
    
    /**
     * Constructor: HGIS.Format.WPSDescribeProcess
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Parse a WPS DescribeProcess and return an object with its information.
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object}
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var info = {};
        this.readNode(data, info);
        return info;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wps": {
            "ProcessDescriptions": function(node, obj) {
                obj.processDescriptions = {};
                this.readChildNodes(node, obj.processDescriptions);
            },
            "ProcessDescription": function(node, processDescriptions) {
                var processVersion = this.getAttributeNS(node, this.namespaces.wps, "processVersion");
                var processDescription = {
                    processVersion: processVersion,
                    statusSupported: (node.getAttribute("statusSupported") === "true"),
                    storeSupported: (node.getAttribute("storeSupported") === "true")
                };
                this.readChildNodes(node, processDescription);
                processDescriptions[processDescription.identifier] = processDescription;
            },
            "DataInputs": function(node, processDescription) {
                processDescription.dataInputs = [];
                this.readChildNodes(node, processDescription.dataInputs);
            },
            "ProcessOutputs": function(node, processDescription) {
                processDescription.processOutputs = [];
                this.readChildNodes(node, processDescription.processOutputs);
            },
            "Output": function(node, processOutputs) {
                var output = {};
                this.readChildNodes(node, output);
                processOutputs.push(output);
            },
            "ComplexOutput": function(node, output) {
                output.complexOutput = {};
                this.readChildNodes(node, output.complexOutput);
            },
            "LiteralOutput": function(node, output) {
                output.literalOutput = {};
                this.readChildNodes(node, output.literalOutput);
            },
            "Input": function(node, dataInputs) {
                var input = {
                    maxOccurs: parseInt(node.getAttribute("maxOccurs")),
                    minOccurs: parseInt(node.getAttribute("minOccurs"))
                };
                this.readChildNodes(node, input);
                dataInputs.push(input);
            },
            "BoundingBoxData": function(node, input) {
                input.boundingBoxData = {};
                this.readChildNodes(node, input.boundingBoxData);
            },
            "CRS": function(node, obj) {
                if (!obj.CRSs) {
                    obj.CRSs = {};
                }
                obj.CRSs[this.getChildValue(node)] = true;
            },
            "LiteralData": function(node, input) {
                input.literalData = {};
                this.readChildNodes(node, input.literalData);
            },
            "ComplexData": function(node, input) {
                input.complexData = {};
                this.readChildNodes(node,  input.complexData);
            },
            "Default": function(node, complexData) {
                complexData["default"] = {};
                this.readChildNodes(node,  complexData["default"]);
            },
            "Supported": function(node, complexData) {
                complexData["supported"] = {};
                this.readChildNodes(node,  complexData["supported"]);
            },
            "Format": function(node, obj) {
                var format = {};
                this.readChildNodes(node, format);
                if (!obj.formats) {
                    obj.formats = {};
                }
                obj.formats[format.mimeType] = true;
            },
            "MimeType": function(node, format) {
                format.mimeType = this.getChildValue(node);
            }
        },
        "ows": HGIS.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },
    
    CLASS_NAME: "HGIS.Format.WPSDescribeProcess" 

});
/* ======================================================================
    HGIS/Format/WKT.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format.js
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Geometry/Point.js
 * @requires HGIS/Geometry/MultiPoint.js
 * @requires HGIS/Geometry/LineString.js
 * @requires HGIS/Geometry/MultiLineString.js
 * @requires HGIS/Geometry/Polygon.js
 * @requires HGIS/Geometry/MultiPolygon.js
 */

/**
 * Class: HGIS.Format.WKT
 * Class for reading and writing Well-Known Text.  Create a new instance
 * with the <HGIS.Format.WKT> constructor.
 * 
 * Inherits from:
 *  - <HGIS.Format>
 */
HGIS.Format.WKT = HGIS.Class(HGIS.Format, {
    
    /**
     * Constructor: HGIS.Format.WKT
     * Create a new parser for WKT
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *           this instance
     *
     * Returns:
     * {<HGIS.Format.WKT>} A new WKT parser.
     */
    initialize: function(options) {
        this.regExes = {
            'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
            'spaces': /\s+/,
            'parenComma': /\)\s*,\s*\(/,
            'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/,  // can't use {2} here
            'trimParens': /^\s*\(?(.*?)\)?\s*$/
        };
        HGIS.Format.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: read
     * Deserialize a WKT string and return a vector feature or an
     * array of vector features.  Supports WKT for POINT, MULTIPOINT,
     * LINESTRING, MULTILINESTRING, POLYGON, MULTIPOLYGON, and
     * GEOMETRYCOLLECTION.
     *
     * Parameters:
     * wkt - {String} A WKT string
     *
     * Returns:
     * {<HGIS.Feature.Vector>|Array} A feature or array of features for
     * GEOMETRYCOLLECTION WKT.
     */
    read: function(wkt) {
        var features, type, str;
        wkt = wkt.replace(/[\n\r]/g, " ");
        var matches = this.regExes.typeStr.exec(wkt);
        if(matches) {
            type = matches[1].toLowerCase();
            str = matches[2];
            if(this.parse[type]) {
                features = this.parse[type].apply(this, [str]);
            }
            if (this.internalProjection && this.externalProjection) {
                if (features && 
                    features.CLASS_NAME == "HGIS.Feature.Vector") {
                    features.geometry.transform(this.externalProjection,
                                                this.internalProjection);
                } else if (features &&
                           type != "geometrycollection" &&
                           typeof features == "object") {
                    for (var i=0, len=features.length; i<len; i++) {
                        var component = features[i];
                        component.geometry.transform(this.externalProjection,
                                                     this.internalProjection);
                    }
                }
            }
        }    
        return features;
    },

    /**
     * APIMethod: write
     * Serialize a feature or array of features into a WKT string.
     *
     * Parameters:
     * features - {<HGIS.Feature.Vector>|Array} A feature or array of
     *            features
     *
     * Returns:
     * {String} The WKT string representation of the input geometries
     */
    write: function(features) {
        var collection, geometry, isCollection;
        if (features.constructor == Array) {
            collection = features;
            isCollection = true;
        } else {
            collection = [features];
            isCollection = false;
        }
        var pieces = [];
        if (isCollection) {
            pieces.push('GEOMETRYCOLLECTION(');
        }
        for (var i=0, len=collection.length; i<len; ++i) {
            if (isCollection && i>0) {
                pieces.push(',');
            }
            geometry = collection[i].geometry;
            pieces.push(this.extractGeometry(geometry));
        }
        if (isCollection) {
            pieces.push(')');
        }
        return pieces.join('');
    },

    /**
     * Method: extractGeometry
     * Entry point to construct the WKT for a single Geometry object.
     *
     * Parameters:
     * geometry - {<HGIS.Geometry.Geometry>}
     *
     * Returns:
     * {String} A WKT string of representing the geometry
     */
    extractGeometry: function(geometry) {
        var type = geometry.CLASS_NAME.split('.')[2].toLowerCase();
        if (!this.extract[type]) {
            return null;
        }
        if (this.internalProjection && this.externalProjection) {
            geometry = geometry.clone();
            geometry.transform(this.internalProjection, this.externalProjection);
        }                       
        var wktType = type == 'collection' ? 'GEOMETRYCOLLECTION' : type.toUpperCase();
        var data = wktType + '(' + this.extract[type].apply(this, [geometry]) + ')';
        return data;
    },
    
    /**
     * Object with properties corresponding to the geometry types.
     * Property values are functions that do the actual data extraction.
     */
    extract: {
        /**
         * Return a space delimited string of point coordinates.
         * @param {HGIS.Geometry.Point} point
         * @returns {String} A string of coordinates representing the point
         */
        'point': function(point) {
            return point.x + ' ' + point.y;
        },

        /**
         * Return a comma delimited string of point coordinates from a multipoint.
         * @param {HGIS.Geometry.MultiPoint} multipoint
         * @returns {String} A string of point coordinate strings representing
         *                  the multipoint
         */
        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.point.apply(this, [multipoint.components[i]]) +
                           ')');
            }
            return array.join(',');
        },
        
        /**
         * Return a comma delimited string of point coordinates from a line.
         * @param {HGIS.Geometry.LineString} linestring
         * @returns {String} A string of point coordinate strings representing
         *                  the linestring
         */
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array.join(',');
        },

        /**
         * Return a comma delimited string of linestring strings from a multilinestring.
         * @param {HGIS.Geometry.MultiLineString} multilinestring
         * @returns {String} A string of of linestring strings representing
         *                  the multilinestring
         */
        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.linestring.apply(this, [multilinestring.components[i]]) +
                           ')');
            }
            return array.join(',');
        },
        
        /**
         * Return a comma delimited string of linear ring arrays from a polygon.
         * @param {HGIS.Geometry.Polygon} polygon
         * @returns {String} An array of linear ring arrays representing the polygon
         */
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.linestring.apply(this, [polygon.components[i]]) +
                           ')');
            }
            return array.join(',');
        },

        /**
         * Return an array of polygon arrays from a multipolygon.
         * @param {HGIS.Geometry.MultiPolygon} multipolygon
         * @returns {String} An array of polygon arrays representing
         *                  the multipolygon
         */
        'multipolygon': function(multipolygon) {
            var array = [];
            for(var i=0, len=multipolygon.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.polygon.apply(this, [multipolygon.components[i]]) +
                           ')');
            }
            return array.join(',');
        },

        /**
         * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an <HGIS.Geometry.Collection>
         * @param {HGIS.Geometry.Collection} collection
         * @returns {String} internal WKT representation of the collection
         */
        'collection': function(collection) {
            var array = [];
            for(var i=0, len=collection.components.length; i<len; ++i) {
                array.push(this.extractGeometry.apply(this, [collection.components[i]]));
            }
            return array.join(',');
        }

    },

    /**
     * Object with properties corresponding to the geometry types.
     * Property values are functions that do the actual parsing.
     */
    parse: {
        /**
         * Return point feature given a point WKT fragment.
         * @param {String} str A WKT fragment representing the point
         * @returns {HGIS.Feature.Vector} A point feature
         * @private
         */
        'point': function(str) {
            var coords = HGIS.String.trim(str).split(this.regExes.spaces);
            return new HGIS.Feature.Vector(
                new HGIS.Geometry.Point(coords[0], coords[1])
            );
        },

        /**
         * Return a multipoint feature given a multipoint WKT fragment.
         * @param {String} str A WKT fragment representing the multipoint
         * @returns {HGIS.Feature.Vector} A multipoint feature
         * @private
         */
        'multipoint': function(str) {
            var point;
            var points = HGIS.String.trim(str).split(',');
            var components = [];
            for(var i=0, len=points.length; i<len; ++i) {
                point = points[i].replace(this.regExes.trimParens, '$1');
                components.push(this.parse.point.apply(this, [point]).geometry);
            }
            return new HGIS.Feature.Vector(
                new HGIS.Geometry.MultiPoint(components)
            );
        },
        
        /**
         * Return a linestring feature given a linestring WKT fragment.
         * @param {String} str A WKT fragment representing the linestring
         * @returns {HGIS.Feature.Vector} A linestring feature
         * @private
         */
        'linestring': function(str) {
            var points = HGIS.String.trim(str).split(',');
            var components = [];
            for(var i=0, len=points.length; i<len; ++i) {
                components.push(this.parse.point.apply(this, [points[i]]).geometry);
            }
            return new HGIS.Feature.Vector(
                new HGIS.Geometry.LineString(components)
            );
        },

        /**
         * Return a multilinestring feature given a multilinestring WKT fragment.
         * @param {String} str A WKT fragment representing the multilinestring
         * @returns {HGIS.Feature.Vector} A multilinestring feature
         * @private
         */
        'multilinestring': function(str) {
            var line;
            var lines = HGIS.String.trim(str).split(this.regExes.parenComma);
            var components = [];
            for(var i=0, len=lines.length; i<len; ++i) {
                line = lines[i].replace(this.regExes.trimParens, '$1');
                components.push(this.parse.linestring.apply(this, [line]).geometry);
            }
            return new HGIS.Feature.Vector(
                new HGIS.Geometry.MultiLineString(components)
            );
        },
        
        /**
         * Return a polygon feature given a polygon WKT fragment.
         * @param {String} str A WKT fragment representing the polygon
         * @returns {HGIS.Feature.Vector} A polygon feature
         * @private
         */
        'polygon': function(str) {
            var ring, linestring, linearring;
            var rings = HGIS.String.trim(str).split(this.regExes.parenComma);
            var components = [];
            for(var i=0, len=rings.length; i<len; ++i) {
                ring = rings[i].replace(this.regExes.trimParens, '$1');
                linestring = this.parse.linestring.apply(this, [ring]).geometry;
                linearring = new HGIS.Geometry.LinearRing(linestring.components);
                components.push(linearring);
            }
            return new HGIS.Feature.Vector(
                new HGIS.Geometry.Polygon(components)
            );
        },

        /**
         * Return a multipolygon feature given a multipolygon WKT fragment.
         * @param {String} str A WKT fragment representing the multipolygon
         * @returns {HGIS.Feature.Vector} A multipolygon feature
         * @private
         */
        'multipolygon': function(str) {
            var polygon;
            var polygons = HGIS.String.trim(str).split(this.regExes.doubleParenComma);
            var components = [];
            for(var i=0, len=polygons.length; i<len; ++i) {
                polygon = polygons[i].replace(this.regExes.trimParens, '$1');
                components.push(this.parse.polygon.apply(this, [polygon]).geometry);
            }
            return new HGIS.Feature.Vector(
                new HGIS.Geometry.MultiPolygon(components)
            );
        },

        /**
         * Return an array of features given a geometrycollection WKT fragment.
         * @param {String} str A WKT fragment representing the geometrycollection
         * @returns {Array} An array of HGIS.Feature.Vector
         * @private
         */
        'geometrycollection': function(str) {
            // separate components of the collection with |
            str = str.replace(/,\s*([A-Za-z])/g, '|$1');
            var wktArray = HGIS.String.trim(str).split('|');
            var components = [];
            for(var i=0, len=wktArray.length; i<len; ++i) {
                components.push(HGIS.Format.WKT.prototype.read.apply(this,[wktArray[i]]));
            }
            return components;
        }

    },

    CLASS_NAME: "HGIS.Format.WKT" 
});     
/* ======================================================================
    HGIS/WPSProcess.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/SingleFile.js
 */

/**
 * @requires HGIS/Geometry.js
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Format/WKT.js
 * @requires HGIS/Format/GeoJSON.js
 * @requires HGIS/Format/WPSExecute.js
 * @requires HGIS/Request.js
 */

/**
 * Class: HGIS.WPSProcess
 * Representation of a WPS process. Usually instances of
 * <HGIS.WPSProcess> are created by calling 'getProcess' on an
 * <HGIS.WPSClient> instance.
 *
 * Currently <HGIS.WPSProcess> supports processes that have geometries
 * or features as output, using WKT or GeoJSON as output format. It also
 * supports chaining of processes by using the <output> method to create a
 * handle that is used as process input instead of a static value.
 */
HGIS.WPSProcess = HGIS.Class({
    
    /**
     * Property: client
     * {<HGIS.WPSClient>} The client that manages this process.
     */
    client: null,
    
    /**
     * Property: server
     * {String} Local client identifier for this process's server.
     */
    server: null,
    
    /**
     * Property: identifier
     * {String} Process identifier known to the server.
     */
    identifier: null,
    
    /**
     * Property: description
     * {Object} DescribeProcess response for this process.
     */
    description: null,
    
    /**
     * APIProperty: localWPS
     * {String} Service endpoint for locally chained WPS processes. Default is
     *     'http://geoserver/wps'.
     */
    localWPS: 'http://geoserver/wps',
    
    /**
     * Property: formats
     * {Object} HGIS.Format instances keyed by mimetype.
     */
    formats: null,
    
    /**
     * Property: chained
     * {Integer} Number of chained processes for pending execute requests that
     * don't have a full configuration yet.
     */
    chained: 0,
    
    /**
     * Property: executeCallbacks
     * {Array} Callbacks waiting to be executed until all chained processes
     * are configured;
     */
    executeCallbacks: null,
    
    /**
     * Constructor: HGIS.WPSProcess
     *
     * Parameters:
     * options - {Object} Object whose properties will be set on the instance.
     *
     * Avaliable options:
     * client - {<HGIS.WPSClient>} Mandatory. Client that manages this
     *     process.
     * server - {String} Mandatory. Local client identifier of this process's
     *     server.
     * identifier - {String} Mandatory. Process identifier known to the server.
     */
    initialize: function(options) {
        HGIS.Util.extend(this, options);        
        this.executeCallbacks = [];
        this.formats = {
            'application/wkt': new HGIS.Format.WKT(),
            'application/json': new HGIS.Format.GeoJSON()
        };
    },
    
    /**
     * Method: describe
     * Makes the client issue a DescribeProcess request asynchronously.
     *
     * Parameters:
     * options - {Object} Configuration for the method call
     *
     * Available options:
     * callback - {Function} Callback to execute when the description is
     *     available. Will be called with the parsed description as argument.
     *     Optional.
     * scope - {Object} The scope in which the callback will be executed.
     *     Default is the global object.
     */
    describe: function(options) {
        options = options || {};
        if (!this.description) {
            this.client.describeProcess(this.server, this.identifier, function(description) {
                if (!this.description) {
                    this.parseDescription(description);
                }
                if (options.callback) {
                    options.callback.call(options.scope, this.description);
                }
            }, this);
        } else if (options.callback) {
            var description = this.description;
            window.setTimeout(function() {
                options.callback.call(options.scope, description);
            }, 0);
        }
    },
    
    /**
     * APIMethod: configure
     * Configure the process, but do not execute it. Use this for processes
     * that are chained as input of a different process by means of the
     * <output> method.
     *
     * Parameters:
     * options - {Object}
     *
     * Returns:
     * {<HGIS.WPSProcess>} this process.
     *
     * Available options:
     * inputs - {Object} The inputs for the process, keyed by input identifier.
     *     For spatial data inputs, the value of an input is usually an
     *     <HGIS.Geometry>, an <HGIS.Feature.Vector> or an array of
     *     geometries or features.
     * callback - {Function} Callback to call when the configuration is
     *     complete. Optional.
     * scope - {Object} Optional scope for the callback.
     */
    configure: function(options) {
        this.describe({
            callback: function() {
                var description = this.description,
                    inputs = options.inputs,
                    input, i, ii;
                for (i=0, ii=description.dataInputs.length; i<ii; ++i) {
                    input = description.dataInputs[i];
                    this.setInputData(input, inputs[input.identifier]);
                }
                if (options.callback) {
                    options.callback.call(options.scope);
                }
            },
            scope: this
        });
        return this;
    },
    
    /**
     * APIMethod: execute
     * Configures and executes the process
     *
     * Parameters:
     * options - {Object}
     *
     * Available options:
     * inputs - {Object} The inputs for the process, keyed by input identifier.
     *     For spatial data inputs, the value of an input is usually an
     *     <HGIS.Geometry>, an <HGIS.Feature.Vector> or an array of
     *     geometries or features.
     * output - {String} The identifier of the output to request and parse.
     *     Optional. If not provided, the first output will be requested.
     * success - {Function} Callback to call when the process is complete.
     *     This function is called with an outputs object as argument, which
     *     will have a property with the identifier of the requested output
     *     (or 'result' if output was not configured). For processes that
     *     generate spatial output, the value will be an array of
     *     <HGIS.Feature.Vector> instances.
     * scope - {Object} Optional scope for the success callback.
     */
    execute: function(options) {
        this.configure({
            inputs: options.inputs,
            callback: function() {
                var me = this;
                //TODO For now we only deal with a single output
                var outputIndex = this.getOutputIndex(
                    me.description.processOutputs, options.output
                );
                me.setResponseForm({outputIndex: outputIndex});
                (function callback() {
                    HGIS.Util.removeItem(me.executeCallbacks, callback);
                    if (me.chained !== 0) {
                        // need to wait until chained processes have a
                        // description and configuration - see chainProcess
                        me.executeCallbacks.push(callback);
                        return;
                    }
                    // all chained processes are added as references now, so
                    // let's proceed.
                    HGIS.Request.POST({
                        url: me.client.servers[me.server].url,
                        data: new HGIS.Format.WPSExecute().write(me.description),
                        success: function(response) {
                            var output = me.description.processOutputs[outputIndex];
                            var mimeType = me.findMimeType(
                                output.complexOutput.supported.formats
                            );
                            //TODO For now we assume a spatial output
                            var features = me.formats[mimeType].read(response.responseText);
                            if (features instanceof HGIS.Feature.Vector) {
                                features = [features];
                            }
                            if (options.success) {
                                var outputs = {};
                                outputs[options.output || 'result'] = features;
                                options.success.call(options.scope, outputs);
                            }
                        },
                        scope: me
                    });
                })();
            },
            scope: this
        });
    },
    
    /**
     * APIMethod: output
     * Chain an output of a configured process (see <configure>) as input to
     * another process.
     *
     * (code)
     * intersect = client.getProcess('opengeo', 'JTS:intersection');    
     * intersect.configure({
     *     // ...
     * });
     * buffer = client.getProcess('opengeo', 'JTS:buffer');
     * buffer.execute({
     *     inputs: {
     *         geom: intersect.output('result'), // <-- here we're chaining
     *         distance: 1
     *     },
     *     // ...
     * });
     * (end)
     *
     * Parameters:
     * identifier - {String} Identifier of the output that we're chaining. If
     *     not provided, the first output will be used.
     */
    output: function(identifier) {
        return new HGIS.WPSProcess.ChainLink({
            process: this,
            output: identifier
        });
    },
    
    /**
     * Method: parseDescription
     * Parses the DescribeProcess response
     *
     * Parameters:
     * description - {Object}
     */
    parseDescription: function(description) {
        var server = this.client.servers[this.server];
        this.description = new HGIS.Format.WPSDescribeProcess()
            .read(server.processDescription[this.identifier])
            .processDescriptions[this.identifier];
    },
    
    /**
     * Method: setInputData
     * Sets the data for a single input
     *
     * Parameters:
     * input - {Object}  An entry from the dataInputs array of the process
     *     description.
     * data - {Mixed} For spatial data inputs, this is usually an
     *     <HGIS.Geometry>, an <HGIS.Feature.Vector> or an array of
     *     geometries or features.
     */
    setInputData: function(input, data) {
        // clear any previous data
        delete input.data;
        delete input.reference;
        if (data instanceof HGIS.WPSProcess.ChainLink) {
            ++this.chained;
            input.reference = {
                method: 'POST',
                href: data.process.server === this.server ?
                    this.localWPS : this.client.servers[data.process.server].url
            };
            data.process.describe({
                callback: function() {
                    --this.chained;
                    this.chainProcess(input, data);
                },
                scope: this
            });
        } else {
            input.data = {};
            var complexData = input.complexData;
            if (complexData) {
                var format = this.findMimeType(complexData.supported.formats);
                input.data.complexData = {
                    mimeType: format,
                    value: this.formats[format].write(this.toFeatures(data))
                };
            } else {
                input.data.literalData = {
                    value: data
                };
            }
        }
    },
    
    /**
     * Method: setResponseForm
     * Sets the responseForm property of the <execute> payload.
     *
     * Parameters:
     * options - {Object} See below.
     *
     * Available options:
     * outputIndex - {Integer} The index of the output to use. Optional.
     * supportedFormats - {Object} Object with supported mime types as key,
     *     and true as value for supported types. Optional.
     */
    setResponseForm: function(options) {
        options = options || {};
        var output = this.description.processOutputs[options.outputIndex || 0];
        this.description.responseForm = {
            rawDataOutput: {
                identifier: output.identifier,
                mimeType: this.findMimeType(output.complexOutput.supported.formats, options.supportedFormats)
            }
        };
    },
    
    /**
     * Method: getOutputIndex
     * Gets the index of a processOutput by its identifier
     *
     * Parameters:
     * outputs - {Array} The processOutputs array to look at
     * identifier - {String} The identifier of the output
     *
     * Returns
     * {Integer} The index of the processOutput with the provided identifier
     *     in the outputs array.
     */
    getOutputIndex: function(outputs, identifier) {
        var output;
        if (identifier) {
            for (var i=outputs.length-1; i>=0; --i) {
                if (outputs[i].identifier === identifier) {
                    output = i;
                    break;
                }
            }
        } else {
            output = 0;
        }
        return output;
    },
    
    /**
     * Method: chainProcess
     * Sets a fully configured chained process as input for this process.
     *
     * Parameters:
     * input - {Object} The dataInput that the chained process provides.
     * chainLink - {<HGIS.WPSProcess.ChainLink>} The process to chain.
     */
    chainProcess: function(input, chainLink) {
        var output = this.getOutputIndex(
            chainLink.process.description.processOutputs, chainLink.output
        );
        input.reference.mimeType = this.findMimeType(
            input.complexData.supported.formats,
            chainLink.process.description.processOutputs[output].complexOutput.supported.formats
        );
        var formats = {};
        formats[input.reference.mimeType] = true;
        chainLink.process.setResponseForm({
            outputIndex: output,
            supportedFormats: formats
        });
        input.reference.body = chainLink.process.description;
        while (this.executeCallbacks.length > 0) {
            this.executeCallbacks[0]();
        }
    },
    
    /**
     * Method: toFeatures
     * Converts spatial input into features so it can be processed by
     * <HGIS.Format> instances.
     *
     * Parameters:
     * source - {Mixed} An <HGIS.Geometry>, an
     *     <HGIS.Feature.Vector>, or an array of geometries or features
     *
     * Returns:
     * {Array(<HGIS.Feature.Vector>)}
     */
    toFeatures: function(source) {
        var isArray = HGIS.Util.isArray(source);
        if (!isArray) {
            source = [source];
        }
        var target = new Array(source.length),
            current;
        for (var i=0, ii=source.length; i<ii; ++i) {
            current = source[i];
            target[i] = current instanceof HGIS.Feature.Vector ?
                current : new HGIS.Feature.Vector(current);
        }
        return isArray ? target : target[0];
    },
    
    /**
     * Method: findMimeType
     * Finds a supported mime type.
     *
     * Parameters:
     * sourceFormats - {Object} An object literal with mime types as key and
     *     true as value for supported formats.
     * targetFormats - {Object} Like <sourceFormats>, but optional to check for
     *     supported mime types on a different target than this process.
     *     Default is to check against this process's supported formats.
     *
     * Returns:
     * {String} A supported mime type.
     */
    findMimeType: function(sourceFormats, targetFormats) {
        targetFormats = targetFormats || this.formats;
        for (var f in sourceFormats) {
            if (f in targetFormats) {
                return f;
            }
        }
    },
    
    CLASS_NAME: "HGIS.WPSProcess"
    
});

/**
 * Class: HGIS.WPSProcess.ChainLink
 * Type for chaining processes.
 */
HGIS.WPSProcess.ChainLink = HGIS.Class({
    
    /**
     * Property: process
     * {<HGIS.WPSProcess>} The process to chain
     */
    process: null,
    
    /**
     * Property: output
     * {String} The output identifier of the output we are going to use as
     *     input for another process.
     */
    output: null,
    
    /**
     * Constructor: HGIS.WPSProcess.ChainLink
     *
     * Parameters:
     * options - {Object} Properties to set on the instance.
     */
    initialize: function(options) {
        HGIS.Util.extend(this, options);
    },
    
    CLASS_NAME: "HGIS.WPSProcess.ChainLink"
    
});
/* ======================================================================
    HGIS/WPSClient.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/SingleFile.js
 */

/**
 * @requires HGIS/Events.js
 * @requires HGIS/WPSProcess.js
 * @requires HGIS/Format/WPSDescribeProcess.js
 * @requires HGIS/Request.js
 */

/**
 * Class: HGIS.WPSClient
 * High level API for interaction with Web Processing Services (WPS).
 * An <HGIS.WPSClient> instance is used to create <HGIS.WPSProcess>
 * instances for servers known to the WPSClient. The WPSClient also caches
 * DescribeProcess responses to reduce the number of requests sent to servers
 * when processes are created.
 */
HGIS.WPSClient = HGIS.Class({
    
    /**
     * Property: servers
     * {Object} Service metadata, keyed by a local identifier.
     *
     * Properties:
     * url - {String} the url of the server
     * version - {String} WPS version of the server
     * processDescription - {Object} Cache of raw DescribeProcess
     *     responses, keyed by process identifier.
     */
    servers: null,
    
    /**
     * Property: version
     * {String} The default WPS version to use if none is configured. Default
     *     is '1.0.0'.
     */
    version: '1.0.0',
    
    /**
     * Property: lazy
     * {Boolean} Should the DescribeProcess be deferred until a process is
     *     fully configured? Default is false.
     */
    lazy: false,
    
    /**
     * Property: events
     * {<HGIS.Events>}
     *
     * Supported event types:
     * describeprocess - Fires when the process description is available.
     *     Listeners receive an object with a 'raw' property holding the raw
     *     DescribeProcess response, and an 'identifier' property holding the
     *     process identifier of the described process.
     */
    events: null,
    
    /**
     * Constructor: HGIS.WPSClient
     *
     * Parameters:
     * options - {Object} Object whose properties will be set on the instance.
     *
     * Avaliable options:
     * servers - {Object} Mandatory. Service metadata, keyed by a local
     *     identifier. Can either be a string with the service url or an
     *     object literal with additional metadata:
     *
     *     (code)
     *     servers: {
     *         local: '/geoserver/wps'
     *     }, {
     *         opengeo: {
     *             url: 'http://demo.opengeo.org/geoserver/wps',
     *             version: '1.0.0'
     *         }
     *     }
     *     (end)
     *
     * lazy - {Boolean} Optional. Set to true if DescribeProcess should not be
     *     requested until a process is fully configured. Default is false.
     */
    initialize: function(options) {
        HGIS.Util.extend(this, options);
        this.events = new HGIS.Events(this);
        this.servers = {};
        for (var s in options.servers) {
            this.servers[s] = typeof options.servers[s] == 'string' ? {
                url: options.servers[s],
                version: this.version,
                processDescription: {}
            } : options.servers[s];
        }
    },
    
    /**
     * APIMethod: execute
     * Shortcut to execute a process with a single function call. This is
     * equivalent to using <getProcess> and then calling execute on the
     * process.
     *
     * Parameters:
     * options - {Object} Options for the execute operation.
     *
     * Available options:
     * server - {String} Mandatory. One of the local identifiers of the
     *     configured servers.
     * process - {String} Mandatory. A process identifier known to the
     *     server.
     * inputs - {Object} The inputs for the process, keyed by input identifier.
     *     For spatial data inputs, the value of an input is usually an
     *     <HGIS.Geometry>, an <HGIS.Feature.Vector> or an array of
     *     geometries or features.
     * output - {String} The identifier of an output to parse. Optional. If not
     *     provided, the first output will be parsed.
     * success - {Function} Callback to call when the process is complete.
     *     This function is called with an outputs object as argument, which
     *     will have a property with the identifier of the requested output
     *     (e.g. 'result'). For processes that generate spatial output, the
     *     value will either be a single <HGIS.Feature.Vector> or an
     *     array of features.
     * scope - {Object} Optional scope for the success callback.
     */
    execute: function(options) {
        var process = this.getProcess(options.server, options.process);
        process.execute({
            inputs: options.inputs,
            success: options.success,
            scope: options.scope
        });
    },
    
    /**
     * APIMethod: getProcess
     * Creates an <HGIS.WPSProcess>.
     *
     * Parameters:
     * serverID - {String} Local identifier from the servers that this instance
     *     was constructed with.
     * processID - {String} Process identifier known to the server.
     *
     * Returns:
     * {<HGIS.WPSProcess>}
     */
    getProcess: function(serverID, processID) {
        var process = new HGIS.WPSProcess({
            client: this,
            server: serverID,
            identifier: processID
        });
        if (!this.lazy) {
            process.describe();
        }
        return process;
    },
    
    /**
     * Method: describeProcess
     *
     * Parameters:
     * serverID - {String} Identifier of the server
     * processID - {String} Identifier of the requested process
     * callback - {Function} Callback to call when the description is available
     * scope - {Object} Optional execution scope for the callback function
     */
    describeProcess: function(serverID, processID, callback, scope) {
        var server = this.servers[serverID];
        if (!server.processDescription[processID]) {
            if (!(processID in server.processDescription)) {
                // set to null so we know a describeFeature request is pending
                server.processDescription[processID] = null;
                HGIS.Request.GET({
                    url: server.url,
                    params: {
                        SERVICE: 'WPS',
                        VERSION: server.version,
                        REQUEST: 'DescribeProcess',
                        IDENTIFIER: processID
                    },
                    success: function(response) {
                        server.processDescription[processID] = response.responseText;
                        this.events.triggerEvent('describeprocess', {
                            identifier: processID,
                            raw: response.responseText
                        });
                    },
                    scope: this
                });
            } else {
                // pending request
                this.events.register('describeprocess', this, function describe(evt) {
                    if (evt.identifier === processID) {
                        this.events.unregister('describeprocess', this, describe);
                        callback.call(scope, evt.raw);
                    }
                });
            }
        } else {
            window.setTimeout(function() {
                callback.call(scope, server.processDescription[processID]);
            }, 0);
        }
    },
    
    /**
     * Method: destroy
     */
    destroy: function() {
        this.events.destroy();
        this.events = null;
        this.servers = null;
    },
    
    CLASS_NAME: 'HGIS.WPSClient'
    
});
/* ======================================================================
    HGIS/Format/CSWGetRecords/v2_0_2.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/CSWGetRecords.js
 * @requires HGIS/Format/Filter/v1_0_0.js
 * @requires HGIS/Format/Filter/v1_1_0.js
 * @requires HGIS/Format/OWSCommon/v1_0_0.js
 */

/**
 * Class: HGIS.Format.CSWGetRecords.v2_0_2
 *     A format for creating CSWGetRecords v2.0.2 transactions. 
 *     Create a new instance with the
 *     <HGIS.Format.CSWGetRecords.v2_0_2> constructor.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.CSWGetRecords.v2_0_2 = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        csw: "http://www.opengis.net/cat/csw/2.0.2",
        dc: "http://purl.org/dc/elements/1.1/",
        dct: "http://purl.org/dc/terms/",
        gmd: "http://www.isotc211.org/2005/gmd",
        geonet: "http://www.fao.org/geonetwork",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    
    /**
     * Property: defaultPrefix
     * {String} The default prefix (used by Format.XML).
     */
    defaultPrefix: "csw",
    
    /**
     * Property: version
     * {String} CSW version number.
     */
    version: "2.0.2",
    
    /**
     * Property: schemaLocation
     * {String} http://www.opengis.net/cat/csw/2.0.2
     *   http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd
     */
    schemaLocation: "http://www.opengis.net/cat/csw/2.0.2 http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd",

    /**
     * APIProperty: requestId
     * {String} Value of the requestId attribute of the GetRecords element.
     */
    requestId: null,

    /**
     * APIProperty: resultType
     * {String} Value of the resultType attribute of the GetRecords element,
     *     specifies the result type in the GetRecords response, "hits" is
     *     the default.
     */
    resultType: null,

    /**
     * APIProperty: outputFormat
     * {String} Value of the outputFormat attribute of the GetRecords element,
     *     specifies the format of the GetRecords response,
     *     "application/xml" is the default.
     */
    outputFormat: null,

    /**
     * APIProperty: outputSchema
     * {String} Value of the outputSchema attribute of the GetRecords element,
     *     specifies the schema of the GetRecords response.
     */
    outputSchema: null,

    /**
     * APIProperty: startPosition
     * {String} Value of the startPosition attribute of the GetRecords element,
     *     specifies the start position (offset+1) for the GetRecords response,
     *     1 is the default.
     */
    startPosition: null,

    /**
     * APIProperty: maxRecords
     * {String} Value of the maxRecords attribute of the GetRecords element,
     *     specifies the maximum number of records in the GetRecords response,
     *     10 is the default.
     */
    maxRecords: null,

    /**
     * APIProperty: DistributedSearch
     * {String} Value of the csw:DistributedSearch element, used when writing
     *     a csw:GetRecords document.
     */
    DistributedSearch: null,

    /**
     * APIProperty: ResponseHandler
     * {Array({String})} Values of the csw:ResponseHandler elements, used when
     *     writting a csw:GetRecords document.
     */
    ResponseHandler: null,

    /**
     * APIProperty: Query
     * {String} Value of the csw:Query element, used when writing a csw:GetRecords
     *     document.
     */
    Query: null,

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * Constructor: HGIS.Format.CSWGetRecords.v2_0_2
     * A class for parsing and generating CSWGetRecords v2.0.2 transactions.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties (documented as class properties):
     * - requestId
     * - resultType
     * - outputFormat
     * - outputSchema
     * - startPosition
     * - maxRecords
     * - DistributedSearch
     * - ResponseHandler
     * - Query
     */
    initialize: function(options) {
        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: read
     * Parse the response from a GetRecords request.
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var obj = {};
        this.readNode(data, obj);
        return obj;
    },
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "csw": {
            "GetRecordsResponse": function(node, obj) {
                obj.records = [];
                this.readChildNodes(node, obj);
                var version = this.getAttributeNS(node, "", 'version');
                if (version != "") {
                    obj.version = version;
                }
            },
            "RequestId": function(node, obj) {
                obj.RequestId = this.getChildValue(node);
            },
            "SearchStatus": function(node, obj) {
                obj.SearchStatus = {};
                var timestamp = this.getAttributeNS(node, "", 'timestamp');
                if (timestamp != "") {
                    obj.SearchStatus.timestamp = timestamp;
                }
            },
            "SearchResults": function(node, obj) {
                this.readChildNodes(node, obj);
                var attrs = node.attributes;
                var SearchResults = {};
                for(var i=0, len=attrs.length; i<len; ++i) {
                    if ((attrs[i].name == "numberOfRecordsMatched") ||
                        (attrs[i].name == "numberOfRecordsReturned") ||
                        (attrs[i].name == "nextRecord")) {
                        SearchResults[attrs[i].name] = parseInt(attrs[i].nodeValue);
                    } else {
                        SearchResults[attrs[i].name] = attrs[i].nodeValue;
                    }
                }
                obj.SearchResults = SearchResults;
            },
            "SummaryRecord": function(node, obj) {
                var record = {type: "SummaryRecord"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "BriefRecord": function(node, obj) {
                var record = {type: "BriefRecord"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "DCMIRecord": function(node, obj) {
                var record = {type: "DCMIRecord"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "Record": function(node, obj) {
                var record = {type: "Record"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                obj[name] = this.getChildValue(node);
            }
        },
        "geonet": {
            "info": function(node, obj) {
                var gninfo = {};
                this.readChildNodes(node, gninfo);
                obj.gninfo = gninfo;
            }
        },
        "dc": {
            // audience, contributor, coverage, creator, date, description, format,
            // identifier, language, provenance, publisher, relation, rights,
            // rightsHolder, source, subject, title, type, URI
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(HGIS.Util.isArray(obj[name]))) {
                    obj[name] = [];
                }
                var dc_element = {};
                var attrs = node.attributes;
                for(var i=0, len=attrs.length; i<len; ++i) {
                    dc_element[attrs[i].name] = attrs[i].nodeValue;
                }
                dc_element.value = this.getChildValue(node);
                if (dc_element.value != "") {
                    obj[name].push(dc_element);
                }
            }
        },
        "dct": {
            // abstract, modified, spatial
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(HGIS.Util.isArray(obj[name]))) {
                    obj[name] = [];
                }
                obj[name].push(this.getChildValue(node));
            }
        },
        "ows": HGIS.Util.applyDefaults({
            "BoundingBox": function(node, obj) {
                if (obj.bounds) {
                    obj.BoundingBox = [{crs: obj.projection, value: 
                        [
                            obj.bounds.left, 
                            obj.bounds.bottom, 
                            obj.bounds.right, 
                            obj.bounds.top
                    ]
                    }];
                    delete obj.projection;
                    delete obj.bounds;
                }
                HGIS.Format.OWSCommon.v1_0_0.prototype.readers["ows"]["BoundingBox"].apply(
                    this, arguments);
            }
        }, HGIS.Format.OWSCommon.v1_0_0.prototype.readers["ows"])
    },
    
    /**
     * Method: write
     * Given an configuration js object, write a CSWGetRecords request. 
     *
     * Parameters:
     * options - {Object} A object mapping the request.
     *
     * Returns:
     * {String} A serialized CSWGetRecords request.
     */
    write: function(options) {
        var node = this.writeNode("csw:GetRecords", options);
        node.setAttribute("xmlns:gmd", this.namespaces.gmd);
        return HGIS.Format.XML.prototype.write.apply(this, [node]);
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "csw": {
            "GetRecords": function(options) {
                if (!options) {
                    options = {};
                }
                var node = this.createElementNSPlus("csw:GetRecords", {
                    attributes: {
                        service: "CSW",
                        version: this.version,
                        requestId: options.requestId || this.requestId,
                        resultType: options.resultType || this.resultType,
                        outputFormat: options.outputFormat || this.outputFormat,
                        outputSchema: options.outputSchema || this.outputSchema,
                        startPosition: options.startPosition || this.startPosition,
                        maxRecords: options.maxRecords || this.maxRecords
                    }
                });
                if (options.DistributedSearch || this.DistributedSearch) {
                    this.writeNode(
                        "csw:DistributedSearch",
                        options.DistributedSearch || this.DistributedSearch,
                        node
                    );
                }
                var ResponseHandler = options.ResponseHandler || this.ResponseHandler;
                if (HGIS.Util.isArray(ResponseHandler) && ResponseHandler.length > 0) {
                    // ResponseHandler must be a non-empty array
                    for(var i=0, len=ResponseHandler.length; i<len; i++) {
                        this.writeNode(
                            "csw:ResponseHandler",
                            ResponseHandler[i],
                            node
                        );
                    }
                }
                this.writeNode("Query", options.Query || this.Query, node);
                return node;
            },
            "DistributedSearch": function(options) {
                var node = this.createElementNSPlus("csw:DistributedSearch", {
                    attributes: {
                        hopCount: options.hopCount
                    }
                });
                return node;
            },
            "ResponseHandler": function(options) {
                var node = this.createElementNSPlus("csw:ResponseHandler", {
                    value: options.value
                });
                return node;
            },
            "Query": function(options) {
                if (!options) {
                    options = {};
                }
                var node = this.createElementNSPlus("csw:Query", {
                    attributes: {
                        typeNames: options.typeNames || "csw:Record"
                    }
                });
                var ElementName = options.ElementName;
                if (HGIS.Util.isArray(ElementName) && ElementName.length > 0) {
                    // ElementName must be a non-empty array
                    for(var i=0, len=ElementName.length; i<len; i++) {
                        this.writeNode(
                            "csw:ElementName",
                            ElementName[i],
                            node
                        );
                    }
                } else {
                    this.writeNode(
                        "csw:ElementSetName",
                        options.ElementSetName || {value: 'summary'},
                        node
                    );
                }
                if (options.Constraint) {
                    this.writeNode(
                        "csw:Constraint",
                        options.Constraint,
                        node
                    );
                }
                if (options.SortBy) {
                    this.writeNode(
                        "ogc:SortBy",
                        options.SortBy,
                        node
                    );
                }
                return node;
            },
            "ElementName": function(options) {
                var node = this.createElementNSPlus("csw:ElementName", {
                    value: options.value
                });
                return node;
            },
            "ElementSetName": function(options) {
                var node = this.createElementNSPlus("csw:ElementSetName", {
                    attributes: {
                        typeNames: options.typeNames
                    },
                    value: options.value
                });
                return node;
            },
            "Constraint": function(options) {
                var node = this.createElementNSPlus("csw:Constraint", {
                    attributes: {
                        version: options.version
                    }
                });
                if (options.Filter) {
                    var format = new HGIS.Format.Filter({
                        version: options.version
                    });
                    node.appendChild(format.write(options.Filter));
                } else if (options.CqlText) {
                    var child = this.createElementNSPlus("CqlText", {
                        value: options.CqlText.value
                    });
                    node.appendChild(child);
                }
                return node;
            }
        },
        "ogc": HGIS.Format.Filter.v1_1_0.prototype.writers["ogc"]
    },
   
    CLASS_NAME: "HGIS.Format.CSWGetRecords.v2_0_2" 
});
/* ======================================================================
    Rico/license.js
   ====================================================================== */

/**
 * @license Apache 2 
 *  
 * Contains portions of Rico <http://openrico.org/>
 * 
 * Copyright 2005 Sabre Airline Solutions  
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License. You
 * may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0  
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License. 
 */
/* ======================================================================
    HGIS/Marker/Box.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Marker.js
 */

/**
 * Class: HGIS.Marker.Box
 *
 * Inherits from:
 *  - <HGIS.Marker> 
 */
HGIS.Marker.Box = HGIS.Class(HGIS.Marker, {

    /** 
     * Property: bounds 
     * {<HGIS.Bounds>} 
     */
    bounds: null,

    /** 
     * Property: div 
     * {DOMElement} 
     */
    div: null,
    
    /** 
     * Constructor: HGIS.Marker.Box
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>} 
     * borderColor - {String} 
     * borderWidth - {int} 
     */
    initialize: function(bounds, borderColor, borderWidth) {
        this.bounds = bounds;
        this.div    = HGIS.Util.createDiv();
        this.div.style.overflow = 'hidden';
        this.events = new HGIS.Events(this, this.div);
        this.setBorder(borderColor, borderWidth);
    },

    /**
     * Method: destroy 
     */    
    destroy: function() {

        this.bounds = null;
        this.div = null;

        HGIS.Marker.prototype.destroy.apply(this, arguments);
    },

    /** 
     * Method: setBorder
     * Allow the user to change the box's color and border width
     * 
     * Parameters:
     * color - {String} Default is "red"
     * width - {int} Default is 2
     */
    setBorder: function (color, width) {
        if (!color) {
            color = "red";
        }
        if (!width) {
            width = 2;
        }
        this.div.style.border = width + "px solid " + color;
    },
    
    /** 
    * Method: draw
    * 
    * Parameters:
    * px - {<HGIS.Pixel>} 
    * sz - {<HGIS.Size>} 
    * 
    * Returns: 
    * {DOMElement} A new DOM Image with this marker's icon set at the 
    *         location passed-in
    */
    draw: function(px, sz) {
        HGIS.Util.modifyDOMElement(this.div, null, px, sz);
        return this.div;
    }, 

    /**
     * Method: onScreen
     * 
     * Rreturn:
     * {Boolean} Whether or not the marker is currently visible on screen.
     */
    onScreen:function() {
        var onScreen = false;
        if (this.map) {
            var screenBounds = this.map.getExtent();
            onScreen = screenBounds.containsBounds(this.bounds, true, true);
        }    
        return onScreen;
    },
    
    /**
     * Method: display
     * Hide or show the icon
     * 
     * Parameters:
     * display - {Boolean} 
     */
    display: function(display) {
        this.div.style.display = (display) ? "" : "none";
    },

    CLASS_NAME: "HGIS.Marker.Box"
});

/* ======================================================================
    HGIS/Format/Text.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Geometry/Point.js
 */

/**
 * Class: HGIS.Format.Text
 * Read Text format. Create a new instance with the <HGIS.Format.Text>
 *     constructor. This reads text which is formatted like CSV text, using
 *     tabs as the seperator by default. It provides parsing of data originally
 *     used in the MapViewerService, described on the wiki. This Format is used
 *     by the <HGIS.Layer.Text> class.
 *
 * Inherits from:
 *  - <HGIS.Format>
 */
HGIS.Format.Text = HGIS.Class(HGIS.Format, {
    
    /**
     * APIProperty: defaultStyle
     * defaultStyle allows one to control the default styling of the features.
     *    It should be a symbolizer hash. By default, this is set to match the
     *    Layer.Text behavior, which is to use the default HGIS Icon.
     */
    defaultStyle: null,
     
    /**
     * APIProperty: extractStyles
     * set to true to extract styles from the TSV files, using information
     * from the image or icon, iconSize and iconOffset fields. This will result
     * in features with a symbolizer (style) property set, using the
     * default symbolizer specified in <defaultStyle>. Set to false if you
     * wish to use a styleMap or HGIS.Style options to style your
     * layer instead.
     */
    extractStyles: true,

    /**
     * Constructor: HGIS.Format.Text
     * Create a new parser for TSV Text.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        options = options || {};

        if(options.extractStyles !== false) {
            options.defaultStyle = {
                'externalGraphic': HGIS.Util.getImageLocation("marker.png"),
                'graphicWidth': 21,
                'graphicHeight': 25,
                'graphicXOffset': -10.5,
                'graphicYOffset': -12.5
            };
        }
        
        HGIS.Format.prototype.initialize.apply(this, [options]);
    }, 

    /**
     * APIMethod: read
     * Return a list of features from a Tab Seperated Values text string.
     * 
     * Parameters:
     * text - {String} 
     *
     * Returns:
     * Array({<HGIS.Feature.Vector>})
     */
    read: function(text) {
        var lines = text.split('\n');
        var columns;
        var features = [];
        // length - 1 to allow for trailing new line
        for (var lcv = 0; lcv < (lines.length - 1); lcv++) {
            var currLine = lines[lcv].replace(/^\s*/,'').replace(/\s*$/,'');
        
            if (currLine.charAt(0) != '#') { /* not a comment */
            
                if (!columns) {
                    //First line is columns
                    columns = currLine.split('\t');
                } else {
                    var vals = currLine.split('\t');
                    var geometry = new HGIS.Geometry.Point(0,0);
                    var attributes = {};
                    var style = this.defaultStyle ? 
                        HGIS.Util.applyDefaults({}, this.defaultStyle) :
                        null;  
                    var icon, iconSize, iconOffset, overflow;
                    var set = false;
                    for (var valIndex = 0; valIndex < vals.length; valIndex++) {
                        if (vals[valIndex]) {
                            if (columns[valIndex] == 'point') {
                                var coords = vals[valIndex].split(',');
                                geometry.y = parseFloat(coords[0]);
                                geometry.x = parseFloat(coords[1]);
                                set = true;
                            } else if (columns[valIndex] == 'lat') {
                                geometry.y = parseFloat(vals[valIndex]);
                                set = true;
                            } else if (columns[valIndex] == 'lon') {
                                geometry.x = parseFloat(vals[valIndex]);
                                set = true;
                            } else if (columns[valIndex] == 'title')
                                attributes['title'] = vals[valIndex];
                            else if (columns[valIndex] == 'image' ||
                                     columns[valIndex] == 'icon' && style) {
                                style['externalGraphic'] = vals[valIndex];
                            } else if (columns[valIndex] == 'iconSize' && style) {
                                var size = vals[valIndex].split(',');
                                style['graphicWidth'] = parseFloat(size[0]);
                                style['graphicHeight'] = parseFloat(size[1]);
                            } else if (columns[valIndex] == 'iconOffset' && style) {
                                var offset = vals[valIndex].split(',');
                                style['graphicXOffset'] = parseFloat(offset[0]);
                                style['graphicYOffset'] = parseFloat(offset[1]);
                            } else if (columns[valIndex] == 'description') {
                                attributes['description'] = vals[valIndex];
                            } else if (columns[valIndex] == 'overflow') {
                                attributes['overflow'] = vals[valIndex];
                            } else {
                                // For StyleMap filtering, allow additional
                                // columns to be stored as attributes.
                                attributes[columns[valIndex]] = vals[valIndex];
                            }    
                        }
                    }
                    if (set) {
                      if (this.internalProjection && this.externalProjection) {
                          geometry.transform(this.externalProjection, 
                                             this.internalProjection); 
                      }
                      var feature = new HGIS.Feature.Vector(geometry, attributes, style);
                      features.push(feature);
                    }
                }
            }
        }
        return features;
    },   

    CLASS_NAME: "HGIS.Format.Text" 
});    
/* ======================================================================
    HGIS/Layer/Text.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer/Markers.js
 * @requires HGIS/Format/Text.js
 * @requires HGIS/Request/XMLHttpRequest.js
 */

/**
 * Class: HGIS.Layer.Text
 * This layer creates markers given data in a text file.  The <location>
 *     property of the layer (specified as a property of the options argument
 *     in the <HGIS.Layer.Text> constructor) points to a tab delimited
 *     file with data used to create markers.
 *
 * The first row of the data file should be a header line with the column names
 *     of the data. Each column should be delimited by a tab space. The
 *     possible columns are:
 *      - *point* lat,lon of the point where a marker is to be placed
 *      - *lat*  Latitude of the point where a marker is to be placed
 *      - *lon*  Longitude of the point where a marker is to be placed
 *      - *icon* or *image* URL of marker icon to use.
 *      - *iconSize* Size of Icon to use.
 *      - *iconOffset* Where the top-left corner of the icon is to be placed
 *            relative to the latitude and longitude of the point.
 *      - *title* The text of the 'title' is placed inside an 'h2' marker
 *            inside a popup, which opens when the marker is clicked.
 *      - *description* The text of the 'description' is placed below the h2
 *            in the popup. this can be plain text or HTML.
 *
 * Example text file:
 * (code)
 * lat	lon	title	description	iconSize	iconOffset	icon
 * 10	20	title	description	21,25		-10,-25		http://www.HGIS.org/dev/img/marker.png
 * (end)
 *
 * Inherits from:
 *  - <HGIS.Layer.Markers>
 */
HGIS.Layer.Text = HGIS.Class(HGIS.Layer.Markers, {

    /**
     * APIProperty: location 
     * {String} URL of text file.  Must be specified in the "options" argument
     *   of the constructor. Can not be changed once passed in. 
     */
    location:null,

    /** 
     * Property: features
     * {Array(<HGIS.Feature>)} 
     */
    features: null,
    
    /**
     * APIProperty: formatOptions
     * {Object} Hash of options which should be passed to the format when it is
     * created. Must be passed in the constructor.
     */
    formatOptions: null, 

    /** 
     * Property: selectedFeature
     * {<HGIS.Feature>}
     */
    selectedFeature: null,

    /**
     * Constructor: HGIS.Layer.Text
     * Create a text layer.
     * 
     * Parameters:
     * name - {String} 
     * options - {Object} Object with properties to be set on the layer.
     *     Must include <location> property.
     */
    initialize: function(name, options) {
        HGIS.Layer.Markers.prototype.initialize.apply(this, arguments);
        this.features = [];
    },

    /**
     * APIMethod: destroy 
     */
    destroy: function() {
        // Warning: Layer.Markers.destroy() must be called prior to calling
        // clearFeatures() here, otherwise we leak memory. Indeed, if
        // Layer.Markers.destroy() is called after clearFeatures(), it won't be
        // able to remove the marker image elements from the layer's div since
        // the markers will have been destroyed by clearFeatures().
        HGIS.Layer.Markers.prototype.destroy.apply(this, arguments);
        this.clearFeatures();
        this.features = null;
    },
    
    /**
     * Method: loadText
     * Start the load of the Text data. Don't do this when we first add the layer,
     * since we may not be visible at any point, and it would therefore be a waste.
     */
    loadText: function() {
        if (!this.loaded) {
            if (this.location != null) {

                var onFail = function(e) {
                    this.events.triggerEvent("loadend");
                };

                this.events.triggerEvent("loadstart");
                HGIS.Request.GET({
                    url: this.location,
                    success: this.parseData,
                    failure: onFail,
                    scope: this
                });
                this.loaded = true;
            }
        }    
    },    
    
    /**
     * Method: moveTo
     * If layer is visible and Text has not been loaded, load Text. 
     * 
     * Parameters:
     * bounds - {Object} 
     * zoomChanged - {Object} 
     * minor - {Object} 
     */
    moveTo:function(bounds, zoomChanged, minor) {
        HGIS.Layer.Markers.prototype.moveTo.apply(this, arguments);
        if(this.visibility && !this.loaded){
            this.loadText();
        }
    },
    
    /**
     * Method: parseData
     *
     * Parameters:
     * ajaxRequest - {<HGIS.Request.XMLHttpRequest>} 
     */
    parseData: function(ajaxRequest) {
        var text = ajaxRequest.responseText;
        
        var options = {};
        
        HGIS.Util.extend(options, this.formatOptions);
        
        if (this.map && !this.projection.equals(this.map.getProjectionObject())) {
            options.externalProjection = this.projection;
            options.internalProjection = this.map.getProjectionObject();
        }    
        
        var parser = new HGIS.Format.Text(options);
        var features = parser.read(text);
        for (var i=0, len=features.length; i<len; i++) {
            var data = {};
            var feature = features[i];
            var location;
            var iconSize, iconOffset;
            
            location = new HGIS.LonLat(feature.geometry.x, 
                                             feature.geometry.y);
            
            if (feature.style.graphicWidth 
                && feature.style.graphicHeight) {
                iconSize = new HGIS.Size(
                    feature.style.graphicWidth,
                    feature.style.graphicHeight);
            }        
            
            // FIXME: At the moment, we only use this if we have an 
            // externalGraphic, because icon has no setOffset API Method.
            /**
             * FIXME FIRST!!
             * The Text format does all sorts of parseFloating
             * The result of a parseFloat for a bogus string is NaN.  That
             * means the three possible values here are undefined, NaN, or a
             * number.  The previous check was an identity check for null.  This
             * means it was failing for all undefined or NaN.  A slightly better
             * check is for undefined.  An even better check is to see if the
             * value is a number (see #1441).
             */
            if (feature.style.graphicXOffset !== undefined
                && feature.style.graphicYOffset !== undefined) {
                iconOffset = new HGIS.Pixel(
                    feature.style.graphicXOffset, 
                    feature.style.graphicYOffset);
            }
            
            if (feature.style.externalGraphic != null) {
                data.icon = new HGIS.Icon(feature.style.externalGraphic, 
                                                iconSize, 
                                                iconOffset);
            } else {
                data.icon = HGIS.Marker.defaultIcon();

                //allows for the case where the image url is not 
                // specified but the size is. use a default icon
                // but change the size
                if (iconSize != null) {
                    data.icon.setSize(iconSize);
                }
            }
            
            if ((feature.attributes.title != null) 
                && (feature.attributes.description != null)) {
                data['popupContentHTML'] = 
                    '<h2>'+feature.attributes.title+'</h2>' + 
                    '<p>'+feature.attributes.description+'</p>';
            }
            
            data['overflow'] = feature.attributes.overflow || "auto"; 
            
            var markerFeature = new HGIS.Feature(this, location, data);
            this.features.push(markerFeature);
            var marker = markerFeature.createMarker();
            if ((feature.attributes.title != null) 
                && (feature.attributes.description != null)) {
              marker.events.register('click', markerFeature, this.markerClick);
            }
            this.addMarker(marker);
        }
        this.events.triggerEvent("loadend");
    },
    
    /**
     * Property: markerClick
     * 
     * Parameters:
     * evt - {Event} 
     *
     * Context:
     * - {<HGIS.Feature>}
     */
    markerClick: function(evt) {
        var sameMarkerClicked = (this == this.layer.selectedFeature);
        this.layer.selectedFeature = (!sameMarkerClicked) ? this : null;
        for(var i=0, len=this.layer.map.popups.length; i<len; i++) {
            this.layer.map.removePopup(this.layer.map.popups[i]);
        }
        if (!sameMarkerClicked) {
            this.layer.map.addPopup(this.createPopup()); 
        }
        HGIS.Event.stop(evt);
    },

    /**
     * Method: clearFeatures
     */
    clearFeatures: function() {
        if (this.features != null) {
            while(this.features.length > 0) {
                var feature = this.features[0];
                HGIS.Util.removeItem(this.features, feature);
                feature.destroy();
            }
        }        
    },

    CLASS_NAME: "HGIS.Layer.Text"
});
/* ======================================================================
    HGIS/Handler/RegularPolygon.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Handler/Drag.js
 */

/**
 * Class: HGIS.Handler.RegularPolygon
 * Handler to draw a regular polygon on the map.  Polygon is displayed on mouse
 *     down, moves or is modified on mouse move, and is finished on mouse up.
 *     The handler triggers callbacks for 'done' and 'cancel'.  Create a new
 *     instance with the <HGIS.Handler.RegularPolygon> constructor.
 * 
 * Inherits from:
 *  - <HGIS.Handler.Drag>
 */
HGIS.Handler.RegularPolygon = HGIS.Class(HGIS.Handler.Drag, {
    
    /**
     * APIProperty: sides
     * {Integer} Number of sides for the regular polygon.  Needs to be greater
     *     than 2.  Defaults to 4.
     */
    sides: 4,

    /**
     * APIProperty: radius
     * {Float} Optional radius in map units of the regular polygon.  If this is
     *     set to some non-zero value, a polygon with a fixed radius will be
     *     drawn and dragged with mose movements.  If this property is not
     *     set, dragging changes the radius of the polygon.  Set to null by
     *     default.
     */
    radius: null,
    
    /**
     * APIProperty: snapAngle
     * {Float} If set to a non-zero value, the handler will snap the polygon
     *     rotation to multiples of the snapAngle.  Value is an angle measured
     *     in degrees counterclockwise from the positive x-axis.  
     */
    snapAngle: null,
    
    /**
     * APIProperty: snapToggle
     * {String} If set, snapToggle is checked on mouse events and will set
     *     the snap mode to the opposite of what it currently is.  To disallow
     *     toggling between snap and non-snap mode, set freehandToggle to
     *     null.  Acceptable toggle values are 'shiftKey', 'ctrlKey', and
     *     'altKey'. Snap mode is only possible if this.snapAngle is set to a
     *     non-zero value.
     */
    snapToggle: 'shiftKey',
    
    /**
     * Property: layerOptions
     * {Object} Any optional properties to be set on the sketch layer.
     */
    layerOptions: null,

    /**
     * APIProperty: persist
     * {Boolean} Leave the feature rendered until clear is called.  Default
     *     is false.  If set to true, the feature remains rendered until
     *     clear is called, typically by deactivating the handler or starting
     *     another drawing.
     */
    persist: false,

    /**
     * APIProperty: irregular
     * {Boolean} Draw an irregular polygon instead of a regular polygon.
     *     Default is false.  If true, the initial mouse down will represent
     *     one corner of the polygon bounds and with each mouse movement, the
     *     polygon will be stretched so the opposite corner of its bounds
     *     follows the mouse position.  This property takes precedence over
     *     the radius property.  If set to true, the radius property will
     *     be ignored.
     */
    irregular: false,

    /**
     * APIProperty: citeCompliant
     * {Boolean} If set to true, coordinates of features drawn in a map extent
     * crossing the date line won't exceed the world bounds. Default is false.
     */
    citeCompliant: false,

    /**
     * Property: angle
     * {Float} The angle from the origin (mouse down) to the current mouse
     *     position, in radians.  This is measured counterclockwise from the
     *     positive x-axis.
     */
    angle: null,

    /**
     * Property: fixedRadius
     * {Boolean} The polygon has a fixed radius.  True if a radius is set before
     *     drawing begins.  False otherwise.
     */
    fixedRadius: false,

    /**
     * Property: feature
     * {<HGIS.Feature.Vector>} The currently drawn polygon feature
     */
    feature: null,

    /**
     * Property: layer
     * {<HGIS.Layer.Vector>} The temporary drawing layer
     */
    layer: null,

    /**
     * Property: origin
     * {<HGIS.Geometry.Point>} Location of the first mouse down
     */
    origin: null,

    /**
     * Constructor: HGIS.Handler.RegularPolygon
     * Create a new regular polygon handler.
     *
     * Parameters:
     * control - {<HGIS.Control>} The control that owns this handler
     * callbacks - {Object} An object with a properties whose values are
     *     functions.  Various callbacks described below.
     * options - {Object} An object with properties to be set on the handler.
     *     If the options.sides property is not specified, the number of sides
     *     will default to 4.
     *
     * Named callbacks:
     * create - Called when a sketch is first created.  Callback called with
     *     the creation point geometry and sketch feature.
     * done - Called when the sketch drawing is finished.  The callback will
     *     recieve a single argument, the sketch geometry.
     * cancel - Called when the handler is deactivated while drawing.  The
     *     cancel callback will receive a geometry.
     */
    initialize: function(control, callbacks, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = HGIS.Util.extend(HGIS.Feature.Vector.style['default'], {});
        }

        HGIS.Handler.Drag.prototype.initialize.apply(this,
                                                [control, callbacks, options]);
        this.options = (options) ? options : {};
    },
    
    /**
     * APIMethod: setOptions
     * 
     * Parameters:
     * newOptions - {Object} 
     */
    setOptions: function (newOptions) {
        HGIS.Util.extend(this.options, newOptions);
        HGIS.Util.extend(this, newOptions);
    },
    
    /**
     * APIMethod: activate
     * Turn on the handler.
     *
     * Returns:
     * {Boolean} The handler was successfully activated
     */
    activate: function() {
        var activated = false;
        if(HGIS.Handler.Drag.prototype.activate.apply(this, arguments)) {
            // create temporary vector layer for rendering geometry sketch
            var options = HGIS.Util.extend({
                displayInLayerSwitcher: false,
                // indicate that the temp vector layer will never be out of range
                // without this, resolution properties must be specified at the
                // map-level for this temporary layer to init its resolutions
                // correctly
                calculateInRange: HGIS.Function.True,
                wrapDateLine: this.citeCompliant
            }, this.layerOptions);
            this.layer = new HGIS.Layer.Vector(this.CLASS_NAME, options);
            this.map.addLayer(this.layer);
            activated = true;
        }
        return activated;
    },

    /**
     * APIMethod: deactivate
     * Turn off the handler.
     *
     * Returns:
     * {Boolean} The handler was successfully deactivated
     */
    deactivate: function() {
        var deactivated = false;
        if(HGIS.Handler.Drag.prototype.deactivate.apply(this, arguments)) {
            // call the cancel callback if mid-drawing
            if(this.dragging) {
                this.cancel();
            }
            // If a layer's map property is set to null, it means that that
            // layer isn't added to the map. Since we ourself added the layer
            // to the map in activate(), we can assume that if this.layer.map
            // is null it means that the layer has been destroyed (as a result
            // of map.destroy() for example.
            if (this.layer.map != null) {
                this.layer.destroy(false);
                if (this.feature) {
                    this.feature.destroy();
                }
            }
            this.layer = null;
            this.feature = null;
            deactivated = true;
        }
        return deactivated;
    },
    
    /**
     * Method: down
     * Start drawing a new feature
     *
     * Parameters:
     * evt - {Event} The drag start event
     */
    down: function(evt) {
        this.fixedRadius = !!(this.radius);
        var maploc = this.layer.getLonLatFromViewPortPx(evt.xy); 
        this.origin = new HGIS.Geometry.Point(maploc.lon, maploc.lat);
        // create the new polygon
        if(!this.fixedRadius || this.irregular) {
            // smallest radius should not be less one pixel in map units
            // VML doesn't behave well with smaller
            this.radius = this.map.getResolution();
        }
        if(this.persist) {
            this.clear();
        }
        this.feature = new HGIS.Feature.Vector();
        this.createGeometry();
        this.callback("create", [this.origin, this.feature]);
        this.layer.addFeatures([this.feature], {silent: true});
        this.layer.drawFeature(this.feature, this.style);
    },
    
    /**
     * Method: move
     * Respond to drag move events
     *
     * Parameters:
     * evt - {Evt} The move event
     */
    move: function(evt) {
        var maploc = this.layer.getLonLatFromViewPortPx(evt.xy); 
        var point = new HGIS.Geometry.Point(maploc.lon, maploc.lat);
        if(this.irregular) {
            var ry = Math.sqrt(2) * Math.abs(point.y - this.origin.y) / 2;
            this.radius = Math.max(this.map.getResolution() / 2, ry);
        } else if(this.fixedRadius) {
            this.origin = point;
        } else {
            this.calculateAngle(point, evt);
            this.radius = Math.max(this.map.getResolution() / 2,
                                   point.distanceTo(this.origin));
        }
        this.modifyGeometry();
        if(this.irregular) {
            var dx = point.x - this.origin.x;
            var dy = point.y - this.origin.y;
            var ratio;
            if(dy == 0) {
                ratio = dx / (this.radius * Math.sqrt(2));
            } else {
                ratio = dx / dy;
            }
            this.feature.geometry.resize(1, this.origin, ratio);
            this.feature.geometry.move(dx / 2, dy / 2);
        }
        this.layer.drawFeature(this.feature, this.style);
    },

    /**
     * Method: up
     * Finish drawing the feature
     *
     * Parameters:
     * evt - {Event} The mouse up event
     */
    up: function(evt) {
        this.finalize();
        // the mouseup method of superclass doesn't call the
        // "done" callback if there's been no move between
        // down and up
        if (this.start == this.last) {
            this.callback("done", [evt.xy]);
        }
    },

    /**
     * Method: out
     * Finish drawing the feature.
     *
     * Parameters:
     * evt - {Event} The mouse out event
     */
    out: function(evt) {
        this.finalize();
    },

    /**
     * Method: createGeometry
     * Create the new polygon geometry.  This is called at the start of the
     *     drag and at any point during the drag if the number of sides
     *     changes.
     */
    createGeometry: function() {
        this.angle = Math.PI * ((1/this.sides) - (1/2));
        if(this.snapAngle) {
            this.angle += this.snapAngle * (Math.PI / 180);
        }
        this.feature.geometry = HGIS.Geometry.Polygon.createRegularPolygon(
            this.origin, this.radius, this.sides, this.snapAngle
        );
    },
    
    /**
     * Method: modifyGeometry
     * Modify the polygon geometry in place.
     */
    modifyGeometry: function() {
        var angle, point;
        var ring = this.feature.geometry.components[0];
        // if the number of sides ever changes, create a new geometry
        if(ring.components.length != (this.sides + 1)) {
            this.createGeometry();
            ring = this.feature.geometry.components[0];
        }
        for(var i=0; i<this.sides; ++i) {
            point = ring.components[i];
            angle = this.angle + (i * 2 * Math.PI / this.sides);
            point.x = this.origin.x + (this.radius * Math.cos(angle));
            point.y = this.origin.y + (this.radius * Math.sin(angle));
            point.clearBounds();
        }
    },
    
    /**
     * Method: calculateAngle
     * Calculate the angle based on settings.
     *
     * Parameters:
     * point - {<HGIS.Geometry.Point>}
     * evt - {Event}
     */
    calculateAngle: function(point, evt) {
        var alpha = Math.atan2(point.y - this.origin.y,
                               point.x - this.origin.x);
        if(this.snapAngle && (this.snapToggle && !evt[this.snapToggle])) {
            var snapAngleRad = (Math.PI / 180) * this.snapAngle;
            this.angle = Math.round(alpha / snapAngleRad) * snapAngleRad;
        } else {
            this.angle = alpha;
        }
    },

    /**
     * APIMethod: cancel
     * Finish the geometry and call the "cancel" callback.
     */
    cancel: function() {
        // the polygon geometry gets cloned in the callback method
        this.callback("cancel", null);
        this.finalize();
    },

    /**
     * Method: finalize
     * Finish the geometry and call the "done" callback.
     */
    finalize: function() {
        this.origin = null;
        this.radius = this.options.radius;
    },

    /**
     * APIMethod: clear
     * Clear any rendered features on the temporary layer.  This is called
     *     when the handler is deactivated, canceled, or done (unless persist
     *     is true).
     */
    clear: function() {
        if (this.layer) {
            this.layer.renderer.clear();
            this.layer.destroyFeatures();
        }
    },
    
    /**
     * Method: callback
     * Trigger the control's named callback with the given arguments
     *
     * Parameters:
     * name - {String} The key for the callback that is one of the properties
     *     of the handler's callbacks object.
     * args - {Array} An array of arguments with which to call the callback
     *     (defined by the control).
     */
    callback: function (name, args) {
        // override the callback method to always send the polygon geometry
        if (this.callbacks[name]) {
            this.callbacks[name].apply(this.control,
                                       [this.feature.geometry.clone()]);
        }
        // since sketch features are added to the temporary layer
        // they must be cleared here if done or cancel
        if(!this.persist && (name == "done" || name == "cancel")) {
            this.clear();
        }
    },

    CLASS_NAME: "HGIS.Handler.RegularPolygon"
});
/* ======================================================================
    HGIS/Control/SLDSelect.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Layer/WMS.js
 * @requires HGIS/Handler/RegularPolygon.js
 * @requires HGIS/Handler/Polygon.js
 * @requires HGIS/Handler/Path.js
 * @requires HGIS/Handler/Click.js
 * @requires HGIS/Filter/Spatial.js
 * @requires HGIS/Format/SLD/v1_0_0.js
 */

/**
 * Class: HGIS.Control.SLDSelect
 * Perform selections on WMS layers using Styled Layer Descriptor (SLD)
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.SLDSelect = HGIS.Class(HGIS.Control, {

    /** 
     * APIProperty: events
     * {<HGIS.Events>} Events instance for listeners and triggering
     *     control specific events.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types (in addition to those from <HGIS.Control.events>):
     * selected - Triggered when a selection occurs.  Listeners receive an 
     *     event with *filters* and *layer* properties.  Filters will be an 
     *     array of HGIS.Filter objects created in order to perform 
     *     the particular selection.
     */

    /**
     * APIProperty: clearOnDeactivate
     * {Boolean} Should the selection be cleared when the control is 
     *     deactivated. Default value is false.
     */
    clearOnDeactivate: false,

    /**
     * APIProperty: layers
     * {Array(<HGIS.Layer.WMS>)} The WMS layers this control will work 
     *     on.
     */
    layers: null,

    /**
     * Property: callbacks
     * {Object} The functions that are sent to the handler for callback
     */
    callbacks: null,

    /**
     * APIProperty: selectionSymbolizer
     * {Object} Determines the styling of the selected objects. Default is
     *     a selection in red.
     */
    selectionSymbolizer: {
        'Polygon': {fillColor: '#FF0000', stroke: false},
        'Line': {strokeColor: '#FF0000', strokeWidth: 2},
        'Point': {graphicName: 'square', fillColor: '#FF0000', pointRadius: 5}
    },

    /**
     * APIProperty: layerOptions
     * {Object} The options to apply to the selection layer, by default the
     *     selection layer will be kept out of the layer switcher.
     */
    layerOptions: null,

    /**
     * APIProperty: handlerOptions
     * {Object} Used to set non-default properties on the control's handler
     */

    /**
     * APIProperty: sketchStyle
     * {<HGIS.Style>|Object} Style or symbolizer to use for the sketch
     * handler. The recommended way of styling the sketch layer, however, is
     * to configure an <HGIS.StyleMap> in the layerOptions of the
     * <handlerOptions>:
     * 
     * (code)
     * new HGIS.Control.SLDSelect(HGIS.Handler.Path, {
     *     handlerOptions: {
     *         layerOptions: {
     *             styleMap: new HGIS.StyleMap({
     *                 "default": {strokeColor: "yellow"}
     *             })
     *         }
     *     }
     * });
     * (end)
     */
    sketchStyle: null,

    /**
     * APIProperty: wfsCache
     * {Object} Cache to use for storing parsed results from
     *     <HGIS.Format.WFSDescribeFeatureType.read>. If not provided,
     *     these will be cached on the prototype.
     */
    wfsCache: {},

    /**
     * APIProperty: layerCache
     * {Object} Cache to use for storing references to the selection layers.
     *     Normally each source layer will have exactly 1 selection layer of
     *     type HGIS.Layer.WMS. If not provided, layers will
     *     be cached on the prototype. Note that if <clearOnDeactivate> is
     *     true, the layer will no longer be cached after deactivating the
     *     control.
     */
    layerCache: {},

    /**
     * Constructor: HGIS.Control.SLDSelect
     * Create a new control for selecting features in WMS layers using
     *     Styled Layer Descriptor (SLD).
     *
     * Parameters:
     * handler - {<HGIS.Class>} A sketch handler class. This determines
     *     the type of selection, e.g. box (<HGIS.Handler.Box>), point
     *     (<HGIS.Handler.Point>), path (<HGIS.Handler.Path>) or
     *     polygon (<HGIS.Handler.Polygon>) selection. To use circle
     *     type selection, use <HGIS.Handler.RegularPolygon> and pass
     *     the number of desired sides (e.g. 40) as "sides" property to the
     *     <handlerOptions>.
     * options - {Object} An object containing all configuration properties for
     *     the control.
     *
     * Valid options:
     * layers - Array({<HGIS.Layer.WMS>}) The layers to perform the
     *     selection on.
     */
    initialize: function(handler, options) {
        HGIS.Control.prototype.initialize.apply(this, [options]);

        this.callbacks = HGIS.Util.extend({done: this.select, 
            click: this.select}, this.callbacks);
        this.handlerOptions = this.handlerOptions || {};
        this.layerOptions = HGIS.Util.applyDefaults(this.layerOptions, {
            displayInLayerSwitcher: false,
            tileOptions: {maxGetUrlLength: 2048}
        });
        if (this.sketchStyle) {
            this.handlerOptions.layerOptions = HGIS.Util.applyDefaults(
                this.handlerOptions.layerOptions,
                {styleMap: new HGIS.StyleMap({"default": this.sketchStyle})}
            );
        }
        this.handler = new handler(this, this.callbacks, this.handlerOptions);
    },

    /**
     * APIMethod: destroy
     * Take care of things that are not handled in superclass.
     */
    destroy: function() {
        for (var key in this.layerCache) {
            delete this.layerCache[key];
        }
        for (var key in this.wfsCache) {
            delete this.wfsCache[key];
        }
        HGIS.Control.prototype.destroy.apply(this, arguments);
    },

    /**
     * Method: coupleLayerVisiblity
     * Couple the selection layer and the source layer with respect to
     *     layer visibility. So if the source layer is turned off, the
     *     selection layer is also turned off.
     *
     * Context: 
     * - {<HGIS.Layer>}
     *
     * Parameters:
     * evt - {Object}
     */
    coupleLayerVisiblity: function(evt) {
        this.setVisibility(evt.object.getVisibility());
    },

    /**
     * Method: createSelectionLayer
     * Creates a "clone" from the source layer in which the selection can
     * be drawn. This ensures both the source layer and the selection are 
     * visible and not only the selection.
     *
     * Parameters:
     * source - {<HGIS.Layer.WMS>} The source layer on which the selection
     *     is performed.
     *
     * Returns:
     * {<HGIS.Layer.WMS>} A WMS layer with maxGetUrlLength configured to 2048
     *     since SLD selections can easily get quite long.
     */
    createSelectionLayer: function(source) {
        // check if we already have a selection layer for the source layer
        var selectionLayer;
        if (!this.layerCache[source.id]) {
            selectionLayer = new HGIS.Layer.WMS(source.name, 
                source.url, source.params, 
                HGIS.Util.applyDefaults(
                    this.layerOptions,
                    source.getOptions())
            );
            this.layerCache[source.id] = selectionLayer;
            // make sure the layers are coupled wrt visibility, but only
            // if they are not displayed in the layer switcher, because in
            // that case the user cannot control visibility.
            if (this.layerOptions.displayInLayerSwitcher === false) {
                source.events.on({
                    "visibilitychanged": this.coupleLayerVisiblity,
                    scope: selectionLayer});
            }
            this.map.addLayer(selectionLayer);
        } else {
            selectionLayer = this.layerCache[source.id];
        }
        return selectionLayer;
    },

    /**
     * Method: createSLD
     * Create the SLD document for the layer using the supplied filters.
     *
     * Parameters:
     * layer - {<HGIS.Layer.WMS>}
     * filters - Array({<HGIS.Filter>}) The filters to be applied.
     * geometryAttributes - Array({Object}) The geometry attributes of the 
     *     layer.
     *
     * Returns:
     * {String} The SLD document generated as a string.
     */
    createSLD: function(layer, filters, geometryAttributes) {
        var sld = {version: "1.0.0", namedLayers: {}};
        var layerNames = [layer.params.LAYERS].join(",").split(",");
        for (var i=0, len=layerNames.length; i<len; i++) { 
            var name = layerNames[i];
            sld.namedLayers[name] = {name: name, userStyles: []};
            var symbolizer = this.selectionSymbolizer;
            var geometryAttribute = geometryAttributes[i];
            if (geometryAttribute.type.indexOf('Polygon') >= 0) {
                symbolizer = {Polygon: this.selectionSymbolizer['Polygon']};
            } else if (geometryAttribute.type.indexOf('LineString') >= 0) {
                symbolizer = {Line: this.selectionSymbolizer['Line']};
            } else if (geometryAttribute.type.indexOf('Point') >= 0) {
                symbolizer = {Point: this.selectionSymbolizer['Point']};
            }
            var filter = filters[i];
            sld.namedLayers[name].userStyles.push({name: 'default', rules: [
                new HGIS.Rule({symbolizer: symbolizer, 
                    filter: filter, 
                    maxScaleDenominator: layer.options.minScale})
            ]});
        }
        return new HGIS.Format.SLD({srsName: this.map.getProjection()}).write(sld);
    },

    /**
     * Method: parseDescribeLayer
     * Parse the SLD WMS DescribeLayer response and issue the corresponding
     *     WFS DescribeFeatureType request
     *
     * request - {XMLHttpRequest} The request object.
     */
    parseDescribeLayer: function(request) {
        var format = new HGIS.Format.WMSDescribeLayer();
        var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        var describeLayer = format.read(doc);
        var typeNames = [];
        var url = null;
        for (var i=0, len=describeLayer.length; i<len; i++) {
            // perform a WFS DescribeFeatureType request
            if (describeLayer[i].owsType == "WFS") {
                typeNames.push(describeLayer[i].typeName);
                url = describeLayer[i].owsURL;
            }
        }
        var options = {
            url: url,
            params: {
                SERVICE: "WFS",
                TYPENAME: typeNames.toString(),
                REQUEST: "DescribeFeatureType",
                VERSION: "1.0.0"
            },
            callback: function(request) {
                var format = new HGIS.Format.WFSDescribeFeatureType();
                var doc = request.responseXML;
                if(!doc || !doc.documentElement) {
                    doc = request.responseText;
                }
                var describeFeatureType = format.read(doc);
                this.control.wfsCache[this.layer.id] = describeFeatureType;
                this.control._queue && this.control.applySelection();
            },
            scope: this
        };
        HGIS.Request.GET(options);
    },

   /**
    * Method: getGeometryAttributes
    * Look up the geometry attributes from the WFS DescribeFeatureType response
    *
    * Parameters:
    * layer - {<HGIS.Layer.WMS>} The layer for which to look up the 
    *     geometry attributes.
    *
    * Returns:
    * Array({Object}) Array of geometry attributes
    */ 
   getGeometryAttributes: function(layer) {
        var result = [];
        var cache = this.wfsCache[layer.id];
        for (var i=0, len=cache.featureTypes.length; i<len; i++) {
            var typeName = cache.featureTypes[i];
            var properties = typeName.properties;
            for (var j=0, lenj=properties.length; j < lenj; j++) {
                var property = properties[j];
                var type = property.type;
                if ((type.indexOf('LineString') >= 0) ||
                    (type.indexOf('GeometryAssociationType') >=0) ||
                    (type.indexOf('GeometryPropertyType') >= 0) ||
                    (type.indexOf('Point') >= 0) ||
                    (type.indexOf('Polygon') >= 0) ) {
                        result.push(property);
                }
            }
        }
        return result;
    },

    /**
     * APIMethod: activate
     * Activate the control. Activating the control will perform a SLD WMS
     *     DescribeLayer request followed by a WFS DescribeFeatureType request
     *     so that the proper symbolizers can be chosen based on the geometry
     *     type.
     */
    activate: function() {
        var activated = HGIS.Control.prototype.activate.call(this);
        if(activated) {
            for (var i=0, len=this.layers.length; i<len; i++) {
                var layer = this.layers[i];
                if (layer && !this.wfsCache[layer.id]) {
                    var options = {
                        url: layer.url,
                        params: {
                            SERVICE: "WMS",
                            VERSION: layer.params.VERSION,
                            LAYERS: layer.params.LAYERS,
                            REQUEST: "DescribeLayer"
                        },
                        callback: this.parseDescribeLayer,
                        scope: {layer: layer, control: this}
                    };
                    HGIS.Request.GET(options);
                }
            }
        }
        return activated;
    },

    /**
     * APIMethod: deactivate
     * Deactivate the control. If clearOnDeactivate is true, remove the
     *     selection layer(s).
     */
    deactivate: function() {
        var deactivated = HGIS.Control.prototype.deactivate.call(this);
        if(deactivated) {
            for (var i=0, len=this.layers.length; i<len; i++) {
                var layer = this.layers[i];
                if (layer && this.clearOnDeactivate === true) {
                    var layerCache = this.layerCache;
                    var selectionLayer = layerCache[layer.id];
                    if (selectionLayer) {
                        layer.events.un({
                            "visibilitychanged": this.coupleLayerVisiblity,
                            scope: selectionLayer});
                        selectionLayer.destroy();
                        delete layerCache[layer.id];
                    }
                }
            }
        }
        return deactivated;
    },

    /**
     * APIMethod: setLayers
     * Set the layers on which the selection should be performed.  Call the 
     *     setLayers method if the layer(s) to be used change and the same 
     *     control should be used on a new set of layers.
     *     If the control is already active, it will be active after the new
     *     set of layers is set.
     *
     * Parameters:
     * layers - {Array(<HGIS.Layer.WMS>)}  The new set of layers on which 
     *     the selection should be performed.
     */
    setLayers: function(layers) {
        if(this.active) {
            this.deactivate();
            this.layers = layers;
            this.activate();
        } else {
            this.layers = layers;
        }
    },

    /**
     * Function: createFilter
     * Create the filter to be used in the SLD.
     *
     * Parameters:
     * geometryAttribute - {Object} Used to get the name of the geometry 
     *     attribute which is needed for constructing the spatial filter.
     * geometry - {<HGIS.Geometry>} The geometry to use.
     *
     * Returns:
     * {<HGIS.Filter.Spatial>} The spatial filter created.
     */
    createFilter: function(geometryAttribute, geometry) {
        var filter = null;
        if (this.handler instanceof HGIS.Handler.RegularPolygon) {
            // box
            if (this.handler.irregular === true) {
                filter = new HGIS.Filter.Spatial({
                    type: HGIS.Filter.Spatial.BBOX,
                    property: geometryAttribute.name,
                    value: geometry.getBounds()}
                );
            } else {
                filter = new HGIS.Filter.Spatial({
                    type: HGIS.Filter.Spatial.INTERSECTS,
                    property: geometryAttribute.name,
                    value: geometry}
                );
            }
        } else if (this.handler instanceof HGIS.Handler.Polygon) {
            filter = new HGIS.Filter.Spatial({
                type: HGIS.Filter.Spatial.INTERSECTS,
                property: geometryAttribute.name,
                value: geometry}
            );
        } else if (this.handler instanceof HGIS.Handler.Path) {
            // if source layer is point based, use DWITHIN instead
            if (geometryAttribute.type.indexOf('Point') >= 0) {
                filter = new HGIS.Filter.Spatial({
                    type: HGIS.Filter.Spatial.DWITHIN,
                    property: geometryAttribute.name,
                    distance: this.map.getExtent().getWidth()*0.01 ,
                    distanceUnits: this.map.getUnits(),
                    value: geometry}
                );
            } else {
                filter = new HGIS.Filter.Spatial({
                    type: HGIS.Filter.Spatial.INTERSECTS,
                    property: geometryAttribute.name,
                    value: geometry}
                );
            }
        } else if (this.handler instanceof HGIS.Handler.Click) {
            if (geometryAttribute.type.indexOf('Polygon') >= 0) {
                filter = new HGIS.Filter.Spatial({
                    type: HGIS.Filter.Spatial.INTERSECTS,
                    property: geometryAttribute.name,
                    value: geometry}
                );
            } else {
                filter = new HGIS.Filter.Spatial({
                    type: HGIS.Filter.Spatial.DWITHIN,
                    property: geometryAttribute.name,
                    distance: this.map.getExtent().getWidth()*0.01 ,
                    distanceUnits: this.map.getUnits(),
                    value: geometry}
                );
            }
        }
        return filter;
    },

    /**
     * Method: select
     * When the handler is done, use SLD_BODY on the selection layer to
     *     display the selection in the map.
     *
     * Parameters:
     * geometry - {Object} or {<HGIS.Geometry>}
     */
    select: function(geometry) {
        this._queue = function() {
            for (var i=0, len=this.layers.length; i<len; i++) {
                var layer = this.layers[i];
                var geometryAttributes = this.getGeometryAttributes(layer);
                var filters = [];
                for (var j=0, lenj=geometryAttributes.length; j<lenj; j++) {
                    var geometryAttribute = geometryAttributes[j];
                    if (geometryAttribute !== null) {
                        // from the click handler we will not get an actual 
                        // geometry so transform
                        if (!(geometry instanceof HGIS.Geometry)) {
                            var point = this.map.getLonLatFromPixel(
                                geometry.xy);
                            geometry = new HGIS.Geometry.Point(
                                point.lon, point.lat);
                        }
                        var filter = this.createFilter(geometryAttribute,
                        geometry);
                        if (filter !== null) {
                            filters.push(filter);
                        }
                    }
                }
    
                var selectionLayer = this.createSelectionLayer(layer);
    
                this.events.triggerEvent("selected", {
                    layer: layer,
                    filters: filters
                });

                var sld = this.createSLD(layer, filters, geometryAttributes);
    
                selectionLayer.mergeNewParams({SLD_BODY: sld});
                delete this._queue;
            }
        };
        this.applySelection();
    },
    
    /**
     * Method: applySelection
     * Checks if all required wfs data is cached, and applies the selection
     */
    applySelection: function() {
        var canApply = true;
        for (var i=0, len=this.layers.length; i<len; i++) {
            if(!this.wfsCache[this.layers[i].id]) {
                canApply = false;
                break;
            }
        }
        canApply && this._queue.call(this);
    },

    CLASS_NAME: "HGIS.Control.SLDSelect"
});
/* ======================================================================
    HGIS/Control/Scale.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Control.js
 * @requires HGIS/Lang.js
 */

/**
 * Class: HGIS.Control.Scale
 * The Scale control displays the current map scale as a ratio (e.g. Scale = 
 * 1:1M). By default it is displayed in the lower right corner of the map.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.Scale = HGIS.Class(HGIS.Control, {
    
    /**
     * Property: element
     * {DOMElement}
     */
    element: null,
    
    /**
     * APIProperty: geodesic
     * {Boolean} Use geodesic measurement. Default is false. The recommended
     * setting for maps in EPSG:4326 is false, and true EPSG:900913. If set to
     * true, the scale will be calculated based on the horizontal size of the
     * pixel in the center of the map viewport.
     */
    geodesic: false,

    /**
     * Constructor: HGIS.Control.Scale
     * 
     * Parameters:
     * element - {DOMElement} 
     * options - {Object} 
     */
    initialize: function(element, options) {
        HGIS.Control.prototype.initialize.apply(this, [options]);
        this.element = HGIS.Util.getElement(element);        
    },

    /**
     * Method: draw
     * 
     * Returns:
     * {DOMElement}
     */    
    draw: function() {
        HGIS.Control.prototype.draw.apply(this, arguments);
        if (!this.element) {
            this.element = document.createElement("div");
            this.div.appendChild(this.element);
        }
        this.map.events.register( 'moveend', this, this.updateScale);
        this.updateScale();
        return this.div;
    },
   
    /**
     * Method: updateScale
     */
    updateScale: function() {
        var scale;
        if(this.geodesic === true) {
            var units = this.map.getUnits();
            if(!units) {
                return;
            }
            var inches = HGIS.INCHES_PER_UNIT;
            scale = (this.map.getGeodesicPixelSize().w || 0.000001) *
                    inches["km"] * HGIS.DOTS_PER_INCH;
        } else {
            scale = this.map.getScale();
        }
            
        if (!scale) {
            return;
        }

        if (scale >= 9500 && scale <= 950000) {
            scale = Math.round(scale / 1000) + "K";
        } else if (scale >= 950000) {
            scale = Math.round(scale / 1000000) + "M";
        } else {
            scale = Math.round(scale);
        }    
        
        this.element.innerHTML = HGIS.i18n("Scale = 1 : ${scaleDenom}", {'scaleDenom':scale});
    }, 

    CLASS_NAME: "HGIS.Control.Scale"
});

/* ======================================================================
    HGIS/Layer/MapGuide.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Request/XMLHttpRequest.js
 * @requires HGIS/Layer/Grid.js
 */

/**
 * Class: HGIS.Layer.MapGuide
 * Instances of HGIS.Layer.MapGuide are used to display
 * data from a MapGuide OS instance.
 *
 * Inherits from:
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.MapGuide = HGIS.Class(HGIS.Layer.Grid, {

    /** 
     * APIProperty: isBaseLayer
     * {Boolean} Treat this layer as a base layer.  Default is true.
     **/
    isBaseLayer: true,
    
    /**
     * APIProperty: useHttpTile
     * {Boolean} use a tile cache exposed directly via a webserver rather than the 
     *    via mapguide server. This does require extra configuration on the Mapguide Server,
     *    and will only work when singleTile is false. The url for the layer must be set to the
     *    webserver path rather than the Mapguide mapagent.
     *    See http://trac.osgeo.org/mapguide/wiki/CodeSamples/Tiles/ServingTilesViaHttp
     **/
    useHttpTile: false,
    
    /** 
     * APIProperty: singleTile
     * {Boolean} use tile server or request single tile image. 
     **/
    singleTile: false,
    
    /** 
     * APIProperty: useOverlay
     * {Boolean} flag to indicate if the layer should be retrieved using
     * GETMAPIMAGE (default) or using GETDYNAMICOVERLAY requests.
     **/
    useOverlay: false,
    
    /** 
     * APIProperty: useAsyncOverlay
     * {Boolean} indicates if the MapGuide site supports the asynchronous 
     * GETDYNAMICOVERLAY requests which is available in MapGuide Enterprise 2010
     * and MapGuide Open Source v2.0.3 or higher. The newer versions of MG 
     * is called asynchronously, allows selections to be drawn separately from 
     * the map and offers styling options.
     * 
     * With older versions of MapGuide, set useAsyncOverlay=false.  Note that in
     * this case a synchronous AJAX call is issued and the mapname and session
     * parameters must be used to initialize the layer, not the mapdefinition
     * parameter. Also note that this will issue a synchronous AJAX request 
     * before the image request can be issued so the users browser may lock
     * up if the MG Web tier does not respond in a timely fashion.
     **/
    useAsyncOverlay: true,
    
    /**
     * Constant: TILE_PARAMS
     * {Object} Hashtable of default parameter key/value pairs for tiled layer
     */
    TILE_PARAMS: {
         operation: 'GETTILEIMAGE',
         version: '1.2.0'
    },

    /**
     * Constant: SINGLE_TILE_PARAMS
     * {Object} Hashtable of default parameter key/value pairs for untiled layer
     */
    SINGLE_TILE_PARAMS: {
        operation: 'GETMAPIMAGE',
        format: 'PNG',
        locale: 'en',
        clip: '1',
        version: '1.0.0'
    },
    
    /**
     * Constant: OVERLAY_PARAMS
     * {Object} Hashtable of default parameter key/value pairs for untiled layer
     */
    OVERLAY_PARAMS: {
        operation: 'GETDYNAMICMAPOVERLAYIMAGE',
        format: 'PNG',
        locale: 'en',
        clip: '1',
        version: '2.0.0'
    },
    
    /** 
     * Constant: FOLDER_PARAMS
     * {Object} Hashtable of parameter key/value pairs which describe 
     * the folder structure for tiles as configured in the mapguide 
     * serverconfig.ini section [TileServiceProperties]
     */
    FOLDER_PARAMS: {
        tileColumnsPerFolder: 30,
        tileRowsPerFolder: 30,
        format: 'png',
        querystring: null
    },

    /** 
     * Property: defaultSize
     * {<HGIS.Size>} Tile size as produced by MapGuide server
     **/
    defaultSize: new HGIS.Size(300,300),

    /** 
     * Property: tileOriginCorner
     * {String} MapGuide tile server uses top-left as tile origin
     **/
    tileOriginCorner: "tl",

    /**
     * Constructor: HGIS.Layer.MapGuide
     * Create a new Mapguide layer, either tiled or untiled.  
     *
     * For tiled layers, the 'groupName' and 'mapDefinition' values 
     * must be specified as parameters in the constructor.
     *
     * For untiled base layers, specify either combination of 'mapName' and
     * 'session', or 'mapDefinition' and 'locale'.  
     *
     * For older versions of MapGuide and overlay layers, set useAsyncOverlay 
     * to false and in this case mapName and session are required parameters 
     * for the constructor.
     *
     * NOTE: MapGuide OS uses a DPI value and degrees to meters conversion 
     * factor that are different than the defaults used in HGIS, 
     * so these must be adjusted accordingly in your application.  
     * See the MapGuide example for how to set these values for MGOS.
     *
     * Parameters:
     * name - {String} Name of the layer displayed in the interface
     * url - {String} Location of the MapGuide mapagent executable
     *            (e.g. http://localhost:8008/mapguide/mapagent/mapagent.fcgi)
     * params - {Object} hashtable of additional parameters to use. Some
     *     parameters may require additional code on the server. The ones that
     *     you may want to use are: 
     *   - mapDefinition - {String} The MapGuide resource definition
     *            (e.g. Library://Samples/Gmap/Maps/gmapTiled.MapDefinition)
     *   - locale - Locale setting 
     *            (for untiled overlays layers only)
     *   - mapName - {String} Name of the map as stored in the MapGuide session.
     *          (for untiled layers with a session parameter only)
     *   - session - { String} MapGuide session ID 
     *            (for untiled overlays layers only)
     *   - basemaplayergroupname - {String} GroupName for tiled MapGuide layers only
     *   - format - Image format to be returned (for untiled overlay layers only)
     *   - showLayers - {String} A comma separated list of GUID's for the
     *       layers to display eg: 'cvc-xcv34,453-345-345sdf'.
     *   - hideLayers - {String} A comma separated list of GUID's for the
     *       layers to hide eg: 'cvc-xcv34,453-345-345sdf'.
     *   - showGroups - {String} A comma separated list of GUID's for the
     *       groups to display eg: 'cvc-xcv34,453-345-345sdf'.
     *   - hideGroups - {String} A comma separated list of GUID's for the
     *       groups to hide eg: 'cvc-xcv34,453-345-345sdf'
     *   - selectionXml - {String} A selection xml string Some server plumbing
     *       is required to read such a value.
     * options - {Object} Hashtable of extra options to tag onto the layer; 
     *          will vary depending if tiled or untiled maps are being requested
     */
    initialize: function(name, url, params, options) {
        
        HGIS.Layer.Grid.prototype.initialize.apply(this, arguments);
        
        // unless explicitly set in options, if the layer is transparent, 
        // it will be an overlay
        if (options == null || options.isBaseLayer == null) {
            this.isBaseLayer = ((this.transparent != "true") && 
                                (this.transparent != true));
        }

        if (options && options.useOverlay!=null) {
          this.useOverlay = options.useOverlay;
        }
        
        //initialize for untiled layers
        if (this.singleTile) {
          if (this.useOverlay) {
            HGIS.Util.applyDefaults(
                           this.params,
                           this.OVERLAY_PARAMS
                           );
            if (!this.useAsyncOverlay) {
              this.params.version = "1.0.0";
            }
          } else {
            HGIS.Util.applyDefaults(
                           this.params,
                           this.SINGLE_TILE_PARAMS
                           );
          }         
        } else {
            //initialize for tiled layers
            if (this.useHttpTile) {
                HGIS.Util.applyDefaults(
                               this.params,
                               this.FOLDER_PARAMS
                               );
            } else {
                HGIS.Util.applyDefaults(
                               this.params,
                               this.TILE_PARAMS
                               );
            }
            this.setTileSize(this.defaultSize); 
        }
    },

    /**
     * Method: clone
     * Create a clone of this layer
     *
     * Returns:
     * {<HGIS.Layer.MapGuide>} An exact clone of this layer
     */
    clone: function (obj) {
      if (obj == null) {
            obj = new HGIS.Layer.MapGuide(this.name,
                                           this.url,
                                           this.params,
                                           this.getOptions());
      }
      //get all additions from superclasses
      obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);

      return obj;
    },

    /**
     * Method: getURL
     * Return a query string for this layer
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>} A bounds representing the bbox 
     *                                for the request
     *
     * Returns:
     * {String} A string with the layer's url and parameters and also 
     *          the passed-in bounds and appropriate tile size specified 
     *          as parameters.
     */
    getURL: function (bounds) {
        var url;
        var center = bounds.getCenterLonLat();
        var mapSize = this.map.getSize();

        if (this.singleTile) {
          //set up the call for GETMAPIMAGE or GETDYNAMICMAPOVERLAY with
          //dynamic map parameters
          var params = {
            setdisplaydpi: HGIS.DOTS_PER_INCH,
            setdisplayheight: mapSize.h*this.ratio,
            setdisplaywidth: mapSize.w*this.ratio,
            setviewcenterx: center.lon,
            setviewcentery: center.lat,
            setviewscale: this.map.getScale()
          };
          
          if (this.useOverlay && !this.useAsyncOverlay) {
            //first we need to call GETVISIBLEMAPEXTENT to set the extent
            var getVisParams = {};
            getVisParams = HGIS.Util.extend(getVisParams, params);
            getVisParams.operation = "GETVISIBLEMAPEXTENT";
            getVisParams.version = "1.0.0";
            getVisParams.session = this.params.session;
            getVisParams.mapName = this.params.mapName;
            getVisParams.format = 'text/xml';
            url = this.getFullRequestString( getVisParams );
            
            HGIS.Request.GET({url: url, async: false});
          }
          //construct the full URL
          url = this.getFullRequestString( params );
        } else {

          //tiled version
          var currentRes = this.map.getResolution();
          var colidx = Math.floor((bounds.left-this.maxExtent.left)/currentRes);
          colidx = Math.round(colidx/this.tileSize.w);
          var rowidx = Math.floor((this.maxExtent.top-bounds.top)/currentRes);
          rowidx = Math.round(rowidx/this.tileSize.h);

          if (this.useHttpTile){
              url = this.getImageFilePath(
                   {
                       tilecol: colidx,
                       tilerow: rowidx,
                       scaleindex: this.resolutions.length - this.map.zoom - 1
                    });

          } else {
            url = this.getFullRequestString(
                   {
                       tilecol: colidx,
                       tilerow: rowidx,
                       scaleindex: this.resolutions.length - this.map.zoom - 1
                    });
          }
       }
       return url;
    },

    /**
     * Method: getFullRequestString
     * getFullRequestString on MapGuide layers is special, because we 
     * do a regular expression replace on ',' in parameters to '+'.
     * This is why it is subclassed here.
     *
     * Parameters:
     * altUrl - {String} Alternative base URL to use.
     *
     * Returns:
     * {String} A string with the layer's url appropriately encoded for MapGuide
     */
    getFullRequestString:function(newParams, altUrl) {
        // use layer's url unless altUrl passed in
        var url = (altUrl == null) ? this.url : altUrl;
        
        // if url is not a string, it should be an array of strings, 
        //  in which case we will randomly select one of them in order
        //  to evenly distribute requests to different urls.
        if (typeof url == "object") {
            url = url[Math.floor(Math.random()*url.length)];
        }   
        // requestString always starts with url
        var requestString = url;        

        // create a new params hashtable with all the layer params and the 
        // new params together. then convert to string
        var allParams = HGIS.Util.extend({}, this.params);
        allParams = HGIS.Util.extend(allParams, newParams);
        // ignore parameters that are already in the url search string
        var urlParams = HGIS.Util.upperCaseObject(
                            HGIS.Util.getParameters(url));
        for(var key in allParams) {
            if(key.toUpperCase() in urlParams) {
                delete allParams[key];
            }
        }
        var paramsString = HGIS.Util.getParameterString(allParams);
        
        /* MapGuide needs '+' seperating things like bounds/height/width.
           Since typically this is URL encoded, we use a slight hack: we
           depend on the list-like functionality of getParameterString to
           leave ',' only in the case of list items (since otherwise it is
           encoded) then do a regular expression replace on the , characters
           to '+' */
        paramsString = paramsString.replace(/,/g, "+");
        
        if (paramsString != "") {
            var lastServerChar = url.charAt(url.length - 1);
            if ((lastServerChar == "&") || (lastServerChar == "?")) {
                requestString += paramsString;
            } else {
                if (url.indexOf('?') == -1) {
                    //serverPath has no ? -- add one
                    requestString += '?' + paramsString;
                } else {
                    //serverPath contains ?, so must already have paramsString at the end
                    requestString += '&' + paramsString;
                }
            }
        }
        return requestString;
    },

     /** 
     * Method: getImageFilePath
     * special handler to request mapguide tiles from an http exposed tilecache 
     *
     * Parameters:
     * altUrl - {String} Alternative base URL to use.
     *
     * Returns:
     * {String} A string with the url for the tile image
     */
    getImageFilePath:function(newParams, altUrl) {
        // use layer's url unless altUrl passed in
        var url = (altUrl == null) ? this.url : altUrl;
        
        // if url is not a string, it should be an array of strings, 
        //  in which case we will randomly select one of them in order
        //  to evenly distribute requests to different urls.
        if (typeof url == "object") {
            url = url[Math.floor(Math.random()*url.length)];
        }   
        // requestString always starts with url
        var requestString = url;        

        var tileRowGroup = "";
        var tileColGroup = "";
        
        if (newParams.tilerow < 0) {
          tileRowGroup =  '-';
        }
          
        if (newParams.tilerow == 0 ) {
          tileRowGroup += '0';
        } else {
          tileRowGroup += Math.floor(Math.abs(newParams.tilerow/this.params.tileRowsPerFolder)) * this.params.tileRowsPerFolder;
        }
          
        if (newParams.tilecol < 0) {
          tileColGroup =  '-';
        }
        
        if (newParams.tilecol == 0) {
          tileColGroup += '0';
        } else {
          tileColGroup += Math.floor(Math.abs(newParams.tilecol/this.params.tileColumnsPerFolder)) * this.params.tileColumnsPerFolder;
        }
        
        var tilePath = '/S' + Math.floor(newParams.scaleindex)
                + '/' + this.params.basemaplayergroupname
                + '/R' + tileRowGroup
                + '/C' + tileColGroup
                + '/' + (newParams.tilerow % this.params.tileRowsPerFolder) 
                + '_' + (newParams.tilecol % this.params.tileColumnsPerFolder) 
                + '.' + this.params.format;
    
        if (this.params.querystring) {
               tilePath += "?" + this.params.querystring;
        }
        
        requestString += tilePath;
        return requestString;
    },
    
    CLASS_NAME: "HGIS.Layer.MapGuide"
});
/* ======================================================================
    HGIS/Control/Measure.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Feature/Vector.js
 */

/**
 * Class: HGIS.Control.Measure
 * Allows for drawing of features for measurements.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.Measure = HGIS.Class(HGIS.Control, {

    /**
     * APIProperty: events
     * {<HGIS.Events>} Events instance for listeners and triggering
     *     control specific events.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types (in addition to those from <HGIS.Control.events>):
     * measure - Triggered when a measurement sketch is complete.  Listeners
     *      will receive an event with measure, units, order, and geometry
     *      properties.
     * measurepartial - Triggered when a new point is added to the
     *      measurement sketch or if the <immediate> property is true and the
     *      measurement sketch is modified.  Listeners receive an event with measure,
     *      units, order, and geometry.
     */

    /**
     * APIProperty: handlerOptions
     * {Object} Used to set non-default properties on the control's handler
     */

    /**
     * Property: callbacks
     * {Object} The functions that are sent to the handler for callback
     */
    callbacks: null,

    /**
     * APIProperty: displaySystem
     * {String} Display system for output measurements.  Supported values
     *     are 'english', 'metric', and 'geographic'.  Default is 'metric'.
     */
    displaySystem: 'metric',

    /**
     * APIProperty: geodesic
     * {Boolean} Calculate geodesic metrics instead of planar metrics.  This
     *     requires that geometries can be transformed into Geographic/WGS84
     *     (if that is not already the map projection).  Default is false.
     */
    geodesic: false,

    /**
     * Property: displaySystemUnits
     * {Object} Units for various measurement systems.  Values are arrays
     *     of unit abbreviations (from HGIS.INCHES_PER_UNIT) in decreasing
     *     order of length.
     */
    displaySystemUnits: {
        geographic: ['dd'],
        english: ['mi', 'ft', 'in'],
        metric: ['km', 'm']
    },

    /**
     * Property: delay
     * {Number} Number of milliseconds between clicks before the event is
     *     considered a double-click.  The "measurepartial" event will not
     *     be triggered if the sketch is completed within this time.  This
     *     is required for IE where creating a browser reflow (if a listener
     *     is modifying the DOM by displaying the measurement values) messes
     *     with the dblclick listener in the sketch handler.
     */
    partialDelay: 300,

    /**
     * Property: delayedTrigger
     * {Number} Timeout id of trigger for measurepartial.
     */
    delayedTrigger: null,

    /**
     * APIProperty: persist
     * {Boolean} Keep the temporary measurement sketch drawn after the
     *     measurement is complete.  The geometry will persist until a new
     *     measurement is started, the control is deactivated, or <cancel> is
     *     called.
     */
    persist: false,

    /**
     * APIProperty: immediate
     * {Boolean} Activates the immediate measurement so that the "measurepartial"
     *     event is also fired once the measurement sketch is modified.
     *     Default is false.
     */
    immediate : false,

    /**
     * Constructor: HGIS.Control.Measure
     *
     * Parameters:
     * handler - {<HGIS.Handler>}
     * options - {Object}
     */
    initialize: function(handler, options) {
        HGIS.Control.prototype.initialize.apply(this, [options]);
        var callbacks = {done: this.measureComplete,
            point: this.measurePartial};
        if (this.immediate){
            callbacks.modify = this.measureImmediate;
        }
        this.callbacks = HGIS.Util.extend(callbacks, this.callbacks);

        // let the handler options override, so old code that passes 'persist'
        // directly to the handler does not need an update
        this.handlerOptions = HGIS.Util.extend(
            {persist: this.persist}, this.handlerOptions
        );
        this.handler = new handler(this, this.callbacks, this.handlerOptions);
    },

    /**
     * APIMethod: deactivate
     */
    deactivate: function() {
        this.cancelDelay();
        return HGIS.Control.prototype.deactivate.apply(this, arguments);
    },

    /**
     * APIMethod: cancel
     * Stop the control from measuring.  If <persist> is true, the temporary
     *     sketch will be erased.
     */
    cancel: function() {
        this.cancelDelay();
        this.handler.cancel();
    },

    /**
     * APIMethod: setImmediate
     * Sets the <immediate> property. Changes the activity of immediate
     * measurement.
     */
    setImmediate: function(immediate) {
        this.immediate = immediate;
        if (this.immediate){
            this.callbacks.modify = this.measureImmediate;
        } else {
            delete this.callbacks.modify;
        }
    },

    /**
     * Method: updateHandler
     *
     * Parameters:
     * handler - {Function} One of the sketch handler constructors.
     * options - {Object} Options for the handler.
     */
    updateHandler: function(handler, options) {
        var active = this.active;
        if(active) {
            this.deactivate();
        }
        this.handler = new handler(this, this.callbacks, options);
        if(active) {
            this.activate();
        }
    },

    /**
     * Method: measureComplete
     * Called when the measurement sketch is done.
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     */
    measureComplete: function(geometry) {
        this.cancelDelay();
        this.measure(geometry, "measure");
    },

    /**
     * Method: measurePartial
     * Called each time a new point is added to the measurement sketch.
     *
     * Parameters:
     * point - {<HGIS.Geometry.Point>} The last point added.
     * geometry - {<HGIS.Geometry>} The sketch geometry.
     */
    measurePartial: function(point, geometry) {
        this.cancelDelay();
        geometry = geometry.clone();
        // when we're wating for a dblclick, we have to trigger measurepartial
        // after some delay to deal with reflow issues in IE
        if (this.handler.freehandMode(this.handler.evt)) {
            // no dblclick in freehand mode
            this.measure(geometry, "measurepartial");
        } else {
        	//为解决绘制太快，无法计算中间段的长度而修改--2017-08-07
        	var me=this;
        	function measPartial(){
        		 me.measure(geometry, "measurepartial");
        	}
        	window.setTimeout(measPartial,this.partialDelay);
        	
        	//下面的为原来的
            /* this.delayedTrigger = window.setTimeout(
                 HGIS.Function.bind(function() {
                     this.delayedTrigger = null;
                     this.measure(geometry, "measurepartial");
                 }, this),
                 this.partialDelay
             );*/
        }
    },

    /**
     * Method: measureImmediate
     * Called each time the measurement sketch is modified.
     *
     * Parameters:
     * point - {<HGIS.Geometry.Point>} The point at the mouse position.
     * feature - {<HGIS.Feature.Vector>} The sketch feature.
     * drawing - {Boolean} Indicates whether we're currently drawing.
     */
    measureImmediate : function(point, feature, drawing) {
        if (drawing && !this.handler.freehandMode(this.handler.evt)) {
            this.cancelDelay();
            this.measure(feature.geometry, "measurepartial");
        }
    },

    /**
     * Method: cancelDelay
     * Cancels the delay measurement that measurePartial began.
     */
    cancelDelay: function() {
        if (this.delayedTrigger !== null) {
            window.clearTimeout(this.delayedTrigger);
            this.delayedTrigger = null;
        }
    },

    /**
     * Method: measure
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * eventType - {String}
     */
    measure: function(geometry, eventType) {
        var stat, order;
        if(geometry.CLASS_NAME.indexOf('LineString') > -1) {
            stat = this.getBestLength(geometry);
            order = 1;
        } else {
            stat = this.getBestArea(geometry);
            order = 2;
        }
        this.events.triggerEvent(eventType, {
            measure: stat[0],
            units: stat[1],
            order: order,
            geometry: geometry
        });
    },

    /**
     * Method: getBestArea
     * Based on the <displaySystem> returns the area of a geometry.
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     *
     * Returns:
     * {Array([Float, String])}  Returns a two item array containing the
     *     area and the units abbreviation.
     */
    getBestArea: function(geometry) {
        var units = this.displaySystemUnits[this.displaySystem];
        var unit, area;
        for(var i=0, len=units.length; i<len; ++i) {
            unit = units[i];
            area = this.getArea(geometry, unit);
            if(area > 1) {
                break;
            }
        }
        return [area, unit];
    },

    /**
     * Method: getArea
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * units - {String} Unit abbreviation
     *
     * Returns:
     * {Float} The geometry area in the given units.
     */
    getArea: function(geometry, units) {
        var area, geomUnits;
        if(HGIS.InitParam.geodesic) {
            area = geometry.getGeodesicArea(this.map.getProjectionObject());
            geomUnits = "m";
        } else {
            area = geometry.getArea();
            geomUnits = this.map.getUnits();
        }
        var inPerDisplayUnit = HGIS.INCHES_PER_UNIT[units];
        if(inPerDisplayUnit) {
            var inPerMapUnit = HGIS.INCHES_PER_UNIT[geomUnits];
            area *= Math.pow((inPerMapUnit / inPerDisplayUnit), 2);
        }
        return area;
    },

    /**
     * Method: getBestLength
     * Based on the <displaySystem> returns the length of a geometry.
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     *
     * Returns:
     * {Array([Float, String])}  Returns a two item array containing the
     *     length and the units abbreviation.
     */
    getBestLength: function(geometry) {
        var units = this.displaySystemUnits[this.displaySystem];
        var unit, length;
        for(var i=0, len=units.length; i<len; ++i) {
            unit = units[i];
            length = this.getLength(geometry, unit);
            if(length > 1) {
                break;
            }
        }
        return [length, unit];
    },

    /**
     * Method: getLength
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * units - {String} Unit abbreviation
     *
     * Returns:
     * {Float} The geometry length in the given units.
     */
    getLength: function(geometry, units) {
        var length, geomUnits;
        if(HGIS.InitParam.geodesic) {
            length = geometry.getGeodesicLength(this.map.getProjectionObject());
            geomUnits = "m";
        } else {
            length = geometry.getLength();
            geomUnits = this.map.getUnits();
        }
        var inPerDisplayUnit = HGIS.INCHES_PER_UNIT[units];
        if(inPerDisplayUnit) {
            var inPerMapUnit = HGIS.INCHES_PER_UNIT[geomUnits];
            length *= (inPerMapUnit / inPerDisplayUnit);
        }
        return length;
    },

    CLASS_NAME: "HGIS.Control.Measure"
});
/* ======================================================================
    HGIS/Format/WMC/v1_0_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WMC/v1.js
 */

/**
 * Class: HGIS.Format.WMC.v1_0_0
 * Read and write WMC version 1.0.0.
 * 
 * Inherits from:
 *  - <HGIS.Format.WMC.v1>
 */
HGIS.Format.WMC.v1_0_0 = HGIS.Class(
    HGIS.Format.WMC.v1, {
    
    /**
     * Constant: VERSION
     * {String} 1.0.0
     */
    VERSION: "1.0.0",
    
    /**
     * Property: schemaLocation
     * {String} http://www.opengis.net/context
     *     http://schemas.opengis.net/context/1.0.0/context.xsd
     */
    schemaLocation: "http://www.opengis.net/context http://schemas.opengis.net/context/1.0.0/context.xsd",

    /**
     * Constructor: HGIS.Format.WMC.v1_0_0
     * Instances of this class are not created directly.  Use the
     *     <HGIS.Format.WMC> constructor instead.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        HGIS.Format.WMC.v1.prototype.initialize.apply(
            this, [options]
        );
    },

    /**
     * Method: read_wmc_SRS
     */
    read_wmc_SRS: function(layerContext, node) {
        var srs    = this.getChildValue(node);
        if (typeof layerContext.projections != "object") {
            layerContext.projections = {};
        }
        var values = srs.split(/ +/);
        for (var i=0, len=values.length; i<len; i++) {
            layerContext.projections[values[i]] = true;
        }
    },

    /**
     * Method: write_wmc_Layer
     * Create a Layer node given a layer context object. This method adds
     *     elements specific to version 1.0.0.
     *
     * Parameters:
     * context - {Object} A layer context object.}
     *
     * Returns:
     * {Element} A WMC Layer element node.
     */
    write_wmc_Layer: function(context) {
        var node = HGIS.Format.WMC.v1.prototype.write_wmc_Layer.apply(
            this, [context]
        );
    
        // optional SRS element(s)
        if (context.srs) {
            var projections = [];
            for(var name in context.srs) {
                projections.push(name);
            }
            node.appendChild(this.createElementDefaultNS("SRS", projections.join(" ")));
        }

        // optional FormatList element
        node.appendChild(this.write_wmc_FormatList(context));

        // optional StyleList element
        node.appendChild(this.write_wmc_StyleList(context));
        
        // optional DimensionList element
        if (context.dimensions) {
            node.appendChild(this.write_wmc_DimensionList(context));
        }

        // HGIS specific properties go in an Extension element
        node.appendChild(this.write_wmc_LayerExtension(context));
    },    

    CLASS_NAME: "HGIS.Format.WMC.v1_0_0" 

});
/* ======================================================================
    HGIS/Popup/Anchored.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Popup.js
 */

/**
 * Class: HGIS.Popup.Anchored
 * 
 * Inherits from:
 *  - <HGIS.Popup>
 */
HGIS.Popup.Anchored = 
  HGIS.Class(HGIS.Popup, {

    /** 
     * Property: relativePosition
     * {String} Relative position of the popup ("br", "tr", "tl" or "bl").
     */
    relativePosition: null,
    
    /**
     * APIProperty: keepInMap 
     * {Boolean} If panMapIfOutOfView is false, and this property is true, 
     *     contrain the popup such that it always fits in the available map
     *     space. By default, this is set. If you are creating popups that are
     *     near map edges and not allowing pannning, and especially if you have
     *     a popup which has a fixedRelativePosition, setting this to false may
     *     be a smart thing to do.
     *   
     *     For anchored popups, default is true, since subclasses will
     *     usually want this functionality.
     */
    keepInMap: true,

    /**
     * Property: anchor
     * {Object} Object to which we'll anchor the popup. Must expose a 
     *     'size' (<HGIS.Size>) and 'offset' (<HGIS.Pixel>).
     */
    anchor: null,
    /**
     * APIProperty: changeAnchorIfOutOfView 
     * {Boolean} 超出视图范围后，是否对锚点进行调整,默认为true.
     * 当changeAnchorIfOutOfView为true时，当需要显示的弹框位置超出了视图范围，弹框的锚点信息将做变更，以将弹框完整展示。
     */
    changeAnchorIfOutOfView : false,
    /** 
    * Constructor: HGIS.Popup.Anchored
    * 
    * Parameters:
    * id - {String}
    * lonlat - {<HGIS.LonLat>}
    * contentSize - {<HGIS.Size>}
    * contentHTML - {String}
    * anchor - {Object} Object which must expose a 'size' <HGIS.Size> 
    *     and 'offset' <HGIS.Pixel> (generally an <HGIS.Icon>).
    * closeBox - {Boolean}
    * closeBoxCallback - {Function} Function to be called on closeBox click.
    */
    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox,
                        closeBoxCallback) {
        var newArguments = [
            id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback
        ];
        HGIS.Popup.prototype.initialize.apply(this, newArguments);

        this.anchor = (anchor != null) ? anchor 
                                       : { size: new HGIS.Size(0,0),
                                           offset: new HGIS.Pixel(0,0)};
        this.contentSize = contentSize ? contentSize :null ;
    },

    /**
     * APIMethod: destroy
     */
    destroy: function() {
        this.anchor = null;
        this.relativePosition = null;
        
        HGIS.Popup.prototype.destroy.apply(this, arguments);        
    },

    /**
     * APIMethod: show
     * Overridden from Popup since user might hide popup and then show() it 
     *     in a new location (meaning we might want to update the relative
     *     position on the show)
     */
    show: function() {
        this.updatePosition();
        HGIS.Popup.prototype.show.apply(this, arguments);
    },

    /**
     * Method: moveTo
     * Since the popup is moving to a new px, it might need also to be moved
     *     relative to where the marker is. We first calculate the new 
     *     relativePosition, and then we calculate the new px where we will 
     *     put the popup, based on the new relative position. 
     * 
     *     If the relativePosition has changed, we must also call 
     *     updateRelativePosition() to make any visual changes to the popup 
     *     which are associated with putting it in a new relativePosition.
     * 
     * Parameters:
     * px - {<HGIS.Pixel>}
     */
    moveTo: function(px) {
        var oldRelativePosition = this.relativePosition;
        this.relativePosition = this.calculateRelativePosition(px);

        HGIS.Popup.prototype.moveTo.call(this, this.calculateNewPx(px));
        
        //if this move has caused the popup to change its relative position, 
        // we need to make the appropriate cosmetic changes.
        if (this.relativePosition != oldRelativePosition) {
            this.updateRelativePosition();
        }
    },
    /**
     * Method: changeAnchorSize
     * 当弹框超出视图范围的时候，调整锚点的大小，以其将弹框完全显示在视图范围以内
     */
    changeAnchorSize: function() {
        // 参考调用 popup 中的panIntoView 方法计算出地图需要移动的量 ，此处移动的量作为改变锚点大小 以适应地图的依据
        var arr = HGIS.Popup.prototype.calculateOffset.call(this);
        if(arr[0] != 0 || arr[1] != 0){
	        this.div.style.left = parseInt(this.div.style.left) -arr[0]  + "px";
	        this.div.style.top =  parseInt(this.div.style.top) -arr[1]  + "px";
        }
    },

    /**
     * APIMethod: setSize
     * 
     * Parameters:
     * contentSize - {<HGIS.Size>} the new size for the popup's 
     *     contents div (in pixels).
     */
    setSize:function(contentSize) { 
        HGIS.Popup.prototype.setSize.apply(this, arguments);

        if ((this.lonlat) && (this.map)) {
            var px = this.map.getLayerPxFromLonLat(this.lonlat);
            this.moveTo(px);
        }
    },  
    
    /** 
     * Method: calculateRelativePosition
     * 
     * Parameters:
     * px - {<HGIS.Pixel>}
     * 
     * Returns:
     * {String} The relative position ("br" "tr" "tl" "bl") at which the popup
     *     should be placed.
     */
    calculateRelativePosition:function(px) {
        var lonlat = this.map.getLonLatFromLayerPx(px);        
        
        var extent = this.map.getExtent();
        var quadrant = extent.determineQuadrant(lonlat);
        
        return HGIS.Bounds.oppositeQuadrant(quadrant);
    }, 

    /**
     * Method: updateRelativePosition
     * The popup has been moved to a new relative location, so we may want to 
     *     make some cosmetic adjustments to it. 
     * 
     *     Note that in the classic Anchored popup, there is nothing to do 
     *     here, since the popup looks exactly the same in all four positions.
     *     Subclasses such as Framed, however, will want to do something
     *     special here.
     */
    updateRelativePosition: function() {
        //to be overridden by subclasses
    },

    /** 
     * Method: calculateNewPx
     * 
     * Parameters:
     * px - {<HGIS.Pixel>}
     * 
     * Returns:
     * {<HGIS.Pixel>} The the new px position of the popup on the screen
     *     relative to the passed-in px.
     */
    calculateNewPx:function(px) {
        var newPx = px.offset(this.anchor.offset);
        
        //use contentSize if size is not already set
        var size = this.size || this.contentSize;

        var top = (this.relativePosition.charAt(0) == 't');
        newPx.y += (top) ? -size.h : this.anchor.size.h;
        
        var left = (this.relativePosition.charAt(1) == 'l');
        newPx.x += (left) ? -size.w : this.anchor.size.w;

        return newPx;   
    },

    CLASS_NAME: "HGIS.Popup.Anchored"
});
/* ======================================================================
    HGIS/Popup/Framed.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Popup/Anchored.js
 */

/**
 * Class: HGIS.Popup.Framed
 * 
 * Inherits from:
 *  - <HGIS.Popup.Anchored>
 */
HGIS.Popup.Framed =
  HGIS.Class(HGIS.Popup.Anchored, {

    /**
     * Property: imageSrc
     * {String} location of the image to be used as the popup frame
     */
    imageSrc: null,

    /**
     * Property: imageSize
     * {<HGIS.Size>} Size (measured in pixels) of the image located
     *     by the 'imageSrc' property.
     */
    imageSize: null,

    /**
     * APIProperty: isAlphaImage
     * {Boolean} The image has some alpha and thus needs to use the alpha 
     *     image hack. Note that setting this to true will have no noticeable
     *     effect in FF or IE7 browsers, but will all but crush the ie6 
     *     browser. 
     *     Default is false.
     */
    isAlphaImage: false,
    /**
     * APIProperty: changeAnchorIfOutOfView 
     * {Boolean} 超出视图范围后，是否对锚点进行调整,默认为true.
     * 当changeAnchorIfOutOfView为true时，当弹框的展示区域超出了视图范围，弹框的锚点信息将做变更，以将弹框完整展示。
     */
    changeAnchorIfOutOfView :false,
    /**
     * Property: positionBlocks
     * {Object} Hash of different position blocks (Object/Hashs). Each block 
     *     will be keyed by a two-character 'relativePosition' 
     *     code string (ie "tl", "tr", "bl", "br"). Block properties are 
     *     'offset', 'padding' (self-explanatory), and finally the 'blocks'
     *     parameter, which is an array of the block objects. 
     * 
     *     Each block object must have 'size', 'anchor', and 'position' 
     *     properties.
     * 
     *     Note that positionBlocks should never be modified at runtime.
     */
    positionBlocks: null,

    /**
     * Property: blocks
     * {Array[Object]} Array of objects, each of which is one "block" of the 
     *     popup. Each block has a 'div' and an 'image' property, both of 
     *     which are DOMElements, and the latter of which is appended to the 
     *     former. These are reused as the popup goes changing positions for
     *     great economy and elegance.
     */
    blocks: null,

    /** 
     * APIProperty: fixedRelativePosition
     * {Boolean} We want the framed popup to work dynamically placed relative
     *     to its anchor but also in just one fixed position. A well designed
     *     framed popup will have the pixels and logic to display itself in 
     *     any of the four relative positions, but (understandably), this will
     *     not be the case for all of them. By setting this property to 'true', 
     *     framed popup will not recalculate for the best placement each time
     *     it's open, but will always open the same way. 
     *     Note that if this is set to true, it is generally advisable to also
     *     set the 'panIntoView' property to true so that the popup can be 
     *     scrolled into view (since it will often be offscreen on open)
     *     Default is false.
     */
    fixedRelativePosition: false,

    /** 
     * Constructor: HGIS.Popup.Framed
     * 
     * Parameters:
     * id - {String}
     * lonlat - {<HGIS.LonLat>}
     * contentSize - {<HGIS.Size>}
     * contentHTML - {String}
     * anchor - {Object} Object to which we'll anchor the popup. Must expose 
     *     a 'size' (<HGIS.Size>) and 'offset' (<HGIS.Pixel>) 
     *     (Note that this is generally an <HGIS.Icon>).
     * closeBox - {Boolean}
     * closeBoxCallback - {Function} Function to be called on closeBox click.
     */
    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox, 
                        closeBoxCallback) {

        HGIS.Popup.Anchored.prototype.initialize.apply(this, arguments);

        if (this.fixedRelativePosition) {
            //based on our decided relativePostion, set the current padding
            // this keeps us from getting into trouble 
            this.updateRelativePosition();
            
            //make calculateRelativePosition always return the specified
            // fixed position.
            this.calculateRelativePosition = function(px) {
                return this.relativePosition;
            };
        }

        this.contentDiv.style.position = "absolute";
        this.contentDiv.style.zIndex = 1;

        if (closeBox) {
            this.closeDiv.style.zIndex = 1;
        }

        this.groupDiv.style.position = "absolute";
        this.groupDiv.style.top = "0px";
        this.groupDiv.style.left = "0px";
        this.groupDiv.style.height = "100%";
        this.groupDiv.style.width = "100%";
    },

    /** 
     * APIMethod: destroy
     */
    destroy: function() {
        this.imageSrc = null;
        this.imageSize = null;
        this.isAlphaImage = null;

        this.fixedRelativePosition = false;
        this.positionBlocks = null;

        //remove our blocks
        for(var i = 0; i < this.blocks.length; i++) {
            var block = this.blocks[i];

            if (block.image) {
                block.div.removeChild(block.image);
            }
            block.image = null;

            if (block.div) {
                this.groupDiv.removeChild(block.div);
            }
            block.div = null;
        }
        this.blocks = null;

        HGIS.Popup.Anchored.prototype.destroy.apply(this, arguments);
    },

    /**
     * APIMethod: setBackgroundColor
     */
    setBackgroundColor:function(color) {
        //does nothing since the framed popup's entire scheme is based on a 
        // an image -- changing the background color makes no sense. 
    },

    /**
     * APIMethod: setBorder
     */
    setBorder:function() {
        //does nothing since the framed popup's entire scheme is based on a 
        // an image -- changing the popup's border makes no sense. 
    },

    /**
     * Method: setOpacity
     * Sets the opacity of the popup.
     * 
     * Parameters:
     * opacity - {float} A value between 0.0 (transparent) and 1.0 (solid).   
     */
    setOpacity:function(opacity) {
        //does nothing since we suppose that we'll never apply an opacity
        // to a framed popup
    },

    /**
     * APIMethod: setSize
     * Overridden here, because we need to update the blocks whenever the size
     *     of the popup has changed.
     * 
     * Parameters:
     * contentSize - {<HGIS.Size>} the new size for the popup's 
     *     contents div (in pixels).
     */
    setSize:function(contentSize) { 
        HGIS.Popup.Anchored.prototype.setSize.apply(this, arguments);

        this.updateBlocks();
    },

    /**
     * Method: updateRelativePosition
     * When the relative position changes, we need to set the new padding 
     *     BBOX on the popup, reposition the close div, and update the blocks.
     */
    updateRelativePosition: function() {

        //update the padding
        this.padding = this.positionBlocks[this.relativePosition].padding;

        //update the position of our close box to new padding
        if (this.closeDiv) {
            // use the content div's css padding to determine if we should
            //  padd the close div
            var contentDivPadding = this.getContentDivPadding();

            this.closeDiv.style.right = contentDivPadding.right + 
                                        this.padding.right + "px";
            this.closeDiv.style.top = contentDivPadding.top + 
                                      this.padding.top + "px";
        }

        this.updateBlocks();
    },

    /** 
     * Method: calculateNewPx
     * Besides the standard offset as determined by the Anchored class, our 
     *     Framed popups have a special 'offset' property for each of their 
     *     positions, which is used to offset the popup relative to its anchor.
     * 
     * Parameters:
     * px - {<HGIS.Pixel>}
     * 
     * Returns:
     * {<HGIS.Pixel>} The the new px position of the popup on the screen
     *     relative to the passed-in px.
     */
    calculateNewPx:function(px) {
        var newPx = HGIS.Popup.Anchored.prototype.calculateNewPx.apply(
            this, arguments
        );

        newPx = newPx.offset(this.positionBlocks[this.relativePosition].offset);

        return newPx;
    },

    /**
     * Method: createBlocks
     */
    createBlocks: function() {
        this.blocks = [];

        //since all positions contain the same number of blocks, we can 
        // just pick the first position and use its blocks array to create
        // our blocks array
        var firstPosition = null;
        for(var key in this.positionBlocks) {
            firstPosition = key;
            break;
        }
        
        var position = this.positionBlocks[firstPosition];
        for (var i = 0; i < position.blocks.length; i++) {

            var block = {};
            this.blocks.push(block);

            var divId = this.id + '_FrameDecorationDiv_' + i;
            block.div = HGIS.Util.createDiv(divId, 
                null, null, null, "absolute", null, "hidden", null
            );

            var imgId = this.id + '_FrameDecorationImg_' + i;
            var imageCreator = 
                (this.isAlphaImage) ? HGIS.Util.createAlphaImageDiv
                                    : HGIS.Util.createImage;

            block.image = imageCreator(imgId, 
                null, this.imageSize, this.imageSrc, 
                "absolute", null, null, null
            );

            block.div.appendChild(block.image);
            this.groupDiv.appendChild(block.div);
        }
    },

    /**
     * Method: updateBlocks
     * Internal method, called on initialize and when the popup's relative
     *     position has changed. This function takes care of re-positioning
     *     the popup's blocks in their appropropriate places.
     */
    updateBlocks: function() {
        if (!this.blocks) {
            this.createBlocks();
        }
        
        if (this.size && this.relativePosition) {
            var position = this.positionBlocks[this.relativePosition];
            for (var i = 0; i < position.blocks.length; i++) {
    
                var positionBlock = position.blocks[i];
                var block = this.blocks[i];
    
                // adjust sizes
                var l = positionBlock.anchor.left;
                var b = positionBlock.anchor.bottom;
                var r = positionBlock.anchor.right;
                var t = positionBlock.anchor.top;
    
                //note that we use the isNaN() test here because if the 
                // size object is initialized with a "auto" parameter, the 
                // size constructor calls parseFloat() on the string, 
                // which will turn it into NaN
                //
                var w = (isNaN(positionBlock.size.w)) ? this.size.w - (r + l) 
                                                      : positionBlock.size.w;
    
                var h = (isNaN(positionBlock.size.h)) ? this.size.h - (b + t) 
                                                      : positionBlock.size.h;
    
                block.div.style.width = (w < 0 ? 0 : w) + 'px';
                block.div.style.height = (h < 0 ? 0 : h) + 'px';
    
                block.div.style.left = (l != null) ? l + 'px' : '';
                block.div.style.bottom = (b != null) ? b + 'px' : '';
                block.div.style.right = (r != null) ? r + 'px' : '';            
                block.div.style.top = (t != null) ? t + 'px' : '';
    
                block.image.style.left = positionBlock.position.x + 'px';
                block.image.style.top = positionBlock.position.y + 'px';
            }
    
            this.contentDiv.style.left = this.padding.left + "px";
            this.contentDiv.style.top = this.padding.top + "px";
        }
    },

    CLASS_NAME: "HGIS.Popup.Framed"
});
/* ======================================================================
    HGIS/Popup/FramedCloud.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Popup/Framed.js
 * @requires HGIS/Util.js
 * @requires HGIS/BaseTypes/Bounds.js
 * @requires HGIS/BaseTypes/Pixel.js
 * @requires HGIS/BaseTypes/Size.js
 */

/**
 * Class: HGIS.Popup.FramedCloud
 * 
 * Inherits from: 
 *  - <HGIS.Popup.Framed>
 */
HGIS.Popup.FramedCloud = 
  HGIS.Class(HGIS.Popup.Framed, {

    /** 
     * Property: contentDisplayClass
     * {String} The CSS class of the popup content div.
     */
    contentDisplayClass: "olFramedCloudPopupContent",

    /**
     * APIProperty: autoSize
     * {Boolean} Framed Cloud is autosizing by default.
     */
    autoSize: true,

    /**
     * APIProperty: panMapIfOutOfView
     * {Boolean} Framed Cloud does pan into view by default.
     */
    panMapIfOutOfView: true,
    
    /**
     * APIProperty: changeAnchorIfOutOfView 
     * {Boolean} 超出视图范围后，是否对锚点进行调整,默认为true.
     * 当changeAnchorIfOutOfView为true时，当弹框的展示区域超出了视图范围，弹框的锚点信息将做变更，以将弹框完整展示。
     */
    changeAnchorIfOutOfView :false,
    
    /**
     * APIProperty: imageSize
     * {<HGIS.Size>}
     */
    imageSize: new HGIS.Size(1276, 736),

    /**
     * APIProperty: isAlphaImage
     * {Boolean} The FramedCloud does not use an alpha image (in honor of the 
     *     good ie6 folk out there)
     */
    isAlphaImage: false,

    /** 
     * APIProperty: fixedRelativePosition
     * {Boolean} The Framed Cloud popup works in just one fixed position.
     */
    fixedRelativePosition: false,

    /**
     * Property: positionBlocks
     * {Object} Hash of differen position blocks, keyed by relativePosition
     *     two-character code string (ie "tl", "tr", "bl", "br")
     */
    positionBlocks: {
        "tl": {
            'offset': new HGIS.Pixel(44, 0),
            'padding': new HGIS.Bounds(8, 40, 8, 9),
            'blocks': [
                { // top-left
                    size: new HGIS.Size('auto', 'auto'),
                    anchor: new HGIS.Bounds(0, 51, 22, 0),
                    position: new HGIS.Pixel(0, 0)
                },
                { //top-right
                    size: new HGIS.Size(22, 'auto'),
                    anchor: new HGIS.Bounds(null, 50, 0, 0),
                    position: new HGIS.Pixel(-1238, 0)
                },
                { //bottom-left
                    size: new HGIS.Size('auto', 19),
                    anchor: new HGIS.Bounds(0, 32, 22, null),
                    position: new HGIS.Pixel(0, -631)
                },
                { //bottom-right
                    size: new HGIS.Size(22, 18),
                    anchor: new HGIS.Bounds(null, 32, 0, null),
                    position: new HGIS.Pixel(-1238, -632)
                },
                { // stem
                    size: new HGIS.Size(81, 35),
                    anchor: new HGIS.Bounds(null, 0, 0, null),
                    position: new HGIS.Pixel(0, -688)
                }
            ]
        },
        "tr": {
            'offset': new HGIS.Pixel(-45, 0),
            'padding': new HGIS.Bounds(8, 40, 8, 9),
            'blocks': [
                { // top-left
                    size: new HGIS.Size('auto', 'auto'),
                    anchor: new HGIS.Bounds(0, 51, 22, 0),
                    position: new HGIS.Pixel(0, 0)
                },
                { //top-right
                    size: new HGIS.Size(22, 'auto'),
                    anchor: new HGIS.Bounds(null, 50, 0, 0),
                    position: new HGIS.Pixel(-1238, 0)
                },
                { //bottom-left
                    size: new HGIS.Size('auto', 19),
                    anchor: new HGIS.Bounds(0, 32, 22, null),
                    position: new HGIS.Pixel(0, -631)
                },
                { //bottom-right
                    size: new HGIS.Size(22, 19),
                    anchor: new HGIS.Bounds(null, 32, 0, null),
                    position: new HGIS.Pixel(-1238, -631)
                },
                { // stem
                    size: new HGIS.Size(81, 35),
                    anchor: new HGIS.Bounds(0, 0, null, null),
                    position: new HGIS.Pixel(-215, -687)
                }
            ]
        },
        "bl": {
            'offset': new HGIS.Pixel(45, 0),
            'padding': new HGIS.Bounds(8, 9, 8, 40),
            'blocks': [
                { // top-left
                    size: new HGIS.Size('auto', 'auto'),
                    anchor: new HGIS.Bounds(0, 21, 22, 32),
                    position: new HGIS.Pixel(0, 0)
                },
                { //top-right
                    size: new HGIS.Size(22, 'auto'),
                    anchor: new HGIS.Bounds(null, 21, 0, 32),
                    position: new HGIS.Pixel(-1238, 0)
                },
                { //bottom-left
                    size: new HGIS.Size('auto', 21),
                    anchor: new HGIS.Bounds(0, 0, 22, null),
                    position: new HGIS.Pixel(0, -629)
                },
                { //bottom-right
                    size: new HGIS.Size(22, 21),
                    anchor: new HGIS.Bounds(null, 0, 0, null),
                    position: new HGIS.Pixel(-1238, -629)
                },
                { // stem
                    size: new HGIS.Size(81, 33),
                    anchor: new HGIS.Bounds(null, null, 0, 0),
                    position: new HGIS.Pixel(-101, -674)
                }
            ]
        },
        "br": {
            'offset': new HGIS.Pixel(-44, 0),
            'padding': new HGIS.Bounds(8, 9, 8, 40),
            'blocks': [
                { // top-left
                    size: new HGIS.Size('auto', 'auto'),
                    anchor: new HGIS.Bounds(0, 21, 22, 32),
                    position: new HGIS.Pixel(0, 0)
                },
                { //top-right
                    size: new HGIS.Size(22, 'auto'),
                    anchor: new HGIS.Bounds(null, 21, 0, 32),
                    position: new HGIS.Pixel(-1238, 0)
                },
                { //bottom-left
                    size: new HGIS.Size('auto', 21),
                    anchor: new HGIS.Bounds(0, 0, 22, null),
                    position: new HGIS.Pixel(0, -629)
                },
                { //bottom-right
                    size: new HGIS.Size(22, 21),
                    anchor: new HGIS.Bounds(null, 0, 0, null),
                    position: new HGIS.Pixel(-1238, -629)
                },
                { // stem
                    size: new HGIS.Size(81, 33),
                    anchor: new HGIS.Bounds(0, null, null, 0),
                    position: new HGIS.Pixel(-311, -674)
                }
            ]
        }
    },

    /**
     * APIProperty: minSize
     * {<HGIS.Size>}
     */
    minSize: new HGIS.Size(105, 10),

    /**
     * APIProperty: maxSize
     * {<HGIS.Size>}
     */
    maxSize: new HGIS.Size(1200, 660),

    /** 
     * Constructor: HGIS.Popup.FramedCloud
     * 
     * Parameters:
     * id - {String}
     * lonlat - {<HGIS.LonLat>}
     * contentSize - {<HGIS.Size>}
     * contentHTML - {String}
     * anchor - {Object} Object to which we'll anchor the popup. Must expose 
     *     a 'size' (<HGIS.Size>) and 'offset' (<HGIS.Pixel>) 
     *     (Note that this is generally an <HGIS.Icon>).
     * closeBox - {Boolean}
     * closeBoxCallback - {Function} Function to be called on closeBox click.
     */
    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox, 
                        closeBoxCallback) {

        this.imageSrc = HGIS.Util.getImageLocation('cloud-popup-relative.png');
        HGIS.Popup.Framed.prototype.initialize.apply(this, arguments);
        this.contentDiv.className = this.contentDisplayClass;
    },

    CLASS_NAME: "HGIS.Popup.FramedCloud"
});
/* ======================================================================
    HGIS/Tile/Image/IFrame.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Tile/Image.js
 */

/**
 * Constant: HGIS.Tile.Image.IFrame
 * Mixin for tiles that use form-encoded POST requests to get images from
 * remote services. Images will be loaded using HTTP-POST into an IFrame.
 *
 * This mixin will be applied to <HGIS.Tile.Image> instances
 * configured with <HGIS.Tile.Image.maxGetUrlLength> set.
 */
HGIS.Tile.Image.IFrame = {

    /**
     * Property: useIFrame
     * {Boolean} true if we are currently using an IFrame to render POST
     * responses, false if we are using an img element to render GET responses.
     */ 
    useIFrame: null,

    /**
     * Property: blankImageUrl
     * {String} Using a data scheme url is not supported by all browsers, but
     * we don't care because we either set it as css backgroundImage, or the
     * image's display style is set to "none" when we use it.
     */
    blankImageUrl: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAQAIBRAA7",

    /**
     * Method: draw
     * Set useIFrame in the instance, and operate the image/iframe switch.
     * Then call Tile.Image.draw.
     *
     * Returns:
     * {Boolean}
     */
    draw: function() {
        var draw = HGIS.Tile.Image.prototype.shouldDraw.call(this);
        if(draw) {

            // this.url isn't set to the currect value yet, so we call getURL
            // on the layer and store the result in a local variable
            var url = this.layer.getURL(this.bounds);

            var usedIFrame = this.useIFrame;
            this.useIFrame = this.maxGetUrlLength !== null &&
                             !this.layer.async &&
                             url.length > this.maxGetUrlLength;

            var fromIFrame = usedIFrame && !this.useIFrame;
            var toIFrame = !usedIFrame && this.useIFrame;

            if(fromIFrame || toIFrame) {

                // Switching between GET (image) and POST (iframe).

                // We remove the imgDiv (really either an image or an iframe)
                // from the frame and set it to null to make sure initImage
                // will call getImage.

                if(this.imgDiv && this.imgDiv.parentNode === this.frame) {
                    this.frame.removeChild(this.imgDiv);
                }
                this.imgDiv = null;

                // And if we had an iframe we also remove the event pane.

                if(fromIFrame) {
                    this.frame.removeChild(this.frame.firstChild);
                }
            }
        }
        return HGIS.Tile.Image.prototype.draw.apply(this, arguments);
    },

    /**
     * Method: getImage
     * Creates the content for the frame on the tile.
     */
    getImage: function() {
        if (this.useIFrame === true) {
            if (!this.frame.childNodes.length) {
                var eventPane = document.createElement("div"),
                    style = eventPane.style;
                style.position = "absolute";
                style.width = "100%";
                style.height = "100%";
                style.zIndex = 1;
                style.backgroundImage = "url(" + this.blankImageUrl + ")";
                this.frame.appendChild(eventPane);
            }

            var id = this.id + '_iFrame', iframe;
            if (parseFloat(navigator.appVersion.split("MSIE")[1]) < 9) {
                // Older IE versions do not set the name attribute of an iFrame 
                // properly via DOM manipulation, so we need to do it on our own with
                // this hack.
                iframe = document.createElement('<iframe name="'+id+'">');

                // IFrames in older IE versions are not transparent, if you set
                // the backgroundColor transparent. This is a workaround to get 
                // transparent iframes.
                iframe.style.backgroundColor = '#FFFFFF';
                iframe.style.filter          = 'chroma(color=#FFFFFF)';
            }
            else {
                iframe = document.createElement('iframe');
                iframe.style.backgroundColor = 'transparent';

                // iframe.name needs to be an unique id, otherwise it 
                // could happen that other iframes are overwritten.
                iframe.name = id;
            }

            // some special properties to avoid scaling the images and scrollbars 
            // in the iframe
            iframe.scrolling      = 'no';
            iframe.marginWidth    = '0px';
            iframe.marginHeight   = '0px';
            iframe.frameBorder    = '0';

            iframe.style.position = "absolute";
            iframe.style.width    = "100%";
            iframe.style.height   = "100%";

            if (this.layer.opacity < 1) {
                HGIS.Util.modifyDOMElement(iframe, null, null, null,
                    null, null, null, this.layer.opacity);
            }
            this.frame.appendChild(iframe);
            this.imgDiv = iframe;
            return iframe;
        } else {
            return HGIS.Tile.Image.prototype.getImage.apply(this, arguments);
        }
    },
    
    /**
     * Method: createRequestForm
     * Create the html <form> element with width, height, bbox and all 
     * parameters specified in the layer params.
     *
     * Returns: 
     * {DOMElement} The form element which sends the HTTP-POST request to the
     *              WMS. 
     */
    createRequestForm: function() {
        // creation of the form element
        var form = document.createElement('form');
        form.method = 'POST';
        var cacheId = this.layer.params["_OLSALT"];
        cacheId = (cacheId ? cacheId + "_" : "") + this.bounds.toBBOX();
        form.action = HGIS.Util.urlAppend(this.layer.url, cacheId);
        form.target = this.id + '_iFrame';

        // adding all parameters in layer params as hidden fields to the html
        // form element
        var imageSize = this.layer.getImageSize(),
            params = HGIS.Util.getParameters(this.url),
            field;
            
        for(var par in params) {
            field = document.createElement('input');
            field.type  = 'hidden';
            field.name  = par;
            field.value = params[par];
            form.appendChild(field);
        }   

        return form;
    },

    /**
     * Method: setImgSrc
     * Sets the source for the tile image
     *
     * Parameters:
     * url - {String}
     */
    setImgSrc: function(url) {
        if (this.useIFrame === true) {
            if (url) {
                var form = this.createRequestForm();
                this.frame.appendChild(form);
                form.submit();
                this.frame.removeChild(form);
            } else if (this.imgDiv.parentNode === this.frame) {
                // we don't reuse iframes to avoid caching issues
                this.frame.removeChild(this.imgDiv);
                this.imgDiv = null;
            }
        } else {
            HGIS.Tile.Image.prototype.setImgSrc.apply(this, arguments);
        }
    },
    
    /**
     * Method: onImageLoad
     * Handler for the image onload event
     */
    onImageLoad: function() {
        //TODO de-uglify opacity handling
        HGIS.Tile.Image.prototype.onImageLoad.apply(this, arguments);
        if (this.useIFrame === true) {
            this.imgDiv.style.opacity = 1;
            this.frame.style.opacity = this.layer.opacity;
        }
    },

    /**
     * Method: createBackBuffer
     * Override createBackBuffer to do nothing when we use an iframe. Moving an
     * iframe from one element to another makes it necessary to reload the iframe
     * because its content is lost. So we just give up.
     *
     * Returns:
     * {DOMElement}
     */
    createBackBuffer: function() {
        var backBuffer;
        if(this.useIFrame === false) {
            backBuffer = HGIS.Tile.Image.prototype.createBackBuffer.call(this);
        }
        return backBuffer;
    }
};
/* ======================================================================
    HGIS/Format/SOSCapabilities.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML/VersionedOGC.js
 */
 
/**
 * Class: HGIS.Format.SOSCapabilities
 * Read SOS Capabilities.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML.VersionedOGC>
 */
HGIS.Format.SOSCapabilities = HGIS.Class(HGIS.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.0.0".
     */
    defaultVersion: "1.0.0",
    
    /**
     * Constructor: HGIS.Format.SOSCapabilities
     * Create a new parser for SOS Capabilities.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return information about
     * the service (offering and observedProperty mostly).
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Info about the SOS
     */
    
    CLASS_NAME: "HGIS.Format.SOSCapabilities" 

});
/* ======================================================================
    HGIS/Format/SOSCapabilities/v1_0_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/SOSCapabilities.js
 * @requires HGIS/Format/OWSCommon/v1_1_0.js
 * @requires HGIS/Format/GML/v3.js
 */

/**
 * Class: HGIS.Format.SOSCapabilities.v1_0_0
 * Read SOS Capabilities version 1.0.0.
 * 
 * Inherits from:
 *  - <HGIS.Format.SOSCapabilities>
 */
HGIS.Format.SOSCapabilities.v1_0_0 = HGIS.Class(
    HGIS.Format.SOSCapabilities, {

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        sos: "http://www.opengis.net/sos/1.0",
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink"
    },

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },
    
    /**
     * Constructor: HGIS.Format.SOSCapabilities.v1_0_0
     * Create a new parser for SOS capabilities version 1.0.0. 
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
        this.options = options;
    },

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return info about the SOS.
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Information about the SOS service.
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        return capabilities;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "gml": HGIS.Util.applyDefaults({
            "name": function(node, obj) {
                obj.name = this.getChildValue(node);
            },
            "TimePeriod": function(node, obj) {
                obj.timePeriod = {};
                this.readChildNodes(node, obj.timePeriod);
            },
            "beginPosition": function(node, timePeriod) {
                timePeriod.beginPosition = this.getChildValue(node);
            },
            "endPosition": function(node, timePeriod) {
                timePeriod.endPosition = this.getChildValue(node);
            }
        }, HGIS.Format.GML.v3.prototype.readers["gml"]),
        "sos": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Contents": function(node, obj) {
                obj.contents = {};
                this.readChildNodes(node, obj.contents);
            },
            "ObservationOfferingList": function(node, contents) {
                contents.offeringList = {};
                this.readChildNodes(node, contents.offeringList);
            },
            "ObservationOffering": function(node, offeringList) {
                var id = this.getAttributeNS(node, this.namespaces.gml, "id");
                offeringList[id] = {
                    procedures: [],
                    observedProperties: [],
                    featureOfInterestIds: [],
                    responseFormats: [],
                    resultModels: [],
                    responseModes: []
                };
                this.readChildNodes(node, offeringList[id]);
            },
            "time": function(node, offering) {
                offering.time = {};
                this.readChildNodes(node, offering.time);
            },
            "procedure": function(node, offering) {
                offering.procedures.push(this.getAttributeNS(node, 
                    this.namespaces.xlink, "href"));
            },
            "observedProperty": function(node, offering) {
                offering.observedProperties.push(this.getAttributeNS(node, 
                    this.namespaces.xlink, "href"));
            },
            "featureOfInterest": function(node, offering) {
                offering.featureOfInterestIds.push(this.getAttributeNS(node, 
                    this.namespaces.xlink, "href"));
            },
            "responseFormat": function(node, offering) {
                offering.responseFormats.push(this.getChildValue(node));
            },
            "resultModel": function(node, offering) {
                offering.resultModels.push(this.getChildValue(node));
            },
            "responseMode": function(node, offering) {
                offering.responseModes.push(this.getChildValue(node));
            }
        },
        "ows": HGIS.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "HGIS.Format.SOSCapabilities.v1_0_0" 

});
/* ======================================================================
    HGIS/Handler/Pinch.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Handler.js
 */

/**
 * Class: HGIS.Handler.Pinch
 * The pinch handler is used to deal with sequences of browser events related
 *     to pinch gestures. The handler is used by controls that want to know
 *     when a pinch sequence begins, when a pinch is happening, and when it has
 *     finished.
 *
 * Controls that use the pinch handler typically construct it with callbacks
 *     for 'start', 'move', and 'done'.  Callbacks for these keys are
 *     called when the pinch begins, with each change, and when the pinch is
 *     done.
 *
 * Create a new pinch handler with the <HGIS.Handler.Pinch> constructor.
 *
 * Inherits from:
 *  - <HGIS.Handler>
 */
HGIS.Handler.Pinch = HGIS.Class(HGIS.Handler, {

    /**
     * Property: started
     * {Boolean} When a touchstart event is received, we want to record it,
     *     but not set 'pinching' until the touchmove get started after
     *     starting.
     */
    started: false,

    /**
     * Property: stopDown
     * {Boolean} Stop propagation of touchstart events from getting to
     *     listeners on the same element. Default is false.
     */
    stopDown: false,

    /**
     * Property: pinching
     * {Boolean}
     */
    pinching: false,

    /**
     * Property: last
     * {Object} Object that store informations related to pinch last touch.
     */
    last: null,

    /**
     * Property: start
     * {Object} Object that store informations related to pinch touchstart.
     */
    start: null,

    /**
     * Constructor: HGIS.Handler.Pinch
     * Returns HGIS.Handler.Pinch
     *
     * Parameters:
     * control - {<HGIS.Control>} The control that is making use of
     *     this handler.  If a handler is being used without a control, the
     *     handlers setMap method must be overridden to deal properly with
     *     the map.
     * callbacks - {Object} An object containing functions to be called when
     *     the pinch operation start, change, or is finished. The callbacks
     *     should expect to receive an object argument, which contains
     *     information about scale, distance, and position of touch points.
     * options - {Object}
     */

    /**
     * Method: touchstart
     * Handle touchstart events
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    touchstart: function(evt) {
        var propagate = true;
        this.pinching = false;
        if (HGIS.Event.isMultiTouch(evt)) {
            this.started = true;
            this.last = this.start = {
                distance: this.getDistance(evt.touches),
                delta: 0,
                scale: 1
            };
            this.callback("start", [evt, this.start]);
            propagate = !this.stopDown;
        } else if (this.started) {
            // Some webkit versions send fake single-touch events during
            // multitouch, which cause the drag handler to trigger
            return false;
        } else {
            this.started = false;
            this.start = null;
            this.last = null;
        }
        // prevent document dragging
        HGIS.Event.preventDefault(evt);
        return propagate;
    },

    /**
     * Method: touchmove
     * Handle touchmove events
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    touchmove: function(evt) {
        if (this.started && HGIS.Event.isMultiTouch(evt)) {
            this.pinching = true;
            var current = this.getPinchData(evt);
            this.callback("move", [evt, current]);
            this.last = current;
            // prevent document dragging
            HGIS.Event.stop(evt);
        } else if (this.started) {
            // Some webkit versions send fake single-touch events during
            // multitouch, which cause the drag handler to trigger
            return false;
        }
        return true;
    },

    /**
     * Method: touchend
     * Handle touchend events
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Boolean} Let the event propagate.
     */
    touchend: function(evt) {
        if (this.started && !HGIS.Event.isMultiTouch(evt)) {
            this.started = false;
            this.pinching = false;
            this.callback("done", [evt, this.start, this.last]);
            this.start = null;
            this.last = null;
            return false;
        }
        return true;
    },

    /**
     * Method: activate
     * Activate the handler.
     *
     * Returns:
     * {Boolean} The handler was successfully activated.
     */
    activate: function() {
        var activated = false;
        if (HGIS.Handler.prototype.activate.apply(this, arguments)) {
            this.pinching = false;
            activated = true;
        }
        return activated;
    },

    /**
     * Method: deactivate
     * Deactivate the handler.
     *
     * Returns:
     * {Boolean} The handler was successfully deactivated.
     */
    deactivate: function() {
        var deactivated = false;
        if (HGIS.Handler.prototype.deactivate.apply(this, arguments)) {
            this.started = false;
            this.pinching = false;
            this.start = null;
            this.last = null;
            deactivated = true;
        }
        return deactivated;
    },

    /**
     * Method: getDistance
     * Get the distance in pixels between two touches.
     *
     * Parameters:
     * touches - {Array(Object)}
     *
     * Returns:
     * {Number} The distance in pixels.
     */
    getDistance: function(touches) {
        var t0 = touches[0];
        var t1 = touches[1];
        return Math.sqrt(
            Math.pow(t0.olClientX - t1.olClientX, 2) +
            Math.pow(t0.olClientY - t1.olClientY, 2)
        );
    },


    /**
     * Method: getPinchData
     * Get informations about the pinch event.
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {Object} Object that contains data about the current pinch.
     */
    getPinchData: function(evt) {
        var distance = this.getDistance(evt.touches);
        var scale = distance / this.start.distance;
        return {
            distance: distance,
            delta: this.last.distance - distance,
            scale: scale
        };
    },

    CLASS_NAME: "HGIS.Handler.Pinch"
});

/* ======================================================================
    HGIS/Control/NavToolbar.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control/Panel.js
 * @requires HGIS/Control/Navigation.js
 * @requires HGIS/Control/ZoomBox.js
 */

/**
 * Class: HGIS.Control.NavToolbar
 * This Toolbar is an alternative to the Navigation control that displays
 *     the state of the control, and provides a UI for changing state to
 *     use the zoomBox via a Panel control.
 *
 * If you wish to change the properties of the Navigation control used
 *     in the NavToolbar, see: 
 *     http://trac.HGIS.org/wiki/Toolbars#SubclassingNavToolbar 
 * 
 * 
 * Inherits from:
 *  - <HGIS.Control.Panel>
 */
HGIS.Control.NavToolbar = HGIS.Class(HGIS.Control.Panel, {

    /**
     * Constructor: HGIS.Control.NavToolbar 
     * Add our two mousedefaults controls.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be used
     *     to extend the control.
     */
    initialize: function(options) {
        HGIS.Control.Panel.prototype.initialize.apply(this, [options]);
        this.addControls([
          new HGIS.Control.Navigation(),
          new HGIS.Control.ZoomBox()
        ]);
    },

    /**
     * Method: draw 
     * calls the default draw, and then activates mouse defaults.
     */
    draw: function() {
        var div = HGIS.Control.Panel.prototype.draw.apply(this, arguments);
        if (this.defaultControl === null) {
            this.defaultControl = this.controls[0];
        }
        return div;
    },

    CLASS_NAME: "HGIS.Control.NavToolbar"
});
/* ======================================================================
    HGIS/Strategy/Refresh.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Strategy.js
 */

/**
 * Class: HGIS.Strategy.Refresh
 * A strategy that refreshes the layer. By default the strategy waits for a
 *     call to <refresh> before refreshing.  By configuring the strategy with 
 *     the <interval> option, refreshing can take place automatically.
 *
 * Inherits from:
 *  - <HGIS.Strategy>
 */
HGIS.Strategy.Refresh = HGIS.Class(HGIS.Strategy, {
    
    /**
     * Property: force
     * {Boolean} Force a refresh on the layer. Default is false.
     */
    force: false,

    /**
     * Property: interval
     * {Number} Auto-refresh. Default is 0.  If > 0, layer will be refreshed 
     *     every N milliseconds.
     */
    interval: 0,
    
    /**
     * Property: timer
     * {Number} The id of the timer.
     */
    timer: null,

    /**
     * Constructor: HGIS.Strategy.Refresh
     * Create a new Refresh strategy.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
   
    /**
     * APIMethod: activate
     * Activate the strategy. Register any listeners, do appropriate setup.
     * 
     * Returns:
     * {Boolean} True if the strategy was successfully activated.
     */
    activate: function() {
        var activated = HGIS.Strategy.prototype.activate.call(this);
        if(activated) {
            if(this.layer.visibility === true) {
                this.start();
            } 
            this.layer.events.on({
                "visibilitychanged": this.reset,
                scope: this
            });
        }
        return activated;
    },
    
    /**
     * APIMethod: deactivate
     * Deactivate the strategy. Unregister any listeners, do appropriate
     *     tear-down.
     * 
     * Returns:
     * {Boolean} True if the strategy was successfully deactivated.
     */
    deactivate: function() {
        var deactivated = HGIS.Strategy.prototype.deactivate.call(this);
        if(deactivated) {
            this.stop();
            this.layer.events.un({
                "visibilitychanged": this.reset,
                scope: this
            });
        }
        return deactivated;
    },
    
    /**
     * Method: reset
     * Start or cancel the refresh interval depending on the visibility of 
     *     the layer.
     */
    reset: function() {
        if(this.layer.visibility === true) {
            this.start();
        } else {
            this.stop();
        }
    },
    
    /**
     * Method: start
     * Start the refresh interval. 
     */
    start: function() {
        if(this.interval && typeof this.interval === "number" && 
            this.interval > 0) {

            this.timer = window.setInterval(
                HGIS.Function.bind(this.refresh, this),
                this.interval);
        }
    },
    
    /**
     * APIMethod: refresh
     * Tell the strategy to refresh which will refresh the layer.
     */
    refresh: function() {
        if (this.layer && this.layer.refresh && 
            typeof this.layer.refresh == "function") {

            this.layer.refresh({force: this.force});
        }
    },
   
    /**
     * Method: stop
     * Cancels the refresh interval. 
     */
    stop: function() {
        if(this.timer !== null) {
            window.clearInterval(this.timer);
            this.timer = null;
        }
    },
    
    CLASS_NAME: "HGIS.Strategy.Refresh" 
});
/* ======================================================================
    HGIS/Layer/ArcGIS93Rest.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer/Grid.js
 */

/**
 * Class: HGIS.Layer.ArcGIS93Rest
 * Instances of HGIS.Layer.ArcGIS93Rest are used to display data from
 *     ESRI ArcGIS Server 9.3 (and up?) Mapping Services using the REST API.
 *     Create a new ArcGIS93Rest layer with the <HGIS.Layer.ArcGIS93Rest>
 *     constructor.  More detail on the REST API is available at
 *     http://sampleserver1.arcgisonline.com/ArcGIS/SDK/REST/index.html ;
 *     specifically, the URL provided to this layer should be an export service
 *     URL: http://sampleserver1.arcgisonline.com/ArcGIS/SDK/REST/export.html 
 * 
 * Inherits from:
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.ArcGIS93Rest = HGIS.Class(HGIS.Layer.Grid, {

    /**
     * Constant: DEFAULT_PARAMS
     * {Object} Hashtable of default parameter key/value pairs 
     */
    DEFAULT_PARAMS: { 
      format: "png"
    },
        
    /**
     * APIProperty: isBaseLayer
     * {Boolean} Default is true for ArcGIS93Rest layer
     */
    isBaseLayer: true,
 
 
    /**
     * Constructor: HGIS.Layer.ArcGIS93Rest
     * Create a new ArcGIS93Rest layer object.
     *
     * Example:
     * (code)
     * var arcims = new HGIS.Layer.ArcGIS93Rest("MyName",
     *                                    "http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Specialty/ESRI_StateCityHighway_USA/MapServer/export", 
     *                                    {
     *                                      layers: "0,1,2"
     *                                    });
     * (end)
     *
     * Parameters:
     * name - {String} A name for the layer
     * url - {String} Base url for the ArcGIS server REST service
     * options - {Object} An object with key/value pairs representing the
     *                    options and option values.
     *
     * Valid Options:
     *        format - {String} MIME type of desired image type.
     *        layers - {String} Comma-separated list of layers to display.
     *        srs - {String} Projection ID.
     */
    initialize: function(name, url, params, options) {
        var newArguments = [];
        //uppercase params
        params = HGIS.Util.upperCaseObject(params);
        newArguments.push(name, url, params, options);
        HGIS.Layer.Grid.prototype.initialize.apply(this, newArguments);
        HGIS.Util.applyDefaults(
                       this.params, 
                       HGIS.Util.upperCaseObject(this.DEFAULT_PARAMS)
                       );
                       
        //layer is transparent        
        if (this.params.TRANSPARENT && 
            this.params.TRANSPARENT.toString().toLowerCase() == "true") {
            
            // unless explicitly set in options, make layer an overlay
            if ( (options == null) || (!options.isBaseLayer) ) {
                this.isBaseLayer = false;
            } 
            
            // jpegs can never be transparent, so intelligently switch the 
            //  format, depending on the browser's capabilities
            if (this.params.FORMAT == "jpg") {
                this.params.FORMAT = HGIS.Util.alphaHack() ? "gif"
                                                                 : "png";
            }
        }
    },    

    /**
         * Method: clone
         * Create a clone of this layer
         *
         * Returns:
         * {<HGIS.Layer.ArcGIS93Rest>} An exact clone of this layer
         */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new HGIS.Layer.ArcGIS93Rest(this.name,
                                           this.url,
                                           this.params,
                                           this.getOptions());
        }

        //get all additions from superclasses
        obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },
    
    
    /**
     * Method: getURL
     * Return an image url this layer.
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>} A bounds representing the bbox for the
     *                                request.
     *
     * Returns:
     * {String} A string with the map image's url.
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);

        // ArcGIS Server only wants the numeric portion of the projection ID.
        var projWords = this.projection.getCode().split(":");
        var srid = projWords[projWords.length - 1];

        var imageSize = this.getImageSize(); 
        var newParams = {
            'BBOX': bounds.toBBOX(),
            'SIZE': imageSize.w + "," + imageSize.h,
            // We always want image, the other options were json, image with a whole lotta html around it, etc.
            'F': "image",
            'BBOXSR': srid,
            'IMAGESR': srid
        };

        // Now add the filter parameters.
        if (this.layerDefs) {
            var layerDefStrList = [];
            var layerID;
            for(layerID in this.layerDefs) {
                if (this.layerDefs.hasOwnProperty(layerID)) {
                    if (this.layerDefs[layerID]) {
                        layerDefStrList.push(layerID);
                        layerDefStrList.push(":");
                        layerDefStrList.push(this.layerDefs[layerID]);
                        layerDefStrList.push(";");
                    }
                }
            }
            if (layerDefStrList.length > 0) {
                newParams['LAYERDEFS'] = layerDefStrList.join("");
            }
        }
        var requestString = this.getFullRequestString(newParams);
        return requestString;
    },
    
    /**
     * Method: setLayerFilter
     * addTile creates a tile, initializes it, and adds it to the layer div. 
     *
     * Parameters:
     * id - {String} The id of the layer to which the filter applies.
     * queryDef - {String} A sql-ish query filter, for more detail see the ESRI
     *                     documentation at http://sampleserver1.arcgisonline.com/ArcGIS/SDK/REST/export.html
     */
    setLayerFilter: function ( id, queryDef ) {
        if (!this.layerDefs) {
            this.layerDefs = {};
        }
        if (queryDef) {
            this.layerDefs[id] = queryDef;
        } else {
            delete this.layerDefs[id];
        }
    },
    
    /**
     * Method: clearLayerFilter
     * Clears layer filters, either from a specific layer,
     * or all of them.
     *
     * Parameters:
     * id - {String} The id of the layer from which to remove any
     *               filter.  If unspecified/blank, all filters
     *               will be removed.
     */
    clearLayerFilter: function ( id ) {
        if (id) {
            delete this.layerDefs[id];
        } else {
            delete this.layerDefs;
        }
    },
    
    /**
     * APIMethod: mergeNewParams
     * Catch changeParams and uppercase the new params to be merged in
     *     before calling changeParams on the super class.
     * 
     *     Once params have been changed, the tiles will be reloaded with
     *     the new parameters.
     * 
     * Parameters:
     * newParams - {Object} Hashtable of new params to use
     */
    mergeNewParams:function(newParams) {
        var upperParams = HGIS.Util.upperCaseObject(newParams);
        var newArguments = [upperParams];
        return HGIS.Layer.Grid.prototype.mergeNewParams.apply(this, 
                                                             newArguments);
    },

    CLASS_NAME: "HGIS.Layer.ArcGIS93Rest"
});
/* ======================================================================
    HGIS/Handler/Hover.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Handler.js
 */

/**
 * Class: HGIS.Handler.Hover
 * The hover handler is to be used to emulate mouseovers on objects
 *      on the map that aren't DOM elements. For example one can use
 *      this handler to send WMS/GetFeatureInfo requests as the user
 *      moves the mouve over the map.
 * 
 * Inherits from:
 *  - <HGIS.Handler> 
 */
HGIS.Handler.Hover = HGIS.Class(HGIS.Handler, {

    /**
     * APIProperty: delay
     * {Integer} - Number of milliseconds between mousemoves before
     *      the event is considered a hover. Default is 500.
     */
    delay: 500,
    
    /**
     * APIProperty: pixelTolerance
     * {Integer} - Maximum number of pixels between mousemoves for
     *      an event to be considered a hover. Default is null.
     */
    pixelTolerance: null,

    /**
     * APIProperty: stopMove
     * {Boolean} - Stop other listeners from being notified on mousemoves.
     *      Default is false.
     */
    stopMove: false,

    /**
     * Property: px
     * {<HGIS.Pixel>} - The location of the last mousemove, expressed
     *      in pixels.
     */
    px: null,

    /**
     * Property: timerId
     * {Number} - The id of the timer.
     */
    timerId: null,
 
    /**
     * Constructor: HGIS.Handler.Hover
     * Construct a hover handler.
     *
     * Parameters:
     * control - {<HGIS.Control>} The control that initialized this
     *     handler.  The control is assumed to have a valid map property; that
     *     map is used in the handler's own setMap method.
     * callbacks - {Object} An object with keys corresponding to callbacks
     *     that will be called by the handler. The callbacks should
     *     expect to receive a single argument, the event. Callbacks for
     *     'move', the mouse is moving, and 'pause', the mouse is pausing,
     *     are supported.
     * options - {Object} An optional object whose properties will be set on
     *     the handler.
     */

    /**
     * Method: mousemove
     * Called when the mouse moves on the map.
     *
     * Parameters:
     * evt - {<HGIS.Event>}
     *
     * Returns:
     * {Boolean} Continue propagating this event.
     */
    mousemove: function(evt) {
        if(this.passesTolerance(evt.xy)) {
            this.clearTimer();
            this.callback('move', [evt]);
            this.px = evt.xy;
            // clone the evt so original properties can be accessed even
            // if the browser deletes them during the delay
            evt = HGIS.Util.extend({}, evt);
            this.timerId = window.setTimeout(
                HGIS.Function.bind(this.delayedCall, this, evt),
                this.delay
            );
        }
        return !this.stopMove;
    },

    /**
     * Method: mouseout
     * Called when the mouse goes out of the map.
     *
     * Parameters:
     * evt - {<HGIS.Event>}
     *
     * Returns:
     * {Boolean} Continue propagating this event.
     */
    mouseout: function(evt) {
        if (HGIS.Util.mouseLeft(evt, this.map.viewPortDiv)) {
            this.clearTimer();
            this.callback('move', [evt]);
        }
        return true;
    },

    /**
     * Method: passesTolerance
     * Determine whether the mouse move is within the optional pixel tolerance.
     *
     * Parameters:
     * px - {<HGIS.Pixel>}
     *
     * Returns:
     * {Boolean} The mouse move is within the pixel tolerance.
     */
    passesTolerance: function(px) {
        var passes = true;
        if(this.pixelTolerance && this.px) {
            var dpx = Math.sqrt(
                Math.pow(this.px.x - px.x, 2) +
                Math.pow(this.px.y - px.y, 2)
            );
            if(dpx < this.pixelTolerance) {
                passes = false;
            }
        }
        return passes;
    },

    /**
     * Method: clearTimer
     * Clear the timer and set <timerId> to null.
     */
    clearTimer: function() {
        if(this.timerId != null) {
            window.clearTimeout(this.timerId);
            this.timerId = null;
        }
    },

    /**
     * Method: delayedCall
     * Triggers pause callback.
     *
     * Parameters:
     * evt - {<HGIS.Event>}
     */
    delayedCall: function(evt) {
        this.callback('pause', [evt]);
    },

    /**
     * APIMethod: deactivate
     * Deactivate the handler.
     *
     * Returns:
     * {Boolean} The handler was successfully deactivated.
     */
    deactivate: function() {
        var deactivated = false;
        if(HGIS.Handler.prototype.deactivate.apply(this, arguments)) {
            this.clearTimer();
            deactivated = true;
        }
        return deactivated;
    },

    CLASS_NAME: "HGIS.Handler.Hover"
});
/* ======================================================================
    HGIS/Control/GetFeature.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Handler/Click.js
 * @requires HGIS/Handler/Box.js
 * @requires HGIS/Handler/Hover.js
 * @requires HGIS/Filter/Spatial.js
 */

/**
 * Class: HGIS.Control.GetFeature
 * Gets vector features for locations underneath the mouse cursor. Can be
 *     configured to act on click, hover or dragged boxes. Uses an
 *     <HGIS.Protocol> that supports spatial filters to retrieve
 *     features from a server and fires events that notify applications of the
 *     selected features. 
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.GetFeature = HGIS.Class(HGIS.Control, {
    
    /**
     * APIProperty: protocol
     * {<HGIS.Protocol>} Required. The protocol used for fetching
     *     features.
     */
    protocol: null,
    
    /**
     * APIProperty: multipleKey
     * {String} An event modifier ('altKey' or 'shiftKey') that temporarily sets
     *     the <multiple> property to true.  Default is null.
     */
    multipleKey: null,
    
    /**
     * APIProperty: toggleKey
     * {String} An event modifier ('altKey' or 'shiftKey') that temporarily sets
     *     the <toggle> property to true.  Default is null.
     */
    toggleKey: null,
    
    /**
     * Property: modifiers
     * {Object} The event modifiers to use, according to the current event
     *     being handled by this control's handlers
     */
    modifiers: null,
    
    /**
     * APIProperty: multiple
     * {Boolean} Allow selection of multiple geometries.  Default is false.
     */
    multiple: false, 

    /**
     * APIProperty: click
     * {Boolean} Use a click handler for selecting/unselecting features. If
     *     both <click> and <box> are set to true, the click handler takes
     *     precedence over the box handler if a box with zero extent was
     *     selected.  Default is true.
     */
    click: true,

    /**
     * APIProperty: single
     * {Boolean} Tells whether select by click should select a single
     *     feature. If set to false, all matching features are selected.
     *     If set to true, only the best matching feature is selected.
     *     This option has an effect only of the <click> option is set
     *     to true. Default is true.
     */
    single: true,
    
    /**
     * APIProperty: clickout
     * {Boolean} Unselect features when clicking outside any feature.
     *     Applies only if <click> is true.  Default is true.
     */
    clickout: true,
    
    /**
     * APIProperty: toggle
     * {Boolean} Unselect a selected feature on click.  Applies only if
     *     <click> is true.  Default is false.
     */
    toggle: false,

    /**
     * APIProperty: clickTolerance
     * {Integer} Tolerance for the filter query in pixels. This has the
     *     same effect as the tolerance parameter on WMS GetFeatureInfo
     *     requests.  Will be ignored for box selections.  Applies only if
     *     <click> or <hover> is true.  Default is 5.  Note that this not
     *     only affects requests on click, but also on hover.
     */
    clickTolerance: 5,
    
    /**
     * APIProperty: hover
     * {Boolean} Send feature requests on mouse moves.  Default is false.
     */
    hover: false,

    /**
     * APIProperty: box
     * {Boolean} Allow feature selection by drawing a box. If set to
     *     true set <click> to false to disable the click handler and
     *     rely on the box handler only, even for "zero extent" boxes.
     *     See the description of the <click> option for additional
     *     information.  Default is false.
     */
    box: false,
    
    /**
     * APIProperty: maxFeatures
     * {Integer} Maximum number of features to return from a query in single mode
     *     if supported by the <protocol>. This set of features is then used to
     *     determine the best match client-side. Default is 10.
     */
    maxFeatures: 10,
    
    /**
     * Property: features
     * {Object} Hash of {<HGIS.Feature.Vector>}, keyed by fid, holding
     *     the currently selected features
     */
    features: null,
    
    /**
     * Proeprty: hoverFeature
     * {<HGIS.Feature.Vector>} The feature currently selected by the
     *     hover handler
     */
    hoverFeature: null,
    
    /**
     * APIProperty: handlerOptions
     * {Object} Additional options for the handlers used by this control. This
     *     is a hash with the keys "click", "box" and "hover".
     */
    
    /**
     * Property: handlers
     * {Object} Object with references to multiple <HGIS.Handler>
     *     instances.
     */
    handlers: null,

    /**
     * Property: hoverResponse
     * {<HGIS.Protocol.Response>} The response object associated with
     *     the currently running hover request (if any).
     */
    hoverResponse: null,
    
    /**
     * Property: filterType
     * {<String>} The type of filter to use when sending off a request. 
     *     Possible values: 
     *     HGIS.Filter.Spatial.<BBOX|INTERSECTS|WITHIN|CONTAINS>
     *     Defaults to: HGIS.Filter.Spatial.BBOX
     */
    filterType: HGIS.Filter.Spatial.BBOX,

    /** 
     * APIProperty: events
     * {<HGIS.Events>} Events instance for listeners and triggering
     *     control specific events.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types (in addition to those from <HGIS.Control.events>):
     * beforefeatureselected - Triggered when <click> is true before a
     *      feature is selected. The event object has a feature property with
     *      the feature about to select
     * featureselected - Triggered when <click> is true and a feature is
     *      selected. The event object has a feature property with the
     *      selected feature
     * beforefeaturesselected - Triggered when <click> is true before a
     *      set of features is selected. The event object is an array of
     *      feature properties with the features about to be selected.  
     *      Return false after receiving this event to discontinue processing
     *      of all featureselected events and the featuresselected event.
     * featuresselected - Triggered when <click> is true and a set of
     *      features is selected.  The event object is an array of feature
     *      properties of the selected features
     * featureunselected - Triggered when <click> is true and a feature is
     *      unselected. The event object has a feature property with the
     *      unselected feature
     * clickout - Triggered when when <click> is true and no feature was
     *      selected.
     * hoverfeature - Triggered when <hover> is true and the mouse has
     *      stopped over a feature
     * outfeature - Triggered when <hover> is true and the mouse moves
     *      moved away from a hover-selected feature
     */

    /**
     * Constructor: HGIS.Control.GetFeature
     * Create a new control for fetching remote features.
     *
     * Parameters:
     * options - {Object} A configuration object which at least has to contain
     *     a <protocol> property (if not, it has to be set before a request is
     *     made)
     */
    initialize: function(options) {
        options.handlerOptions = options.handlerOptions || {};

        HGIS.Control.prototype.initialize.apply(this, [options]);
        
        this.features = {};

        this.handlers = {};
        
        if(this.click) {
            this.handlers.click = new HGIS.Handler.Click(this,
                {click: this.selectClick}, this.handlerOptions.click || {});
        }

        if(this.box) {
            this.handlers.box = new HGIS.Handler.Box(
                this, {done: this.selectBox},
                HGIS.Util.extend(this.handlerOptions.box, {
                    boxDivClassName: "olHandlerBoxSelectFeature"
                })
            ); 
        }
        
        if(this.hover) {
            this.handlers.hover = new HGIS.Handler.Hover(
                this, {'move': this.cancelHover, 'pause': this.selectHover},
                HGIS.Util.extend(this.handlerOptions.hover, {
                    'delay': 250,
                    'pixelTolerance': 2
                })
            );
        }
    },
    
    /**
     * Method: activate
     * Activates the control.
     * 
     * Returns:
     * {Boolean} The control was effectively activated.
     */
    activate: function () {
        if (!this.active) {
            for(var i in this.handlers) {
                this.handlers[i].activate();
            }
        }
        return HGIS.Control.prototype.activate.apply(
            this, arguments
        );
    },

    /**
     * Method: deactivate
     * Deactivates the control.
     * 
     * Returns:
     * {Boolean} The control was effectively deactivated.
     */
    deactivate: function () {
        if (this.active) {
            for(var i in this.handlers) {
                this.handlers[i].deactivate();
            }
        }
        return HGIS.Control.prototype.deactivate.apply(
            this, arguments
        );
    },
    
    /**
     * Method: selectClick
     * Called on click
     *
     * Parameters:
     * evt - {<HGIS.Event>} 
     */
    selectClick: function(evt) {
        var bounds = this.pixelToBounds(evt.xy);
        
        this.setModifiers(evt);
        this.request(bounds, {single: this.single});
    },

    /**
     * Method: selectBox
     * Callback from the handlers.box set up when <box> selection is on
     *
     * Parameters:
     * position - {<HGIS.Bounds>|Object} An HGIS.Bounds or
     * an object with a 'left', 'bottom', 'right' and 'top' properties.
     */
    selectBox: function(position) {
        var bounds;
        if (position instanceof HGIS.Bounds) {
            var minXY = this.map.getLonLatFromPixel({
                x: position.left,
                y: position.bottom
            });
            var maxXY = this.map.getLonLatFromPixel({
                x: position.right,
                y: position.top
            });
            bounds = new HGIS.Bounds(
                minXY.lon, minXY.lat, maxXY.lon, maxXY.lat
            );
            
        } else {
            if(this.click) {
                // box without extent - let the click handler take care of it
                return;
            }
            bounds = this.pixelToBounds(position);
        }
        this.setModifiers(this.handlers.box.dragHandler.evt);
        this.request(bounds);
    },
    
    /**
     * Method: selectHover
     * Callback from the handlers.hover set up when <hover> selection is on
     *
     * Parameters:
     * evt - {Object} event object with an xy property
     */
    selectHover: function(evt) {
        var bounds = this.pixelToBounds(evt.xy);
        this.request(bounds, {single: true, hover: true});
    },

    /**
     * Method: cancelHover
     * Callback from the handlers.hover set up when <hover> selection is on
     */
    cancelHover: function() {
        if (this.hoverResponse) {
            this.protocol.abort(this.hoverResponse);
            this.hoverResponse = null;

            HGIS.Element.removeClass(this.map.viewPortDiv, "olCursorWait");
        }
    },

    /**
     * Method: request
     * Sends a GetFeature request to the WFS
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>} bounds for the request's BBOX filter
     * options - {Object} additional options for this method.
     * 
     * Supported options include:
     * single - {Boolean} A single feature should be returned.
     *     Note that this will be ignored if the protocol does not
     *     return the geometries of the features.
     * hover - {Boolean} Do the request for the hover handler.
     */
    request: function(bounds, options) {
        options = options || {};
        var filter = new HGIS.Filter.Spatial({
            type: this.filterType, 
            value: bounds
        });
        
        // Set the cursor to "wait" to tell the user we're working.
        HGIS.Element.addClass(this.map.viewPortDiv, "olCursorWait");

        var response = this.protocol.read({
            maxFeatures: options.single == true ? this.maxFeatures : undefined,
            filter: filter,
            callback: function(result) {
                if(result.success()) {
                    if(result.features.length) {
                        if(options.single == true) {
                            this.selectBestFeature(result.features,
                                bounds.getCenterLonLat(), options);
                        } else {
                            this.select(result.features);
                        }
                    } else if(options.hover) {
                        this.hoverSelect();
                    } else {
                        this.events.triggerEvent("clickout");
                        if(this.clickout) {
                            this.unselectAll();
                        }
                    }
                }
                // Reset the cursor.
                HGIS.Element.removeClass(this.map.viewPortDiv, "olCursorWait");
            },
            scope: this
        });
        if(options.hover == true) {
            this.hoverResponse = response;
        }
    },

    /**
     * Method: selectBestFeature
     * Selects the feature from an array of features that is the best match
     *     for the click position.
     * 
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)}
     * clickPosition - {<HGIS.LonLat>}
     * options - {Object} additional options for this method
     * 
     * Supported options include:
     * hover - {Boolean} Do the selection for the hover handler.
     */
    selectBestFeature: function(features, clickPosition, options) {
        options = options || {};
        if(features.length) {
            var point = new HGIS.Geometry.Point(clickPosition.lon,
                clickPosition.lat);
            var feature, resultFeature, dist;
            var minDist = Number.MAX_VALUE;
            for(var i=0; i<features.length; ++i) {
                feature = features[i];
                if(feature.geometry) {
                    dist = point.distanceTo(feature.geometry, {edge: false});
                    if(dist < minDist) {
                        minDist = dist;
                        resultFeature = feature;
                        if(minDist == 0) {
                            break;
                        }
                    }
                }
            }
            
            if(options.hover == true) {
                this.hoverSelect(resultFeature);
            } else {
                this.select(resultFeature || features);
            } 
        }
    },
    
    /**
     * Method: setModifiers
     * Sets the multiple and toggle modifiers according to the current event
     * 
     * Parameters:
     * evt - {<HGIS.Event>}
     */
    setModifiers: function(evt) {
        this.modifiers = {
            multiple: this.multiple || (this.multipleKey && evt[this.multipleKey]),
            toggle: this.toggle || (this.toggleKey && evt[this.toggleKey])
        };        
    },

    /**
     * Method: select
     * Add feature to the hash of selected features and trigger the
     * featureselected and featuresselected events.
     * 
     * Parameters:
     * features - {<HGIS.Feature.Vector>} or an array of features
     */
    select: function(features) {
        if(!this.modifiers.multiple && !this.modifiers.toggle) {
            this.unselectAll();
        }
        if(!(HGIS.Util.isArray(features))) {
            features = [features];
        }
        
        var cont = this.events.triggerEvent("beforefeaturesselected", {
            features: features
        });
        if(cont !== false) {
            var selectedFeatures = [];
            var feature;
            for(var i=0, len=features.length; i<len; ++i) {
                feature = features[i];
                if(this.features[feature.fid || feature.id]) {
                    if(this.modifiers.toggle) {
                        this.unselect(this.features[feature.fid || feature.id]);
                    }
                } else {
                    cont = this.events.triggerEvent("beforefeatureselected", {
                        feature: feature
                    });
                    if(cont !== false) {
                        this.features[feature.fid || feature.id] = feature;
                        selectedFeatures.push(feature);
                
                        this.events.triggerEvent("featureselected",
                            {feature: feature});
                    }
                }
            }
            this.events.triggerEvent("featuresselected", {
                features: selectedFeatures
            });
        }
    },
    
    /**
     * Method: hoverSelect
     * Sets/unsets the <hoverFeature>
     * 
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} the feature to hover-select.
     *     If none is provided, the current <hoverFeature> will be nulled and
     *     the outfeature event will be triggered.
     */
    hoverSelect: function(feature) {
        var fid = feature ? feature.fid || feature.id : null;
        var hfid = this.hoverFeature ?
            this.hoverFeature.fid || this.hoverFeature.id : null;
            
        if(hfid && hfid != fid) {
            this.events.triggerEvent("outfeature",
                {feature: this.hoverFeature});
            this.hoverFeature = null;
        }
        if(fid && fid != hfid) {
            this.events.triggerEvent("hoverfeature", {feature: feature});
            this.hoverFeature = feature;
        }
    },

    /**
     * Method: unselect
     * Remove feature from the hash of selected features and trigger the
     * featureunselected event.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     */
    unselect: function(feature) {
        delete this.features[feature.fid || feature.id];
        this.events.triggerEvent("featureunselected", {feature: feature});
    },
    
    /**
     * Method: unselectAll
     * Unselect all selected features.
     */
    unselectAll: function() {
        // we'll want an option to supress notification here
        for(var fid in this.features) {
            this.unselect(this.features[fid]);
        }
    },
    
    /** 
     * Method: setMap
     * Set the map property for the control. 
     * 
     * Parameters:
     * map - {<HGIS.Map>} 
     */
    setMap: function(map) {
        for(var i in this.handlers) {
            this.handlers[i].setMap(map);
        }
        HGIS.Control.prototype.setMap.apply(this, arguments);
    },
    
    /**
     * Method: pixelToBounds
     * Takes a pixel as argument and creates bounds after adding the
     * <clickTolerance>.
     * 
     * Parameters:
     * pixel - {<HGIS.Pixel>}
     */
    pixelToBounds: function(pixel) {
        var llPx = pixel.add(-this.clickTolerance/2, this.clickTolerance/2);
        var urPx = pixel.add(this.clickTolerance/2, -this.clickTolerance/2);
        var ll = this.map.getLonLatFromPixel(llPx);
        var ur = this.map.getLonLatFromPixel(urPx);
        return new HGIS.Bounds(ll.lon, ll.lat, ur.lon, ur.lat);
    },

    CLASS_NAME: "HGIS.Control.GetFeature"
});
/* ======================================================================
    HGIS/Format/QueryStringFilter.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Console.js
 * @requires HGIS/Format.js
 * @requires HGIS/Filter/Spatial.js
 * @requires HGIS/Filter/Comparison.js
 * @requires HGIS/Filter/Logical.js
 */

/**
 * Class: HGIS.Format.QueryStringFilter
 * Parser for reading a query string and creating a simple filter.
 *
 * Inherits from:
 *  - <HGIS.Format>
 */
HGIS.Format.QueryStringFilter = (function() {

    /** 
     * Map the HGIS.Filter.Comparison types to the operation strings of 
     * the protocol.
     */
    var cmpToStr = {};
    cmpToStr[HGIS.Filter.Comparison.EQUAL_TO] = "eq";
    cmpToStr[HGIS.Filter.Comparison.NOT_EQUAL_TO] = "ne";
    cmpToStr[HGIS.Filter.Comparison.LESS_THAN] = "lt";
    cmpToStr[HGIS.Filter.Comparison.LESS_THAN_OR_EQUAL_TO] = "lte";
    cmpToStr[HGIS.Filter.Comparison.GREATER_THAN] = "gt";
    cmpToStr[HGIS.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO] = "gte";
    cmpToStr[HGIS.Filter.Comparison.LIKE] = "ilike";

    /**
     * Function: regex2value
     * Convert the value from a regular expression string to a LIKE/ILIKE
     * string known to the web service.
     *
     * Parameters:
     * value - {String} The regex string.
     *
     * Returns:
     * {String} The converted string.
     */
    function regex2value(value) {

        // highly sensitive!! Do not change this without running the
        // Protocol/HTTP.html unit tests

        // convert % to \%
        value = value.replace(/%/g, "\\%");

        // convert \\. to \\_ (\\.* occurences converted later)
        value = value.replace(/\\\\\.(\*)?/g, function($0, $1) {
            return $1 ? $0 : "\\\\_";
        });

        // convert \\.* to \\%
        value = value.replace(/\\\\\.\*/g, "\\\\%");

        // convert . to _ (\. and .* occurences converted later)
        value = value.replace(/(\\)?\.(\*)?/g, function($0, $1, $2) {
            return $1 || $2 ? $0 : "_";
        });

        // convert .* to % (\.* occurnces converted later)
        value = value.replace(/(\\)?\.\*/g, function($0, $1) {
            return $1 ? $0 : "%";
        });

        // convert \. to .
        value = value.replace(/\\\./g, ".");

        // replace \* with * (watching out for \\*)
        value = value.replace(/(\\)?\\\*/g, function($0, $1) {
            return $1 ? $0 : "*";
        });

        return value;
    }
    
    return HGIS.Class(HGIS.Format, {
        
        /**
         * Property: wildcarded.
         * {Boolean} If true percent signs are added around values
         *     read from LIKE filters, for example if the protocol
         *     read method is passed a LIKE filter whose property
         *     is "foo" and whose value is "bar" the string
         *     "foo__ilike=%bar%" will be sent in the query string;
         *     defaults to false.
         */
        wildcarded: false,

        /**
         * APIProperty: srsInBBOX
         * {Boolean} Include the SRS identifier in BBOX query string parameter.  
         *     Default is false.  If true and the layer has a projection object set,
         *     any BBOX filter will be serialized with a fifth item identifying the
         *     projection.  E.g. bbox=-1000,-1000,1000,1000,EPSG:900913
         */
        srsInBBOX: false,

        /**
         * APIMethod: write
         * Serialize an <HGIS.Filter> objects using the "simple" filter syntax for 
         *     query string parameters.  This function must be called as a method of
         *     a protocol instance.
         *
         * Parameters:
         * filter - {<HGIS.Filter>} filter to convert.
         * params - {Object} The parameters object.
         *
         * Returns:
         * {Object} The resulting parameters object.
         */
        write: function(filter, params) {
            params = params || {};
            var className = filter.CLASS_NAME;
            var filterType = className.substring(className.lastIndexOf(".") + 1);
            switch (filterType) {
                case "Spatial":
                    switch (filter.type) {
                        case HGIS.Filter.Spatial.BBOX:
                            params.bbox = filter.value.toArray();
                            if (this.srsInBBOX && filter.projection) {
                                params.bbox.push(filter.projection.getCode());
                            }
                            break;
                        case HGIS.Filter.Spatial.DWITHIN:
                            params.tolerance = filter.distance;
                            // no break here
                        case HGIS.Filter.Spatial.WITHIN:
                            params.lon = filter.value.x;
                            params.lat = filter.value.y;
                            break;
                        default:
                            HGIS.Console.warn(
                                "Unknown spatial filter type " + filter.type);
                    }
                    break;
                case "Comparison":
                    var op = cmpToStr[filter.type];
                    if (op !== undefined) {
                        var value = filter.value;
                        if (filter.type == HGIS.Filter.Comparison.LIKE) {
                            value = regex2value(value);
                            if (this.wildcarded) {
                                value = "%" + value + "%";
                            }
                        }
                        params[filter.property + "__" + op] = value;
                        params.queryable = params.queryable || [];
                        params.queryable.push(filter.property);
                    } else {
                        HGIS.Console.warn(
                            "Unknown comparison filter type " + filter.type);
                    }
                    break;
                case "Logical":
                    if (filter.type === HGIS.Filter.Logical.AND) {
                        for (var i=0,len=filter.filters.length; i<len; i++) {
                            params = this.write(filter.filters[i], params);
                        }
                    } else {
                        HGIS.Console.warn(
                            "Unsupported logical filter type " + filter.type);
                    }
                    break;
                default:
                    HGIS.Console.warn("Unknown filter type " + filterType);
            }
            return params;
        },
        
        CLASS_NAME: "HGIS.Format.QueryStringFilter"
        
    });


})();
/* ======================================================================
    HGIS/Control/MousePosition.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Control.js
 */

/**
 * Class: HGIS.Control.MousePosition
 * The MousePosition control displays geographic coordinates of the mouse
 * pointer, as it is moved about the map.
 *
 * You can use the <prefix>- or <suffix>-properties to provide more information
 * about the displayed coordinates to the user:
 *
 * (code)
 *     var mousePositionCtrl = new HGIS.Control.MousePosition({
 *         prefix: '<a target="_blank" ' +
 *             'href="http://spatialreference.org/ref/epsg/4326/">' +
 *             'EPSG:4326</a> coordinates: '
 *         }
 *     );
 * (end code)
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.MousePosition = HGIS.Class(HGIS.Control, {

    /**
     * APIProperty: autoActivate
     * {Boolean} Activate the control when it is added to a map.  Default is
     *     true.
     */
    autoActivate: true,

    /**
     * Property: element
     * {DOMElement}
     */
    element: null,

    /**
     * APIProperty: prefix
     * {String} A string to be prepended to the current pointers coordinates
     *     when it is rendered.  Defaults to the empty string ''.
     */
    prefix: '',

    /**
     * APIProperty: separator
     * {String} A string to be used to seperate the two coordinates from each
     *     other.  Defaults to the string ', ', which will result in a
     *     rendered coordinate of e.g. '42.12, 21.22'.
     */
    separator: ', ',

    /**
     * APIProperty: suffix
     * {String} A string to be appended to the current pointers coordinates
     *     when it is rendered.  Defaults to the empty string ''.
     */
    suffix: '',

    /**
     * APIProperty: numDigits
     * {Integer} The number of digits each coordinate shall have when being
     *     rendered, Defaults to 5.
     */
    numDigits: 5,

    /**
     * APIProperty: granularity
     * {Integer}
     */
    granularity: 10,

    /**
     * APIProperty: emptyString
     * {String} Set this to some value to set when the mouse is outside the
     *     map.
     */
    emptyString: null,

    /**
     * Property: lastXy
     * {<HGIS.Pixel>}
     */
    lastXy: null,

    /**
     * APIProperty: displayProjection
     * {<HGIS.Projection>} The projection in which the mouse position is
     *     displayed.
     */
    displayProjection: null,

    /**
     * Constructor: HGIS.Control.MousePosition
     *
     * Parameters:
     * options - {Object} Options for control.
     */

    /**
     * Method: destroy
     */
     destroy: function() {
         this.deactivate();
         HGIS.Control.prototype.destroy.apply(this, arguments);
     },

    /**
     * APIMethod: activate
     */
    activate: function() {
        if (HGIS.Control.prototype.activate.apply(this, arguments)) {
            this.map.events.register('mousemove', this, this.redraw);
            this.map.events.register('mouseout', this, this.reset);
            this.redraw();
            return true;
        } else {
            return false;
        }
    },

    /**
     * APIMethod: deactivate
     */
    deactivate: function() {
        if (HGIS.Control.prototype.deactivate.apply(this, arguments)) {
            this.map.events.unregister('mousemove', this, this.redraw);
            this.map.events.unregister('mouseout', this, this.reset);
            this.element.innerHTML = "";
            return true;
        } else {
            return false;
        }
    },

    /**
     * Method: draw
     * {DOMElement}
     */
    draw: function() {
        HGIS.Control.prototype.draw.apply(this, arguments);

        if (!this.element) {
            this.div.left = "";
            this.div.top = "";
            this.element = this.div;
        }

        return this.div;
    },

    /**
     * Method: redraw
     */
    redraw: function(evt) {

        var lonLat;

        if (evt == null) {
            this.reset();
            return;
        } else {
            if (this.lastXy == null ||
                Math.abs(evt.xy.x - this.lastXy.x) > this.granularity ||
                Math.abs(evt.xy.y - this.lastXy.y) > this.granularity)
            {
                this.lastXy = evt.xy;
                return;
            }

            lonLat = this.map.getLonLatFromPixel(evt.xy);
            if (!lonLat) {
                // map has not yet been properly initialized
                return;
            }
            if (this.displayProjection) {
                lonLat.transform(this.map.getProjectionObject(),
                                 this.displayProjection );
            }
            this.lastXy = evt.xy;

        }

        var newHtml = this.formatOutput(lonLat);

        if (newHtml != this.element.innerHTML) {
            this.element.innerHTML = newHtml;
        }
    },

    /**
     * Method: reset
     */
    reset: function(evt) {
        if (this.emptyString != null) {
            this.element.innerHTML = this.emptyString;
        }
    },

    /**
     * Method: formatOutput
     * Override to provide custom display output
     *
     * Parameters:
     * lonLat - {<HGIS.LonLat>} Location to display
     */
    formatOutput: function(lonLat) {
        var digits = parseInt(this.numDigits);
        var newHtml =
            this.prefix +
            lonLat.lon.toFixed(digits) +
            this.separator +
            lonLat.lat.toFixed(digits) +
            this.suffix;
        return newHtml;
    },

    CLASS_NAME: "HGIS.Control.MousePosition"
});
/* ======================================================================
    HGIS/Control/Geolocate.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Geometry/Point.js
 * @requires HGIS/Projection.js
 */

/**
 * Class: HGIS.Control.Geolocate
 * The Geolocate control wraps w3c geolocation API into control that can be
 * bound to a map, and generate events on location update
 *
 * To use this control requires to load the proj4js library if the projection
 * of the map is not EPSG:4326 or EPSG:900913.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.Geolocate = HGIS.Class(HGIS.Control, {

    /** 
     * APIProperty: events
     * {<HGIS.Events>} Events instance for listeners and triggering
     *     control specific events.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types (in addition to those from <HGIS.Control.events>):
     * locationupdated - Triggered when browser return a new position. Listeners will 
     *     receive an object with a 'position' property which is the browser.geolocation.position
     *     native object, as well as a 'point' property which is the location transformed in the 
     *     current map projection.
     * locationfailed - Triggered when geolocation has failed
     * locationuncapable - Triggered when control is activated on a browser
     *     which doesn't support geolocation
     */

    /**
     * Property: geolocation
     * {Object} The geolocation engine, as a property to be possibly mocked.
     * This is set lazily to avoid a memory leak in IE9.
     */
    geolocation: null,

    /**
     * Property: available
     * {Boolean} The navigator.geolocation object is available.
     */
    available: ('geolocation' in navigator),

    /**
     * APIProperty: bind
     * {Boolean} If true, map center will be set on location update.
     */
    bind: true,

    /**
     * APIProperty: watch
     * {Boolean} If true, position will be update regularly.
     */
    watch: false,

    /**
     * APIProperty: geolocationOptions
     * {Object} Options to pass to the navigator's geolocation API. See
     *     <http://dev.w3.org/geo/api/spec-source.html>. No specific
     *     option is passed to the geolocation API by default.
     */
    geolocationOptions: null,

    /**
     * Constructor: HGIS.Control.Geolocate
     * Create a new control to deal with browser geolocation API
     *
     */

    /**
     * Method: destroy
     */
    destroy: function() {
        this.deactivate();
        HGIS.Control.prototype.destroy.apply(this, arguments);
    },

    /**
     * Method: activate
     * Activates the control.
     *
     * Returns:
     * {Boolean} The control was effectively activated.
     */
    activate: function () {
        if (this.available && !this.geolocation) {
            // set lazily to avoid IE9 memory leak
            this.geolocation = navigator.geolocation;
        }
        if (!this.geolocation) {
            this.events.triggerEvent("locationuncapable");
            return false;
        }
        if (HGIS.Control.prototype.activate.apply(this, arguments)) {
            if (this.watch) {
                this.watchId = this.geolocation.watchPosition(
                    HGIS.Function.bind(this.geolocate, this),
                    HGIS.Function.bind(this.failure, this),
                    this.geolocationOptions
                );
            } else {
                this.getCurrentLocation();
            }
            return true;
        }
        return false;
    },

    /**
     * Method: deactivate
     * Deactivates the control.
     *
     * Returns:
     * {Boolean} The control was effectively deactivated.
     */
    deactivate: function () {
        if (this.active && this.watchId !== null) {
            this.geolocation.clearWatch(this.watchId);
        }
        return HGIS.Control.prototype.deactivate.apply(
            this, arguments
        );
    },

    /**
     * Method: geolocate
     * Activates the control.
     *
     */
    geolocate: function (position) {
        var center = new HGIS.LonLat(
            position.coords.longitude,
            position.coords.latitude
        ).transform(
            new HGIS.Projection("EPSG:4326"),
            this.map.getProjectionObject()
        );
        if (this.bind) {
            this.map.setCenter(center);
        }
        this.events.triggerEvent("locationupdated", {
            position: position,
            point: new HGIS.Geometry.Point(
                center.lon, center.lat
            )
        });
    },

    /**
     * APIMethod: getCurrentLocation
     *
     * Returns:
     * {Boolean} Returns true if a event will be fired (successfull
     * registration)
     */
    getCurrentLocation: function() {
        if (!this.active || this.watch) {
            return false;
        }
        this.geolocation.getCurrentPosition(
            HGIS.Function.bind(this.geolocate, this),
            HGIS.Function.bind(this.failure, this),
            this.geolocationOptions
        );
        return true;
    },

    /**
     * Method: failure
     * method called on browser's geolocation failure
     *
     */
    failure: function (error) {
        this.events.triggerEvent("locationfailed", {error: error});
    },

    CLASS_NAME: "HGIS.Control.Geolocate"
});
/* ======================================================================
    HGIS/Tile/UTFGrid.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Tile.js
 * @requires HGIS/Format/JSON.js
 * @requires HGIS/Request.js
 */

/**
 * Class: HGIS.Tile.UTFGrid
 * Instances of HGIS.Tile.UTFGrid are used to manage 
 * UTFGrids. This is an unusual tile type in that it doesn't have a
 * rendered image; only a 'hit grid' that can be used to 
 * look up feature attributes.
 *
 * See the <HGIS.Tile.UTFGrid> constructor for details on constructing a
 * new instance.
 *
 * Inherits from:
 *  - <HGIS.Tile>
 */
HGIS.Tile.UTFGrid = HGIS.Class(HGIS.Tile, {

    /** 
     * Property: url
     * {String}
     * The URL of the UTFGrid file being requested. Provided by the <getURL>
     *     method. 
     */
    url: null,
    
    /**
     * Property: utfgridResolution
     * {Number}
     * Ratio of the pixel width to the width of a UTFGrid data point.  If an 
     *     entry in the grid represents a 4x4 block of pixels, the 
     *     utfgridResolution would be 4.  Default is 2.
     */
    utfgridResolution: 2,
    
    /** 
     * Property: json
     * {Object}
     * Stores the parsed JSON tile data structure. 
     */
    json: null,
    
    /** 
     * Property: format
     * {HGIS.Format.JSON}
     * Parser instance used to parse JSON for cross browser support.  The native
     *     JSON.parse method will be used where available (all except IE<8).
     */
    format: null,

    /** 
     * Constructor: HGIS.Tile.UTFGrid
     * Constructor for a new <HGIS.Tile.UTFGrid> instance.
     * 
     * Parameters:
     * layer - {<HGIS.Layer>} layer that the tile will go in.
     * position - {<HGIS.Pixel>}
     * bounds - {<HGIS.Bounds>}
     * url - {<String>} Deprecated. Remove me in 3.0.
     * size - {<HGIS.Size>}
     * options - {Object}
     */

    /** 
     * APIMethod: destroy
     * Clean up.
     */
    destroy: function() {
        this.clear();
        HGIS.Tile.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Method: draw
     * Check that a tile should be drawn, and draw it.
     * In the case of UTFGrids, "drawing" it means fetching and
     * parsing the json. 
     * 
     * Returns:
     * {Boolean} Was a tile drawn?
     */
    draw: function() {
        var drawn = HGIS.Tile.prototype.draw.apply(this, arguments);
        if (drawn) {
            if (this.isLoading) {
                this.abortLoading();
                //if we're already loading, send 'reload' instead of 'loadstart'.
                this.events.triggerEvent("reload"); 
            } else {
                this.isLoading = true;
                this.events.triggerEvent("loadstart");
            }
            this.url = this.layer.getURL(this.bounds);

            if (this.layer.useJSONP) {
                // Use JSONP method to avoid xbrowser policy
                var ols = new HGIS.Protocol.Script({
                    url: this.url,
                    callback: function(response) {
                        this.isLoading = false;
                        this.events.triggerEvent("loadend");
                        this.json = response.data;
                    },
                    scope: this
                });
                ols.read();
                this.request = ols;
            } else {
                // Use standard XHR
                this.request = HGIS.Request.GET({
                    url: this.url,
                    callback: function(response) {
                        this.isLoading = false;
                        this.events.triggerEvent("loadend");
                        if (response.status === 200) {
                            this.parseData(response.responseText);
                        }
                    },
                    scope: this
                });
            }
        } else {
            this.unload();
        }
        return drawn;
    },
    
    /**
     * Method: abortLoading
     * Cancel a pending request.
     */
    abortLoading: function() {
        if (this.request) {
            this.request.abort();
            delete this.request;
        }
        this.isLoading = false;
    },
    
    /**
     * Method: getFeatureInfo
     * Get feature information associated with a pixel offset.  If the pixel
     *     offset corresponds to a feature, the returned object will have id
     *     and data properties.  Otherwise, null will be returned.
     *     
     *
     * Parameters:
     * i - {Number} X-axis pixel offset (from top left of tile)
     * j - {Number} Y-axis pixel offset (from top left of tile)
     *
     * Returns:
     * {Object} Object with feature id and data properties corresponding to the 
     *     given pixel offset.
     */
    getFeatureInfo: function(i, j) {
        var info = null;
        if (this.json) {
            var id = this.getFeatureId(i, j);
            if (id !== null) {
                info = {id: id, data: this.json.data[id]};
            }
        }
        return info;
    },
    
    /**
     * Method: getFeatureId
     * Get the identifier for the feature associated with a pixel offset.
     *
     * Parameters:
     * i - {Number} X-axis pixel offset (from top left of tile)
     * j - {Number} Y-axis pixel offset (from top left of tile)
     *
     * Returns:
     * {Object} The feature identifier corresponding to the given pixel offset.
     *     Returns null if pixel doesn't correspond to a feature.
     */
    getFeatureId: function(i, j) {
        var id = null;
        if (this.json) {
            var resolution = this.utfgridResolution;
            var row = Math.floor(j / resolution);
            var col = Math.floor(i / resolution);
            var charCode = this.json.grid[row].charCodeAt(col);
            var index = this.indexFromCharCode(charCode);
            var keys = this.json.keys;
            if (!isNaN(index) && (index in keys)) {
                id = keys[index];
            }
        }
        return id;
    },
    
    /**
     * Method: indexFromCharCode
     * Given a character code for one of the UTFGrid "grid" characters, 
     *     resolve the integer index for the feature id in the UTFGrid "keys"
     *     array.
     *
     * Parameters:
     * charCode - {Integer}
     *
     * Returns:
     * {Integer} Index for the feature id from the keys array.
     */
    indexFromCharCode: function(charCode) {
        if (charCode >= 93) {
            charCode--;
        }
        if (charCode >= 35) {
            charCode --;
        }
        return charCode - 32;
    },
    
    /**
     * Method: parseData
     * Parse the JSON from a request
     *
     * Parameters:
     * str - {String} UTFGrid as a JSON string. 
     * 
     * Returns:
     * {Object} parsed javascript data
     */
    parseData: function(str) {
        if (!this.format) {
            this.format = new HGIS.Format.JSON();
        }
        this.json = this.format.read(str);
    },
    
    /** 
     * Method: clear
     * Delete data stored with this tile.
     */
    clear: function() {
        this.json = null;
    },
    
    CLASS_NAME: "HGIS.Tile.UTFGrid"

});
/* ======================================================================
    HGIS/Protocol/HTTP.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Protocol.js
 * @requires HGIS/Request/XMLHttpRequest.js
 */

/**
 * if application uses the query string, for example, for BBOX parameters,
 * HGIS/Format/QueryStringFilter.js should be included in the build config file
 */

/**
 * Class: HGIS.Protocol.HTTP
 * A basic HTTP protocol for vector layers.  Create a new instance with the
 *     <HGIS.Protocol.HTTP> constructor.
 *
 * Inherits from:
 *  - <HGIS.Protocol>
 */
HGIS.Protocol.HTTP = HGIS.Class(HGIS.Protocol, {

    /**
     * Property: url
     * {String} Service URL, read-only, set through the options
     *     passed to constructor.
     */
    url: null,

    /**
     * Property: headers
     * {Object} HTTP request headers, read-only, set through the options
     *     passed to the constructor,
     *     Example: {'Content-Type': 'plain/text'}
     */
    headers: null,

    /**
     * Property: params
     * {Object} Parameters of GET requests, read-only, set through the options
     *     passed to the constructor,
     *     Example: {'bbox': '5,5,5,5'}
     */
    params: null,
    
    /**
     * Property: callback
     * {Object} Function to be called when the <read>, <create>,
     *     <update>, <delete> or <commit> operation completes, read-only,
     *     set through the options passed to the constructor.
     */
    callback: null,

    /**
     * Property: scope
     * {Object} Callback execution scope, read-only, set through the
     *     options passed to the constructor.
     */
    scope: null,

    /**
     * APIProperty: readWithPOST
     * {Boolean} true if read operations are done with POST requests
     *     instead of GET, defaults to false.
     */
    readWithPOST: false,

    /**
     * APIProperty: updateWithPOST
     * {Boolean} true if update operations are done with POST requests
     *     defaults to false.
     */
    updateWithPOST: false,
    
    /**
     * APIProperty: deleteWithPOST
     * {Boolean} true if delete operations are done with POST requests
     *     defaults to false.
     *     if true, POST data is set to output of format.write().
     */
    deleteWithPOST: false,

    /**
     * Property: wildcarded.
     * {Boolean} If true percent signs are added around values
     *     read from LIKE filters, for example if the protocol
     *     read method is passed a LIKE filter whose property
     *     is "foo" and whose value is "bar" the string
     *     "foo__ilike=%bar%" will be sent in the query string;
     *     defaults to false.
     */
    wildcarded: false,

    /**
     * APIProperty: srsInBBOX
     * {Boolean} Include the SRS identifier in BBOX query string parameter.  
     *     Default is false.  If true and the layer has a projection object set,
     *     any BBOX filter will be serialized with a fifth item identifying the
     *     projection.  E.g. bbox=-1000,-1000,1000,1000,EPSG:900913
     */
    srsInBBOX: false,

    /**
     * Constructor: HGIS.Protocol.HTTP
     * A class for giving layers generic HTTP protocol.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options include:
     * url - {String}
     * headers - {Object} 
     * params - {Object} URL parameters for GET requests
     * format - {<HGIS.Format>}
     * callback - {Function}
     * scope - {Object}
     */
    initialize: function(options) {
        options = options || {};
        this.params = {};
        this.headers = {};
        HGIS.Protocol.prototype.initialize.apply(this, arguments);

        if (!this.filterToParams && HGIS.Format.QueryStringFilter) {
            var format = new HGIS.Format.QueryStringFilter({
                wildcarded: this.wildcarded,
                srsInBBOX: this.srsInBBOX
            });
            this.filterToParams = function(filter, params) {
                return format.write(filter, params);
            };
        }
    },
    
    /**
     * APIMethod: destroy
     * Clean up the protocol.
     */
    destroy: function() {
        this.params = null;
        this.headers = null;
        HGIS.Protocol.prototype.destroy.apply(this);
    },

    /**
     * APIMethod: filterToParams
     * Optional method to translate an <HGIS.Filter> object into an object
     *     that can be serialized as request query string provided.  If a custom
     *     method is not provided, the filter will be serialized using the 
     *     <HGIS.Format.QueryStringFilter> class.
     *
     * Parameters:
     * filter - {<HGIS.Filter>} filter to convert.
     * params - {Object} The parameters object.
     *
     * Returns:
     * {Object} The resulting parameters object.
     */
    
    /**
     * APIMethod: read
     * Construct a request for reading new features.
     *
     * Parameters:
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Valid options:
     * url - {String} Url for the request.
     * params - {Object} Parameters to get serialized as a query string.
     * headers - {Object} Headers to be set on the request.
     * filter - {<HGIS.Filter>} Filter to get serialized as a
     *     query string.
     * readWithPOST - {Boolean} If the request should be done with POST.
     *
     * Returns:
     * {<HGIS.Protocol.Response>} A response object, whose "priv" property
     *     references the HTTP request, this object is also passed to the
     *     callback function when the request completes, its "features" property
     *     is then populated with the features received from the server.
     */
    read: function(options) {
        HGIS.Protocol.prototype.read.apply(this, arguments);
        options = options || {};
        options.params = HGIS.Util.applyDefaults(
            options.params, this.options.params);
        options = HGIS.Util.applyDefaults(options, this.options);
        if (options.filter && this.filterToParams) {
            options.params = this.filterToParams(
                options.filter, options.params
            );
        }
        var readWithPOST = (options.readWithPOST !== undefined) ?
                           options.readWithPOST : this.readWithPOST;
        var resp = new HGIS.Protocol.Response({requestType: "read"});
        if(readWithPOST) {
            var headers = options.headers || {};
            headers["Content-Type"] = "application/x-www-form-urlencoded";
            resp.priv = HGIS.Request.POST({
                url: options.url,
                callback: this.createCallback(this.handleRead, resp, options),
                data: HGIS.Util.getParameterString(options.params),
                headers: headers
            });
        } else {
            resp.priv = HGIS.Request.GET({
                url: options.url,
                callback: this.createCallback(this.handleRead, resp, options),
                params: options.params,
                headers: options.headers
            });
        }
        return resp;
    },

    /**
     * Method: handleRead
     * Individual callbacks are created for read, create and update, should
     *     a subclass need to override each one separately.
     *
     * Parameters:
     * resp - {<HGIS.Protocol.Response>} The response object to pass to
     *     the user callback.
     * options - {Object} The user options passed to the read call.
     */
    handleRead: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * APIMethod: create
     * Construct a request for writing newly created features.
     *
     * Parameters:
     * features - {Array({<HGIS.Feature.Vector>})} or
     *     {<HGIS.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Returns:
     * {<HGIS.Protocol.Response>} An <HGIS.Protocol.Response>
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes, its "features" property is then populated with the
     *     the features received from the server.
     */
    create: function(features, options) {
        options = HGIS.Util.applyDefaults(options, this.options);

        var resp = new HGIS.Protocol.Response({
            reqFeatures: features,
            requestType: "create"
        });

        resp.priv = HGIS.Request.POST({
            url: options.url,
            callback: this.createCallback(this.handleCreate, resp, options),
            headers: options.headers,
            data: this.format.write(features)
        });

        return resp;
    },

    /**
     * Method: handleCreate
     * Called the the request issued by <create> is complete.  May be overridden
     *     by subclasses.
     *
     * Parameters:
     * resp - {<HGIS.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the create call.
     */
    handleCreate: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * APIMethod: update
     * Construct a request updating modified feature.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Returns:
     * {<HGIS.Protocol.Response>} An <HGIS.Protocol.Response>
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes, its "features" property is then populated with the
     *     the feature received from the server.
     */
    update: function(feature, options) {
        options = options || {};
        var url = options.url ||
                  feature.url ||
                  this.options.url + "/" + feature.fid;
        options = HGIS.Util.applyDefaults(options, this.options);

        var resp = new HGIS.Protocol.Response({
            reqFeatures: feature,
            requestType: "update"
        });

        var method = this.updateWithPOST ? "POST" : "PUT";
        resp.priv = HGIS.Request[method]({
            url: url,
            callback: this.createCallback(this.handleUpdate, resp, options),
            headers: options.headers,
            data: this.format.write(feature)
        });

        return resp;
    },

    /**
     * Method: handleUpdate
     * Called the the request issued by <update> is complete.  May be overridden
     *     by subclasses.
     *
     * Parameters:
     * resp - {<HGIS.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the update call.
     */
    handleUpdate: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * APIMethod: delete
     * Construct a request deleting a removed feature.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     * options - {Object} Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * Returns:
     * {<HGIS.Protocol.Response>} An <HGIS.Protocol.Response>
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes.
     */
    "delete": function(feature, options) {
        options = options || {};
        var url = options.url ||
                  feature.url ||
                  this.options.url + "/" + feature.fid;
        options = HGIS.Util.applyDefaults(options, this.options);

        var resp = new HGIS.Protocol.Response({
            reqFeatures: feature,
            requestType: "delete"
        });

        var method = this.deleteWithPOST ? "POST" : "DELETE";
        var requestOptions = {
            url: url,
            callback: this.createCallback(this.handleDelete, resp, options),
            headers: options.headers
        };
        if (this.deleteWithPOST) {
            requestOptions.data = this.format.write(feature);
        }
        resp.priv = HGIS.Request[method](requestOptions);

        return resp;
    },

    /**
     * Method: handleDelete
     * Called the the request issued by <delete> is complete.  May be overridden
     *     by subclasses.
     *
     * Parameters:
     * resp - {<HGIS.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the delete call.
     */
    handleDelete: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * Method: handleResponse
     * Called by CRUD specific handlers.
     *
     * Parameters:
     * resp - {<HGIS.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the create, read, update,
     *     or delete call.
     */
    handleResponse: function(resp, options) {
        var request = resp.priv;
        if(options.callback) {
            if(request.status >= 200 && request.status < 300) {
                // success
                if(resp.requestType != "delete") {
                    resp.features = this.parseFeatures(request);
                }
                resp.code = HGIS.Protocol.Response.SUCCESS;
            } else {
                // failure
                resp.code = HGIS.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, resp);
        }
    },

    /**
     * Method: parseFeatures
     * Read HTTP response body and return features.
     *
     * Parameters:
     * request - {XMLHttpRequest} The request object
     *
     * Returns:
     * {Array({<HGIS.Feature.Vector>})} or
     *     {<HGIS.Feature.Vector>} Array of features or a single feature.
     */
    parseFeatures: function(request) {
        var doc = request.responseXML;
        if (!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if (!doc || doc.length <= 0) {
            return null;
        }
        return this.format.read(doc);
    },

    /**
     * APIMethod: commit
     * Iterate over each feature and take action based on the feature state.
     *     Possible actions are create, update and delete.
     *
     * Parameters:
     * features - {Array({<HGIS.Feature.Vector>})}
     * options - {Object} Optional object for setting up intermediate commit
     *     callbacks.
     *
     * Valid options:
     * create - {Object} Optional object to be passed to the <create> method.
     * update - {Object} Optional object to be passed to the <update> method.
     * delete - {Object} Optional object to be passed to the <delete> method.
     * callback - {Function} Optional function to be called when the commit
     *     is complete.
     * scope - {Object} Optional object to be set as the scope of the callback.
     *
     * Returns:
     * {Array(<HGIS.Protocol.Response>)} An array of response objects,
     *     one per request made to the server, each object's "priv" property
     *     references the corresponding HTTP request.
     */
    commit: function(features, options) {
        options = HGIS.Util.applyDefaults(options, this.options);
        var resp = [], nResponses = 0;
        
        // Divide up features before issuing any requests.  This properly
        // counts requests in the event that any responses come in before
        // all requests have been issued.
        var types = {};
        types[HGIS.State.INSERT] = [];
        types[HGIS.State.UPDATE] = [];
        types[HGIS.State.DELETE] = [];
        var feature, list, requestFeatures = [];
        for(var i=0, len=features.length; i<len; ++i) {
            feature = features[i];
            list = types[feature.state];
            if(list) {
                list.push(feature);
                requestFeatures.push(feature); 
            }
        }
        // tally up number of requests
        var nRequests = (types[HGIS.State.INSERT].length > 0 ? 1 : 0) +
            types[HGIS.State.UPDATE].length +
            types[HGIS.State.DELETE].length;
        
        // This response will be sent to the final callback after all the others
        // have been fired.
        var success = true;
        var finalResponse = new HGIS.Protocol.Response({
            reqFeatures: requestFeatures        
        });
        
        function insertCallback(response) {
            var len = response.features ? response.features.length : 0;
            var fids = new Array(len);
            for(var i=0; i<len; ++i) {
                fids[i] = response.features[i].fid;
            }   
            finalResponse.insertIds = fids;
            callback.apply(this, [response]);
        }
 
        function callback(response) {
            this.callUserCallback(response, options);
            success = success && response.success();
            nResponses++;
            if (nResponses >= nRequests) {
                if (options.callback) {
                    finalResponse.code = success ? 
                        HGIS.Protocol.Response.SUCCESS :
                        HGIS.Protocol.Response.FAILURE;
                    options.callback.apply(options.scope, [finalResponse]);
                }    
            }
        }

        // start issuing requests
        var queue = types[HGIS.State.INSERT];
        if(queue.length > 0) {
            resp.push(this.create(
                queue, HGIS.Util.applyDefaults(
                    {callback: insertCallback, scope: this}, options.create
                )
            ));
        }
        queue = types[HGIS.State.UPDATE];
        for(var i=queue.length-1; i>=0; --i) {
            resp.push(this.update(
                queue[i], HGIS.Util.applyDefaults(
                    {callback: callback, scope: this}, options.update
                ))
            );
        }
        queue = types[HGIS.State.DELETE];
        for(var i=queue.length-1; i>=0; --i) {
            resp.push(this["delete"](
                queue[i], HGIS.Util.applyDefaults(
                    {callback: callback, scope: this}, options["delete"]
                ))
            );
        }
        return resp;
    },

    /**
     * APIMethod: abort
     * Abort an ongoing request, the response object passed to
     * this method must come from this HTTP protocol (as a result
     * of a create, read, update, delete or commit operation).
     *
     * Parameters:
     * response - {<HGIS.Protocol.Response>}
     */
    abort: function(response) {
        if (response) {
            response.priv.abort();
        }
    },

    /**
     * Method: callUserCallback
     * This method is used from within the commit method each time an
     *     an HTTP response is received from the server, it is responsible
     *     for calling the user-supplied callbacks.
     *
     * Parameters:
     * resp - {<HGIS.Protocol.Response>}
     * options - {Object} The map of options passed to the commit call.
     */
    callUserCallback: function(resp, options) {
        var opt = options[resp.requestType];
        if(opt && opt.callback) {
            opt.callback.call(opt.scope, resp);
        }
    },

    CLASS_NAME: "HGIS.Protocol.HTTP" 
});
/* ======================================================================
    HGIS/Strategy/Cluster.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Strategy.js
 */

/**
 * Class: HGIS.Strategy.Cluster
 * Strategy for vector feature clustering.
 *
 * Inherits from:
 *  - <HGIS.Strategy>
 */
HGIS.Strategy.Cluster = HGIS.Class(HGIS.Strategy, {
    
    /**
     * APIProperty: distance
     * {Integer} Pixel distance between features that should be considered a
     *     single cluster.  Default is 20 pixels.
     */
    distance: 20,
    
    /**
     * APIProperty: threshold
     * {Integer} Optional threshold below which original features will be
     *     added to the layer instead of clusters.  For example, a threshold
     *     of 3 would mean that any time there are 2 or fewer features in
     *     a cluster, those features will be added directly to the layer instead
     *     of a cluster representing those features.  Default is null (which is
     *     equivalent to 1 - meaning that clusters may contain just one feature).
     */
    threshold: null,
    
    /**
     * Property: features
     * {Array(<HGIS.Feature.Vector>)} Cached features.
     */
    features: null,
    
    /**
     * Property: clusters
     * {Array(<HGIS.Feature.Vector>)} Calculated clusters.
     */
    clusters: null,
    
    /**
     * Property: clustering
     * {Boolean} The strategy is currently clustering features.
     */
    clustering: false,
    
    /**
     * Property: resolution
     * {Float} The resolution (map units per pixel) of the current cluster set.
     */
    resolution: null,

    /**
     * Constructor: HGIS.Strategy.Cluster
     * Create a new clustering strategy.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
    
    /**
     * APIMethod: activate
     * Activate the strategy.  Register any listeners, do appropriate setup.
     * 
     * Returns:
     * {Boolean} The strategy was successfully activated.
     */
    activate: function() {
        var activated = HGIS.Strategy.prototype.activate.call(this);
        if(activated) {
            this.layer.events.on({
                "beforefeaturesadded": this.cacheFeatures,
                "featuresremoved": this.clearCache,
                "moveend": this.cluster,
                scope: this
            });
        }
        return activated;
    },
    
    /**
     * APIMethod: deactivate
     * Deactivate the strategy.  Unregister any listeners, do appropriate
     *     tear-down.
     * 
     * Returns:
     * {Boolean} The strategy was successfully deactivated.
     */
    deactivate: function() {
        var deactivated = HGIS.Strategy.prototype.deactivate.call(this);
        if(deactivated) {
            this.clearCache();
            this.layer.events.un({
                "beforefeaturesadded": this.cacheFeatures,
                "featuresremoved": this.clearCache,
                "moveend": this.cluster,
                scope: this
            });
        }
        return deactivated;
    },
    
    /**
     * Method: cacheFeatures
     * Cache features before they are added to the layer.
     *
     * Parameters:
     * event - {Object} The event that this was listening for.  This will come
     *     with a batch of features to be clustered.
     *     
     * Returns:
     * {Boolean} False to stop features from being added to the layer.
     */
    cacheFeatures: function(event) {
        var propagate = true;
        if(!this.clustering) {
            this.clearCache();
            this.features = event.features;
            this.cluster();
            propagate = false;
        }
        return propagate;
    },
    
    /**
     * Method: clearCache
     * Clear out the cached features.
     */
    clearCache: function() {
        if(!this.clustering) {
            this.features = null;
        }
    },
    
    /**
     * Method: cluster
     * Cluster features based on some threshold distance.
     *
     * Parameters:
     * event - {Object} The event received when cluster is called as a
     *     result of a moveend event.
     */
    cluster: function(event) {
        if((!event || event.zoomChanged) && this.features) {
            var resolution = this.layer.map.getResolution();
            if(resolution != this.resolution || !this.clustersExist()) {
                this.resolution = resolution;
                var clusters = [];
                var feature, clustered, cluster;
                for(var i=0; i<this.features.length; ++i) {
                    feature = this.features[i];
                    if(feature.geometry) {
                        clustered = false;
                        for(var j=clusters.length-1; j>=0; --j) {
                            cluster = clusters[j];
                            if(this.shouldCluster(cluster, feature)) {
                                this.addToCluster(cluster, feature);
                                clustered = true;
                                break;
                            }
                        }
                        if(!clustered) {
                            clusters.push(this.createCluster(this.features[i]));
                        }
                    }
                }
                this.clustering = true;
                this.layer.removeAllFeatures();
                this.clustering = false;
                if(clusters.length > 0) {
                    if(this.threshold > 1) {
                        var clone = clusters.slice();
                        clusters = [];
                        var candidate;
                        for(var i=0, len=clone.length; i<len; ++i) {
                            candidate = clone[i];
                            if(candidate.attributes.count < this.threshold) {
                                Array.prototype.push.apply(clusters, candidate.cluster);
                            } else {
                                clusters.push(candidate);
                            }
                        }
                    }
                    this.clustering = true;
                    // A legitimate feature addition could occur during this
                    // addFeatures call.  For clustering to behave well, features
                    // should be removed from a layer before requesting a new batch.
                    this.layer.addFeatures(clusters);
                    this.clustering = false;
                }
                this.clusters = clusters;
            }
        }
    },
    
    /**
     * Method: clustersExist
     * Determine whether calculated clusters are already on the layer.
     *
     * Returns:
     * {Boolean} The calculated clusters are already on the layer.
     */
    clustersExist: function() {
        var exist = false;
        if(this.clusters && this.clusters.length > 0 &&
           this.clusters.length == this.layer.features.length) {
            exist = true;
            for(var i=0; i<this.clusters.length; ++i) {
                if(this.clusters[i] != this.layer.features[i]) {
                    exist = false;
                    break;
                }
            }
        }
        return exist;
    },
    
    /**
     * Method: shouldCluster
     * Determine whether to include a feature in a given cluster.
     *
     * Parameters:
     * cluster - {<HGIS.Feature.Vector>} A cluster.
     * feature - {<HGIS.Feature.Vector>} A feature.
     *
     * Returns:
     * {Boolean} The feature should be included in the cluster.
     */
    shouldCluster: function(cluster, feature) {
        var cc = cluster.geometry.getBounds().getCenterLonLat();
        var fc = feature.geometry.getBounds().getCenterLonLat();
        var distance = (
            Math.sqrt(
                Math.pow((cc.lon - fc.lon), 2) + Math.pow((cc.lat - fc.lat), 2)
            ) / this.resolution
        );
        return (distance <= this.distance);
    },
    
    /**
     * Method: addToCluster
     * Add a feature to a cluster.
     *
     * Parameters:
     * cluster - {<HGIS.Feature.Vector>} A cluster.
     * feature - {<HGIS.Feature.Vector>} A feature.
     */
    addToCluster: function(cluster, feature) {
        cluster.cluster.push(feature);
        cluster.attributes.count += 1;
    },
    
    /**
     * Method: createCluster
     * Given a feature, create a cluster.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     *
     * Returns:
     * {<HGIS.Feature.Vector>} A cluster.
     */
    createCluster: function(feature) {
        var center = feature.geometry.getBounds().getCenterLonLat();
        var cluster = new HGIS.Feature.Vector(
            new HGIS.Geometry.Point(center.lon, center.lat),
            {count: 1}
        );
        cluster.cluster = [feature];
        return cluster;
    },

    CLASS_NAME: "HGIS.Strategy.Cluster" 
});
/* ======================================================================
    HGIS/Strategy/Filter.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Strategy.js
 * @requires HGIS/Filter.js
 */

/**
 * Class: HGIS.Strategy.Filter
 * Strategy for limiting features that get added to a layer by 
 *     evaluating a filter.  The strategy maintains a cache of
 *     all features until removeFeatures is called on the layer.
 *
 * Inherits from:
 *  - <HGIS.Strategy>
 */
HGIS.Strategy.Filter = HGIS.Class(HGIS.Strategy, {
    
    /**
     * APIProperty: filter
     * {<HGIS.Filter>}  Filter for limiting features sent to the layer.
     *     Use the <setFilter> method to update this filter after construction.
     */
    filter: null,
    
    /**
     * Property: cache
     * {Array(<HGIS.Feature.Vector>)} List of currently cached
     *     features.
     */
    cache: null,
    
    /**
     * Property: caching
     * {Boolean} The filter is currently caching features.
     */
    caching: false,
    
    /**
     * Constructor: HGIS.Strategy.Filter
     * Create a new filter strategy.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */

    /**
     * APIMethod: activate
     * Activate the strategy.  Register any listeners, do appropriate setup.
     *     By default, this strategy automatically activates itself when a layer
     *     is added to a map.
     *
     * Returns:
     * {Boolean} True if the strategy was successfully activated or false if
     *      the strategy was already active.
     */
    activate: function() {
        var activated = HGIS.Strategy.prototype.activate.apply(this, arguments);
        if (activated) {
            this.cache = [];
            this.layer.events.on({
                "beforefeaturesadded": this.handleAdd,
                "beforefeaturesremoved": this.handleRemove,
                scope: this
            });
        }
        return activated;
    },
    
    /**
     * APIMethod: deactivate
     * Deactivate the strategy.  Clear the feature cache.
     *
     * Returns:
     * {Boolean} True if the strategy was successfully deactivated or false if
     *      the strategy was already inactive.
     */
    deactivate: function() {
        this.cache = null;
        if (this.layer && this.layer.events) {
            this.layer.events.un({
                "beforefeaturesadded": this.handleAdd,
                "beforefeaturesremoved": this.handleRemove,
                scope: this
            });            
        }
        return HGIS.Strategy.prototype.deactivate.apply(this, arguments);
    },
    
    /**
     * Method: handleAdd
     */
    handleAdd: function(event) {
        if (!this.caching && this.filter) {
            var features = event.features;
            event.features = [];
            var feature;
            for (var i=0, ii=features.length; i<ii; ++i) {
                feature = features[i];
                if (this.filter.evaluate(feature)) {
                    event.features.push(feature);
                } else {
                    this.cache.push(feature);
                }
            }
        }
    },
    
    /**
     * Method: handleRemove
     */
    handleRemove: function(event) {
        if (!this.caching) {
            this.cache = [];
        }
    },

    /** 
     * APIMethod: setFilter
     * Update the filter for this strategy.  This will re-evaluate
     *     any features on the layer and in the cache.  Only features
     *     for which filter.evalute(feature) returns true will be
     *     added to the layer.  Others will be cached by the strategy.
     *
     * Parameters:
     * filter - {<HGIS.Filter>} A filter for evaluating features.
     */
    setFilter: function(filter) {
        this.filter = filter;
        var previousCache = this.cache;
        this.cache = [];
        // look through layer for features to remove from layer
        this.handleAdd({features: this.layer.features});
        // cache now contains features to remove from layer
        if (this.cache.length > 0) {
            this.caching = true;
            this.layer.removeFeatures(this.cache.slice());
            this.caching = false;
        }
        // now look through previous cache for features to add to layer
        if (previousCache.length > 0) {
            var event = {features: previousCache};
            this.handleAdd(event);
            if (event.features.length > 0) {
                // event has features to add to layer
                this.caching = true;
                this.layer.addFeatures(event.features);
                this.caching = false;
            }
        }
    },

    CLASS_NAME: "HGIS.Strategy.Filter"

});
/* Copyright (c) 2006-2008 MetaCarta, Inc., published under the Clear BSD
 * license.  See http://svn.HGIS.org/trunk/HGIS/license.txt for the
 * full text of the license. */


/**
 * @requires HGIS/Strategy.js
 * @requires HGIS/Console.js
 */

/**
 * Class: HGIS.Strategy.Grid
 * Base class for layers that use a lattice of tiles.  Create a new grid
 * layer with the <HGIS.Layer.Grid> constructor.
 *
 * Inherits from:
 *  - <HGIS.Layer.HTTPRequest>
 */
HGIS.Strategy.Grid = HGIS.Class(HGIS.Strategy, {
    /**
     * Property: tileSize
     * {<HGIS.Size>}
     */
    tileSize: null,
    /**
     * Property: grid
     * {Array(Array(<HGIS.Tile>))} This is an array of rows, each row is
     *     an array of tiles.
     */
    grid: null,
    /**
     * APIProperty: buffer
     * {Integer} Used only when in gridded mode, this specifies the number of
     *           extra rows and colums of tiles on each side which will
     *           surround the minimum grid tiles to cover the map.
     */
    buffer: 1,
    /**
     * APIProperty: loadedBounds
     * {HGIS.Bounds} Extent actually loaded in tile coordinates.
     */
    loadedBounds: null,
    /**
     * APIProperty: numLoadingTiles
     * {Integer} How many tiles are still loading?
     */
    numLoadingTiles: 0,
    /**
     * Property: zoom
     * {Integer} Last zoom; detect zoom changes
     */
    zoom: null,
    /**
     * Property: geometryFeatureMap
     * {Object} Maps geometries to features
     */
    geometryFeatureMap: {},
    /**
     * Properties: loadedTiles
     * {Object} All currently loaded tiles.
     */
    tiles: {},
    
    totalTileCount:0,//某次渲染总请求切片数
    allFeatures:[],//某次渲染请求的所有切片内的要素集合
    progress:0,//当前正在处理第几个切片
    /**
     * Constructor: HGIS.Strategy.Grid
     * Create a new Grid strategy.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
    initialize: function(options) {
        HGIS.Strategy.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: destroy
     * Deconstruct the layer and clear the grid.
     */
    destroy: function() {
        this.clearGrid();
        this.grid = null;
        this.tileSize = null;
        HGIS.Strategy.prototype.destroy.apply(this, arguments);
    },


    /**
     * Method: activate
     * Set up strategy with regard to reading new batches of remote data.
     *
     * Returns:
     * {Boolean} The strategy was successfully activated.
     */
    activate: function() {
        var activated = HGIS.Strategy.prototype.activate.call(this);
        if(activated) {
            this.layer.events.on({
                "moveend": this.update,
                "refresh": this.update,
                scope: this
            });
            if(this.layer.visibility == true || this.preload) {
                this.update();
            } else {
                this.layer.events.on({
                    "visibilitychanged": this.load,
                    scope: this
                });
            }
        }
        return activated;
    },

    /**
     * Method: deactivate
     * Tear down strategy with regard to reading new batches of remote data.
     *
     * Returns:
     * {Boolean} The strategy was successfully deactivated.
     */
    deactivate: function() {
        var deactivated = HGIS.Strategy.prototype.deactivate.call(this);
        if(deactivated) {
            this.layer.events.un({
                "moveend": this.update,
                "refresh": this.update,
                "visibilitychanged": this.load,
                scope: this
            });
        }
        return deactivated;
    },

    /**
     * Method: update
     * Callback function called on "moveend" or "refresh" layer events.
     */
    update: function() {
    	this.progress=0;//每次渲染前置为0  
    	this.totalTileCount=0;//每次渲染前置为0  
    	this.allFeatures=[];//每次渲染前置空
        var bounds = this.layer.map.getExtent();
        if (bounds == null) return;
        // Find tiles to load
        var map = this.layer.map;
        var resolution = map.getResolution();
        var tileSize = map.getTileSize();
        var curZoom = map.zoom;
        var extent = this.layer.maxExtent;
        var tilelon = resolution * tileSize.w;
        var tilelat = resolution * tileSize.h;
        //Get tile bounding box
        var left = Math.floor((bounds.left - extent.left)/tilelon) - this.buffer;
        var right = Math.ceil((bounds.right - extent.left)/tilelon) + this.buffer;
        var top = Math.floor((extent.top - bounds.top)/tilelat) - this.buffer;
        var bottom = Math.ceil((extent.top - bounds.bottom)/tilelat) + this.buffer;
        if (curZoom != this.zoom) {
            this.layer.destroyFeatures();
            this.geometryFeatureMap = {};
            this.tiles = {};
            this.zoom = curZoom;
        }
        var TileInfoArr=[];
        for (var x=left; x<right; x++) {
            for (var y=top; y<bottom; y++) {
                if (!([x, y] in this.tiles)) {
                    var bl = x * tilelon + extent.left;
                    var bt = extent.top - y * tilelat;
                    var tileInfo={x:x,y:y,curZoom:curZoom,bl:bl,bt:bt};
                    TileInfoArr.push(tileInfo);
                    //this.loadTile(x, y, curZoom, new HGIS.Bounds(bl, bt-tilelat, bl+tilelon, bt));
                }
            }
        }
        //this.layer.renderer.tileCount=TileInfoArr.length;//切片总数赋给layer
        //this.layer.renderer.count404=0;//404重置为0
        this.totalTileCount=TileInfoArr.length;//切片总数赋给totalTile
       // console.log("总瓦片数:"+this.totalTileCount);
        for(var i=0;i<TileInfoArr.length;i++){
        	this.loadTile(TileInfoArr[i].x, TileInfoArr[i].y, TileInfoArr[i].curZoom, new HGIS.Bounds(TileInfoArr[i].bl, TileInfoArr[i].bt-tilelat, TileInfoArr[i].bl+tilelon, TileInfoArr[i].bt),i);
        }
    },

    //使用promise的加载方式
    loadTile_promise: function(x, y, z, bounds) {
        /*if (this.response) {
            this.layer.protocol.abort(this.response);
            this.layer.events.triggerEvent("loadend");
        }
        this.layer.events.triggerEvent("loadstart");*/
    	
    	var $this=this;
        var url = HGIS.String.format(this.layer.protocol.url, {x: x, y:y, z:z});
        new Promise(function (resolve,reject) {
		if(HGIS.Strategy.Parameters.isCache && HGIS.Strategy.Parameters.isConnected){
			var success_query=function (res) {
				resolve(URL.createObjectURL(res));
            };
		var error_query=function (err) {
			$this.takeUrlToIndexedDB(url,z);
                    resolve(url);
                };
                HGIS.Strategy.Parameters.wtc.query(url.hashCode(),z,success_query,error_query);
            }else{
            	resolve(url);
		}
	  }).then(function(res){
		$this.response = $this.layer.protocol.read({
	            url: res,
	            filter: $this.layer.filter,
	            callback: $this.readDone,
	            scope: {scope: $this, options: {x:x, y:y, z:z, bounds:bounds}}
	        });
	  });
    },
    
    /**
     *将url资源保存到indexedDB
     */
    takeUrlToIndexedDB: function(imgurl,level){
        var xhr = new XMLHttpRequest();
    	   xhr.open("GET", imgurl, true);
        // Set the responseType to blob
        xhr.responseType = "blob";
        xhr.addEventListener("load", function () {
            if (xhr.status === 200) {
                //console.log("[takeUrlToIndexedDB] 获取hvt成功");
                HGIS.Strategy.Parameters.wtc.insert(imgurl.hashCode(),level,xhr.response);
            }else{
                //console.error('[takeUrlToIndexedDB] 获取hvt失败');
            }
        }, false);
        // Send XHR
        xhr.send();
     },

    /**
     * Method: triggerRead
     * Returns:
     * {<HGIS.Protocol.Response>} The protocol response object
     *      returned by the layer protocol.
     */
    loadTile: function(x, y, z, bounds,i) {//i:当前第几个切片
       //判断是否支持promise和indexedDb,以及是否初始化表格成功
    	//由于只跟地图缓存有关，可以集中在前边判断
    	if(HGIS.Strategy.Parameters.isCache && HGIS.Strategy.Parameters.isConnected){
    		this.loadTile_promise(x, y, z, bounds,i);
    	}else{
    		this.loadTile_origin(x, y, z, bounds,i);
    	}
    },
    
    //原始的加载方式
    //几乎是同时发起的所有请求
    loadTile_origin: function(x, y, z, bounds,i) {//走的这个 一般一屏42个请求,这个方法会执行42次
        var url = HGIS.String.format(this.layer.protocol.url, {x: x, y:y, z:z});
        //this.layer.renderer.nowTile=i; //renderer中nowTile已删除
        this.response = this.layer.protocol.read({
            url: url,
            filter: this.layer.filter,
            callback: this.readDone,
            scope: {scope: this, options: {x:x, y:y, z:z, bounds:bounds},totalTileCount:this.totalTileCount}
        });
    },
    readDone: function(resp) {
        this.scope.merge(resp, this.options);
    },

    /* Method: merge
     * Given a list of features, determine which ones to add to the layer.
     *     If the layer projection differs from the map projection, features
     *     will be transformed from the layer projection to the map projection.
     *
     * Parameters:
     * resp - {<HGIS.Protocol.Response>} The response object passed
     *      by the protocol.
     */
    merge: function(resp, options) {     
    	this.progress+=1;
    	/*
    	if(resp.features==null){
    		this.layer.renderer.count404+=1;
    		//this.layer.renderer.redraw();2018年4月23日16:57:40
    	}*/
        if (options.z != this.zoom) return; //Zoom has changed while read was active
        var bounds = options.bounds;
        var features = resp.features;
        if(features!=null && features.length > 0) {
        	 //计算DXY  每一张瓦片中的所有要素的dxy是相同的
        	var resolution=this.layer.map.resolution;
        	var extent=this.layer.map.getExtent();
            var originSplit = this.caculateOrigin(features[0].origin,resolution);
            var dxy = this.calculateDXY(originSplit, extent,resolution);
            var remote = this.layer.projection;
            var local = this.layer.map.getProjectionObject();
            var update = !local.equals(remote);
            for(var i=0, len=features.length; i<len; ++i) {
            	var geom = features[i].geometry;
            	features[i].oldGeometry=[];//features[i].oldGeometry=features[i].geometry;不能简单的使用引用进行拷贝，必须深拷贝
            	for(var k=0;k<features[i].geometry.length;k++){//深拷贝  后面重计算DXY的时候要用到最原始的geometry而不是针对当前范围加工过后的
            		features[i].oldGeometry[k]=features[i].geometry[k];
            	}           	
            	//features[i].subType=parseInt(String(features[i].id).substr(0,3));//第11 12 13个表示类型  后来江金伟把前面的featureid去掉了,也不需要排序了
            	if(features[i].type==1){//点  将geometry[0]+dxy.x,geometry[1]+xy
            		geom[0]+=dxy.x;
            		geom[1]+=dxy.y;
            	}else if(features[i].type==2){//线   
        	        for (var j = 0,geomLen = geom.length; j < geomLen; j = j + 2) {
        	            if(geom[j]=="|"){        	            	
        	            	continue;       	            	 
        	            }
        	            geom[j] +=dxy.x;
        	            geom[j + 1] +=dxy.y;        	                        
        	        }
        	        //处理道路线的名称的坐标        	           
    	            if(features[i].attributes['superType']=="ROAD"&&features[i].attributes["textCoords"]!==""){  	            	 
    	            	//保存原有的文字坐标
        	            features[i].attributes["oldTextCoords"] = features[i].attributes["textCoords"];
        	            
        	            var textCoordArr=[];    	         
	            		var coordsArr = features[i].attributes["textCoords"].split(',');                	            
        	            for(var l=0,ll=coordsArr.length;l<ll;l++){
        	            	var charArr=coordsArr[l].split(" ");        	            	 
        	            	textCoordArr.push([parseInt(charArr[0])+dxy.x,parseInt(charArr[1])+dxy.y,charArr[2]]);            	            	 
        	            }    	            	            	           
        	            features[i].attributes["textCoords"] = textCoordArr;      	         
    	            }        	
            	}else if(features[i].type==3){//面           	      
        	        for(var j=0,geomLen=geom.length; j<geomLen; j=j+2){
        	            if(geom[j]=='|'){            	                
        	                //i=i+2;
        	                continue;
        	            }
        	            geom[j] +=dxy.x;
        	            geom[j+1] +=dxy.y;
        	        }        
            	}              
                //features[i].usage_count = 1;
                if (geom) {
                    if (update) geom.transform(remote, local);
                    this.allFeatures.push(features[i]);
                }
            }
            this.tiles[[options.x, options.y]] = true;
        }
        if(this.progress==this.totalTileCount){//如果全部瓦片处理完成,开始全部add 等待刘淑民完成 2018年4月24日14:07:57
       // 	console.log("全部feature处理完成,记录数:"+this.allFeatures.length);
//        	this.allFeatures=this.allFeatures.sort(function(a,b){
//        		 return a.subType - b.subType;
//        	});
        	this.layer.addFeatures(this.allFeatures);
        	//this.layer.addFeatures(filtered,position);
        }
        this.response = null;
    },
    /**
     * 根据行列号计算切片原点坐标
     * @param rowcol 行列号
     * @returns {number[]} 含有x和y值的坐标数组
     */
    caculateOrigin: function(rowcol,resolution){
        var origin = [0,0];
        var b = rowcol.split("-");
        origin[0] = HGIS.InitParam.tileOrigin.lon + (b[1])*256*resolution;
        origin[1] = HGIS.InitParam.tileOrigin.lat - (b[0])*256*resolution;
        return origin;
    },
    /**
     * 根据原点坐标和地图范围计算xy的偏移值
     * @param origin
     * @param extent
     * @returns {{x: number, y: number}}
     */
	calculateDXY: function(origin,extent,resolution){ 
		var x = (origin[0]-extent.left)/resolution;
		x = Math.round(x);
        var y = (extent.top- origin[1]) /resolution;
		y = Math.round(y);
		return {"x":x,"y":y};
	},
    CLASS_NAME: "HGIS.Strategy.Grid"
});

/* ======================================================================
    HGIS/Protocol/SOS.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Protocol.js
 */

/**
 * Function: HGIS.Protocol.SOS
 * Used to create a versioned SOS protocol.  Default version is 1.0.0.
 *
 * Returns:
 * {<HGIS.Protocol>} An SOS protocol for the given version.
 */
HGIS.Protocol.SOS = function(options) {
    options = HGIS.Util.applyDefaults(
        options, HGIS.Protocol.SOS.DEFAULTS
    );
    var cls = HGIS.Protocol.SOS["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported SOS version: " + options.version;
    }
    return new cls(options);
};

/**
 * Constant: HGIS.Protocol.SOS.DEFAULTS
 */
HGIS.Protocol.SOS.DEFAULTS = {
    "version": "1.0.0"
};
/* ======================================================================
    HGIS/Format/WFSDescribeFeatureType.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/OGCExceptionReport.js
 */
 
/**
 * Class: HGIS.Format.WFSDescribeFeatureType
 * Read WFS DescribeFeatureType response
 * 
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.WFSDescribeFeatureType = HGIS.Class(
    HGIS.Format.XML, {

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g)
    },
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        xsd: "http://www.w3.org/2001/XMLSchema"
    },
    
    /**
     * Constructor: HGIS.Format.WFSDescribeFeatureType
     * Create a new parser for WFS DescribeFeatureType responses.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "xsd": {
            "schema": function(node, obj) {
                var complexTypes = [];
                var customTypes = {};
                var schema = {
                    complexTypes: complexTypes,
                    customTypes: customTypes
                };
                var i, len;
                
                this.readChildNodes(node, schema);

                var attributes = node.attributes;
                var attr, name;
                for(i=0, len=attributes.length; i<len; ++i) {
                    attr = attributes[i];
                    name = attr.name;
                    if(name.indexOf("xmlns") === 0) {
                        this.setNamespace(name.split(":")[1] || "", attr.value);
                    } else {
                        obj[name] = attr.value;
                    }
                }
                obj.featureTypes = complexTypes;                
                obj.targetPrefix = this.namespaceAlias[obj.targetNamespace];
                
                // map complexTypes to names of customTypes
                var complexType, customType;
                for(i=0, len=complexTypes.length; i<len; ++i) {
                    complexType = complexTypes[i];
                    customType = customTypes[complexType.typeName];
                    if(customTypes[complexType.typeName]) {
                        complexType.typeName = customType.name;
                    }
                }
            },
            "complexType": function(node, obj) {
                var complexType = {
                    // this is a temporary typeName, it will be overwritten by
                    // the schema reader with the metadata found in the
                    // customTypes hash
                    "typeName": node.getAttribute("name")
                };
                this.readChildNodes(node, complexType);
                obj.complexTypes.push(complexType);
            },
            "complexContent": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "extension": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "sequence": function(node, obj) {
                var sequence = {
                    elements: []
                };
                this.readChildNodes(node, sequence);
                obj.properties = sequence.elements;
            },
            "element": function(node, obj) {
                var type;
                if(obj.elements) {
                    var element = {};
                    var attributes = node.attributes;
                    var attr;
                    for(var i=0, len=attributes.length; i<len; ++i) {
                        attr = attributes[i];
                        element[attr.name] = attr.value;
                    }
                    
                    type = element.type;
                    if(!type) {
                        type = {};
                        this.readChildNodes(node, type);
                        element.restriction = type;
                        element.type = type.base;
                    }
                    var fullType = type.base || type;
                    element.localType = fullType.split(":").pop();
                    obj.elements.push(element);
                    this.readChildNodes(node, element);
                }
                
                if(obj.complexTypes) {
                    type = node.getAttribute("type");
                    var localType = type.split(":").pop();
                    obj.customTypes[localType] = {
                        "name": node.getAttribute("name"),
                        "type": type
                    };
                }
            },
            "annotation": function(node, obj) {
                obj.annotation = {};
                this.readChildNodes(node, obj.annotation);
            },
            "appinfo": function(node, obj) {
                if (!obj.appinfo) {
                    obj.appinfo = [];
                }
                obj.appinfo.push(this.getChildValue(node));
            },
            "documentation": function(node, obj) {
                if (!obj.documentation) {
                    obj.documentation = [];
                }
                var value = this.getChildValue(node);
                obj.documentation.push({
                    lang: node.getAttribute("xml:lang"),
                    textContent: value.replace(this.regExes.trimSpace, "")
                });
            },
            "simpleType": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "restriction": function(node, obj) {
                obj.base = node.getAttribute("base");
                this.readRestriction(node, obj);
            }
        }
    },
    
    /**
     * Method: readRestriction
     * Reads restriction defined in the child nodes of a restriction element
     * 
     * Parameters:
     * node - {DOMElement} the node to parse
     * obj - {Object} the object that receives the read result
     */
    readRestriction: function(node, obj) {
        var children = node.childNodes;
        var child, nodeName, value;
        for(var i=0, len=children.length; i<len; ++i) {
            child = children[i];
            if(child.nodeType == 1) {
                nodeName = child.nodeName.split(":").pop();
                value = child.getAttribute("value");
                if(!obj[nodeName]) {
                    obj[nodeName] = value;
                } else {
                    if(typeof obj[nodeName] == "string") {
                        obj[nodeName] = [obj[nodeName]];
                    }
                    obj[nodeName].push(value);
                }
            }
        }
    },
    
    /**
     * Method: read
     *
     * Parameters:
     * data - {DOMElement|String} A WFS DescribeFeatureType document.
     *
     * Returns:
     * {Object} An object representing the WFS DescribeFeatureType response.
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var schema = {};
        if (data.nodeName.split(":").pop() === 'ExceptionReport') {
            // an exception must have occurred, so parse it
            var parser = new HGIS.Format.OGCExceptionReport();
            schema.error = parser.read(data);
        } else {
            this.readNode(data, schema);
        }
        return schema;
    },
    
    CLASS_NAME: "HGIS.Format.WFSDescribeFeatureType" 

});
/* ======================================================================
    HGIS/Format/GeoRSS.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Geometry/Point.js
 * @requires HGIS/Geometry/LineString.js
 * @requires HGIS/Geometry/Polygon.js
 */

/**
 * Class: HGIS.Format.GeoRSS
 * Read/write GeoRSS parser. Create a new instance with the 
 *     <HGIS.Format.GeoRSS> constructor.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.GeoRSS = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * APIProperty: rssns
     * {String} RSS namespace to use. Defaults to
     *   "http://backend.userland.com/rss2"
     */
    rssns: "http://backend.userland.com/rss2",
    
    /**
     * APIProperty: featurens
     * {String} Feature Attributes namespace.  Defaults to
     *    "http://mapserver.gis.umn.edu/mapserver"
     */
    featureNS: "http://mapserver.gis.umn.edu/mapserver",
    
    /**
     * APIProperty: georssns
     * {String} GeoRSS namespace to use.  Defaults to
     *     "http://www.georss.org/georss"
     */
    georssns: "http://www.georss.org/georss",

    /**
     * APIProperty: geons
     * {String} W3C Geo namespace to use.  Defaults to
     *     "http://www.w3.org/2003/01/geo/wgs84_pos#"
     */
    geons: "http://www.w3.org/2003/01/geo/wgs84_pos#",
    
    /**
     * APIProperty: featureTitle
     * {String} Default title for features.  Defaults to "Untitled"
     */
    featureTitle: "Untitled",
    
    /**
     * APIProperty: featureDescription
     * {String} Default description for features.  Defaults to "No Description"
     */
    featureDescription: "No Description",
    
    /**
     * Property: gmlParse
     * {Object} GML Format object for parsing features
     * Non-API and only created if necessary
     */
    gmlParser: null,

    /**
     * APIProperty: xy
     * {Boolean} Order of the GML coordinate: true:(x,y) or false:(y,x)
     * For GeoRSS the default is (y,x), therefore: false
     */ 
    xy: false,
    
    /**
     * Constructor: HGIS.Format.GeoRSS
     * Create a new parser for GeoRSS.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    
    /**
     * Method: createGeometryFromItem
     * Return a geometry from a GeoRSS Item.
     *
     * Parameters:
     * item - {DOMElement} A GeoRSS item node.
     *
     * Returns:
     * {<HGIS.Geometry>} A geometry representing the node.
     */
    createGeometryFromItem: function(item) {
        var point = this.getElementsByTagNameNS(item, this.georssns, "point");
        var lat = this.getElementsByTagNameNS(item, this.geons, 'lat');
        var lon = this.getElementsByTagNameNS(item, this.geons, 'long');
        
        var line = this.getElementsByTagNameNS(item,
                                                this.georssns,
                                                "line");
        var polygon = this.getElementsByTagNameNS(item,
                                                this.georssns,
                                                "polygon");
        var where = this.getElementsByTagNameNS(item, 
                                                this.georssns, 
                                                "where");
        var box = this.getElementsByTagNameNS(item, 
                                              this.georssns, 
                                              "box");

        if (point.length > 0 || (lat.length > 0 && lon.length > 0)) {
            var location;
            if (point.length > 0) {
                location = HGIS.String.trim(
                                point[0].firstChild.nodeValue).split(/\s+/);
                if (location.length !=2) {
                    location = HGIS.String.trim(
                                point[0].firstChild.nodeValue).split(/\s*,\s*/);
                }
            } else {
                location = [parseFloat(lat[0].firstChild.nodeValue),
                                parseFloat(lon[0].firstChild.nodeValue)];
            }    

            var geometry = new HGIS.Geometry.Point(location[1], location[0]);
              
        } else if (line.length > 0) {
            var coords = HGIS.String.trim(this.getChildValue(line[0])).split(/\s+/);
            var components = []; 
            var point;
            for (var i=0, len=coords.length; i<len; i+=2) {
                point = new HGIS.Geometry.Point(coords[i+1], coords[i]);
                components.push(point);
            }
            geometry = new HGIS.Geometry.LineString(components);
        } else if (polygon.length > 0) { 
            var coords = HGIS.String.trim(this.getChildValue(polygon[0])).split(/\s+/);
            var components = []; 
            var point;
            for (var i=0, len=coords.length; i<len; i+=2) {
                point = new HGIS.Geometry.Point(coords[i+1], coords[i]);
                components.push(point);
            }
            geometry = new HGIS.Geometry.Polygon([new HGIS.Geometry.LinearRing(components)]);
        } else if (where.length > 0) { 
            if (!this.gmlParser) {
              this.gmlParser = new HGIS.Format.GML({'xy': this.xy});
            }
            var feature = this.gmlParser.parseFeature(where[0]);
            geometry = feature.geometry;
        } else if (box.length  > 0) {
            var coords = HGIS.String.trim(box[0].firstChild.nodeValue).split(/\s+/);
            var components = [];
            var point;
            if (coords.length > 3) {
                point = new HGIS.Geometry.Point(coords[1], coords[0]);
                components.push(point);
                point = new HGIS.Geometry.Point(coords[1], coords[2]);
                components.push(point);
                point = new HGIS.Geometry.Point(coords[3], coords[2]);
                components.push(point);
                point = new HGIS.Geometry.Point(coords[3], coords[0]);
                components.push(point);
                point = new HGIS.Geometry.Point(coords[1], coords[0]);
                components.push(point);
            }
            geometry = new HGIS.Geometry.Polygon([new HGIS.Geometry.LinearRing(components)]);
        }
        
        if (geometry && this.internalProjection && this.externalProjection) {
            geometry.transform(this.externalProjection, 
                               this.internalProjection);
        }

        return geometry;
    },        

    /**
     * Method: createFeatureFromItem
     * Return a feature from a GeoRSS Item.
     *
     * Parameters:
     * item - {DOMElement} A GeoRSS item node.
     *
     * Returns:
     * {<HGIS.Feature.Vector>} A feature representing the item.
     */
    createFeatureFromItem: function(item) {
        var geometry = this.createGeometryFromItem(item);
     
        /* Provide defaults for title and description */
        var title = this._getChildValue(item, "*", "title", this.featureTitle);
       
        /* First try RSS descriptions, then Atom summaries */
        var description = this._getChildValue(
            item, "*", "description",
            this._getChildValue(item, "*", "content",
                this._getChildValue(item, "*", "summary", this.featureDescription)));

        /* If no link URL is found in the first child node, try the
           href attribute */
        var link = this._getChildValue(item, "*", "link");
        if(!link) {
            try {
                link = this.getElementsByTagNameNS(item, "*", "link")[0].getAttribute("href");
            } catch(e) {
                link = null;
            }
        }

        var id = this._getChildValue(item, "*", "id", null);
        
        var data = {
            "title": title,
            "description": description,
            "link": link
        };
        var feature = new HGIS.Feature.Vector(geometry, data);
        feature.fid = id;
        return feature;
    },        
    
    /**
     * Method: _getChildValue
     *
     * Parameters:
     * node - {DOMElement}
     * nsuri - {String} Child node namespace uri ("*" for any).
     * name - {String} Child node name.
     * def - {String} Optional string default to return if no child found.
     *
     * Returns:
     * {String} The value of the first child with the given tag name.  Returns
     *     default value or empty string if none found.
     */
    _getChildValue: function(node, nsuri, name, def) {
        var value;
        var eles = this.getElementsByTagNameNS(node, nsuri, name);
        if(eles && eles[0] && eles[0].firstChild
            && eles[0].firstChild.nodeValue) {
            value = this.getChildValue(eles[0]);
        } else {
            value = (def == undefined) ? "" : def;
        }
        return value;
    },
    
    /**
     * APIMethod: read
     * Return a list of features from a GeoRSS doc
     *
     * Parameters:
     * doc - {Element} 
     *
     * Returns:
     * {Array(<HGIS.Feature.Vector>)}
     */
    read: function(doc) {
        if (typeof doc == "string") { 
            doc = HGIS.Format.XML.prototype.read.apply(this, [doc]);
        }

        /* Try RSS items first, then Atom entries */
        var itemlist = null;
        itemlist = this.getElementsByTagNameNS(doc, '*', 'item');
        if (itemlist.length == 0) {
            itemlist = this.getElementsByTagNameNS(doc, '*', 'entry');
        }
        
        var numItems = itemlist.length;
        var features = new Array(numItems);
        for(var i=0; i<numItems; i++) {
            features[i] = this.createFeatureFromItem(itemlist[i]);
        }
        return features;
    },
    

    /**
     * APIMethod: write
     * Accept Feature Collection, and return a string. 
     * 
     * Parameters: 
     * features - {Array(<HGIS.Feature.Vector>)} List of features to serialize into a string.
     */
    write: function(features) {
        var georss;
        if(HGIS.Util.isArray(features)) {
            georss = this.createElementNS(this.rssns, "rss");
            for(var i=0, len=features.length; i<len; i++) {
                georss.appendChild(this.createFeatureXML(features[i]));
            }
        } else {
            georss = this.createFeatureXML(features);
        }
        return HGIS.Format.XML.prototype.write.apply(this, [georss]);
    },

    /**
     * Method: createFeatureXML
     * Accept an <HGIS.Feature.Vector>, and build a geometry for it.
     * 
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} 
     *
     * Returns:
     * {DOMElement}
     */
    createFeatureXML: function(feature) {
        var geometryNode = this.buildGeometryNode(feature.geometry);
        var featureNode = this.createElementNS(this.rssns, "item");
        var titleNode = this.createElementNS(this.rssns, "title");
        titleNode.appendChild(this.createTextNode(feature.attributes.title ? feature.attributes.title : ""));
        var descNode = this.createElementNS(this.rssns, "description");
        descNode.appendChild(this.createTextNode(feature.attributes.description ? feature.attributes.description : ""));
        featureNode.appendChild(titleNode);
        featureNode.appendChild(descNode);
        if (feature.attributes.link) {
            var linkNode = this.createElementNS(this.rssns, "link");
            linkNode.appendChild(this.createTextNode(feature.attributes.link));
            featureNode.appendChild(linkNode);
        }    
        for(var attr in feature.attributes) {
            if (attr == "link" || attr == "title" || attr == "description") { continue; } 
            var attrText = this.createTextNode(feature.attributes[attr]); 
            var nodename = attr;
            if (attr.search(":") != -1) {
                nodename = attr.split(":")[1];
            }    
            var attrContainer = this.createElementNS(this.featureNS, "feature:"+nodename);
            attrContainer.appendChild(attrText);
            featureNode.appendChild(attrContainer);
        }    
        featureNode.appendChild(geometryNode);
        return featureNode;
    },    
    
    /** 
     * Method: buildGeometryNode
     * builds a GeoRSS node with a given geometry
     * 
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     *
     * Returns:
     * {DOMElement} A gml node.
     */
    buildGeometryNode: function(geometry) {
        if (this.internalProjection && this.externalProjection) {
            geometry = geometry.clone();
            geometry.transform(this.internalProjection, 
                               this.externalProjection);
        }
        var node;
        // match Polygon
        if (geometry.CLASS_NAME == "HGIS.Geometry.Polygon") {
            node = this.createElementNS(this.georssns, 'georss:polygon');
            
            node.appendChild(this.buildCoordinatesNode(geometry.components[0]));
        }
        // match LineString
        else if (geometry.CLASS_NAME == "HGIS.Geometry.LineString") {
            node = this.createElementNS(this.georssns, 'georss:line');
            
            node.appendChild(this.buildCoordinatesNode(geometry));
        }
        // match Point
        else if (geometry.CLASS_NAME == "HGIS.Geometry.Point") {
            node = this.createElementNS(this.georssns, 'georss:point');
            node.appendChild(this.buildCoordinatesNode(geometry));
        } else {
            throw "Couldn't parse " + geometry.CLASS_NAME;
        }  
        return node;         
    },
    
    /** 
     * Method: buildCoordinatesNode
     * 
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     */
    buildCoordinatesNode: function(geometry) {
        var points = null;
        
        if (geometry.components) {
            points = geometry.components;
        }

        var path;
        if (points) {
            var numPoints = points.length;
            var parts = new Array(numPoints);
            for (var i = 0; i < numPoints; i++) {
                parts[i] = points[i].y + " " + points[i].x;
            }
            path = parts.join(" ");
        } else {
            path = geometry.y + " " + geometry.x;
        }
        return this.createTextNode(path);
    },

    CLASS_NAME: "HGIS.Format.GeoRSS" 
});     
/* ======================================================================
    HGIS/Format/WPSCapabilities.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML/VersionedOGC.js
 */
 
/**
 * Class: HGIS.Format.WPSCapabilities
 * Read WPS Capabilities.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML.VersionedOGC>
 */
HGIS.Format.WPSCapabilities = HGIS.Class(HGIS.Format.XML.VersionedOGC, {
    
    /**
     * APIProperty: defaultVersion
     * {String} Version number to assume if none found.  Default is "1.0.0".
     */
    defaultVersion: "1.0.0",
    
    /**
     * Constructor: HGIS.Format.WPSCapabilities
     * Create a new parser for WPS Capabilities.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return information about
     * the service.
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Info about the WPS
     */
    
    CLASS_NAME: "HGIS.Format.WPSCapabilities" 

});
/* ======================================================================
    HGIS/Format/WPSCapabilities/v1_0_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WPSCapabilities.js
 * @requires HGIS/Format/OWSCommon/v1_1_0.js
 */

/**
 * Class: HGIS.Format.WPSCapabilities.v1_0_0
 * Read WPS Capabilities version 1.0.0.
 * 
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.WPSCapabilities.v1_0_0 = HGIS.Class(
    HGIS.Format.XML, {

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wps: "http://www.opengis.net/wps/1.0.0",
        xlink: "http://www.w3.org/1999/xlink"
    },

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },
    
    /**
     * Constructor: HGIS.Format.WPSCapabilities.v1_0_0
     * Create a new parser for WPS capabilities version 1.0.0. 
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return info about the WPS.
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Information about the WPS service.
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        return capabilities;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wps": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "ProcessOfferings": function(node, obj) {
                obj.processOfferings = {};
                this.readChildNodes(node, obj.processOfferings);
            },
            "Process": function(node, processOfferings) {
                var processVersion = this.getAttributeNS(node, this.namespaces.wps, "processVersion");
                var process = {processVersion: processVersion};
                this.readChildNodes(node, process);
                processOfferings[process.identifier] = process;
            },
            "Languages": function(node, obj) {
                obj.languages = [];
                this.readChildNodes(node, obj.languages);
            },
            "Default": function(node, languages) {
                var language = {isDefault: true};
                this.readChildNodes(node, language);
                languages.push(language);
            },
            "Supported": function(node, languages) {
                var language = {};
                this.readChildNodes(node, language);     
                languages.push(language);
            }
        },
        "ows": HGIS.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "HGIS.Format.WPSCapabilities.v1_0_0" 

});
/* ======================================================================
    HGIS/Control/PinchZoom.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Handler/Pinch.js
 */

/**
 * Class: HGIS.Control.PinchZoom
 *
 * Inherits:
 *  - <HGIS.Control>
 */
HGIS.Control.PinchZoom = HGIS.Class(HGIS.Control, {

    /** 
     * Property: type
     * {HGIS.Control.TYPES}
     */
    type: HGIS.Control.TYPE_TOOL,

    /**
     * Property: pinchOrigin
     * {Object} Cached object representing the pinch start (in pixels).
     */
    pinchOrigin: null,    
    
    /**
     * Property: currentCenter
     * {Object} Cached object representing the latest pinch center (in pixels).
     */
    currentCenter: null,    

    /**
     * APIProperty: autoActivate
     * {Boolean} Activate the control when it is added to a map.  Default is
     *     true.
     */
    autoActivate: true,

    /**
     * APIProperty: preserveCenter
     * {Boolean} Set this to true if you don't want the map center to change
     *     while pinching. For example you may want to set preserveCenter to
     *     true when the user location is being watched and you want to preserve
     *     the user location at the center of the map even if he zooms in or
     *     out using pinch. This property's value can be changed any time on an
     *     existing instance. Default is false.
     */
    preserveCenter: false,
    
    /**
     * APIProperty: handlerOptions
     * {Object} Used to set non-default properties on the pinch handler
     */

    /**
     * Constructor: HGIS.Control.PinchZoom
     * Create a control for zooming with pinch gestures.  This works on devices
     *     with multi-touch support.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *                    the control
     */
    initialize: function(options) {
        HGIS.Control.prototype.initialize.apply(this, arguments);
        this.handler = new HGIS.Handler.Pinch(this, {
            start: this.pinchStart,
            move: this.pinchMove,
            done: this.pinchDone
        }, this.handlerOptions);
    },
    
    /**
     * Method: pinchStart
     *
     * Parameters:
     * evt - {Event}
     * pinchData - {Object} pinch data object related to the current touchmove
     *     of the pinch gesture. This give us the current scale of the pinch.
     */
    pinchStart: function(evt, pinchData) {
        var xy = (this.preserveCenter) ?
            this.map.getPixelFromLonLat(this.map.getCenter()) : evt.xy;
        this.pinchOrigin = xy;
        this.currentCenter = xy;
    },
    
    /**
     * Method: pinchMove
     *
     * Parameters:
     * evt - {Event}
     * pinchData - {Object} pinch data object related to the current touchmove
     *     of the pinch gesture. This give us the current scale of the pinch.
     */
    pinchMove: function(evt, pinchData) {
        var scale = pinchData.scale;
        var containerOrigin = this.map.layerContainerOriginPx;
        var pinchOrigin = this.pinchOrigin;
        var current = (this.preserveCenter) ?
            this.map.getPixelFromLonLat(this.map.getCenter()) : evt.xy;

        var dx = Math.round((containerOrigin.x + current.x - pinchOrigin.x) + (scale - 1) * (containerOrigin.x - pinchOrigin.x));
        var dy = Math.round((containerOrigin.y + current.y - pinchOrigin.y) + (scale - 1) * (containerOrigin.y - pinchOrigin.y));

        this.map.applyTransform(dx, dy, scale);
        this.currentCenter = current;
    },

    /**
     * Method: pinchDone
     *
     * Parameters:
     * evt - {Event}
     * start - {Object} pinch data object related to the touchstart event that
     *     started the pinch gesture.
     * last - {Object} pinch data object related to the last touchmove event
     *     of the pinch gesture. This give us the final scale of the pinch.
     */
    pinchDone: function(evt, start, last) {
        this.map.applyTransform();
        var zoom = this.map.getZoomForResolution(this.map.getResolution() / last.scale, true);
        if (zoom !== this.map.getZoom() || !this.currentCenter.equals(this.pinchOrigin)) {
            var resolution = this.map.getResolutionForZoom(zoom);

            var location = this.map.getLonLatFromPixel(this.pinchOrigin);
            var zoomPixel = this.currentCenter;        
            var size = this.map.getSize();

            location.lon += resolution * ((size.w / 2) - zoomPixel.x);
            location.lat -= resolution * ((size.h / 2) - zoomPixel.y);

            // Force a reflow before calling setCenter. This is to work
            // around an issue occuring in iOS.
            //
            // See https://github.com/HGIS/HGIS/pull/351.
            //
            // Without a reflow setting the layer container div's top left
            // style properties to "0px" - as done in Map.moveTo when zoom
            // is changed - won't actually correctly reposition the layer
            // container div.
            //
            // Also, we need to use a statement that the Google Closure
            // compiler won't optimize away.
            this.map.div.clientWidth = this.map.div.clientWidth;

            this.map.setCenter(location, zoom);
        }
    },

    CLASS_NAME: "HGIS.Control.PinchZoom"

});
/* ======================================================================
    HGIS/Control/TouchNavigation.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control/DragPan.js
 * @requires HGIS/Control/PinchZoom.js
 * @requires HGIS/Handler/Click.js
 */

/**
 * Class: HGIS.Control.TouchNavigation
 * The navigation control handles map browsing with touch events (dragging,
 *     double-tapping, tap with two fingers, and pinch zoom).  Create a new 
 *     control with the <HGIS.Control.TouchNavigation> constructor.
 *
 * If you’re only targeting touch enabled devices with your mapping application,
 *     you can create a map with only a TouchNavigation control. The 
 *     <HGIS.Control.Navigation> control is mobile ready by default, but 
 *     you can generate a smaller build of the library by only including this
 *     touch navigation control if you aren't concerned about mouse interaction.
 *
 * Inherits:
 *  - <HGIS.Control>
 */
HGIS.Control.TouchNavigation = HGIS.Class(HGIS.Control, {

    /**
     * Property: dragPan
     * {<HGIS.Control.DragPan>}
     */
    dragPan: null,

    /**
     * APIProperty: dragPanOptions
     * {Object} Options passed to the DragPan control.
     */
    dragPanOptions: null,

    /**
     * Property: pinchZoom
     * {<HGIS.Control.PinchZoom>}
     */
    pinchZoom: null,

    /**
     * APIProperty: pinchZoomOptions
     * {Object} Options passed to the PinchZoom control.
     */
    pinchZoomOptions: null,

    /**
     * APIProperty: clickHandlerOptions
     * {Object} Options passed to the Click handler.
     */
    clickHandlerOptions: null,

    /**
     * APIProperty: documentDrag
     * {Boolean} Allow panning of the map by dragging outside map viewport.
     *     Default is false.
     */
    documentDrag: false,

    /**
     * APIProperty: autoActivate
     * {Boolean} Activate the control when it is added to a map.  Default is
     *     true.
     */
    autoActivate: true,

    /**
     * Constructor: HGIS.Control.TouchNavigation
     * Create a new navigation control
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *                    the control
     */
    initialize: function(options) {
        this.handlers = {};
        HGIS.Control.prototype.initialize.apply(this, arguments);
    },

    /**
     * Method: destroy
     * The destroy method is used to perform any clean up before the control
     * is dereferenced.  Typically this is where event listeners are removed
     * to prevent memory leaks.
     */
    destroy: function() {
        this.deactivate();
        if(this.dragPan) {
            this.dragPan.destroy();
        }
        this.dragPan = null;
        if (this.pinchZoom) {
            this.pinchZoom.destroy();
            delete this.pinchZoom;
        }
        HGIS.Control.prototype.destroy.apply(this,arguments);
    },

    /**
     * Method: activate
     */
    activate: function() {
        if(HGIS.Control.prototype.activate.apply(this,arguments)) {
            this.dragPan.activate();
            this.handlers.click.activate();
            this.pinchZoom.activate();
            return true;
        }
        return false;
    },

    /**
     * Method: deactivate
     */
    deactivate: function() {
        if(HGIS.Control.prototype.deactivate.apply(this,arguments)) {
            this.dragPan.deactivate();
            this.handlers.click.deactivate();
            this.pinchZoom.deactivate();
            return true;
        }
        return false;
    },
    
    /**
     * Method: draw
     */
    draw: function() {
        var clickCallbacks = {
            click: this.defaultClick,
            dblclick: this.defaultDblClick
        };
        var clickOptions = HGIS.Util.extend({
            "double": true,
            stopDouble: true,
            pixelTolerance: 2
        }, this.clickHandlerOptions);
        this.handlers.click = new HGIS.Handler.Click(
            this, clickCallbacks, clickOptions
        );
        this.dragPan = new HGIS.Control.DragPan(
            HGIS.Util.extend({
                map: this.map,
                documentDrag: this.documentDrag
            }, this.dragPanOptions)
        );
        this.dragPan.draw();
        this.pinchZoom = new HGIS.Control.PinchZoom(
            HGIS.Util.extend({map: this.map}, this.pinchZoomOptions)
        );
    },

    /**
     * Method: defaultClick
     *
     * Parameters:
     * evt - {Event}
     */
    defaultClick: function (evt) {
        if(evt.lastTouches && evt.lastTouches.length == 2) {
            this.map.zoomOut();
        }
    },

    /**
     * Method: defaultDblClick
     *
     * Parameters:
     * evt - {Event}
     */
    defaultDblClick: function (evt) {
        this.map.zoomTo(this.map.zoom + 1, evt.xy);
    },

    CLASS_NAME: "HGIS.Control.TouchNavigation"
});
/* ======================================================================
    Rico/Color.js
   ====================================================================== */

/** 
 * @requires Rico/license.js
 * @requires HGIS/Console.js
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/BaseTypes/Element.js
 */


/*
 * This file has been edited substantially from the Rico-released version by
 * the HGIS development team.
 */

HGIS.Console.warn("HGIS.Rico is deprecated");

HGIS.Rico = HGIS.Rico || {};
HGIS.Rico.Color = HGIS.Class({

   initialize: function(red, green, blue) {
      this.rgb = { r: red, g : green, b : blue };
   },

   setRed: function(r) {
      this.rgb.r = r;
   },

   setGreen: function(g) {
      this.rgb.g = g;
   },

   setBlue: function(b) {
      this.rgb.b = b;
   },

   setHue: function(h) {

      // get an HSB model, and set the new hue...
      var hsb = this.asHSB();
      hsb.h = h;

      // convert back to RGB...
      this.rgb = HGIS.Rico.Color.HSBtoRGB(hsb.h, hsb.s, hsb.b);
   },

   setSaturation: function(s) {
      // get an HSB model, and set the new hue...
      var hsb = this.asHSB();
      hsb.s = s;

      // convert back to RGB and set values...
      this.rgb = HGIS.Rico.Color.HSBtoRGB(hsb.h, hsb.s, hsb.b);
   },

   setBrightness: function(b) {
      // get an HSB model, and set the new hue...
      var hsb = this.asHSB();
      hsb.b = b;

      // convert back to RGB and set values...
      this.rgb = HGIS.Rico.Color.HSBtoRGB( hsb.h, hsb.s, hsb.b );
   },

   darken: function(percent) {
      var hsb  = this.asHSB();
      this.rgb = HGIS.Rico.Color.HSBtoRGB(hsb.h, hsb.s, Math.max(hsb.b - percent,0));
   },

   brighten: function(percent) {
      var hsb  = this.asHSB();
      this.rgb = HGIS.Rico.Color.HSBtoRGB(hsb.h, hsb.s, Math.min(hsb.b + percent,1));
   },

   blend: function(other) {
      this.rgb.r = Math.floor((this.rgb.r + other.rgb.r)/2);
      this.rgb.g = Math.floor((this.rgb.g + other.rgb.g)/2);
      this.rgb.b = Math.floor((this.rgb.b + other.rgb.b)/2);
   },

   isBright: function() {
      var hsb = this.asHSB();
      return this.asHSB().b > 0.5;
   },

   isDark: function() {
      return ! this.isBright();
   },

   asRGB: function() {
      return "rgb(" + this.rgb.r + "," + this.rgb.g + "," + this.rgb.b + ")";
   },

   asHex: function() {
      return "#" + this.rgb.r.toColorPart() + this.rgb.g.toColorPart() + this.rgb.b.toColorPart();
   },

   asHSB: function() {
      return HGIS.Rico.Color.RGBtoHSB(this.rgb.r, this.rgb.g, this.rgb.b);
   },

   toString: function() {
      return this.asHex();
   }

});

HGIS.Rico.Color.createFromHex = function(hexCode) {
  if(hexCode.length==4) {
    var shortHexCode = hexCode; 
    var hexCode = '#';
    for(var i=1;i<4;i++) { 
        hexCode += (shortHexCode.charAt(i) + 
shortHexCode.charAt(i)); 
    }
  }
   if ( hexCode.indexOf('#') == 0 ) {
       hexCode = hexCode.substring(1);
   }
   var red   = hexCode.substring(0,2);
   var green = hexCode.substring(2,4);
   var blue  = hexCode.substring(4,6);
   return new HGIS.Rico.Color( parseInt(red,16), parseInt(green,16), parseInt(blue,16) );
};

/**
 * Factory method for creating a color from the background of
 * an HTML element.
 */
HGIS.Rico.Color.createColorFromBackground = function(elem) {

   var actualColor = 
      HGIS.Element.getStyle(HGIS.Util.getElement(elem), 
                                        "backgroundColor");

   if ( actualColor == "transparent" && elem.parentNode ) {
      return HGIS.Rico.Color.createColorFromBackground(elem.parentNode);
   }
   if ( actualColor == null ) {
      return new HGIS.Rico.Color(255,255,255);
   }
   if ( actualColor.indexOf("rgb(") == 0 ) {
      var colors = actualColor.substring(4, actualColor.length - 1 );
      var colorArray = colors.split(",");
      return new HGIS.Rico.Color( parseInt( colorArray[0] ),
                            parseInt( colorArray[1] ),
                            parseInt( colorArray[2] )  );

   }
   else if ( actualColor.indexOf("#") == 0 ) {
      return HGIS.Rico.Color.createFromHex(actualColor);
   }
   else {
      return new HGIS.Rico.Color(255,255,255);
   }
};

HGIS.Rico.Color.HSBtoRGB = function(hue, saturation, brightness) {

   var red   = 0;
    var green = 0;
    var blue  = 0;

   if (saturation == 0) {
      red = parseInt(brightness * 255.0 + 0.5);
       green = red;
       blue = red;
    }
    else {
      var h = (hue - Math.floor(hue)) * 6.0;
      var f = h - Math.floor(h);
      var p = brightness * (1.0 - saturation);
      var q = brightness * (1.0 - saturation * f);
      var t = brightness * (1.0 - (saturation * (1.0 - f)));

      switch (parseInt(h)) {
         case 0:
            red   = (brightness * 255.0 + 0.5);
            green = (t * 255.0 + 0.5);
            blue  = (p * 255.0 + 0.5);
            break;
         case 1:
            red   = (q * 255.0 + 0.5);
            green = (brightness * 255.0 + 0.5);
            blue  = (p * 255.0 + 0.5);
            break;
         case 2:
            red   = (p * 255.0 + 0.5);
            green = (brightness * 255.0 + 0.5);
            blue  = (t * 255.0 + 0.5);
            break;
         case 3:
            red   = (p * 255.0 + 0.5);
            green = (q * 255.0 + 0.5);
            blue  = (brightness * 255.0 + 0.5);
            break;
         case 4:
            red   = (t * 255.0 + 0.5);
            green = (p * 255.0 + 0.5);
            blue  = (brightness * 255.0 + 0.5);
            break;
          case 5:
            red   = (brightness * 255.0 + 0.5);
            green = (p * 255.0 + 0.5);
            blue  = (q * 255.0 + 0.5);
            break;
        }
    }

   return { r : parseInt(red), g : parseInt(green) , b : parseInt(blue) };
};

HGIS.Rico.Color.RGBtoHSB = function(r, g, b) {

   var hue;
   var saturation;
   var brightness;

   var cmax = (r > g) ? r : g;
   if (b > cmax) {
      cmax = b;
   }
   var cmin = (r < g) ? r : g;
   if (b < cmin) {
      cmin = b;
   }
   brightness = cmax / 255.0;
   if (cmax != 0) {
      saturation = (cmax - cmin)/cmax;
   } else {
      saturation = 0;
   }
   if (saturation == 0) {
      hue = 0;
   } else {
      var redc   = (cmax - r)/(cmax - cmin);
        var greenc = (cmax - g)/(cmax - cmin);
        var bluec  = (cmax - b)/(cmax - cmin);

        if (r == cmax) {
           hue = bluec - greenc;
        } else if (g == cmax) {
           hue = 2.0 + redc - bluec;
      } else {
           hue = 4.0 + greenc - redc;
      }
        hue = hue / 6.0;
        if (hue < 0) {
           hue = hue + 1.0;
        }
   }

   return { h : hue, s : saturation, b : brightness };
};

/* ======================================================================
    HGIS/Style2.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/BaseTypes/Class.js
 * @requires HGIS/Rule.js
 * @requires HGIS/Symbolizer/Point.js
 * @requires HGIS/Symbolizer/Line.js
 * @requires HGIS/Symbolizer/Polygon.js
 * @requires HGIS/Symbolizer/Text.js
 * @requires HGIS/Symbolizer/Raster.js
 */

/**
 * Class: HGIS.Style2
 * This class represents a collection of rules for rendering features.
 */
HGIS.Style2 = HGIS.Class({

    /**
     * Property: id
     * {String} A unique id for this session.
     */
    id: null,
    
    /**
     * APIProperty: name
     * {String} Style identifier.
     */
    name: null,
    
    /**
     * APIProperty: title
     * {String} Title of this style.
     */
    title: null,
    
    /**
     * APIProperty: description
     * {String} Description of this style.
     */
    description: null,

    /**
     * APIProperty: layerName
     * {<String>} Name of the layer that this style belongs to, usually
     *     according to the NamedLayer attribute of an SLD document.
     */
    layerName: null,
    
    /**
     * APIProperty: isDefault
     * {Boolean}
     */
    isDefault: false,
     
    /** 
     * APIProperty: rules 
     * {Array(<HGIS.Rule>)} Collection of rendering rules.
     */
    rules: null,
    
    /** 
     * Constructor: HGIS.Style2
     * Creates a style representing a collection of rendering rules.
     *
     * Parameters:
     * config - {Object} An object containing properties to be set on the 
     *     style.  Any documented properties may be set at construction.
     *
     * Returns:
     * {<HGIS.Style2>} A new style object.
     */
    initialize: function(config) {
        HGIS.Util.extend(this, config);
        this.id = HGIS.Util.createUniqueID(this.CLASS_NAME + "_");
    },

    /** 
     * APIMethod: destroy
     * nullify references to prevent circular references and memory leaks
     */
    destroy: function() {
        for (var i=0, len=this.rules.length; i<len; i++) {
            this.rules[i].destroy();
        }
        delete this.rules;
    },

    /**
     * APIMethod: clone
     * Clones this style.
     * 
     * Returns:
     * {<HGIS.Style2>} Clone of this style.
     */
    clone: function() {
        var config = HGIS.Util.extend({}, this);
        // clone rules
        if (this.rules) {
            config.rules = [];
            for (var i=0, len=this.rules.length; i<len; ++i) {
                config.rules.push(this.rules[i].clone());
            }
        }
        return new HGIS.Style2(config);
    },
    
    CLASS_NAME: "HGIS.Style2"
});
/* ======================================================================
    HGIS/Format/WFS.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/GML.js
 * @requires HGIS/Console.js
 * @requires HGIS/Lang.js
 */

/**
 * Class: HGIS.Format.WFS
 * Read/Write WFS. 
 *
 * Inherits from:
 *  - <HGIS.Format.GML>
 */
HGIS.Format.WFS = HGIS.Class(HGIS.Format.GML, {
    
    /** 
     * Property: layer
     * {<HGIS.Layer>}
     */
    layer: null,
    
    /**
     * APIProperty: wfsns
     * {String}
     */
    wfsns: "http://www.opengis.net/wfs",
    
    /**
     * Property: ogcns
     * {String}
     */
    ogcns: "http://www.opengis.net/ogc",
    
    /**
     * Constructor: HGIS.Format.WFS
     * Create a WFS-T formatter. This requires a layer: that layer should
     * have two properties: geometry_column and typename. The parser
     * for this format is subclassed entirely from GML: There is a writer 
     * only, which uses most of the code from the GML layer, and wraps
     * it in transactional elements.
     * 
     * Parameters: 
     * options - {Object} 
     * layer - {<HGIS.Layer>} 
     */
    initialize: function(options, layer) {
        HGIS.Format.GML.prototype.initialize.apply(this, [options]);
        this.layer = layer;
        if (this.layer.featureNS) {
            this.featureNS = this.layer.featureNS;
        }    
        if (this.layer.options.geometry_column) {
            this.geometryName = this.layer.options.geometry_column;
        }
        if (this.layer.options.typename) {
            this.featureName = this.layer.options.typename;
        }
    },
    
    /**
     * Method: write 
     * Takes a feature list, and generates a WFS-T Transaction 
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} 
     */
    write: function(features) {
    
        var transaction = this.createElementNS(this.wfsns, 'wfs:Transaction');
        transaction.setAttribute("version","1.0.0");
        transaction.setAttribute("service","WFS");
        for (var i=0; i < features.length; i++) {
            switch (features[i].state) {
                case HGIS.State.INSERT:
                    transaction.appendChild(this.insert(features[i]));
                    break;
                case HGIS.State.UPDATE:
                    transaction.appendChild(this.update(features[i]));
                    break;
                case HGIS.State.DELETE:
                    transaction.appendChild(this.remove(features[i]));
                    break;
            }
        }
        
        return HGIS.Format.XML.prototype.write.apply(this,[transaction]);
    },
   
    /**
     * Method: createFeatureXML
     *
     * Parameters: 
     * feature - {<HGIS.Feature.Vector>}
     */ 
    createFeatureXML: function(feature) {
        var geometryNode = this.buildGeometryNode(feature.geometry);
        var geomContainer = this.createElementNS(this.featureNS, "feature:" + this.geometryName);
        geomContainer.appendChild(geometryNode);
        var featureContainer = this.createElementNS(this.featureNS, "feature:" + this.featureName);
        featureContainer.appendChild(geomContainer);
        for(var attr in feature.attributes) {
            var attrText = this.createTextNode(feature.attributes[attr]); 
            var nodename = attr;
            if (attr.search(":") != -1) {
                nodename = attr.split(":")[1];
            }    
            var attrContainer = this.createElementNS(this.featureNS, "feature:" + nodename);
            attrContainer.appendChild(attrText);
            featureContainer.appendChild(attrContainer);
        }    
        return featureContainer;
    },
    
    /**
     * Method: insert 
     * Takes a feature, and generates a WFS-T Transaction "Insert" 
     *
     * Parameters: 
     * feature - {<HGIS.Feature.Vector>} 
     */
    insert: function(feature) {
        var insertNode = this.createElementNS(this.wfsns, 'wfs:Insert');
        insertNode.appendChild(this.createFeatureXML(feature));
        return insertNode;
    },
    
    /**
     * Method: update
     * Takes a feature, and generates a WFS-T Transaction "Update" 
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} 
     */
    update: function(feature) {
        if (!feature.fid) { HGIS.Console.userError(HGIS.i18n("noFID")); }
        var updateNode = this.createElementNS(this.wfsns, 'wfs:Update');
        updateNode.setAttribute("typeName", this.featurePrefix + ':' + this.featureName); 
        updateNode.setAttribute("xmlns:" + this.featurePrefix, this.featureNS); 

        var propertyNode = this.createElementNS(this.wfsns, 'wfs:Property');
        var nameNode = this.createElementNS(this.wfsns, 'wfs:Name');
        
        var txtNode = this.createTextNode(this.geometryName);
        nameNode.appendChild(txtNode);
        propertyNode.appendChild(nameNode);
        
        var valueNode = this.createElementNS(this.wfsns, 'wfs:Value');
        
        var geometryNode = this.buildGeometryNode(feature.geometry);
        
        if(feature.layer){
            geometryNode.setAttribute(
                "srsName", feature.layer.projection.getCode()
            );
        }
        
        valueNode.appendChild(geometryNode);
        
        propertyNode.appendChild(valueNode);
        updateNode.appendChild(propertyNode);
        
         // add in attributes
        for(var propName in feature.attributes) {
            propertyNode = this.createElementNS(this.wfsns, 'wfs:Property');
            nameNode = this.createElementNS(this.wfsns, 'wfs:Name');
            nameNode.appendChild(this.createTextNode(propName));
            propertyNode.appendChild(nameNode);
            valueNode = this.createElementNS(this.wfsns, 'wfs:Value');
            valueNode.appendChild(this.createTextNode(feature.attributes[propName]));
            propertyNode.appendChild(valueNode);
            updateNode.appendChild(propertyNode);
        }
        
        
        var filterNode = this.createElementNS(this.ogcns, 'ogc:Filter');
        var filterIdNode = this.createElementNS(this.ogcns, 'ogc:FeatureId');
        filterIdNode.setAttribute("fid", feature.fid);
        filterNode.appendChild(filterIdNode);
        updateNode.appendChild(filterNode);

        return updateNode;
    },
    
    /**
     * Method: remove 
     * Takes a feature, and generates a WFS-T Transaction "Delete" 
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} 
     */
    remove: function(feature) {
        if (!feature.fid) { 
            HGIS.Console.userError(HGIS.i18n("noFID")); 
            return false; 
        }
        var deleteNode = this.createElementNS(this.wfsns, 'wfs:Delete');
        deleteNode.setAttribute("typeName", this.featurePrefix + ':' + this.featureName); 
        deleteNode.setAttribute("xmlns:" + this.featurePrefix, this.featureNS); 

        var filterNode = this.createElementNS(this.ogcns, 'ogc:Filter');
        var filterIdNode = this.createElementNS(this.ogcns, 'ogc:FeatureId');
        filterIdNode.setAttribute("fid", feature.fid);
        filterNode.appendChild(filterIdNode);
        deleteNode.appendChild(filterNode);

        return deleteNode;
    },

    /**
     * APIMethod: destroy
     * Remove ciruclar ref to layer 
     */
    destroy: function() {
        this.layer = null;
    },

    CLASS_NAME: "HGIS.Format.WFS" 
});    
/* ======================================================================
    HGIS/Format/SLD/v1_0_0_GeoServer.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/SLD/v1_0_0.js
 */

/**
 * Class: HGIS.Format.SLD/v1_0_0_GeoServer
 * Read and write SLD version 1.0.0 with GeoServer-specific enhanced options.
 * See http://svn.osgeo.org/geotools/trunk/modules/extension/xsd/xsd-sld/src/main/resources/org/geotools/sld/bindings/StyledLayerDescriptor.xsd
 * for more information.
 *
 * Inherits from:
 *  - <HGIS.Format.SLD.v1_0_0>
 */
HGIS.Format.SLD.v1_0_0_GeoServer = HGIS.Class(
    HGIS.Format.SLD.v1_0_0, {

    /**
     * Property: version
     * {String} The specific parser version.
     */
    version: "1.0.0",

    /**
     * Property: profile
     * {String} The specific profile
     */
    profile: "GeoServer",

   /**
     * Constructor: HGIS.Format.SLD.v1_0_0_GeoServer
     * Create a new parser for GeoServer-enhanced SLD version 1.0.0.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: HGIS.Util.applyDefaults({
        "sld": HGIS.Util.applyDefaults({
            "Priority": function(node, obj) {
                var value = this.readers.ogc._expression.call(this, node);
                if (value) {
                    obj.priority = value;
                }
            },
            "VendorOption": function(node, obj) {
                if (!obj.vendorOptions) {
                    obj.vendorOptions = {};
                }
                obj.vendorOptions[node.getAttribute("name")] = this.getChildValue(node);
            },
            "TextSymbolizer": function(node, rule) {
                HGIS.Format.SLD.v1_0_0.prototype.readers.sld.TextSymbolizer.apply(this, arguments);
                var symbolizer = this.multipleSymbolizers ? rule.symbolizers[rule.symbolizers.length-1] : rule.symbolizer["Text"];
                if (symbolizer.graphic === undefined) {
                    symbolizer.graphic = false;
                }
            }
        }, HGIS.Format.SLD.v1_0_0.prototype.readers["sld"])
    }, HGIS.Format.SLD.v1_0_0.prototype.readers),

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: HGIS.Util.applyDefaults({
        "sld": HGIS.Util.applyDefaults({
            "Priority": function(priority) {
                return this.writers.sld._OGCExpression.call(
                    this, "sld:Priority", priority
                );
            },
            "VendorOption": function(option) {
                return this.createElementNSPlus("sld:VendorOption", {
                    attributes: {name: option.name},
                    value: option.value
                });
            },
            "TextSymbolizer": function(symbolizer) {
                var writers = HGIS.Format.SLD.v1_0_0.prototype.writers;
                var node = writers["sld"]["TextSymbolizer"].apply(this, arguments);
                if (symbolizer.graphic !== false && (symbolizer.externalGraphic || symbolizer.graphicName)) {
                    this.writeNode("Graphic", symbolizer, node);
                }
                if ("priority" in symbolizer) {
                    this.writeNode("Priority", symbolizer.priority, node);
                }
                return this.addVendorOptions(node, symbolizer);
            },
            "PointSymbolizer": function(symbolizer) {
                var writers = HGIS.Format.SLD.v1_0_0.prototype.writers;
                var node = writers["sld"]["PointSymbolizer"].apply(this, arguments);
                return this.addVendorOptions(node, symbolizer);
            },
            "LineSymbolizer": function(symbolizer) {
                var writers = HGIS.Format.SLD.v1_0_0.prototype.writers;
                var node = writers["sld"]["LineSymbolizer"].apply(this, arguments);
                return this.addVendorOptions(node, symbolizer);
            },
            "PolygonSymbolizer": function(symbolizer) {
                var writers = HGIS.Format.SLD.v1_0_0.prototype.writers;
                var node = writers["sld"]["PolygonSymbolizer"].apply(this, arguments);
                return this.addVendorOptions(node, symbolizer);
            }
        }, HGIS.Format.SLD.v1_0_0.prototype.writers["sld"])
    }, HGIS.Format.SLD.v1_0_0.prototype.writers),

    /**
     * Method: addVendorOptions
     * Add in the VendorOption tags and return the node again.
     *
     * Parameters:
     * node - {DOMElement} A DOM node.
     * symbolizer - {Object}
     *
     * Returns:
     * {DOMElement} A DOM node.
     */
    addVendorOptions: function(node, symbolizer) {
        var options = symbolizer.vendorOptions;
        if (options) {
            for (var key in symbolizer.vendorOptions) {
                this.writeNode("VendorOption", {
                    name: key, 
                    value: symbolizer.vendorOptions[key]
                }, node);
            }
        }
        return node;
    },

    CLASS_NAME: "HGIS.Format.SLD.v1_0_0_GeoServer"

});
/* ======================================================================
    HGIS/Layer/Boxes.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer.js
 * @requires HGIS/Layer/Markers.js
 */

/**
 * Class: HGIS.Layer.Boxes
 * Draw divs as 'boxes' on the layer. 
 *
 * Inherits from:
 *  - <HGIS.Layer.Markers>
 */
HGIS.Layer.Boxes = HGIS.Class(HGIS.Layer.Markers, {

    /**
     * Constructor: HGIS.Layer.Boxes
     *
     * Parameters:
     * name - {String} 
     * options - {Object} Hashtable of extra options to tag onto the layer
     */
    
    /**
     * Method: drawMarker 
     * Calculate the pixel location for the marker, create it, and
     *    add it to the layer's div
     *
     * Parameters: 
     * marker - {<HGIS.Marker.Box>} 
     */
    drawMarker: function(marker) {
        var topleft = this.map.getLayerPxFromLonLat({
            lon: marker.bounds.left,
            lat: marker.bounds.top
        });
        var botright = this.map.getLayerPxFromLonLat({
            lon: marker.bounds.right,
            lat: marker.bounds.bottom
        });
        if (botright == null || topleft == null) {
            marker.display(false);
        } else {
            var markerDiv = marker.draw(topleft, {
                w: Math.max(1, botright.x - topleft.x),
                h: Math.max(1, botright.y - topleft.y)
            });
            if (!marker.drawn) {
                this.div.appendChild(markerDiv);
                marker.drawn = true;
            }
        }
    },


    /**
     * APIMethod: removeMarker 
     * 
     * Parameters:
     * marker - {<HGIS.Marker.Box>} 
     */
    removeMarker: function(marker) {
        HGIS.Util.removeItem(this.markers, marker);
        if ((marker.div != null) &&
            (marker.div.parentNode == this.div) ) {
            this.div.removeChild(marker.div);    
        }
    },

    CLASS_NAME: "HGIS.Layer.Boxes"
});
/* ======================================================================
    HGIS/Format/WFSCapabilities/v1_0_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WFSCapabilities/v1.js
 */

/**
 * Class: HGIS.Format.WFSCapabilities/v1_0_0
 * Read WFS Capabilities version 1.0.0.
 * 
 * Inherits from:
 *  - <HGIS.Format.WFSCapabilities.v1>
 */
HGIS.Format.WFSCapabilities.v1_0_0 = HGIS.Class(
    HGIS.Format.WFSCapabilities.v1, {
    
    /**
     * Constructor: HGIS.Format.WFSCapabilities.v1_0_0
     * Create a new parser for WFS capabilities version 1.0.0.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wfs": HGIS.Util.applyDefaults({
            "Service": function(node, capabilities) {
                capabilities.service = {};
                this.readChildNodes(node, capabilities.service);
            },
            "Fees": function(node, service) {
                var fees = this.getChildValue(node);
                if (fees && fees.toLowerCase() != "none") {
                    service.fees = fees;
                }
            },
            "AccessConstraints": function(node, service) {
                var constraints = this.getChildValue(node);
                if (constraints && constraints.toLowerCase() != "none") {
                    service.accessConstraints = constraints;
                }
            },
            "OnlineResource": function(node, service) {
                var onlineResource = this.getChildValue(node);
                if (onlineResource && onlineResource.toLowerCase() != "none") {
                    service.onlineResource = onlineResource;
                }
            },
            "Keywords": function(node, service) {
                var keywords = this.getChildValue(node);
                if (keywords && keywords.toLowerCase() != "none") {
                    service.keywords = keywords.split(', ');
                }
            },
            "Capability": function(node, capabilities) {
                capabilities.capability = {};
                this.readChildNodes(node, capabilities.capability);
            },
            "Request": function(node, obj) {
                obj.request = {};
                this.readChildNodes(node, obj.request);
            },
            "GetFeature": function(node, request) {
                request.getfeature = {
                    href: {}, // DCPType
                    formats: [] // ResultFormat
                };
                this.readChildNodes(node, request.getfeature);
            },
            "ResultFormat": function(node, obj) {
                var children = node.childNodes;
                var childNode;
                for(var i=0; i<children.length; i++) {
                    childNode = children[i];
                    if(childNode.nodeType == 1) {
                        obj.formats.push(childNode.nodeName);
                    }
                }
            },
            "DCPType": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "HTTP": function(node, obj) {
                this.readChildNodes(node, obj.href);
            },
            "Get": function(node, obj) {
                obj.get = node.getAttribute("onlineResource");
            },
            "Post": function(node, obj) {
                obj.post = node.getAttribute("onlineResource");
            },
            "SRS": function(node, obj) {
                var srs = this.getChildValue(node);
                if (srs) {
                    obj.srs = srs;
                }
            }
        }, HGIS.Format.WFSCapabilities.v1.prototype.readers["wfs"])
    },
    
    CLASS_NAME: "HGIS.Format.WFSCapabilities.v1_0_0" 

});
/* ======================================================================
    HGIS/Format/WMSCapabilities/v1_3.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WMSCapabilities/v1.js
 */

/**
 * Class: HGIS.Format.WMSCapabilities/v1_3
 * Abstract base class for WMS Capabilities version 1.3.X. 
 * SLD 1.1.0 adds in the extra operations DescribeLayer and GetLegendGraphic, 
 * see: http://schemas.opengis.net/sld/1.1.0/sld_capabilities.xsd
 * 
 * Inherits from:
 *  - <HGIS.Format.WMSCapabilities.v1>
 */
HGIS.Format.WMSCapabilities.v1_3 = HGIS.Class(
    HGIS.Format.WMSCapabilities.v1, {
    
    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wms": HGIS.Util.applyDefaults({
            "WMS_Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "LayerLimit": function(node, obj) {
                obj.layerLimit = parseInt(this.getChildValue(node));
            },
            "MaxWidth": function(node, obj) {
                obj.maxWidth = parseInt(this.getChildValue(node));
            },
            "MaxHeight": function(node, obj) {
                obj.maxHeight = parseInt(this.getChildValue(node));
            },
            "BoundingBox": function(node, obj) {
                var bbox = HGIS.Format.WMSCapabilities.v1.prototype.readers["wms"].BoundingBox.apply(this, [node, obj]);
                bbox.srs  = node.getAttribute("CRS");
                obj.bbox[bbox.srs] = bbox;
            },
            "CRS": function(node, obj) {
                // CRS is the synonym of SRS
                this.readers.wms.SRS.apply(this, [node, obj]); 
            },
            "EX_GeographicBoundingBox": function(node, obj) {
                // replacement of LatLonBoundingBox
                obj.llbbox = [];
                this.readChildNodes(node, obj.llbbox);
                
            },
            "westBoundLongitude": function(node, obj) {
                obj[0] = this.getChildValue(node);
            },
            "eastBoundLongitude": function(node, obj) {
                obj[2] = this.getChildValue(node);
            },
            "southBoundLatitude": function(node, obj) {
                obj[1] = this.getChildValue(node);
            },
            "northBoundLatitude": function(node, obj) {
                obj[3] = this.getChildValue(node);
            },
            "MinScaleDenominator": function(node, obj) {
                obj.maxScale = parseFloat(this.getChildValue(node)).toPrecision(16);
            },
            "MaxScaleDenominator": function(node, obj) {
                obj.minScale = parseFloat(this.getChildValue(node)).toPrecision(16);
            },
            "Dimension": function(node, obj) {
                // dimension has extra attributes: default, multipleValues, 
                // nearestValue, current which used to be part of Extent. It now
                // also contains the values.
                var name = node.getAttribute("name").toLowerCase();
                var dim = {
                    name: name,
                    units: node.getAttribute("units"),
                    unitsymbol: node.getAttribute("unitSymbol"),
                    nearestVal: node.getAttribute("nearestValue") === "1",
                    multipleVal: node.getAttribute("multipleValues") === "1",
                    "default": node.getAttribute("default") || "",
                    current: node.getAttribute("current") === "1",
                    values: this.getChildValue(node).split(",")
                    
                };
                // Theoretically there can be more dimensions with the same
                // name, but with a different unit. Until we meet such a case,
                // let's just keep the same structure as the WMS 1.1 
                // GetCapabilities parser uses. We will store the last
                // one encountered.
                obj.dimensions[dim.name] = dim;
            },
            "Keyword": function(node, obj) {
                // TODO: should we change the structure of keyword in v1.js?
                // Make it an object with a value instead of a string?
                var keyword = {value: this.getChildValue(node), 
                    vocabulary: node.getAttribute("vocabulary")};
                if (obj.keywords) {
                    obj.keywords.push(keyword);
                }
            }
        }, HGIS.Format.WMSCapabilities.v1.prototype.readers["wms"]),
        "sld": {
            "UserDefinedSymbolization": function(node, obj) {
                this.readers.wms.UserDefinedSymbolization.apply(this, [node, obj]);
                // add the two extra attributes
                obj.userSymbols.inlineFeature = parseInt(node.getAttribute("InlineFeature")) == 1;
                obj.userSymbols.remoteWCS = parseInt(node.getAttribute("RemoteWCS")) == 1;
            },
            "DescribeLayer": function(node, obj) {
                this.readers.wms.DescribeLayer.apply(this, [node, obj]);
            },
            "GetLegendGraphic": function(node, obj) {
                this.readers.wms.GetLegendGraphic.apply(this, [node, obj]);
            }
        }
    },
    
    CLASS_NAME: "HGIS.Format.WMSCapabilities.v1_3" 

});
/* ======================================================================
    HGIS/Layer/Zoomify.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/*
 * Development supported by a R&D grant DC08P02OUK006 - Old Maps Online
 * (www.oldmapsonline.org) from Ministry of Culture of the Czech Republic.
 */


/**
 * @requires HGIS/Layer/Grid.js
 */

/**
 * Class: HGIS.Layer.Zoomify
 *
 * Inherits from:
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.Zoomify = HGIS.Class(HGIS.Layer.Grid, {

    /**
     * Property: size
     * {<HGIS.Size>} The Zoomify image size in pixels.
     */
    size: null,

    /**
     * APIProperty: isBaseLayer
     * {Boolean}
     */
    isBaseLayer: true,

    /**
     * Property: standardTileSize
     * {Integer} The size of a standard (non-border) square tile in pixels.
     */
    standardTileSize: 256,

    /** 
     * Property: tileOriginCorner
     * {String} This layer uses top-left as tile origin
     **/
    tileOriginCorner: "tl",

    /**
     * Property: numberOfTiers
     * {Integer} Depth of the Zoomify pyramid, number of tiers (zoom levels)
     *                          - filled during Zoomify pyramid initialization.
     */
    numberOfTiers: 0,

    /**
     * Property: tileCountUpToTier
     * {Array(Integer)} Number of tiles up to the given tier of pyramid.
     *                          - filled during Zoomify pyramid initialization.
     */
    tileCountUpToTier: null,

    /**
     * Property: tierSizeInTiles
     * {Array(<HGIS.Size>)} Size (in tiles) for each tier of pyramid.
     *                          - filled during Zoomify pyramid initialization.
     */
    tierSizeInTiles: null,

    /**
     * Property: tierImageSize
     * {Array(<HGIS.Size>)} Image size in pixels for each pyramid tier.
     *                          - filled during Zoomify pyramid initialization.
     */
    tierImageSize: null,

    /**
     * Constructor: HGIS.Layer.Zoomify
     *
     * Parameters:
     * name - {String} A name for the layer.
     * url - {String} - Relative or absolute path to the image or more
     *        precisly to the TileGroup[X] directories root.
     *        Flash plugin use the variable name "zoomifyImagePath" for this.
     * size - {<HGIS.Size>} The size (in pixels) of the image.
     * options - {Object} Hashtable of extra options to tag onto the layer
     */
    initialize: function(name, url, size, options) {

        // initilize the Zoomify pyramid for given size
        this.initializeZoomify(size);

        HGIS.Layer.Grid.prototype.initialize.apply(this, [
            name, url, size, {}, options
        ]);
    },

    /**
     * Method: initializeZoomify
     * It generates constants for all tiers of the Zoomify pyramid
     *
     * Parameters:
     * size - {<HGIS.Size>} The size of the image in pixels
     *
     */
    initializeZoomify: function( size ) {

        var imageSize = size.clone();
        this.size = size.clone();
        var tiles = new HGIS.Size(
            Math.ceil( imageSize.w / this.standardTileSize ),
            Math.ceil( imageSize.h / this.standardTileSize )
            );

        this.tierSizeInTiles = [tiles];
        this.tierImageSize = [imageSize];

        while (imageSize.w > this.standardTileSize ||
               imageSize.h > this.standardTileSize ) {

            imageSize = new HGIS.Size(
                Math.floor( imageSize.w / 2 ),
                Math.floor( imageSize.h / 2 )
                );
            tiles = new HGIS.Size(
                Math.ceil( imageSize.w / this.standardTileSize ),
                Math.ceil( imageSize.h / this.standardTileSize )
                );
            this.tierSizeInTiles.push( tiles );
            this.tierImageSize.push( imageSize );
        }

        this.tierSizeInTiles.reverse();
        this.tierImageSize.reverse();

        this.numberOfTiers = this.tierSizeInTiles.length;
        var resolutions = [1];
        this.tileCountUpToTier = [0];
        for (var i = 1; i < this.numberOfTiers; i++) {
            resolutions.unshift(Math.pow(2, i));
            this.tileCountUpToTier.push(
                this.tierSizeInTiles[i-1].w * this.tierSizeInTiles[i-1].h +
                this.tileCountUpToTier[i-1]
                );
        }
        if (!this.serverResolutions) {
            this.serverResolutions = resolutions;
        }
    },

    /**
     * APIMethod:destroy
     */
    destroy: function() {
        // for now, nothing special to do here.
        HGIS.Layer.Grid.prototype.destroy.apply(this, arguments);

        // Remove from memory the Zoomify pyramid - is that enough?
        this.tileCountUpToTier.length = 0;
        this.tierSizeInTiles.length = 0;
        this.tierImageSize.length = 0;

    },

    /**
     * APIMethod: clone
     *
     * Parameters:
     * obj - {Object}
     *
     * Returns:
     * {<HGIS.Layer.Zoomify>} An exact clone of this <HGIS.Layer.Zoomify>
     */
    clone: function (obj) {

        if (obj == null) {
            obj = new HGIS.Layer.Zoomify(this.name,
                                           this.url,
                                           this.size,
                                           this.options);
        }

        //get all additions from superclasses
        obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },

    /**
     * Method: getURL
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     *
     * Returns:
     * {String} A string with the layer's url and parameters and also the
     *          passed-in bounds and appropriate tile size specified as
     *          parameters
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);
        var res = this.getServerResolution();
        var x = Math.round((bounds.left - this.tileOrigin.lon) / (res * this.tileSize.w));
        var y = Math.round((this.tileOrigin.lat - bounds.top) / (res * this.tileSize.h));
        var z = this.getZoomForResolution( res );

        var tileIndex = x + y * this.tierSizeInTiles[z].w + this.tileCountUpToTier[z];
        var path = "TileGroup" + Math.floor( (tileIndex) / 256 ) +
            "/" + z + "-" + x + "-" + y + ".jpg";
        var url = this.url;
        if (HGIS.Util.isArray(url)) {
            url = this.selectUrl(path, url);
        }
        return url + path;
    },

    /**
     * Method: getImageSize
     * getImageSize returns size for a particular tile. If bounds are given as
     * first argument, size is calculated (bottom-right tiles are non square).
     *
     */
    getImageSize: function() {
        if (arguments.length > 0) {
            var bounds = this.adjustBounds(arguments[0]);
            var res = this.getServerResolution();
            var x = Math.round((bounds.left - this.tileOrigin.lon) / (res * this.tileSize.w));
            var y = Math.round((this.tileOrigin.lat - bounds.top) / (res * this.tileSize.h));
            var z = this.getZoomForResolution( res );
            var w = this.standardTileSize;
            var h = this.standardTileSize;
            if (x == this.tierSizeInTiles[z].w -1 ) {
                var w = this.tierImageSize[z].w % this.standardTileSize;
            }
            if (y == this.tierSizeInTiles[z].h -1 ) {
                var h = this.tierImageSize[z].h % this.standardTileSize;
            }
            return (new HGIS.Size(w, h));
        } else {
            return this.tileSize;
        }
    },

    /**
     * APIMethod: setMap
     * When the layer is added to a map, then we can fetch our origin
     *    (if we don't have one.)
     *
     * Parameters:
     * map - {<HGIS.Map>}
     */
    setMap: function(map) {
        HGIS.Layer.Grid.prototype.setMap.apply(this, arguments);
        this.tileOrigin = new HGIS.LonLat(this.map.maxExtent.left,
                                                this.map.maxExtent.top);
    },

    CLASS_NAME: "HGIS.Layer.Zoomify"
});
/* ======================================================================
    HGIS/Layer/MapServer.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer/Grid.js
 */

/**
 * Class: HGIS.Layer.MapServer
 * Instances of HGIS.Layer.MapServer are used to display
 * data from a MapServer CGI instance.
 *
 * Inherits from:
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.MapServer = HGIS.Class(HGIS.Layer.Grid, {

    /**
     * Constant: DEFAULT_PARAMS
     * {Object} Hashtable of default parameter key/value pairs 
     */
    DEFAULT_PARAMS: {
        mode: "map",
        map_imagetype: "png"
    },

    /**
     * Constructor: HGIS.Layer.MapServer
     * Create a new MapServer layer object
     *
     * Parameters:
     * name - {String} A name for the layer
     * url - {String} Base url for the MapServer CGI
     *       (e.g. http://www2.dmsolutions.ca/cgi-bin/mapserv)
     * params - {Object} An object with key/value pairs representing the
     *          GetMap query string parameters and parameter values.
     * options - {Object} Hashtable of extra options to tag onto the layer
     */
    initialize: function(name, url, params, options) {
        HGIS.Layer.Grid.prototype.initialize.apply(this, arguments);

        this.params = HGIS.Util.applyDefaults(
            this.params, this.DEFAULT_PARAMS
        );

        // unless explicitly set in options, if the layer is transparent, 
        // it will be an overlay
        if (options == null || options.isBaseLayer == null) {
            this.isBaseLayer = ((this.params.transparent != "true") && 
                                (this.params.transparent != true));
        }
    },

    /**
     * Method: clone
     * Create a clone of this layer
     *
     * Returns:
     * {<HGIS.Layer.MapServer>} An exact clone of this layer
     */
    clone: function (obj) {
        if (obj == null) {
            obj = new HGIS.Layer.MapServer(this.name,
                                           this.url,
                                           this.params,
                                           this.getOptions());
        }
        //get all additions from superclasses
        obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },
    
    /**
     * Method: getURL
     * Return a query string for this layer
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>} A bounds representing the bbox 
     *                                for the request
     *
     * Returns:
     * {String} A string with the layer's url and parameters and also 
     *          the passed-in bounds and appropriate tile size specified 
     *          as parameters.
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);
        // Make a list, so that getFullRequestString uses literal "," 
        var extent = [bounds.left, bounds. bottom, bounds.right, bounds.top];

        var imageSize = this.getImageSize(); 
        
        // make lists, so that literal ','s are used 
        var url = this.getFullRequestString(
                     {mapext:   extent,
                      imgext:   extent,
                      map_size: [imageSize.w, imageSize.h],
                      imgx:     imageSize.w / 2,
                      imgy:     imageSize.h / 2,
                      imgxy:    [imageSize.w, imageSize.h]
                      });
        
        return url;
    },
    
    /** 
     * Method: getFullRequestString
     * combine the layer's url with its params and these newParams. 
     *   
     * Parameters:
     * newParams - {Object} New parameters that should be added to the 
     *                      request string.
     * altUrl - {String} (optional) Replace the URL in the full request  
     *                              string with the provided URL.
     * 
     * Returns: 
     * {String} A string with the layer's url and parameters embedded in it.
     */
    getFullRequestString:function(newParams, altUrl) {
        // use layer's url unless altUrl passed in
        var url = (altUrl == null) ? this.url : altUrl;
        
        // create a new params hashtable with all the layer params and the 
        // new params together. then convert to string
        var allParams = HGIS.Util.extend({}, this.params);
        allParams = HGIS.Util.extend(allParams, newParams);
        var paramsString = HGIS.Util.getParameterString(allParams);
        
        // if url is not a string, it should be an array of strings, 
        // in which case we will deterministically select one of them in 
        // order to evenly distribute requests to different urls.
        if (HGIS.Util.isArray(url)) {
            url = this.selectUrl(paramsString, url);
        }   
        
        // ignore parameters that are already in the url search string
        var urlParams = HGIS.Util.upperCaseObject(
                            HGIS.Util.getParameters(url));
        for(var key in allParams) {
            if(key.toUpperCase() in urlParams) {
                delete allParams[key];
            }
        }
        paramsString = HGIS.Util.getParameterString(allParams);
        
        // requestString always starts with url
        var requestString = url;        

        // MapServer needs '+' seperating things like bounds/height/width.
        //   Since typically this is URL encoded, we use a slight hack: we
        //  depend on the list-like functionality of getParameterString to
        //  leave ',' only in the case of list items (since otherwise it is
        //  encoded) then do a regular expression replace on the , characters
        //  to '+'
        //
        paramsString = paramsString.replace(/,/g, "+");
        
        if (paramsString != "") {
            var lastServerChar = url.charAt(url.length - 1);
            if ((lastServerChar == "&") || (lastServerChar == "?")) {
                requestString += paramsString;
            } else {
                if (url.indexOf('?') == -1) {
                    //serverPath has no ? -- add one
                    requestString += '?' + paramsString;
                } else {
                    //serverPath contains ?, so must already have paramsString at the end
                    requestString += '&' + paramsString;
                }
            }
        }
        return requestString;
    },

    CLASS_NAME: "HGIS.Layer.MapServer"
});
/* ======================================================================
    HGIS/Renderer/VML.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Renderer/Elements.js
 */

/**
 * Class: HGIS.Renderer.VML
 * Render vector features in browsers with VML capability.  Construct a new
 * VML renderer with the <HGIS.Renderer.VML> constructor.
 * 
 * Note that for all calculations in this class, we use (num | 0) to truncate a 
 * float value to an integer. This is done because it seems that VML doesn't 
 * support float values.
 *
 * Inherits from:
 *  - <HGIS.Renderer.Elements>
 */
HGIS.Renderer.VML = HGIS.Class(HGIS.Renderer.Elements, {

    /**
     * Property: xmlns
     * {String} XML Namespace URN
     */
    xmlns: "urn:schemas-microsoft-com:vml",
    
    /**
     * Property: symbolCache
     * {DOMElement} node holding symbols. This hash is keyed by symbol name,
     *     and each value is a hash with a "path" and an "extent" property.
     */
    symbolCache: {},

    /**
     * Property: offset
     * {Object} Hash with "x" and "y" properties
     */
    offset: null,
    
    /**
     * Constructor: HGIS.Renderer.VML
     * Create a new VML renderer.
     *
     * Parameters:
     * containerID - {String} The id for the element that contains the renderer
     */
    initialize: function(containerID) {
        if (!this.supported()) { 
            return; 
        }
        if (!document.namespaces.olv) {
            document.namespaces.add("olv", this.xmlns);
            var style = document.createStyleSheet();
            var shapes = ['shape','rect', 'oval', 'fill', 'stroke', 'imagedata', 'group','textbox']; 
            for (var i = 0, len = shapes.length; i < len; i++) {

                style.addRule('olv\\:' + shapes[i], "behavior: url(#default#VML); " +
                              "position: absolute; display: inline-block;");
            }                  
        }
        
        HGIS.Renderer.Elements.prototype.initialize.apply(this, 
                                                                arguments);
    },

    /**
     * APIMethod: supported
     * Determine whether a browser supports this renderer.
     *
     * Returns:
     * {Boolean} The browser supports the VML renderer
     */
    supported: function() {
        return !!(document.namespaces);
    },    

    /**
     * Method: setExtent
     * Set the renderer's extent
     *
     * Parameters:
     * extent - {<HGIS.Bounds>}
     * resolutionChanged - {Boolean}
     * 
     * Returns:
     * {Boolean} true to notify the layer that the new extent does not exceed
     *     the coordinate range, and the features will not need to be redrawn.
     */
    setExtent: function(extent, resolutionChanged) {
        var coordSysUnchanged = HGIS.Renderer.Elements.prototype.setExtent.apply(this, arguments);
        var resolution = this.getResolution();
    
        var left = (extent.left/resolution) | 0;
        var top = (extent.top/resolution - this.size.h) | 0;
        if (resolutionChanged || !this.offset) {
            this.offset = {x: left, y: top};
            left = 0;
            top = 0;
        } else {
            left = left - this.offset.x;
            top = top - this.offset.y;
        }

        
        var org = (left - this.xOffset) + " " + top;
        this.root.coordorigin = org;
        var roots = [this.root, this.vectorRoot, this.textRoot];
        var root;
        for(var i=0, len=roots.length; i<len; ++i) {
            root = roots[i];

            var size = this.size.w + " " + this.size.h;
            root.coordsize = size;
            
        }
        // flip the VML display Y axis upside down so it 
        // matches the display Y axis of the map
        this.root.style.flip = "y";
        
        return coordSysUnchanged;
    },


    /**
     * Method: setSize
     * Set the size of the drawing surface
     *
     * Parameters:
     * size - {<HGIS.Size>} the size of the drawing surface
     */
    setSize: function(size) {
        HGIS.Renderer.prototype.setSize.apply(this, arguments);
        
        // setting width and height on all roots to avoid flicker which we
        // would get with 100% width and height on child roots
        var roots = [
            this.rendererRoot,
            this.root,
            this.vectorRoot,
            this.textRoot
        ];
        var w = this.size.w + "px";
        var h = this.size.h + "px";
        var root;
        for(var i=0, len=roots.length; i<len; ++i) {
            root = roots[i];
            root.style.width = w;
            root.style.height = h;
        }
    },

    /**
     * Method: getNodeType
     * Get the node type for a geometry and style
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * style - {Object}
     *
     * Returns:
     * {String} The corresponding node type for the specified geometry
     */
    getNodeType: function(geometry, style) {
        var nodeType = null;
        switch (geometry.CLASS_NAME) {
            case "HGIS.Geometry.Point":
                if (style.externalGraphic) {
                    nodeType = "olv:rect";
                } else if (this.isComplexSymbol(style.graphicName)) {
                    nodeType = "olv:shape";
                } else {
                    nodeType = "olv:oval";
                }
                break;
            case "HGIS.Geometry.Rectangle":
                nodeType = "olv:rect";
                break;
            case "HGIS.Geometry.LineString":
            case "HGIS.Geometry.LinearRing":
            case "HGIS.Geometry.Polygon":
            case "HGIS.Geometry.Curve":
                nodeType = "olv:shape";
                break;
            default:
                break;
        }
        return nodeType;
    },

    /**
     * Method: setStyle
     * Use to set all the style attributes to a VML node.
     *
     * Parameters:
     * node - {DOMElement} An VML element to decorate
     * style - {Object}
     * options - {Object} Currently supported options include 
     *                              'isFilled' {Boolean} and
     *                              'isStroked' {Boolean}
     * geometry - {<HGIS.Geometry>}
     */
    setStyle: function(node, style, options, geometry) {
        style = style  || node._style;
        options = options || node._options;
        var fillColor = style.fillColor;

        var title = style.title || style.graphicTitle;
        if (title) {
            node.title = title;
        } 

        if (node._geometryClass === "HGIS.Geometry.Point") {
            if (style.externalGraphic) {
                options.isFilled = true;
                var width = style.graphicWidth || style.graphicHeight;
                var height = style.graphicHeight || style.graphicWidth;
                width = width ? width : style.pointRadius*2;
                height = height ? height : style.pointRadius*2;

                var resolution = this.getResolution();
                var xOffset = (style.graphicXOffset != undefined) ?
                    style.graphicXOffset : -(0.5 * width);
                var yOffset = (style.graphicYOffset != undefined) ?
                    style.graphicYOffset : -(0.5 * height);
                
                node.style.left = ((((geometry.x - this.featureDx)/resolution - this.offset.x)+xOffset) | 0) + "px";
                node.style.top = (((geometry.y/resolution - this.offset.y)-(yOffset+height)) | 0) + "px";
                node.style.width = width + "px";
                node.style.height = height + "px";
                node.style.flip = "y";
                
                // modify fillColor and options for stroke styling below
                fillColor = "none";
                options.isStroked = false;
            } else if (this.isComplexSymbol(style.graphicName)) {
                var cache = this.importSymbol(style.graphicName);
                node.path = cache.path;
                node.coordorigin = cache.left + "," + cache.bottom;
                var size = cache.size;
                node.coordsize = size + "," + size;        
                this.drawCircle(node, geometry, style.pointRadius);
                node.style.flip = "y";
            } else {
                this.drawCircle(node, geometry, style.pointRadius);
            }
        }

        // fill 
        if (options.isFilled) { 
            node.fillcolor = fillColor; 
        } else { 
            node.filled = "false"; 
        }
        var fills = node.getElementsByTagName("fill");
        var fill = (fills.length == 0) ? null : fills[0];
        if (!options.isFilled) {
            if (fill) {
                node.removeChild(fill);
            }
        } else {
            if (!fill) {
                fill = this.createNode('olv:fill', node.id + "_fill");
            }
            fill.opacity = style.fillOpacity;

            if (node._geometryClass === "HGIS.Geometry.Point" &&
                    style.externalGraphic) {

                // override fillOpacity
                if (style.graphicOpacity) {
                    fill.opacity = style.graphicOpacity;
                }
                
                fill.src = style.externalGraphic;
                fill.type = "frame";
                
                if (!(style.graphicWidth && style.graphicHeight)) {
                  fill.aspect = "atmost";
                }                
            }
            if (fill.parentNode != node) {
                node.appendChild(fill);
            }
        }

        // additional rendering for rotated graphics or symbols
        var rotation = style.rotation;
        if ((rotation !== undefined || node._rotation !== undefined)) {
            node._rotation = rotation;
            if (style.externalGraphic) {
                this.graphicRotate(node, xOffset, yOffset, style);
                // make the fill fully transparent, because we now have
                // the graphic as imagedata element. We cannot just remove
                // the fill, because this is part of the hack described
                // in graphicRotate
                fill.opacity = 0;
            } else if(node._geometryClass === "HGIS.Geometry.Point") {
                node.style.rotation = rotation || 0;
            }
        }

        // stroke 
        var strokes = node.getElementsByTagName("stroke");
        var stroke = (strokes.length == 0) ? null : strokes[0];
        if (!options.isStroked) {
            node.stroked = false;
            if (stroke) {
                stroke.on = false;
            }
        } else {
            if (!stroke) {
                stroke = this.createNode('olv:stroke', node.id + "_stroke");
                node.appendChild(stroke);
            }
            stroke.on = true;
            stroke.color = style.strokeColor; 
            stroke.weight = style.strokeWidth + "px"; 
            stroke.opacity = style.strokeOpacity;
            stroke.endcap = style.strokeLinecap == 'butt' ? 'flat' :
                (style.strokeLinecap || 'round');
            if (style.strokeDashstyle) {
                stroke.dashstyle = this.dashStyle(style);
            }
        }
        
        if (style.cursor != "inherit" && style.cursor != null) {
            node.style.cursor = style.cursor;
        }
        return node;
    },

    /**
     * Method: graphicRotate
     * If a point is to be styled with externalGraphic and rotation, VML fills
     * cannot be used to display the graphic, because rotation of graphic
     * fills is not supported by the VML implementation of Internet Explorer.
     * This method creates a olv:imagedata element inside the VML node,
     * DXImageTransform.Matrix and BasicImage filters for rotation and
     * opacity, and a 3-step hack to remove rendering artefacts from the
     * graphic and preserve the ability of graphics to trigger events.
     * Finally, HGIS methods are used to determine the correct
     * insertion point of the rotated image, because DXImageTransform.Matrix
     * does the rotation without the ability to specify a rotation center
     * point.
     * 
     * Parameters:
     * node    - {DOMElement}
     * xOffset - {Number} rotation center relative to image, x coordinate
     * yOffset - {Number} rotation center relative to image, y coordinate
     * style   - {Object}
     */
    graphicRotate: function(node, xOffset, yOffset, style) {
        var style = style || node._style;
        var rotation = style.rotation || 0;
        
        var aspectRatio, size;
        if (!(style.graphicWidth && style.graphicHeight)) {
            // load the image to determine its size
            var img = new Image();
            img.onreadystatechange = HGIS.Function.bind(function() {
                if(img.readyState == "complete" ||
                        img.readyState == "interactive") {
                    aspectRatio = img.width / img.height;
                    size = Math.max(style.pointRadius * 2, 
                        style.graphicWidth || 0,
                        style.graphicHeight || 0);
                    xOffset = xOffset * aspectRatio;
                    style.graphicWidth = size * aspectRatio;
                    style.graphicHeight = size;
                    this.graphicRotate(node, xOffset, yOffset, style);
                }
            }, this);
            img.src = style.externalGraphic;
            
            // will be called again by the onreadystate handler
            return;
        } else {
            size = Math.max(style.graphicWidth, style.graphicHeight);
            aspectRatio = style.graphicWidth / style.graphicHeight;
        }
        
        var width = Math.round(style.graphicWidth || size * aspectRatio);
        var height = Math.round(style.graphicHeight || size);
        node.style.width = width + "px";
        node.style.height = height + "px";
        
        // Three steps are required to remove artefacts for images with
        // transparent backgrounds (resulting from using DXImageTransform
        // filters on svg objects), while preserving awareness for browser
        // events on images:
        // - Use the fill as usual (like for unrotated images) to handle
        //   events
        // - specify an imagedata element with the same src as the fill
        // - style the imagedata element with an AlphaImageLoader filter
        //   with empty src
        var image = document.getElementById(node.id + "_image");
        if (!image) {
            image = this.createNode("olv:imagedata", node.id + "_image");
            node.appendChild(image);
        }
        image.style.width = width + "px";
        image.style.height = height + "px";
        image.src = style.externalGraphic;
        image.style.filter =
            "progid:DXImageTransform.Microsoft.AlphaImageLoader(" + 
            "src='', sizingMethod='scale')";

        var rot = rotation * Math.PI / 180;
        var sintheta = Math.sin(rot);
        var costheta = Math.cos(rot);

        // do the rotation on the image
        var filter =
            "progid:DXImageTransform.Microsoft.Matrix(M11=" + costheta +
            ",M12=" + (-sintheta) + ",M21=" + sintheta + ",M22=" + costheta +
            ",SizingMethod='auto expand')\n";

        // set the opacity (needed for the imagedata)
        var opacity = style.graphicOpacity || style.fillOpacity;
        if (opacity && opacity != 1) {
            filter += 
                "progid:DXImageTransform.Microsoft.BasicImage(opacity=" + 
                opacity+")\n";
        }
        node.style.filter = filter;

        // do the rotation again on a box, so we know the insertion point
        var centerPoint = new HGIS.Geometry.Point(-xOffset, -yOffset);
        var imgBox = new HGIS.Bounds(0, 0, width, height).toGeometry();
        imgBox.rotate(style.rotation, centerPoint);
        var imgBounds = imgBox.getBounds();

        node.style.left = Math.round(
            parseInt(node.style.left) + imgBounds.left) + "px";
        node.style.top = Math.round(
            parseInt(node.style.top) - imgBounds.bottom) + "px";
    },

    /**
     * Method: postDraw
     * Does some node postprocessing to work around browser issues:
     * - Some versions of Internet Explorer seem to be unable to set fillcolor
     *   and strokecolor to "none" correctly before the fill node is appended
     *   to a visible vml node. This method takes care of that and sets
     *   fillcolor and strokecolor again if needed.
     * - In some cases, a node won't become visible after being drawn. Setting
     *   style.visibility to "visible" works around that.
     * 
     * Parameters:
     * node - {DOMElement}
     */
    postDraw: function(node) {
        node.style.visibility = "visible";
        var fillColor = node._style.fillColor;
        var strokeColor = node._style.strokeColor;
        if (fillColor == "none" &&
                node.fillcolor != fillColor) {
            node.fillcolor = fillColor;
        }
        if (strokeColor == "none" &&
                node.strokecolor != strokeColor) {
            node.strokecolor = strokeColor;
        }
    },


    /**
     * Method: setNodeDimension
     * Get the geometry's bounds, convert it to our vml coordinate system, 
     * then set the node's position, size, and local coordinate system.
     *   
     * Parameters:
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     */
    setNodeDimension: function(node, geometry) {

        var bbox = geometry.getBounds();
        if(bbox) {
            var resolution = this.getResolution();
        
            var scaledBox = 
                new HGIS.Bounds(((bbox.left - this.featureDx)/resolution - this.offset.x) | 0,
                                      (bbox.bottom/resolution - this.offset.y) | 0,
                                      ((bbox.right - this.featureDx)/resolution - this.offset.x) | 0,
                                      (bbox.top/resolution - this.offset.y) | 0);
            
            // Set the internal coordinate system to draw the path
            node.style.left = scaledBox.left + "px";
            node.style.top = scaledBox.top + "px";
            node.style.width = scaledBox.getWidth() + "px";
            node.style.height = scaledBox.getHeight() + "px";
    
            node.coordorigin = scaledBox.left + " " + scaledBox.top;
            node.coordsize = scaledBox.getWidth()+ " " + scaledBox.getHeight();
        }
    },
    
    /** 
     * Method: dashStyle
     * 
     * Parameters:
     * style - {Object}
     * 
     * Returns:
     * {String} A VML compliant 'stroke-dasharray' value
     */
    dashStyle: function(style) {
        var dash = style.strokeDashstyle;
        switch (dash) {
            case 'solid':
            case 'dot':
            case 'dash':
            case 'dashdot':
            case 'longdash':
            case 'longdashdot':
                return dash;
            default:
                // very basic guessing of dash style patterns
                var parts = dash.split(/[ ,]/);
                if (parts.length == 2) {
                    if (1*parts[0] >= 2*parts[1]) {
                        return "longdash";
                    }
                    return (parts[0] == 1 || parts[1] == 1) ? "dot" : "dash";
                } else if (parts.length == 4) {
                    return (1*parts[0] >= 2*parts[1]) ? "longdashdot" :
                        "dashdot";
                }
                return "solid";
        }
    },

    /**
     * Method: createNode
     * Create a new node
     *
     * Parameters:
     * type - {String} Kind of node to draw
     * id - {String} Id for node
     *
     * Returns:
     * {DOMElement} A new node of the given type and id
     */
    createNode: function(type, id) {
        var node = document.createElement(type);
        if (id) {
            node.id = id;
        }
        
        // IE hack to make elements unselectable, to prevent 'blue flash'
        // while dragging vectors; #1410
        node.unselectable = 'on';
        node.onselectstart = HGIS.Function.False;
        
        return node;    
    },
    
    /**
     * Method: nodeTypeCompare
     * Determine whether a node is of a given type
     *
     * Parameters:
     * node - {DOMElement} An VML element
     * type - {String} Kind of node
     *
     * Returns:
     * {Boolean} Whether or not the specified node is of the specified type
     */
    nodeTypeCompare: function(node, type) {

        //split type
        var subType = type;
        var splitIndex = subType.indexOf(":");
        if (splitIndex != -1) {
            subType = subType.substr(splitIndex+1);
        }

        //split nodeName
        var nodeName = node.nodeName;
        splitIndex = nodeName.indexOf(":");
        if (splitIndex != -1) {
            nodeName = nodeName.substr(splitIndex+1);
        }

        return (subType == nodeName);
    },

    /**
     * Method: createRenderRoot
     * Create the renderer root
     *
     * Returns:
     * {DOMElement} The specific render engine's root element
     */
    createRenderRoot: function() {
        return this.nodeFactory(this.container.id + "_vmlRoot", "div");
    },

    /**
     * Method: createRoot
     * Create the main root element
     * 
     * Parameters:
     * suffix - {String} suffix to append to the id
     *
     * Returns:
     * {DOMElement}
     */
    createRoot: function(suffix) {
        return this.nodeFactory(this.container.id + suffix, "olv:group");
    },
    
    /**************************************
     *                                    *
     *     GEOMETRY DRAWING FUNCTIONS     *
     *                                    *
     **************************************/
    
    /**
     * Method: drawPoint
     * Render a point
     * 
     * Parameters:
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement} or false if the point could not be drawn
     */
    drawPoint: function(node, geometry) {
        return this.drawCircle(node, geometry, 1);
    },

    /**
     * Method: drawCircle
     * Render a circle.
     * Size and Center a circle given geometry (x,y center) and radius
     * 
     * Parameters:
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * radius - {float}
     * 
     * Returns:
     * {DOMElement} or false if the circle could not ne drawn
     */
    drawCircle: function(node, geometry, radius) {
        if(!isNaN(geometry.x)&& !isNaN(geometry.y)) {
            var resolution = this.getResolution();

            node.style.left = ((((geometry.x - this.featureDx) /resolution - this.offset.x) | 0) - radius) + "px";
            node.style.top = (((geometry.y /resolution - this.offset.y) | 0) - radius) + "px";
    
            var diameter = radius * 2;
            
            node.style.width = diameter + "px";
            node.style.height = diameter + "px";
            return node;
        }
        return false;
    },


    /**
     * Method: drawLineString
     * Render a linestring.
     * 
     * Parameters:
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement}
     */
    drawLineString: function(node, geometry) {
        return this.drawLine(node, geometry, false);
    },

    /**
     * Method: drawLinearRing
     * Render a linearring
     * 
     * Parameters:
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement}
     */
    drawLinearRing: function(node, geometry) {
        return this.drawLine(node, geometry, true);
    },

    /**
     * Method: DrawLine
     * Render a line.
     * 
     * Parameters:
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * closeLine - {Boolean} Close the line? (make it a ring?)
     * 
     * Returns:
     * {DOMElement}
     */
    drawLine: function(node, geometry, closeLine) {

        this.setNodeDimension(node, geometry);

        var resolution = this.getResolution();
        var numComponents = geometry.components.length;
        var parts = new Array(numComponents);

        var comp, x, y;
        for (var i = 0; i < numComponents; i++) {
            comp = geometry.components[i];
            x = ((comp.x - this.featureDx)/resolution - this.offset.x) | 0;
            y = (comp.y/resolution - this.offset.y) | 0;
            parts[i] = " " + x + "," + y + " l ";
        }
        var end = (closeLine) ? " x e" : " e";
        node.path = "m" + parts.join("") + end;
        return node;
    },

    /**
     * Method: drawPolygon
     * Render a polygon
     * 
     * Parameters:
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement}
     */
    drawPolygon: function(node, geometry) {
        this.setNodeDimension(node, geometry);

        var resolution = this.getResolution();
    
        var path = [];
        var j, jj, points, area, first, second, i, ii, comp, pathComp, x, y;
        for (j=0, jj=geometry.components.length; j<jj; j++) {
            path.push("m");
            points = geometry.components[j].components;
            // we only close paths of interior rings with area
            area = (j === 0);
            first = null;
            second = null;
            for (i=0, ii=points.length; i<ii; i++) {
                comp = points[i];
                x = ((comp.x - this.featureDx) / resolution - this.offset.x) | 0;
                y = (comp.y / resolution - this.offset.y) | 0;
                pathComp = " " + x + "," + y;
                path.push(pathComp);
                if (i==0) {
                    path.push(" l");
                }
                if (!area) {
                    // IE improperly renders sub-paths that have no area.
                    // Instead of checking the area of every ring, we confirm
                    // the ring has at least three distinct points.  This does
                    // not catch all non-zero area cases, but it greatly improves
                    // interior ring digitizing and is a minor performance hit
                    // when rendering rings with many points.
                    if (!first) {
                        first = pathComp;
                    } else if (first != pathComp) {
                        if (!second) {
                            second = pathComp;
                        } else if (second != pathComp) {
                            // stop looking
                            area = true;
                        }
                    }
                }
            }
            path.push(area ? " x " : " ");
        }
        path.push("e");
        node.path = path.join("");
        return node;
    },

    /**
     * Method: drawRectangle
     * Render a rectangle
     * 
     * Parameters:
     * node - {DOMElement}
     * geometry - {<HGIS.Geometry>}
     * 
     * Returns:
     * {DOMElement}
     */
    drawRectangle: function(node, geometry) {
        var resolution = this.getResolution();
    
        node.style.left = (((geometry.x - this.featureDx)/resolution - this.offset.x) | 0) + "px";
        node.style.top = ((geometry.y/resolution - this.offset.y) | 0) + "px";
        node.style.width = ((geometry.width/resolution) | 0) + "px";
        node.style.height = ((geometry.height/resolution) | 0) + "px";
        
        return node;
    },
    
    /**
     * Method: drawText
     * This method is only called by the renderer itself.
     * 
     * Parameters: 
     * featureId - {String}
     * style -
     * location - {<HGIS.Geometry.Point>}
     */
    drawText: function(featureId, style, location) {
        var label = this.nodeFactory(featureId + this.LABEL_ID_SUFFIX, "olv:rect");
        var textbox = this.nodeFactory(featureId + this.LABEL_ID_SUFFIX + "_textbox", "olv:textbox");
        
        var resolution = this.getResolution();
        label.style.left = (((location.x - this.featureDx)/resolution - this.offset.x) | 0) + "px";
        label.style.top = ((location.y/resolution - this.offset.y) | 0) + "px";
        label.style.flip = "y";

        textbox.innerText = style.label;
        
        //显示背景
		if(style.labelBackgroundColor){
		  textbox.style.backgroundColor = style.labelBackgroundColor;
		}
		if(style.labelBorderColor ||style.labelBorderSize){
		    textbox.style.border = "solid" + 
			 (style.labelBorderSize? style.labelBorderSize:"1px") + " " + 
			 (style.labelBorderColor? style.labelBorderColor:"#000000");			
		}

        if (style.cursor != "inherit" && style.cursor != null) {
            textbox.style.cursor = style.cursor;
        }
        if (style.fontColor) {
            textbox.style.color = style.fontColor;
        }
        if (style.fontOpacity) {
            textbox.style.filter = 'alpha(opacity=' + (style.fontOpacity * 100) + ')';
        }
        if (style.fontFamily) {
            textbox.style.fontFamily = style.fontFamily;
        }
        if (style.fontSize) {
            textbox.style.fontSize = style.fontSize;
        }
        if (style.fontWeight) {
            textbox.style.fontWeight = style.fontWeight;
        }
        if (style.fontStyle) {
            textbox.style.fontStyle = style.fontStyle;
        }
        if(style.labelSelect === true) {
            label._featureId = featureId;
            textbox._featureId = featureId;
            textbox._geometry = location;
            textbox._geometryClass = location.CLASS_NAME;
        }
        textbox.style.whiteSpace = "nowrap";
        // fun with IE: IE7 in standards compliant mode does not display any
        // text with a left inset of 0. So we set this to 1px and subtract one
        // pixel later when we set label.style.left
        textbox.inset = "1px,0px,0px,0px";

        if(!label.parentNode) {
            label.appendChild(textbox);
            this.textRoot.appendChild(label);
        }

        var align = style.labelAlign || "cm";
        if (align.length == 1) {
            align += "m";
        }
        var xshift = textbox.clientWidth *
            (HGIS.Renderer.VML.LABEL_SHIFT[align.substr(0,1)]);
        var yshift = textbox.clientHeight *
            (HGIS.Renderer.VML.LABEL_SHIFT[align.substr(1,1)]);
        label.style.left = parseInt(label.style.left)-xshift-1+"px";
        label.style.top = parseInt(label.style.top)+yshift+"px";
        
    },
    
    /**
     * Method: moveRoot
     * moves this renderer's root to a different renderer.
     * 
     * Parameters:
     * renderer - {<HGIS.Renderer>} target renderer for the moved root
     * root - {DOMElement} optional root node. To be used when this renderer
     *     holds roots from multiple layers to tell this method which one to
     *     detach
     * 
     * Returns:
     * {Boolean} true if successful, false otherwise
     */
    moveRoot: function(renderer) {
        var layer = this.map.getLayer(renderer.container.id);
        if(layer instanceof HGIS.Layer.Vector.RootContainer) {
            layer = this.map.getLayer(this.container.id);
        }
        layer && layer.renderer.clear();
        HGIS.Renderer.Elements.prototype.moveRoot.apply(this, arguments);
        layer && layer.redraw();
    },
    
    /**
     * Method: importSymbol
     * add a new symbol definition from the rendererer's symbol hash
     * 
     * Parameters:
     * graphicName - {String} name of the symbol to import
     * 
     * Returns:
     * {Object} - hash of {DOMElement} "symbol" and {Number} "size"
     */      
    importSymbol: function (graphicName)  {
        var id = this.container.id + "-" + graphicName;
        
        // check if symbol already exists in the cache
        var cache = this.symbolCache[id];
        if (cache) {
            return cache;
        }
        
        var symbol = HGIS.Renderer.symbol[graphicName];
        if (!symbol) {
            throw new Error(graphicName + ' is not a valid symbol name');
        }

        var symbolExtent = new HGIS.Bounds(
                                    Number.MAX_VALUE, Number.MAX_VALUE, 0, 0);
        
        var pathitems = ["m"];
        for (var i=0; i<symbol.length; i=i+2) {
            var x = symbol[i];
            var y = symbol[i+1];
            symbolExtent.left = Math.min(symbolExtent.left, x);
            symbolExtent.bottom = Math.min(symbolExtent.bottom, y);
            symbolExtent.right = Math.max(symbolExtent.right, x);
            symbolExtent.top = Math.max(symbolExtent.top, y);

            pathitems.push(x);
            pathitems.push(y);
            if (i == 0) {
                pathitems.push("l");
            }
        }
        pathitems.push("x e");
        var path = pathitems.join(" ");

        var diff = (symbolExtent.getWidth() - symbolExtent.getHeight()) / 2;
        if(diff > 0) {
            symbolExtent.bottom = symbolExtent.bottom - diff;
            symbolExtent.top = symbolExtent.top + diff;
        } else {
            symbolExtent.left = symbolExtent.left + diff;
            symbolExtent.right = symbolExtent.right - diff;
        }
        
        cache = {
            path: path,
            size: symbolExtent.getWidth(), // equals getHeight() now
            left: symbolExtent.left,
            bottom: symbolExtent.bottom
        };
        this.symbolCache[id] = cache;
        
        return cache;
    },
    
    CLASS_NAME: "HGIS.Renderer.VML"
});

/**
 * Constant: HGIS.Renderer.VML.LABEL_SHIFT
 * {Object}
 */
HGIS.Renderer.VML.LABEL_SHIFT = {
    "l": 0,
    "c": .5,
    "r": 1,
    "t": 0,
    "m": .5,
    "b": 1
};
/* ======================================================================
    HGIS/Control/CacheRead.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 */

/**
 * Class: HGIS.Control.CacheRead
 * A control for using image tiles cached with <HGIS.Control.CacheWrite>
 * from the browser's local storage.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.CacheRead = HGIS.Class(HGIS.Control, {
    
    /**
     * APIProperty: fetchEvent
     * {String} The layer event to listen to for replacing remote resource tile
     *     URLs with cached data URIs. Supported values are "tileerror" (try
     *     remote first, fall back to cached) and "tileloadstart" (try cache
     *     first, fall back to remote). Default is "tileloadstart".
     *
     *     Note that "tileerror" will not work for CORS enabled images (see
     *     https://developer.mozilla.org/en/CORS_Enabled_Image), i.e. layers
     *     configured with a <HGIS.Tile.Image.crossOriginKeyword> in
     *     <HGIS.Layer.Grid.tileOptions>.
     */
    fetchEvent: "tileloadstart",
    
    /**
     * APIProperty: layers
     * {Array(<HGIS.Layer.Grid>)}. Optional. If provided, only these
     *     layers will receive tiles from the cache.
     */
    layers: null,
    
    /**
     * APIProperty: autoActivate
     * {Boolean} Activate the control when it is added to a map.  Default is
     *     true.
     */
    autoActivate: true,

    /**
     * Constructor: HGIS.Control.CacheRead
     *
     * Parameters:
     * options - {Object} Object with API properties for this control
     */
    
    /** 
     * Method: setMap
     * Set the map property for the control. 
     * 
     * Parameters:
     * map - {<HGIS.Map>} 
     */
    setMap: function(map) {
        HGIS.Control.prototype.setMap.apply(this, arguments);
        var i, layers = this.layers || map.layers;
        for (i=layers.length-1; i>=0; --i) {
            this.addLayer({layer: layers[i]});
        }
        if (!this.layers) {
            map.events.on({
                addlayer: this.addLayer,
                removeLayer: this.removeLayer,
                scope: this
            });
        }
    },
    
    /**
     * Method: addLayer
     * Adds a layer to the control. Once added, tiles requested for this layer
     *     will be cached.
     *
     * Parameters:
     * evt - {Object} Object with a layer property referencing an
     *     <HGIS.Layer> instance
     */
    addLayer: function(evt) {
        evt.layer.events.register(this.fetchEvent, this, this.fetch);        
    },
    
    /**
     * Method: removeLayer
     * Removes a layer from the control. Once removed, tiles requested for this
     *     layer will no longer be cached.
     *
     * Parameters:
     * evt - {Object} Object with a layer property referencing an
     *     <HGIS.Layer> instance
     */
    removeLayer: function(evt) {
        evt.layer.events.unregister(this.fetchEvent, this, this.fetch);
    },
    
    /**
     * Method: fetch
     * Listener to the <fetchEvent> event. Replaces a tile's url with a data
     * URI from the cache.
     *
     * Parameters:
     * evt - {Object} Event object with a tile property.
     */
    fetch: function(evt) {
        if (this.active && window.localStorage &&
                evt.tile instanceof HGIS.Tile.Image) {
            var tile = evt.tile,
                url = tile.url;
            // deal with modified tile urls when both CacheWrite and CacheRead
            // are active
            if (!tile.layer.crossOriginKeyword && HGIS.ProxyHost &&
                    url.indexOf(HGIS.ProxyHost) === 0) {
                url = HGIS.Control.CacheWrite.urlMap[url];        
            }
            var dataURI = window.localStorage.getItem("olCache_" + url);
            if (dataURI) {
                tile.url = dataURI;
                if (evt.type === "tileerror") {
                    tile.setImgSrc(dataURI);
                }
            }
        }
    },
    
    /**
     * Method: destroy
     * The destroy method is used to perform any clean up before the control
     * is dereferenced.  Typically this is where event listeners are removed
     * to prevent memory leaks.
     */
    destroy: function() {
        if (this.layers || this.map) {
            var i, layers = this.layers || this.map.layers;
            for (i=layers.length-1; i>=0; --i) {
                this.removeLayer({layer: layers[i]});
            }
        }
        if (this.map) {
            this.map.events.un({
                addlayer: this.addLayer,
                removeLayer: this.removeLayer,
                scope: this
            });
        }
        HGIS.Control.prototype.destroy.apply(this, arguments);
    },
    
    CLASS_NAME: "HGIS.Control.CacheRead"
});
/* ======================================================================
    HGIS/Protocol/WFS/v1_0_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Protocol/WFS/v1.js
 * @requires HGIS/Format/WFST/v1_0_0.js
 */

/**
 * Class: HGIS.Protocol.WFS.v1_0_0
 * A WFS v1.0.0 protocol for vector layers.  Create a new instance with the
 *     <HGIS.Protocol.WFS.v1_0_0> constructor.
 *
 * Inherits from:
 *  - <HGIS.Protocol.WFS.v1>
 */
HGIS.Protocol.WFS.v1_0_0 = HGIS.Class(HGIS.Protocol.WFS.v1, {
    
    /**
     * Property: version
     * {String} WFS version number.
     */
    version: "1.0.0",
    
    /**
     * Constructor: HGIS.Protocol.WFS.v1_0_0
     * A class for giving layers WFS v1.0.0 protocol.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties:
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (optional).
     * featurePrefix - {String} Feature namespace alias (optional - only used
     *     if featureNS is provided).  Default is 'feature'.
     * geometryName - {String} Name of geometry attribute.  Default is 'the_geom'.
     */
   
    CLASS_NAME: "HGIS.Protocol.WFS.v1_0_0" 
});
/* ======================================================================
    HGIS/Format/WMSGetFeatureInfo.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 */

/**
 * Class: HGIS.Format.WMSGetFeatureInfo
 * Class to read GetFeatureInfo responses from Web Mapping Services
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.WMSGetFeatureInfo = HGIS.Class(HGIS.Format.XML, {

    /**
     * APIProperty: layerIdentifier
     * {String} All xml nodes containing this search criteria will populate an
     *     internal array of layer nodes.
     */ 
    layerIdentifier: '_layer',

    /**
     * APIProperty: featureIdentifier
     * {String} All xml nodes containing this search criteria will populate an 
     *     internal array of feature nodes for each layer node found.
     */
    featureIdentifier: '_feature',

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * Property: gmlFormat
     * {<HGIS.Format.GML>} internal GML format for parsing geometries
     *     in msGMLOutput
     */
    gmlFormat: null,

    /**
     * Constructor: HGIS.Format.WMSGetFeatureInfo
     * Create a new parser for WMS GetFeatureInfo responses
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Read WMS GetFeatureInfo data from a string, and return an array of features
     *
     * Parameters:
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array(<HGIS.Feature.Vector>)} An array of features.
     */
    read: function(data) {
        var result;
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        var root = data.documentElement;
        if(root) {
            var scope = this;
            var read = this["read_" + root.nodeName];
            if(read) {
                result = read.call(this, root);
            } else {
                // fall-back to GML since this is a common output format for WMS
                // GetFeatureInfo responses
                result = new HGIS.Format.GML((this.options ? this.options : {})).read(data);
            }
        } else {
            result = data;
        }
        return result;
    },
    
    
    /**
     * Method: read_msGMLOutput
     * Parse msGMLOutput nodes.
     *
     * Parameters:
     * data - {DOMElement}
     *
     * Returns:
     * {Array}
     */
    read_msGMLOutput: function(data) {
        var response = [];
        var layerNodes = this.getSiblingNodesByTagCriteria(data,
            this.layerIdentifier);
        if (layerNodes) {
            for (var i=0, len=layerNodes.length; i<len; ++i) {
                var node = layerNodes[i];
                var layerName = node.nodeName;
                if (node.prefix) {
                    layerName = layerName.split(':')[1];
                }
                var layerName = layerName.replace(this.layerIdentifier, '');
                var featureNodes = this.getSiblingNodesByTagCriteria(node, 
                    this.featureIdentifier);
                if (featureNodes) {
                    for (var j = 0; j < featureNodes.length; j++) {
                        var featureNode = featureNodes[j];
                        var geomInfo = this.parseGeometry(featureNode);
                        var attributes = this.parseAttributes(featureNode);
                        var feature = new HGIS.Feature.Vector(geomInfo.geometry, 
                            attributes, null);
                        feature.bounds = geomInfo.bounds;
                        feature.type = layerName;
                        response.push(feature);
                    }
                }
            }
        }
        return response;
    },
    
    /**
     * Method: read_FeatureInfoResponse
     * Parse FeatureInfoResponse nodes.
     *
     * Parameters:
     * data - {DOMElement}
     *
     * Returns:
     * {Array}
     */
    read_FeatureInfoResponse: function(data) {
        var response = [];
        var featureNodes = this.getElementsByTagNameNS(data, '*',
            'FIELDS');

        for(var i=0, len=featureNodes.length;i<len;i++) {
            var featureNode = featureNodes[i];
            var geom = null;

            // attributes can be actual attributes on the FIELDS tag, 
            // or FIELD children
            var attributes = {};
            var j;
            var jlen = featureNode.attributes.length;
            if (jlen > 0) {
                for(j=0; j<jlen; j++) {
                    var attribute = featureNode.attributes[j];
                    attributes[attribute.nodeName] = attribute.nodeValue;
                }
            } else {
                var nodes = featureNode.childNodes;
                for (j=0, jlen=nodes.length; j<jlen; ++j) {
                    var node = nodes[j];
                    if (node.nodeType != 3) {
                        attributes[node.getAttribute("name")] = 
                            node.getAttribute("value");
                    }
                }
            }

            response.push(
                new HGIS.Feature.Vector(geom, attributes, null)
            );
        }
        return response;
    },

    /**
     * Method: getSiblingNodesByTagCriteria
     * Recursively searches passed xml node and all it's descendant levels for 
     *     nodes whose tagName contains the passed search string. This returns an 
     *     array of all sibling nodes which match the criteria from the highest 
     *     hierarchial level from which a match is found.
     * 
     * Parameters:
     * node - {DOMElement} An xml node
     * criteria - {String} Search string which will match some part of a tagName 
     *                                       
     * Returns:
     * Array({DOMElement}) An array of sibling xml nodes
     */                
    getSiblingNodesByTagCriteria: function(node, criteria){
        var nodes = [];
        var children, tagName, n, matchNodes, child;
        if (node && node.hasChildNodes()) {
            children = node.childNodes;
            n = children.length;

            for(var k=0; k<n; k++){
                child = children[k];
                while (child && child.nodeType != 1) {
                    child = child.nextSibling;
                    k++;
                }
                tagName = (child ? child.nodeName : '');
                if (tagName.length > 0 && tagName.indexOf(criteria) > -1) {
                    nodes.push(child);
                } else {
                    matchNodes = this.getSiblingNodesByTagCriteria(
                        child, criteria);

                    if(matchNodes.length > 0){
                        (nodes.length == 0) ? 
                            nodes = matchNodes : nodes.push(matchNodes);
                    }
                }
            }

        }
        return nodes;
    },

    /**
     * Method: parseAttributes
     *
     * Parameters:
     * node - {<DOMElement>}
     *
     * Returns:
     * {Object} An attributes object.
     * 
     * Notes:
     * Assumes that attributes are direct child xml nodes of the passed node
     * and contain only a single text node. 
     */    
    parseAttributes: function(node){
        var attributes = {};
        if (node.nodeType == 1) {
            var children = node.childNodes;
            var n = children.length;
            for (var i = 0; i < n; ++i) {
                var child = children[i];
                if (child.nodeType == 1) {
                    var grandchildren = child.childNodes;
                    var name = (child.prefix) ?
                        child.nodeName.split(":")[1] : child.nodeName;
                    if (grandchildren.length == 0) {
                        attributes[name] = null;
                    } else if (grandchildren.length == 1) {
                        var grandchild = grandchildren[0];
                        if (grandchild.nodeType == 3 ||
                            grandchild.nodeType == 4) {
                            var value = grandchild.nodeValue.replace(
                                this.regExes.trimSpace, "");
                            attributes[name] = value;
                        }
                    }
                }
            }
        }
        return attributes;
    },

    /**
     * Method: parseGeometry
     * Parse the geometry and the feature bounds out of the node using 
     *     Format.GML
     *
     * Parameters:
     * node - {<DOMElement>}
     *
     * Returns:
     * {Object} An object containing the geometry and the feature bounds
    */
    parseGeometry: function(node) {
        // we need to use the old Format.GML parser since we do not know the 
        // geometry name
        if (!this.gmlFormat) {
            this.gmlFormat = new HGIS.Format.GML();
        }
        var feature = this.gmlFormat.parseFeature(node);
        var geometry, bounds = null;
        if (feature) {
            geometry = feature.geometry && feature.geometry.clone();
            bounds = feature.bounds && feature.bounds.clone();
            feature.destroy();
        }
        return {geometry: geometry, bounds: bounds};
    },

    CLASS_NAME: "HGIS.Format.WMSGetFeatureInfo"
    
});
/* ======================================================================
    HGIS/Control/WMTSGetFeatureInfo.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Control.js
 * @requires HGIS/Handler/Click.js
 * @requires HGIS/Handler/Hover.js
 * @requires HGIS/Request.js
 * @requires HGIS/Format/WMSGetFeatureInfo.js
 */

/**
 * Class: HGIS.Control.WMTSGetFeatureInfo
 * The WMTSGetFeatureInfo control uses a WMTS query to get information about a 
 *     point on the map.  The information may be in a display-friendly format 
 *     such as HTML, or a machine-friendly format such as GML, depending on the 
 *     server's capabilities and the client's configuration.  This control 
 *     handles click or hover events, attempts to parse the results using an 
 *     HGIS.Format, and fires a 'getfeatureinfo' event for each layer
 *     queried.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.WMTSGetFeatureInfo = HGIS.Class(HGIS.Control, {

   /**
     * APIProperty: hover
     * {Boolean} Send GetFeatureInfo requests when mouse stops moving.
     *     Default is false.
     */
    hover: false,
    
    /**
     * Property: requestEncoding
     * {String} One of "KVP" or "REST".  Only KVP encoding is supported at this 
     *     time.
     */
    requestEncoding: "KVP",

    /**
     * APIProperty: drillDown
     * {Boolean} Drill down over all WMTS layers in the map. When
     *     using drillDown mode, hover is not possible.  A getfeatureinfo event
     *     will be fired for each layer queried.
     */
    drillDown: false,

    /**
     * APIProperty: maxFeatures
     * {Integer} Maximum number of features to return from a WMTS query. This
     *     sets the feature_count parameter on WMTS GetFeatureInfo
     *     requests.
     */
    maxFeatures: 10,

    /** APIProperty: clickCallback
     *  {String} The click callback to register in the
     *      {<HGIS.Handler.Click>} object created when the hover
     *      option is set to false. Default is "click".
     */
    clickCallback: "click",
    
    /**
     * Property: layers
     * {Array(<HGIS.Layer.WMTS>)} The layers to query for feature info.
     *     If omitted, all map WMTS layers will be considered.
     */
    layers: null,

    /**
     * APIProperty: queryVisible
     * {Boolean} Filter out hidden layers when searching the map for layers to 
     *     query.  Default is true.
     */
    queryVisible: true,

    /**
     * Property: infoFormat
     * {String} The mimetype to request from the server
     */
    infoFormat: 'text/html',
    
    /**
     * Property: vendorParams
     * {Object} Additional parameters that will be added to the request, for
     * WMTS implementations that support them. This could e.g. look like
     * (start code)
     * {
     *     radius: 5
     * }
     * (end)
     */
    vendorParams: {},
    
    /**
     * Property: format
     * {<HGIS.Format>} A format for parsing GetFeatureInfo responses.
     *     Default is <HGIS.Format.WMSGetFeatureInfo>.
     */
    format: null,
    
    /**
     * Property: formatOptions
     * {Object} Optional properties to set on the format (if one is not provided
     *     in the <format> property.
     */
    formatOptions: null,

    /**
     * APIProperty: handlerOptions
     * {Object} Additional options for the handlers used by this control, e.g.
     * (start code)
     * {
     *     "click": {delay: 100},
     *     "hover": {delay: 300}
     * }
     * (end)
     */
    
    /**
     * Property: handler
     * {Object} Reference to the <HGIS.Handler> for this control
     */
    handler: null,
    
    /**
     * Property: hoverRequest
     * {<HGIS.Request>} contains the currently running hover request
     *     (if any).
     */
    hoverRequest: null,
    
    /** 
     * APIProperty: events
     * {<HGIS.Events>} Events instance for listeners and triggering
     *     control specific events.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types (in addition to those from <HGIS.Control.events>):
     * beforegetfeatureinfo - Triggered before each request is sent.
     *      The event object has an *xy* property with the position of the 
     *      mouse click or hover event that triggers the request and a *layer*
     *      property referencing the layer about to be queried.  If a listener
     *      returns false, the request will not be issued.
     * getfeatureinfo - Triggered when a GetFeatureInfo response is received.
     *      The event object has a *text* property with the body of the
     *      response (String), a *features* property with an array of the
     *      parsed features, an *xy* property with the position of the mouse
     *      click or hover event that triggered the request, a *layer* property
     *      referencing the layer queried and a *request* property with the 
     *      request itself. If drillDown is set to true, one event will be fired
     *      for each layer queried.
     * exception - Triggered when a GetFeatureInfo request fails (with a 
     *      status other than 200) or whenparsing fails.  Listeners will receive 
     *      an event with *request*, *xy*, and *layer*  properties.  In the case 
     *      of a parsing error, the event will also contain an *error* property.
     */
    
    /** 
     * Property: pending
     * {Number}  The number of pending requests.
     */
    pending: 0,

    /**
     * Constructor: <HGIS.Control.WMTSGetFeatureInfo>
     *
     * Parameters:
     * options - {Object} 
     */
    initialize: function(options) {
        options = options || {};
        options.handlerOptions = options.handlerOptions || {};

        HGIS.Control.prototype.initialize.apply(this, [options]);
        
        if (!this.format) {
            this.format = new HGIS.Format.WMSGetFeatureInfo(
                options.formatOptions
            );
        }
        
        if (this.drillDown === true) {
            this.hover = false;
        }

        if (this.hover) {
            this.handler = new HGIS.Handler.Hover(
                this, {
                    move: this.cancelHover,
                    pause: this.getInfoForHover
                },
                HGIS.Util.extend(
                    this.handlerOptions.hover || {}, {delay: 250}
                )
            );
        } else {
            var callbacks = {};
            callbacks[this.clickCallback] = this.getInfoForClick;
            this.handler = new HGIS.Handler.Click(
                this, callbacks, this.handlerOptions.click || {}
            );
        }
    },

    /**
     * Method: getInfoForClick 
     * Called on click
     *
     * Parameters:
     * evt - {<HGIS.Event>} 
     */
    getInfoForClick: function(evt) {
        this.request(evt.xy, {});
    },
   
    /**
     * Method: getInfoForHover
     * Pause callback for the hover handler
     *
     * Parameters:
     * evt - {Object}
     */
    getInfoForHover: function(evt) {
        this.request(evt.xy, {hover: true});
    },

    /**
     * Method: cancelHover
     * Cancel callback for the hover handler
     */
    cancelHover: function() {
        if (this.hoverRequest) {
            --this.pending;
            if (this.pending <= 0) {
                HGIS.Element.removeClass(this.map.viewPortDiv, "olCursorWait");
                this.pending = 0;
            }            
            this.hoverRequest.abort();
            this.hoverRequest = null;
        }
    },

    /**
     * Method: findLayers
     * Internal method to get the layers, independent of whether we are
     *     inspecting the map or using a client-provided array
     */
    findLayers: function() {
        var candidates = this.layers || this.map.layers;
        var layers = [];
        var layer;
        for (var i=candidates.length-1; i>=0; --i) {
            layer = candidates[i];
            if (layer instanceof HGIS.Layer.WMTS &&
                layer.requestEncoding === this.requestEncoding &&
                (!this.queryVisible || layer.getVisibility())) {
                layers.push(layer);
                if (!this.drillDown || this.hover) {
                    break;
                }
            }
        }
        return layers;
    },
    
    /**
     * Method: buildRequestOptions
     * Build an object with the relevant options for the GetFeatureInfo request.
     *
     * Parameters:
     * layer - {<HGIS.Layer.WMTS>} A WMTS layer.
     * xy - {<HGIS.Pixel>} The position on the map where the 
     *     mouse event occurred.
     */
    buildRequestOptions: function(layer, xy) {
        var loc = this.map.getLonLatFromPixel(xy);
        var getTileUrl = layer.getURL(
            new HGIS.Bounds(loc.lon, loc.lat, loc.lon, loc.lat)
        );
        var params = HGIS.Util.getParameters(getTileUrl);
        var tileInfo = layer.getTileInfo(loc);
        HGIS.Util.extend(params, {
            service: "WMTS",
            version: layer.version,
            request: "GetFeatureInfo",
            infoFormat: this.infoFormat,
            i: tileInfo.i,
            j: tileInfo.j
        });
        HGIS.Util.applyDefaults(params, this.vendorParams);
        return {
            url: HGIS.Util.isArray(layer.url) ? layer.url[0] : layer.url,
            params: HGIS.Util.upperCaseObject(params),
            callback: function(request) {
                this.handleResponse(xy, request, layer);
            },
            scope: this
        };
    },

    /**
     * Method: request
     * Sends a GetFeatureInfo request to the WMTS
     * 
     * Parameters:
     * xy - {<HGIS.Pixel>} The position on the map where the mouse event 
     *     occurred.
     * options - {Object} additional options for this method.
     * 
     * Valid options:
     * - *hover* {Boolean} true if we do the request for the hover handler
     */
    request: function(xy, options) {
        options = options || {};
        var layers = this.findLayers();
        if (layers.length > 0) {
            var issue, layer;
            for (var i=0, len=layers.length; i<len; i++) {
                layer = layers[i];
                issue = this.events.triggerEvent("beforegetfeatureinfo", {
                    xy: xy,
                    layer: layer
                });
                if (issue !== false) {
                    ++this.pending;
                    var requestOptions = this.buildRequestOptions(layer, xy);
                    var request = HGIS.Request.GET(requestOptions);
                    if (options.hover === true) {
                        this.hoverRequest = request;
                    }
                }
            }
            if (this.pending > 0) {
                HGIS.Element.addClass(this.map.viewPortDiv, "olCursorWait");
            }
        }
    },

    /**
     * Method: handleResponse
     * Handler for the GetFeatureInfo response.
     * 
     * Parameters:
     * xy - {<HGIS.Pixel>} The position on the map where the mouse event 
     *     occurred.
     * request - {XMLHttpRequest} The request object.
     * layer - {<HGIS.Layer.WMTS>} The queried layer.
     */
    handleResponse: function(xy, request, layer) {
        --this.pending;
        if (this.pending <= 0) {
            HGIS.Element.removeClass(this.map.viewPortDiv, "olCursorWait");
            this.pending = 0;
        }
        if (request.status && (request.status < 200 || request.status >= 300)) {
            this.events.triggerEvent("exception", {
                xy: xy, 
                request: request,
                layer: layer
            });
        } else {
            var doc = request.responseXML;
            if (!doc || !doc.documentElement) {
                doc = request.responseText;
            }
            var features, except;
            try {
                features = this.format.read(doc);
            } catch (error) {
                except = true;
                this.events.triggerEvent("exception", {
                    xy: xy,
                    request: request,
                    error: error,
                    layer: layer
                });
            }
            if (!except) {
                this.events.triggerEvent("getfeatureinfo", {
                    text: request.responseText,
                    features: features,
                    request: request,
                    xy: xy,
                    layer: layer
                });
            }
        }
    },

    CLASS_NAME: "HGIS.Control.WMTSGetFeatureInfo"
});
/* ======================================================================
    HGIS/Protocol/CSW/v2_0_2.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Protocol/CSW.js
 * @requires HGIS/Format/CSWGetRecords/v2_0_2.js
 */

/**
 * Class: HGIS.Protocol.CSW.v2_0_2
 * CS-W (Catalogue services for the Web) version 2.0.2 protocol.
 *
 * Inherits from:
 *  - <HGIS.Protocol>
 */
HGIS.Protocol.CSW.v2_0_2 = HGIS.Class(HGIS.Protocol, {

    /**
     * Property: formatOptions
     * {Object} Optional options for the format.  If a format is not provided,
     *     this property can be used to extend the default format options.
     */
    formatOptions: null,

    /**
     * Constructor: HGIS.Protocol.CSW.v2_0_2
     * A class for CSW version 2.0.2 protocol management.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     */
    initialize: function(options) {
        HGIS.Protocol.prototype.initialize.apply(this, [options]);
        if(!options.format) {
            this.format = new HGIS.Format.CSWGetRecords.v2_0_2(HGIS.Util.extend({
            }, this.formatOptions));
        }
    },

    /**
     * APIMethod: destroy
     * Clean up the protocol.
     */
    destroy: function() {
        if(this.options && !this.options.format) {
            this.format.destroy();
        }
        this.format = null;
        HGIS.Protocol.prototype.destroy.apply(this);
    },

    /**
     * Method: read
     * Construct a request for reading new records from the Catalogue.
     */
    read: function(options) {
        options = HGIS.Util.extend({}, options);
        HGIS.Util.applyDefaults(options, this.options || {});
        var response = new HGIS.Protocol.Response({requestType: "read"});

        var data = this.format.write(options.params || options);

        response.priv = HGIS.Request.POST({
            url: options.url,
            callback: this.createCallback(this.handleRead, response, options),
            params: options.params,
            headers: options.headers,
            data: data
        });

        return response;
    },

    /**
     * Method: handleRead
     * Deal with response from the read request.
     *
     * Parameters:
     * response - {<HGIS.Protocol.Response>} The response object to pass
     *     to the user callback.
     *     This response is given a code property, and optionally a data property.
     *     The latter represents the CSW records as returned by the call to
     *     the CSW format read method.
     * options - {Object} The user options passed to the read call.
     */
    handleRead: function(response, options) {
        if(options.callback) {
            var request = response.priv;
            if(request.status >= 200 && request.status < 300) {
                // success
                response.data = this.parseData(request);
                response.code = HGIS.Protocol.Response.SUCCESS;
            } else {
                // failure
                response.code = HGIS.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, response);
        }
    },

    /**
     * Method: parseData
     * Read HTTP response body and return records
     *
     * Parameters:
     * request - {XMLHttpRequest} The request object
     *
     * Returns:
     * {Object} The CSW records as returned by the call to the format read method.
     */
    parseData: function(request) {
        var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc || doc.length <= 0) {
            return null;
        }
        return this.format.read(doc);
    },

    CLASS_NAME: "HGIS.Protocol.CSW.v2_0_2"

});
/* ======================================================================
    HGIS/Format/WCSCapabilities/v1_1_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WCSCapabilities/v1.js
 * @requires HGIS/Format/OWSCommon/v1_1_0.js
 */

/**
 * Class: HGIS.Format.WCSCapabilities/v1_1_0
 * Read WCS Capabilities version 1.1.0.
 * 
 * Inherits from:
 *  - <HGIS.Format.WCSCapabilities.v1>
 */
HGIS.Format.WCSCapabilities.v1_1_0 = HGIS.Class(
    HGIS.Format.WCSCapabilities.v1, {

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        wcs: "http://www.opengis.net/wcs/1.1",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        ows: "http://www.opengis.net/ows/1.1"
    },

    /**
     * APIProperty: errorProperty
     * {String} Which property of the returned object to check for in order to
     * determine whether or not parsing has failed. In the case that the
     * errorProperty is undefined on the returned object, the document will be
     * run through an OGCExceptionReport parser.
     */
    errorProperty: "operationsMetadata",

    /**
     * Constructor: HGIS.Format.WCSCapabilities.v1_1_0
     * Create a new parser for WCS capabilities version 1.1.0.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wcs": HGIS.Util.applyDefaults({
            // In 1.0.0, this was WCS_Capabilties, in 1.1.0, it's Capabilities
            "Capabilities": function(node, obj) {           
                this.readChildNodes(node, obj);
            },
            "Contents": function(node, request) {
                request.contentMetadata = [];
                this.readChildNodes(node, request.contentMetadata);
            },
            "CoverageSummary": function(node, contentMetadata) {
                var coverageSummary = {};
                // Read the summary:
                this.readChildNodes(node, coverageSummary);   

                // Add it to the contentMetadata array:  
                contentMetadata.push(coverageSummary);                 
            },
            "Identifier": function(node, coverageSummary) {
                coverageSummary.identifier = this.getChildValue(node);
            },
            "Title": function(node, coverageSummary) {
              coverageSummary.title = this.getChildValue(node);
            },
            "Abstract": function(node, coverageSummary) {
                coverageSummary["abstract"] = this.getChildValue(node);
            },
            "SupportedCRS": function(node, coverageSummary) {
                var crs = this.getChildValue(node);
                if(crs) {
                    if(!coverageSummary.supportedCRS) { 
                        coverageSummary.supportedCRS = [];
                    }
                    coverageSummary.supportedCRS.push(crs);
                }
            },
            "SupportedFormat": function(node, coverageSummary) {
                var format = this.getChildValue(node);
                if(format) {
                    if(!coverageSummary.supportedFormat) { 
                        coverageSummary.supportedFormat = [];
                    }
                    coverageSummary.supportedFormat.push(format);
                }
            }
        }, HGIS.Format.WCSCapabilities.v1.prototype.readers["wcs"]),
        "ows": HGIS.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },

    CLASS_NAME: "HGIS.Format.WCSCapabilities.v1_1_0" 

});
/* ======================================================================
    HGIS/Control/Graticule.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Lang.js
 * @requires HGIS/Rule.js
 * @requires HGIS/StyleMap.js
 * @requires HGIS/Layer/Vector.js
 */

/**
 * Class: HGIS.Control.Graticule
 * The Graticule displays a grid of latitude/longitude lines reprojected on
 * the map.  
 * 
 * Inherits from:
 *  - <HGIS.Control>
 *  
 */
HGIS.Control.Graticule = HGIS.Class(HGIS.Control, {

    /**
     * APIProperty: autoActivate
     * {Boolean} Activate the control when it is added to a map. Default is
     *     true. 
     */
    autoActivate: true,
    
    /**
    * APIProperty: intervals
    * {Array(Float)} A list of possible graticule widths in degrees.
    */
    intervals: [ 45, 30, 20, 10, 5, 2, 1,
                 0.5, 0.2, 0.1, 0.05, 0.01, 
                 0.005, 0.002, 0.001 ],

    /**
     * APIProperty: displayInLayerSwitcher
     * {Boolean} Allows the Graticule control to be switched on and off by 
     *     LayerSwitcher control. Defaults is true.
     */
    displayInLayerSwitcher: true,

    /**
     * APIProperty: visible
     * {Boolean} should the graticule be initially visible (default=true)
     */
    visible: true,

    /**
     * APIProperty: numPoints
     * {Integer} The number of points to use in each graticule line.  Higher
     * numbers result in a smoother curve for projected maps 
     */
    numPoints: 50,

    /**
     * APIProperty: targetSize
     * {Integer} The maximum size of the grid in pixels on the map
     */
    targetSize: 200,

    /**
     * APIProperty: layerName
     * {String} The name to be displayed in the layer switcher, default is set 
     *     by {<HGIS.Lang>}.
     */
    layerName: null,

    /**
     * APIProperty: labelled
     * {Boolean} Should the graticule lines be labelled?. default=true
     */
    labelled: true,

    /**
     * APIProperty: labelFormat
     * {String} the format of the labels, default = 'dm'. See
     * <HGIS.Util.getFormattedLonLat> for other options.
     */
    labelFormat: 'dm',

    /**
     * APIProperty: lineSymbolizer
     * {symbolizer} the symbolizer used to render lines
     */
    lineSymbolizer: {
                strokeColor: "#333",
                strokeWidth: 1,
                strokeOpacity: 0.5
            },

    /**
     * APIProperty: labelSymbolizer
     * {symbolizer} the symbolizer used to render labels
     */
     labelSymbolizer: {},

    /**
     * Property: gratLayer
     * {<HGIS.Layer.Vector>} vector layer used to draw the graticule on
     */
    gratLayer: null,

    /**
     * Constructor: HGIS.Control.Graticule
     * Create a new graticule control to display a grid of latitude longitude
     * lines.
     * 
     * Parameters:
     * options - {Object} An optional object whose properties will be used
     *     to extend the control.
     */
    initialize: function(options) {
        options = options || {};
        options.layerName = options.layerName || HGIS.i18n("Graticule");
        HGIS.Control.prototype.initialize.apply(this, [options]);
        
        this.labelSymbolizer.stroke = false;
        this.labelSymbolizer.fill = false;
        this.labelSymbolizer.label = "${label}";
        this.labelSymbolizer.labelAlign = "${labelAlign}";
        this.labelSymbolizer.labelXOffset = "${xOffset}";
        this.labelSymbolizer.labelYOffset = "${yOffset}";
    },

    /**
     * APIMethod: destroy
     */
    destroy: function() {
        this.deactivate();        
        HGIS.Control.prototype.destroy.apply(this, arguments);        
        if (this.gratLayer) {
            this.gratLayer.destroy();
            this.gratLayer = null;
        }
    },
    
    /**
     * Method: draw
     *
     * initializes the graticule layer and does the initial update
     * 
     * Returns:
     * {DOMElement}
     */
    draw: function() {
        HGIS.Control.prototype.draw.apply(this, arguments);
        if (!this.gratLayer) {
            var gratStyle = new HGIS.Style({},{
                rules: [new HGIS.Rule({'symbolizer':
                    {"Point":this.labelSymbolizer,
                     "Line":this.lineSymbolizer}
                })]
            });
            this.gratLayer = new HGIS.Layer.Vector(this.layerName, {
                styleMap: new HGIS.StyleMap({'default':gratStyle}),
                visibility: this.visible,
                displayInLayerSwitcher: this.displayInLayerSwitcher
            });
        }
        return this.div;
    },

     /**
     * APIMethod: activate
     */
    activate: function() {
        if (HGIS.Control.prototype.activate.apply(this, arguments)) {
            this.map.addLayer(this.gratLayer);
            this.map.events.register('moveend', this, this.update);     
            this.update();
            return true;            
        } else {
            return false;
        }
    },
    
    /**
     * APIMethod: deactivate
     */
    deactivate: function() {
        if (HGIS.Control.prototype.deactivate.apply(this, arguments)) {
            this.map.events.unregister('moveend', this, this.update);
            this.map.removeLayer(this.gratLayer);
            return true;
        } else {
            return false;
        }
    },
    /**
     * Method: update
     *
     * calculates the grid to be displayed and actually draws it
     * 
     * Returns:
     * {DOMElement}
     */
    update: function() {
        //wait for the map to be initialized before proceeding
        var mapBounds = this.map.getExtent();
        if (!mapBounds) {
            return;
        }
        
        //clear out the old grid
        this.gratLayer.destroyFeatures();
        
        //get the projection objects required
        var llProj = new HGIS.Projection("EPSG:4326");
        var mapProj = this.map.getProjectionObject();
        var mapRes = this.map.getResolution();
        
        //if the map is in lon/lat, then the lines are straight and only one
        //point is required
        if (mapProj.proj && mapProj.proj.projName == "longlat") {
            this.numPoints = 1;
        }
        
        //get the map center in EPSG:4326
        var mapCenter = this.map.getCenter(); //lon and lat here are really map x and y
        var mapCenterLL = new HGIS.Pixel(mapCenter.lon, mapCenter.lat);
        HGIS.Projection.transform(mapCenterLL, mapProj, llProj);
        
        /* This block of code determines the lon/lat interval to use for the
         * grid by calculating the diagonal size of one grid cell at the map
         * center.  Iterates through the intervals array until the diagonal
         * length is less than the targetSize option.
         */
        //find lat/lon interval that results in a grid of less than the target size
        var testSq = this.targetSize*mapRes;
        testSq *= testSq;   //compare squares rather than doing a square root to save time
        var llInterval;
        for (var i=0; i<this.intervals.length; ++i) {
            llInterval = this.intervals[i];   //could do this for both x and y??
            var delta = llInterval/2;  
            var p1 = mapCenterLL.offset({x: -delta, y: -delta});  //test coords in EPSG:4326 space
            var p2 = mapCenterLL.offset({x: delta, y: delta});
            HGIS.Projection.transform(p1, llProj, mapProj); // convert them back to map projection
            HGIS.Projection.transform(p2, llProj, mapProj);
            var distSq = (p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y);
            if (distSq <= testSq) {
                break;
            }
        }
        //alert(llInterval);
        
        //round the LL center to an even number based on the interval
        mapCenterLL.x = Math.floor(mapCenterLL.x/llInterval)*llInterval;
        mapCenterLL.y = Math.floor(mapCenterLL.y/llInterval)*llInterval;
        //TODO adjust for minutses/seconds?
        
        /* The following 2 blocks calculate the nodes of the grid along a 
         * line of constant longitude (then latitiude) running through the
         * center of the map until it reaches the map edge.  The calculation
         * goes from the center in both directions to the edge.
         */
        //get the central longitude line, increment the latitude
        var iter = 0;
        var centerLonPoints = [mapCenterLL.clone()];
        var newPoint = mapCenterLL.clone();
        var mapXY;
        do {
            newPoint = newPoint.offset({x: 0, y: llInterval});
            mapXY = HGIS.Projection.transform(newPoint.clone(), llProj, mapProj);
            centerLonPoints.unshift(newPoint);
        } while (mapBounds.containsPixel(mapXY) && ++iter<1000);
        newPoint = mapCenterLL.clone();
        do {          
            newPoint = newPoint.offset({x: 0, y: -llInterval});
            mapXY = HGIS.Projection.transform(newPoint.clone(), llProj, mapProj);
            centerLonPoints.push(newPoint);
        } while (mapBounds.containsPixel(mapXY) && ++iter<1000);
        
        //get the central latitude line, increment the longitude
        iter = 0;
        var centerLatPoints = [mapCenterLL.clone()];
        newPoint = mapCenterLL.clone();
        do {
            newPoint = newPoint.offset({x: -llInterval, y: 0});
            mapXY = HGIS.Projection.transform(newPoint.clone(), llProj, mapProj);
            centerLatPoints.unshift(newPoint);
        } while (mapBounds.containsPixel(mapXY) && ++iter<1000);
        newPoint = mapCenterLL.clone();
        do {          
            newPoint = newPoint.offset({x: llInterval, y: 0});
            mapXY = HGIS.Projection.transform(newPoint.clone(), llProj, mapProj);
            centerLatPoints.push(newPoint);
        } while (mapBounds.containsPixel(mapXY) && ++iter<1000);
        
        //now generate a line for each node in the central lat and lon lines
        //first loop over constant longitude
        var lines = [];
        for(var i=0; i < centerLatPoints.length; ++i) {
            var lon = centerLatPoints[i].x;
            var pointList = [];
            var labelPoint = null;
            var latEnd = Math.min(centerLonPoints[0].y, 90);
            var latStart = Math.max(centerLonPoints[centerLonPoints.length - 1].y, -90);
            var latDelta = (latEnd - latStart)/this.numPoints;
            var lat = latStart;
            for(var j=0; j<= this.numPoints; ++j) {
                var gridPoint = new HGIS.Geometry.Point(lon,lat);
                gridPoint.transform(llProj, mapProj);
                pointList.push(gridPoint);
                lat += latDelta;
                if (gridPoint.y >= mapBounds.bottom && !labelPoint) {
                    labelPoint = gridPoint;
                }
            }
            if (this.labelled) {
                //keep track of when this grid line crosses the map bounds to set
                //the label position
                //labels along the bottom, add 10 pixel offset up into the map
                //TODO add option for labels on top
                var labelPos = new HGIS.Geometry.Point(labelPoint.x,mapBounds.bottom);
                var labelAttrs = {
                    value: lon,
                    label: this.labelled?HGIS.Util.getFormattedLonLat(lon, "lon", this.labelFormat):"",
                    labelAlign: "cb",
                    xOffset: 0,
                    yOffset: 2
                }; 
                this.gratLayer.addFeatures(new HGIS.Feature.Vector(labelPos,labelAttrs));
            }
            var geom = new HGIS.Geometry.LineString(pointList);
            lines.push(new HGIS.Feature.Vector(geom));
        }
        
        //now draw the lines of constant latitude
        for (var j=0; j < centerLonPoints.length; ++j) {
            lat = centerLonPoints[j].y;
            if (lat<-90 || lat>90) {  //latitudes only valid between -90 and 90
                continue;
            }
            var pointList = [];
            var lonStart = centerLatPoints[0].x;
            var lonEnd = centerLatPoints[centerLatPoints.length - 1].x;
            var lonDelta = (lonEnd - lonStart)/this.numPoints;
            var lon = lonStart;
            var labelPoint = null;
            for(var i=0; i <= this.numPoints ; ++i) {
                var gridPoint = new HGIS.Geometry.Point(lon,lat);
                gridPoint.transform(llProj, mapProj);
                pointList.push(gridPoint);
                lon += lonDelta;
                if (gridPoint.x < mapBounds.right) {
                    labelPoint = gridPoint;
                }
            }
            if (this.labelled) {
                //keep track of when this grid line crosses the map bounds to set
                //the label position
                //labels along the right, 30 pixel offset left into the map
                //TODO add option for labels on left
                var labelPos = new HGIS.Geometry.Point(mapBounds.right, labelPoint.y); 
                var labelAttrs = {
                    value: lat,
                    label: this.labelled?HGIS.Util.getFormattedLonLat(lat, "lat", this.labelFormat):"",
                    labelAlign: "rb",
                    xOffset: -2,
                    yOffset: 2
                }; 
                this.gratLayer.addFeatures(new HGIS.Feature.Vector(labelPos,labelAttrs));
            }
            var geom = new HGIS.Geometry.LineString(pointList);
            lines.push(new HGIS.Feature.Vector(geom));
          }
          this.gratLayer.addFeatures(lines);
    },
    
    CLASS_NAME: "HGIS.Control.Graticule"
});

/* ======================================================================
    Rico/Corner.js
   ====================================================================== */

/**
 * @requires HGIS/Console.js
 * @requires Rico/Color.js
 */


/*
 * This file has been edited substantially from the Rico-released
 * version by the HGIS development team.
 *  
 *  Copyright 2005 Sabre Airline Solutions  
 *  
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the
 *  License. You may obtain a copy of the License at
 *  
 *         http://www.apache.org/licenses/LICENSE-2.0  
 *  
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the * License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, * either express or
 * implied. See the License for the specific language governing
 * permissions * and limitations under the License.
 *
 */

HGIS.Console.warn("HGIS.Rico is deprecated");

HGIS.Rico = HGIS.Rico || {};
HGIS.Rico.Corner = {

    round: function(e, options) {
        e = HGIS.Util.getElement(e);
        this._setOptions(options);

        var color = this.options.color;
        if ( this.options.color == "fromElement" ) {
            color = this._background(e);
        }
        var bgColor = this.options.bgColor;
        if ( this.options.bgColor == "fromParent" ) {
            bgColor = this._background(e.offsetParent);
        }
        this._roundCornersImpl(e, color, bgColor);
    },

    /**   This is a helper function to change the background
    *     color of <div> that has had Rico rounded corners added.
    *
    *     It seems we cannot just set the background color for the
    *     outer <div> so each <span> element used to create the
    *     corners must have its background color set individually.
    *
    * @param {DOM} theDiv - A child of the outer <div> that was
    *                        supplied to the `round` method.
    *
    * @param {String} newColor - The new background color to use.
    */
    changeColor: function(theDiv, newColor) {
   
        theDiv.style.backgroundColor = newColor;

        var spanElements = theDiv.parentNode.getElementsByTagName("span");
        
        for (var currIdx = 0; currIdx < spanElements.length; currIdx++) {
            spanElements[currIdx].style.backgroundColor = newColor;
        }
    }, 


    /**   This is a helper function to change the background
    *     opacity of <div> that has had Rico rounded corners added.
    *
    *     See changeColor (above) for algorithm explanation
    *
    * @param {DOM} theDiv A child of the outer <div> that was
    *                        supplied to the `round` method.
    *
    * @param {int} newOpacity The new opacity to use (0-1).
    */
    changeOpacity: function(theDiv, newOpacity) {
   
        var mozillaOpacity = newOpacity;
        var ieOpacity = 'alpha(opacity=' + newOpacity * 100 + ')';
        
        theDiv.style.opacity = mozillaOpacity;
        theDiv.style.filter = ieOpacity;

        var spanElements = theDiv.parentNode.getElementsByTagName("span");
        
        for (var currIdx = 0; currIdx < spanElements.length; currIdx++) {
            spanElements[currIdx].style.opacity = mozillaOpacity;
            spanElements[currIdx].style.filter = ieOpacity;
        }

    },

    /** this function takes care of redoing the rico cornering
    *    
    *    you can't just call updateRicoCorners() again and pass it a 
    *    new options string. you have to first remove the divs that 
    *    rico puts on top and below the content div.
    *
    * @param {DOM} theDiv - A child of the outer <div> that was
    *                        supplied to the `round` method.
    *
    * @param {Object} options - list of options
    */
    reRound: function(theDiv, options) {

        var topRico = theDiv.parentNode.childNodes[0];
        //theDiv would be theDiv.parentNode.childNodes[1]
        var bottomRico = theDiv.parentNode.childNodes[2];
       
        theDiv.parentNode.removeChild(topRico);
        theDiv.parentNode.removeChild(bottomRico); 

        this.round(theDiv.parentNode, options);
    }, 

   _roundCornersImpl: function(e, color, bgColor) {
      if(this.options.border) {
         this._renderBorder(e,bgColor);
      }
      if(this._isTopRounded()) {
         this._roundTopCorners(e,color,bgColor);
      }
      if(this._isBottomRounded()) {
         this._roundBottomCorners(e,color,bgColor);
      }
   },

   _renderBorder: function(el,bgColor) {
      var borderValue = "1px solid " + this._borderColor(bgColor);
      var borderL = "border-left: "  + borderValue;
      var borderR = "border-right: " + borderValue;
      var style   = "style='" + borderL + ";" + borderR +  "'";
      el.innerHTML = "<div " + style + ">" + el.innerHTML + "</div>";
   },

   _roundTopCorners: function(el, color, bgColor) {
      var corner = this._createCorner(bgColor);
      for(var i=0 ; i < this.options.numSlices ; i++ ) {
         corner.appendChild(this._createCornerSlice(color,bgColor,i,"top"));
      }
      el.style.paddingTop = 0;
      el.insertBefore(corner,el.firstChild);
   },

   _roundBottomCorners: function(el, color, bgColor) {
      var corner = this._createCorner(bgColor);
      for(var i=(this.options.numSlices-1) ; i >= 0 ; i-- ) {
         corner.appendChild(this._createCornerSlice(color,bgColor,i,"bottom"));
      }
      el.style.paddingBottom = 0;
      el.appendChild(corner);
   },

   _createCorner: function(bgColor) {
      var corner = document.createElement("div");
      corner.style.backgroundColor = (this._isTransparent() ? "transparent" : bgColor);
      return corner;
   },

   _createCornerSlice: function(color,bgColor, n, position) {
      var slice = document.createElement("span");

      var inStyle = slice.style;
      inStyle.backgroundColor = color;
      inStyle.display  = "block";
      inStyle.height   = "1px";
      inStyle.overflow = "hidden";
      inStyle.fontSize = "1px";

      var borderColor = this._borderColor(color,bgColor);
      if ( this.options.border && n == 0 ) {
         inStyle.borderTopStyle    = "solid";
         inStyle.borderTopWidth    = "1px";
         inStyle.borderLeftWidth   = "0px";
         inStyle.borderRightWidth  = "0px";
         inStyle.borderBottomWidth = "0px";
         inStyle.height            = "0px"; // assumes css compliant box model
         inStyle.borderColor       = borderColor;
      }
      else if(borderColor) {
         inStyle.borderColor = borderColor;
         inStyle.borderStyle = "solid";
         inStyle.borderWidth = "0px 1px";
      }

      if ( !this.options.compact && (n == (this.options.numSlices-1)) ) {
         inStyle.height = "2px";
      }
      this._setMargin(slice, n, position);
      this._setBorder(slice, n, position);
      return slice;
   },

   _setOptions: function(options) {
      this.options = {
         corners : "all",
         color   : "fromElement",
         bgColor : "fromParent",
         blend   : true,
         border  : false,
         compact : false
      };
      HGIS.Util.extend(this.options, options || {});

      this.options.numSlices = this.options.compact ? 2 : 4;
      if ( this._isTransparent() ) {
         this.options.blend = false;
      }
   },

   _whichSideTop: function() {
      if ( this._hasString(this.options.corners, "all", "top") ) {
         return "";
      }
      if ( this.options.corners.indexOf("tl") >= 0 && this.options.corners.indexOf("tr") >= 0 ) {
         return "";
      }
      if (this.options.corners.indexOf("tl") >= 0) {
         return "left";
      } else if (this.options.corners.indexOf("tr") >= 0) {
          return "right";
      }
      return "";
   },

   _whichSideBottom: function() {
      if ( this._hasString(this.options.corners, "all", "bottom") ) {
         return "";
      }
      if ( this.options.corners.indexOf("bl")>=0 && this.options.corners.indexOf("br")>=0 ) {
         return "";
      }

      if(this.options.corners.indexOf("bl") >=0) {
         return "left";
      } else if(this.options.corners.indexOf("br")>=0) {
         return "right";
      }
      return "";
   },

   _borderColor : function(color,bgColor) {
      if ( color == "transparent" ) {
         return bgColor;
      } else if ( this.options.border ) {
         return this.options.border;
      } else if ( this.options.blend ) {
         return this._blend( bgColor, color );
      } else {
         return "";
      }
   },


   _setMargin: function(el, n, corners) {
      var marginSize = this._marginSize(n);
      var whichSide = corners == "top" ? this._whichSideTop() : this._whichSideBottom();

      if ( whichSide == "left" ) {
         el.style.marginLeft = marginSize + "px"; el.style.marginRight = "0px";
      }
      else if ( whichSide == "right" ) {
         el.style.marginRight = marginSize + "px"; el.style.marginLeft  = "0px";
      }
      else {
         el.style.marginLeft = marginSize + "px"; el.style.marginRight = marginSize + "px";
      }
   },

   _setBorder: function(el,n,corners) {
      var borderSize = this._borderSize(n);
      var whichSide = corners == "top" ? this._whichSideTop() : this._whichSideBottom();
      if ( whichSide == "left" ) {
         el.style.borderLeftWidth = borderSize + "px"; el.style.borderRightWidth = "0px";
      }
      else if ( whichSide == "right" ) {
         el.style.borderRightWidth = borderSize + "px"; el.style.borderLeftWidth  = "0px";
      }
      else {
         el.style.borderLeftWidth = borderSize + "px"; el.style.borderRightWidth = borderSize + "px";
      }
      if (this.options.border != false) {
        el.style.borderLeftWidth = borderSize + "px"; el.style.borderRightWidth = borderSize + "px";
      }
   },

   _marginSize: function(n) {
      if ( this._isTransparent() ) {
         return 0;
      }
      var marginSizes          = [ 5, 3, 2, 1 ];
      var blendedMarginSizes   = [ 3, 2, 1, 0 ];
      var compactMarginSizes   = [ 2, 1 ];
      var smBlendedMarginSizes = [ 1, 0 ];

      if ( this.options.compact && this.options.blend ) {
         return smBlendedMarginSizes[n];
      } else if ( this.options.compact ) {
         return compactMarginSizes[n];
      } else if ( this.options.blend ) {
         return blendedMarginSizes[n];
      } else {
         return marginSizes[n];
      }
   },

   _borderSize: function(n) {
      var transparentBorderSizes = [ 5, 3, 2, 1 ];
      var blendedBorderSizes     = [ 2, 1, 1, 1 ];
      var compactBorderSizes     = [ 1, 0 ];
      var actualBorderSizes      = [ 0, 2, 0, 0 ];

      if ( this.options.compact && (this.options.blend || this._isTransparent()) ) {
         return 1;
      } else if ( this.options.compact ) {
         return compactBorderSizes[n];
      } else if ( this.options.blend ) {
         return blendedBorderSizes[n];
      } else if ( this.options.border ) {
         return actualBorderSizes[n];
      } else if ( this._isTransparent() ) {
         return transparentBorderSizes[n];
      }
      return 0;
   },

   _hasString: function(str) { for(var i=1 ; i<arguments.length ; i++) if (str.indexOf(arguments[i]) >= 0) { return true; } return false; },
   _blend: function(c1, c2) { var cc1 = HGIS.Rico.Color.createFromHex(c1); cc1.blend(HGIS.Rico.Color.createFromHex(c2)); return cc1; },
   _background: function(el) { try { return HGIS.Rico.Color.createColorFromBackground(el).asHex(); } catch(err) { return "#ffffff"; } },
   _isTransparent: function() { return this.options.color == "transparent"; },
   _isTopRounded: function() { return this._hasString(this.options.corners, "all", "top", "tl", "tr"); },
   _isBottomRounded: function() { return this._hasString(this.options.corners, "all", "bottom", "bl", "br"); },
   _hasSingleTextChild: function(el) { return el.childNodes.length == 1 && el.childNodes[0].nodeType == 3; }
};
/* ======================================================================
    HGIS/Control/NavigationHistory.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Control/Button.js
 */

/**
 * Class: HGIS.Control.NavigationHistory
 * A navigation history control.  This is a meta-control, that creates two
 *     dependent controls: <previous> and <next>.  Call the trigger method
 *     on the <previous> and <next> controls to restore previous and next
 *     history states.  The previous and next controls will become active
 *     when there are available states to restore and will become deactive
 *     when there are no states to restore.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.NavigationHistory = HGIS.Class(HGIS.Control, {

    /**
     * Property: type
     * {String} Note that this control is not intended to be added directly
     *     to a control panel.  Instead, add the sub-controls previous and
     *     next.  These sub-controls are button type controls that activate
     *     and deactivate themselves.  If this parent control is added to
     *     a panel, it will act as a toggle.
     */
    type: HGIS.Control.TYPE_TOGGLE,

    /**
     * APIProperty: previous
     * {<HGIS.Control>} A button type control whose trigger method restores
     *     the previous state managed by this control.
     */
    previous: null,
    
    /**
     * APIProperty: previousOptions
     * {Object} Set this property on the options argument of the constructor
     *     to set optional properties on the <previous> control.
     */
    previousOptions: null,
    
    /**
     * APIProperty: next
     * {<HGIS.Control>} A button type control whose trigger method restores
     *     the next state managed by this control.
     */
    next: null,

    /**
     * APIProperty: nextOptions
     * {Object} Set this property on the options argument of the constructor
     *     to set optional properties on the <next> control.
     */
    nextOptions: null,

    /**
     * APIProperty: limit
     * {Integer} Optional limit on the number of history items to retain.  If
     *     null, there is no limit.  Default is 50.
     */
    limit: 50,

    /**
     * APIProperty: autoActivate
     * {Boolean} Activate the control when it is added to a map.  Default is
     *     true.
     */
    autoActivate: true,

    /**
     * Property: clearOnDeactivate
     * {Boolean} Clear the history when the control is deactivated.  Default
     *     is false.
     */
    clearOnDeactivate: false,

    /**
     * Property: registry
     * {Object} An object with keys corresponding to event types.  Values
     *     are functions that return an object representing the current state.
     */
    registry: null,

    /**
     * Property: nextStack
     * {Array} Array of items in the history.
     */
    nextStack: null,

    /**
     * Property: previousStack
     * {Array} List of items in the history.  First item represents the current
     *     state.
     */
    previousStack: null,
    
    /**
     * Property: listeners
     * {Object} An object containing properties corresponding to event types.
     *     This object is used to configure the control and is modified on
     *     construction.
     */
    listeners: null,
    
    /**
     * Property: restoring
     * {Boolean} Currently restoring a history state.  This is set to true
     *     before calling restore and set to false after restore returns.
     */
    restoring: false,
    
    /**
     * Constructor: HGIS.Control.NavigationHistory 
     * 
     * Parameters:
     * options - {Object} An optional object whose properties will be used
     *     to extend the control.
     */
    initialize: function(options) {
        HGIS.Control.prototype.initialize.apply(this, [options]);
        
        this.registry = HGIS.Util.extend({
            "moveend": this.getState
        }, this.registry);
        
        var previousOptions = {
            trigger: HGIS.Function.bind(this.previousTrigger, this),
            displayClass: this.displayClass + " " + this.displayClass + "Previous"
        };
        HGIS.Util.extend(previousOptions, this.previousOptions);
        this.previous = new HGIS.Control.Button(previousOptions);
        
        var nextOptions = {
            trigger: HGIS.Function.bind(this.nextTrigger, this),
            displayClass: this.displayClass + " " + this.displayClass + "Next"
        };
        HGIS.Util.extend(nextOptions, this.nextOptions);
        this.next = new HGIS.Control.Button(nextOptions);

        this.clear();
    },
    
    /**
     * Method: onPreviousChange
     * Called when the previous history stack changes.
     *
     * Parameters:
     * state - {Object} An object representing the state to be restored
     *     if previous is triggered again or null if no previous states remain.
     * length - {Integer} The number of remaining previous states that can
     *     be restored.
     */
    onPreviousChange: function(state, length) {
        if(state && !this.previous.active) {
            this.previous.activate();
        } else if(!state && this.previous.active) {
            this.previous.deactivate();
        }
    },
    
    /**
     * Method: onNextChange
     * Called when the next history stack changes.
     *
     * Parameters:
     * state - {Object} An object representing the state to be restored
     *     if next is triggered again or null if no next states remain.
     * length - {Integer} The number of remaining next states that can
     *     be restored.
     */
    onNextChange: function(state, length) {
        if(state && !this.next.active) {
            this.next.activate();
        } else if(!state && this.next.active) {
            this.next.deactivate();
        }
    },
    
    /**
     * APIMethod: destroy
     * Destroy the control.
     */
    destroy: function() {
        HGIS.Control.prototype.destroy.apply(this);
        this.previous.destroy();
        this.next.destroy();
        this.deactivate();
        for(var prop in this) {
            this[prop] = null;
        }
    },
    
    /** 
     * Method: setMap
     * Set the map property for the control and <previous> and <next> child
     *     controls.
     *
     * Parameters:
     * map - {<HGIS.Map>} 
     */
    setMap: function(map) {
        this.map = map;
        this.next.setMap(map);
        this.previous.setMap(map);
    },

    /**
     * Method: draw
     * Called when the control is added to the map.
     */
    draw: function() {
        HGIS.Control.prototype.draw.apply(this, arguments);
        this.next.draw();
        this.previous.draw();
    },
    
    /**
     * Method: previousTrigger
     * Restore the previous state.  If no items are in the previous history
     *     stack, this has no effect.
     *
     * Returns:
     * {Object} Item representing state that was restored.  Undefined if no
     *     items are in the previous history stack.
     */
    previousTrigger: function() {
        var current = this.previousStack.shift();
        var state = this.previousStack.shift();
        if(state != undefined) {
            this.nextStack.unshift(current);
            this.previousStack.unshift(state);
            this.restoring = true;
            this.restore(state);
            this.restoring = false;
            this.onNextChange(this.nextStack[0], this.nextStack.length);
            this.onPreviousChange(
                this.previousStack[1], this.previousStack.length - 1
            );
        } else {
            this.previousStack.unshift(current);
        }
        return state;
    },
    
    /**
     * APIMethod: nextTrigger
     * Restore the next state.  If no items are in the next history
     *     stack, this has no effect.  The next history stack is populated
     *     as states are restored from the previous history stack.
     *
     * Returns:
     * {Object} Item representing state that was restored.  Undefined if no
     *     items are in the next history stack.
     */
    nextTrigger: function() {
        var state = this.nextStack.shift();
        if(state != undefined) {
            this.previousStack.unshift(state);
            this.restoring = true;
            this.restore(state);
            this.restoring = false;
            this.onNextChange(this.nextStack[0], this.nextStack.length);
            this.onPreviousChange(
                this.previousStack[1], this.previousStack.length - 1
            );
        }
        return state;
    },
    
    /**
     * APIMethod: clear
     * Clear history.
     */
    clear: function() {
        this.previousStack = [];
        this.previous.deactivate();
        this.nextStack = [];
        this.next.deactivate();
    },

    /**
     * Method: getState
     * Get the current state and return it.
     *
     * Returns:
     * {Object} An object representing the current state.
     */
    getState: function() {
        return {
            center: this.map.getCenter(),
            resolution: this.map.getResolution(),
            projection: this.map.getProjectionObject(),
            units: this.map.getProjectionObject().getUnits() || 
                this.map.units || this.map.baseLayer.units
        };
    },

    /**
     * Method: restore
     * Update the state with the given object.
     *
     * Parameters:
     * state - {Object} An object representing the state to restore.
     */
    restore: function(state) {
        var center, zoom;
        if (this.map.getProjectionObject() == state.projection) { 
            zoom = this.map.getZoomForResolution(state.resolution);
            center = state.center;
        } else {
            center = state.center.clone();
            center.transform(state.projection, this.map.getProjectionObject());
            var sourceUnits = state.units;
            var targetUnits = this.map.getProjectionObject().getUnits() || 
                this.map.units || this.map.baseLayer.units;
            var resolutionFactor = sourceUnits && targetUnits ? 
                HGIS.INCHES_PER_UNIT[sourceUnits] / HGIS.INCHES_PER_UNIT[targetUnits] : 1;
            zoom = this.map.getZoomForResolution(resolutionFactor*state.resolution); 
        }
        this.map.setCenter(center, zoom);
    },
    
    /**
     * Method: setListeners
     * Sets functions to be registered in the listeners object.
     */
    setListeners: function() {
        this.listeners = {};
        for(var type in this.registry) {
            this.listeners[type] = HGIS.Function.bind(function() {
                if(!this.restoring) {
                    var state = this.registry[type].apply(this, arguments);
                    this.previousStack.unshift(state);
                    if(this.previousStack.length > 1) {
                        this.onPreviousChange(
                            this.previousStack[1], this.previousStack.length - 1
                        );
                    }
                    if(this.previousStack.length > (this.limit + 1)) {
                        this.previousStack.pop();
                    }
                    if(this.nextStack.length > 0) {
                        this.nextStack = [];
                        this.onNextChange(null, 0);
                    }
                }
                return true;
            }, this);
        }
    },

    /**
     * APIMethod: activate
     * Activate the control.  This registers any listeners.
     *
     * Returns:
     * {Boolean} Control successfully activated.
     */
    activate: function() {
        var activated = false;
        if(this.map) {
            if(HGIS.Control.prototype.activate.apply(this)) {
                if(this.listeners == null) {
                    this.setListeners();
                }
                for(var type in this.listeners) {
                    this.map.events.register(type, this, this.listeners[type]);
                }
                activated = true;
                if(this.previousStack.length == 0) {
                    this.initStack();
                }
            }
        }
        return activated;
    },
    
    /**
     * Method: initStack
     * Called after the control is activated if the previous history stack is
     *     empty.
     */
    initStack: function() {
        if(this.map.getCenter()) {
            this.listeners.moveend();
        }
    },
    
    /**
     * APIMethod: deactivate
     * Deactivate the control.  This unregisters any listeners.
     *
     * Returns:
     * {Boolean} Control successfully deactivated.
     */
    deactivate: function() {
        var deactivated = false;
        if(this.map) {
            if(HGIS.Control.prototype.deactivate.apply(this)) {
                for(var type in this.listeners) {
                    this.map.events.unregister(
                        type, this, this.listeners[type]
                    );
                }
                if(this.clearOnDeactivate) {
                    this.clear();
                }
                deactivated = true;
            }
        }
        return deactivated;
    },
    
    CLASS_NAME: "HGIS.Control.NavigationHistory"
});

/* ======================================================================
    HGIS/Layer/UTFGrid.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer/XYZ.js
 * @requires HGIS/Tile/UTFGrid.js
 */

/** 
 * Class: HGIS.Layer.UTFGrid
 * This Layer reads from UTFGrid tiled data sources.  Since UTFGrids are 
 * essentially JSON-based ASCII art with attached attributes, they are not 
 * visibly rendered.  In order to use them in the map, you must add a 
 * <HGIS.Control.UTFGrid> control as well.
 *
 * Example:
 *
 * (start code)
 * var world_utfgrid = new HGIS.Layer.UTFGrid({
 *     url: "/tiles/world_utfgrid/${z}/${x}/${y}.json",
 *     utfgridResolution: 4,
 *     displayInLayerSwitcher: false
 * );
 * map.addLayer(world_utfgrid);
 * 
 * var control = new HGIS.Control.UTFGrid({
 *     layers: [world_utfgrid],
 *     handlerMode: 'move',
 *     callback: function(dataLookup) {
 *         // do something with returned data
 *     }
 * })
 * (end code)
 *
 * 
 * Inherits from:
 *  - <HGIS.Layer.XYZ>
 */
HGIS.Layer.UTFGrid = HGIS.Class(HGIS.Layer.XYZ, {
    
    /**
     * APIProperty: isBaseLayer
     * Default is false, as UTFGrids are designed to be a transparent overlay layer. 
     */
    isBaseLayer: false,
    
    /**
     * APIProperty: projection
     * {<HGIS.Projection>}
     * Source projection for the UTFGrids.  Default is "EPSG:900913".
     */
    projection: new HGIS.Projection("EPSG:900913"),

    /**
     * Property: useJSONP
     * {Boolean}
     * Should we use a JSONP script approach instead of a standard AJAX call?
     *
     * Set to true for using utfgrids from another server. 
     * Avoids same-domain policy restrictions. 
     * Note that this only works if the server accepts 
     * the callback GET parameter and dynamically 
     * wraps the returned json in a function call.
     * 
     * Default is false
     */
    useJSONP: false,
    
    /**
     * APIProperty: url
     * {String}
     * URL tempate for UTFGrid tiles.  Include x, y, and z parameters.
     * E.g. "/tiles/${z}/${x}/${y}.json"
     */

    /**
     * APIProperty: utfgridResolution
     * {Number}
     * Ratio of the pixel width to the width of a UTFGrid data point.  If an 
     *     entry in the grid represents a 4x4 block of pixels, the 
     *     utfgridResolution would be 4.  Default is 2 (specified in 
     *     <HGIS.Tile.UTFGrid>).
     */

    /**
     * Property: tileClass
     * {<HGIS.Tile>} The tile class to use for this layer.
     *     Defaults is <HGIS.Tile.UTFGrid>.
     */
    tileClass: HGIS.Tile.UTFGrid,

    /**
     * Constructor: HGIS.Layer.UTFGrid
     * Create a new UTFGrid layer.
     *
     * Parameters:
     * config - {Object} Configuration properties for the layer.
     *
     * Required configuration properties:
     * url - {String} The url template for UTFGrid tiles.  See the <url> property.
     */
    initialize: function(options) {
        HGIS.Layer.Grid.prototype.initialize.apply(
            this, [options.name, options.url, {}, options]
        );
        this.tileOptions = HGIS.Util.extend({
            utfgridResolution: this.utfgridResolution
        }, this.tileOptions);
    },

    /**
     * Method: createBackBuffer
     * The UTFGrid cannot create a back buffer, so this method is overriden.
     */
    createBackBuffer: function() {},
    
    /**
     * APIMethod: clone
     * Create a clone of this layer
     *
     * Parameters:
     * obj - {Object} Only used by a subclass of this layer.
     * 
     * Returns:
     * {<HGIS.Layer.UTFGrid>} An exact clone of this HGIS.Layer.UTFGrid
     */
    clone: function (obj) {
        if (obj == null) {
            obj = new HGIS.Layer.UTFGrid(this.getOptions());
        }

        // get all additions from superclasses
        obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);

        return obj;
    },

    /**
     * APIProperty: getFeatureInfo
     * Get details about a feature associated with a map location.  The object
     *     returned will have id and data properties.  If the given location
     *     doesn't correspond to a feature, null will be returned.
     *
     * Parameters:
     * location - {<HGIS.LonLat>} map location
     *
     * Returns:
     * {Object} Object representing the feature id and UTFGrid data 
     *     corresponding to the given map location.  Returns null if the given
     *     location doesn't hit a feature.
     */
    getFeatureInfo: function(location) {
        var info = null;
        var tileInfo = this.getTileData(location);
        if (tileInfo && tileInfo.tile) {
            info = tileInfo.tile.getFeatureInfo(tileInfo.i, tileInfo.j);
        }
        return info;
    },

    /**
     * APIMethod: getFeatureId
     * Get the identifier for the feature associated with a map location.
     *
     * Parameters:
     * location - {<HGIS.LonLat>} map location
     *
     * Returns:
     * {String} The feature identifier corresponding to the given map location.
     *     Returns null if the location doesn't hit a feature.
     */
    getFeatureId: function(location) {
        var id = null;
        var info = this.getTileData(location);
        if (info.tile) {
            id = info.tile.getFeatureId(info.i, info.j);
        }
        return id;
    },

    CLASS_NAME: "HGIS.Layer.UTFGrid"
});
/* ======================================================================
    HGIS/TileManager.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Util.js
 * @requires HGIS/BaseTypes.js
 * @requires HGIS/BaseTypes/Element.js
 */

/**
 * Class: HGIS.TileManager
 * Provides queueing of image requests and caching of image elements.
 *
 * Queueing avoids unnecessary image requests while changing zoom levels
 * quickly, and helps improve dragging performance on mobile devices that show
 * a lag in dragging when loading of new images starts. <zoomDelay> and
 * <moveDelay> are the configuration options to control this behavior.
 *
 * Caching avoids setting the src on image elements for images that have already
 * been used. Several maps can share a TileManager instance, in which case each
 * map gets its own tile queue, but all maps share the same tile cache.
 */
HGIS.TileManager = HGIS.Class({
    
    /**
     * APIProperty: cacheSize
     * {Number} Number of image elements to keep referenced in this instance's
     * cache for fast reuse. Default is 256.
     */
    cacheSize: 256,

    /**
     * APIProperty: tilesPerFrame
     * {Number} Number of queued tiles to load per frame (see <frameDelay>).
     *     Default is 2.
     */
    tilesPerFrame: 2,

    /**
     * APIProperty: frameDelay
     * {Number} Delay between tile loading frames (see <tilesPerFrame>) in
     *     milliseconds. Default is 16.
     */
    frameDelay: 16,

    /**
     * APIProperty: moveDelay
     * {Number} Delay in milliseconds after a map's move event before loading
     * tiles. Default is 100.
     */
    moveDelay: 100,
    
    /**
     * APIProperty: zoomDelay
     * {Number} Delay in milliseconds after a map's zoomend event before loading
     * tiles. Default is 200.
     */
    zoomDelay: 200,
    
    /**
     * Property: maps
     * {Array(<HGIS.Map>)} The maps to manage tiles on.
     */
    maps: null,
    
    /**
     * Property: tileQueueId
     * {Object} The ids of the <drawTilesFromQueue> loop, keyed by map id.
     */
    tileQueueId: null,

    /**
     * Property: tileQueue
     * {Object(Array(<HGIS.Tile>))} Tiles queued for drawing, keyed by
     * map id.
     */
    tileQueue: null,
    
    /**
     * Property: tileCache
     * {Object} Cached image elements, keyed by URL.
     */
    tileCache: null,
    
    /**
     * Property: tileCacheIndex
     * {Array(String)} URLs of cached tiles. First entry is the least recently
     *    used.
     */
    tileCacheIndex: null,    
    
    /** 
     * Constructor: HGIS.TileManager
     * Constructor for a new <HGIS.TileManager> instance.
     * 
     * Parameters:
     * options - {Object} Configuration for this instance.
     */   
    initialize: function(options) {
        HGIS.Util.extend(this, options);
        this.maps = [];
        this.tileQueueId = {};
        this.tileQueue = {};
        this.tileCache = {};
        this.tileCacheIndex = [];
    },
    
    /**
     * Method: addMap
     * Binds this instance to a map
     *
     * Parameters:
     * map - {<HGIS.Map>}
     */
    addMap: function(map) {
        if (this._destroyed || !HGIS.Layer.Grid) {
            return;
        }
        this.maps.push(map);
        this.tileQueue[map.id] = [];
        for (var i=0, ii=map.layers.length; i<ii; ++i) {
            this.addLayer({layer: map.layers[i]});
        }
        map.events.on({
            move: this.move,
            zoomend: this.zoomEnd,
            changelayer: this.changeLayer,
            addlayer: this.addLayer,
            preremovelayer: this.removeLayer,
            scope: this
        });
    },
    
    /**
     * Method: removeMap
     * Unbinds this instance from a map
     *
     * Parameters:
     * map - {<HGIS.Map>}
     */
    removeMap: function(map) {
        if (this._destroyed || !HGIS.Layer.Grid) {
            return;
        }
        window.clearTimeout(this.tileQueueId[map.id]);
        if (map.layers) {
            for (var i=0, ii=map.layers.length; i<ii; ++i) {
                this.removeLayer({layer: map.layers[i]});
            }
        }
        if (map.events) {
            map.events.un({
                move: this.move,
                zoomend: this.zoomEnd,
                changelayer: this.changeLayer,
                addlayer: this.addLayer,
                preremovelayer: this.removeLayer,
                scope: this
            });
        }
        delete this.tileQueue[map.id];
        delete this.tileQueueId[map.id];
        HGIS.Util.removeItem(this.maps, map);
    },
    
    /**
     * Method: move
     * Handles the map's move event
     *
     * Parameters:
     * evt - {Object} Listener argument
     */
    move: function(evt) {
        this.updateTimeout(evt.object, this.moveDelay, true);
    },
    
    /**
     * Method: zoomEnd
     * Handles the map's zoomEnd event
     *
     * Parameters:
     * evt - {Object} Listener argument
     */
    zoomEnd: function(evt) {
        this.updateTimeout(evt.object, this.zoomDelay);
    },
    
    /**
     * Method: changeLayer
     * Handles the map's changeLayer event
     *
     * Parameters:
     * evt - {Object} Listener argument
     */
    changeLayer: function(evt) {
        if (evt.property === 'visibility' || evt.property === 'params') {
            this.updateTimeout(evt.object, 0);
        }
    },
    
    /**
     * Method: addLayer
     * Handles the map's addlayer event
     *
     * Parameters:
     * evt - {Object} The listener argument
     */
    addLayer: function(evt) {
        var layer = evt.layer;
        if (layer instanceof HGIS.Layer.Grid) {
            layer.events.on({
                addtile: this.addTile,
                retile: this.clearTileQueue,
                scope: this
            });
            var i, j, tile;
            for (i=layer.grid.length-1; i>=0; --i) {
                for (j=layer.grid[i].length-1; j>=0; --j) {
                    tile = layer.grid[i][j];
                    this.addTile({tile: tile});
                    if (tile.url) {
                        this.manageTileCache({object: tile});
                    }
                }
            }
        }
    },
    
    /**
     * Method: removeLayer
     * Handles the map's preremovelayer event
     *
     * Parameters:
     * evt - {Object} The listener argument
     */
    removeLayer: function(evt) {
        var layer = evt.layer;
        if (layer instanceof HGIS.Layer.Grid) {
            this.clearTileQueue({object: layer});
            if (layer.events) {
                layer.events.un({
                    addtile: this.addTile,
                    retile: this.clearTileQueue,
                    scope: this
                });
            }
            if (layer.grid) {
                var i, j, tile;
                for (i=layer.grid.length-1; i>=0; --i) {
                    for (j=layer.grid[i].length-1; j>=0; --j) {
                        tile = layer.grid[i][j];
                        this.unloadTile({object: tile});
                        if (tile.url) {
                            this.manageTileCache({object: tile});
                        }
                    }
                }
            }
        }
    },
    
    /**
     * Method: updateTimeout
     * Applies the <moveDelay> or <zoomDelay> to the <drawTilesFromQueue> loop,
     * and schedules more queue processing after <frameDelay> if there are still
     * tiles in the queue.
     *
     * Parameters:
     * map - {<HGIS.Map>} The map to update the timeout for
     * delay - {Number} The delay to apply
     * nice - {Boolean} If true, the timeout function will only be created if
     *     the tilequeue is not empty. This is used by the move handler to
     *     avoid impacts on dragging performance. For other events, the tile
     *     queue may not be populated yet, so we need to set the timer
     *     regardless of the queue size.
     */
    updateTimeout: function(map, delay, nice) {
        window.clearTimeout(this.tileQueueId[map.id]);
        var tileQueue = this.tileQueue[map.id];
        if (!nice || tileQueue.length) {
            this.tileQueueId[map.id] = window.setTimeout(
                HGIS.Function.bind(function() {
                    this.drawTilesFromQueue(map);
                    if (tileQueue.length) {
                        this.updateTimeout(map, this.frameDelay);
                    }
                }, this), delay
            );
        }
    },
    
    /**
     * Method: addTile
     * Listener for the layer's addtile event
     *
     * Parameters:
     * evt - {Object} The listener argument
     */
    addTile: function(evt) {
        evt.tile.events.on({
            beforedraw: this.queueTileDraw,
            beforeload: this.manageTileCache,
            loadend: this.addToCache,
            unload: this.unloadTile,
            scope: this
        });        
    },
    
    /**
     * Method: unloadTile
     * Listener for the tile's unload event
     *
     * Parameters:
     * evt - {Object} The listener argument
     */
    unloadTile: function(evt) {
        var tile = evt.object;
        tile.events.un({
            beforedraw: this.queueTileDraw,
            beforeload: this.manageTileCache,
            loadend: this.addToCache,
            unload: this.unloadTile,
            scope: this
        });
        HGIS.Util.removeItem(this.tileQueue[tile.layer.map.id], tile);
    },
    
    /**
     * Method: queueTileDraw
     * Adds a tile to the queue that will draw it.
     *
     * Parameters:
     * evt - {Object} Listener argument of the tile's beforedraw event
     */
    queueTileDraw: function(evt) {
        var tile = evt.object;
        var queued = false;
        var layer = tile.layer;
        var url = layer.getURL(tile.bounds);
        var img = this.tileCache[url];
        if (img && img.className !== 'olTileImage') {
            // cached image no longer valid, e.g. because we're olTileReplacing
            delete this.tileCache[url];
            HGIS.Util.removeItem(this.tileCacheIndex, url);
            img = null;
        }
        // queue only if image with same url not cached already
        if (layer.url && (layer.async || !img)) {
            // add to queue only if not in queue already
            var tileQueue = this.tileQueue[layer.map.id];
            if (!~HGIS.Util.indexOf(tileQueue, tile)) {
                tileQueue.push(tile);
            }
            queued = true;
        }
        return !queued;
    },
    
    /**
     * Method: drawTilesFromQueue
     * Draws tiles from the tileQueue, and unqueues the tiles
     */
    drawTilesFromQueue: function(map) {
        var tileQueue = this.tileQueue[map.id];
        var limit = this.tilesPerFrame;
        var animating = map.zoomTween && map.zoomTween.playing;
        while (!animating && tileQueue.length && limit) {
            tileQueue.shift().draw(true);
            --limit;
        }
    },
    
    /**
     * Method: manageTileCache
     * Adds, updates, removes and fetches cache entries.
     *
     * Parameters:
     * evt - {Object} Listener argument of the tile's beforeload event
     */
    manageTileCache: function(evt) {
        var tile = evt.object;
        var img = this.tileCache[tile.url];
        // only use image from cache if it is not on a layer already
        if (img && (!img.parentNode ||
                 HGIS.Element.hasClass(img.parentNode, 'olBackBuffer'))) {
            if (tile.layer.backBuffer) {
                if (tile.layer.backBuffer === img.parentNode) {
                    // cached image is on the target layer's backbuffer already,
                    // so nothing to do here
                    return;
                }
                img.style.opacity = 0;
                img.style.visibility = 'hidden';
            }
            // Only backbuffer tiles have an id, so we don't want one here
            img.id = null;
            tile.setImage(img);
            // LRU - move tile to the end of the array to mark it as the most
            // recently used
            HGIS.Util.removeItem(this.tileCacheIndex, tile.url);
            this.tileCacheIndex.push(tile.url);
        }
    },
    
    /**
     * Method: addToCache
     *
     * Parameters:
     * evt - {Object} Listener argument for the tile's loadend event
     */
    addToCache: function(evt) {
        var tile = evt.object;
        if (!this.tileCache[tile.url]) {
            if (!HGIS.Element.hasClass(tile.imgDiv, 'olImageLoadError')) {
                if (this.tileCacheIndex.length >= this.cacheSize) {
                    delete this.tileCache[this.tileCacheIndex[0]];
                    this.tileCacheIndex.shift();
                }
                this.tileCache[tile.url] = tile.imgDiv;
                this.tileCacheIndex.push(tile.url);
            }
        }
    },

    /**
     * Method: clearTileQueue
     * Clears the tile queue from tiles of a specific layer
     *
     * Parameters:
     * evt - {Object} Listener argument of the layer's retile event
     */
    clearTileQueue: function(evt) {
        var layer = evt.object;
        var tileQueue = this.tileQueue[layer.map.id];
        for (var i=tileQueue.length-1; i>=0; --i) {
            if (tileQueue[i].layer === layer) {
                tileQueue.splice(i, 1);
            }
        }
    },
    
    /**
     * Method: destroy
     */
    destroy: function() {
        for (var i=this.maps.length-1; i>=0; --i) {
            this.removeMap(this.maps[i]);
        }
        this.maps = null;
        this.tileQueue = null;
        this.tileQueueId = null;
        this.tileCache = null;
        this.tileCacheIndex = null;
        this._destroyed = true;
    }

});
/* ======================================================================
					HGIS/Layer/ArcGIS93Rest.js
====================================================================== */
/* Copyright (c) 2006-2012 by HGIS Contributors (see authors.txt for 
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer/Grid.js
 */

/**
 * Class: HGIS.Layer.ArcGIS93Rest
 * Instances of HGIS.Layer.ArcGIS93Rest are used to display data from
 *     ESRI ArcGIS Server 9.3 (and up?) Mapping Services using the REST API.
 *     Create a new ArcGIS93Rest layer with the <HGIS.Layer.ArcGIS93Rest>
 *     constructor.  More detail on the REST API is available at
 *     http://sampleserver1.arcgisonline.com/ArcGIS/SDK/REST/index.html ;
 *     specifically, the URL provided to this layer should be an export service
 *     URL: http://sampleserver1.arcgisonline.com/ArcGIS/SDK/REST/export.html 
 * 
 * Inherits from:
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.ArcGIS93Rest = HGIS.Class(HGIS.Layer.Grid, {

    /**
     * Constant: DEFAULT_PARAMS
     * {Object} Hashtable of default parameter key/value pairs 
     */
    DEFAULT_PARAMS: { 
      format: "png"
    },
        
    /**
     * APIProperty: isBaseLayer
     * {Boolean} Default is true for ArcGIS93Rest layer
     */
    isBaseLayer: true,
 
 
    /**
     * Constructor: HGIS.Layer.ArcGIS93Rest
     * Create a new ArcGIS93Rest layer object.
     *
     * Example:
     * (code)
     * var arcims = new HGIS.Layer.ArcGIS93Rest("MyName",
     *                                    "http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Specialty/ESRI_StateCityHighway_USA/MapServer/export", 
     *                                    {
     *                                      layers: "0,1,2"
     *                                    });
     * (end)
     *
     * Parameters:
     * name - {String} A name for the layer
     * url - {String} Base url for the ArcGIS server REST service
     * options - {Object} An object with key/value pairs representing the
     *                    options and option values.
     *
     * Valid Options:
     *        format - {String} MIME type of desired image type.
     *        layers - {String} Comma-separated list of layers to display.
     *        srs - {String} Projection ID.
     */
    initialize: function(name, url, params, options) {
        var newArguments = [];
        //uppercase params
        params = HGIS.Util.upperCaseObject(params);
        newArguments.push(name, url, params, options);
        HGIS.Layer.Grid.prototype.initialize.apply(this, newArguments);
        HGIS.Util.applyDefaults(
                       this.params, 
                       HGIS.Util.upperCaseObject(this.DEFAULT_PARAMS)
                       );
                       
        //layer is transparent        
        if (this.params.TRANSPARENT && 
            this.params.TRANSPARENT.toString().toLowerCase() == "true") {
            
            // unless explicitly set in options, make layer an overlay
            if ( (options == null) || (!options.isBaseLayer) ) {
                this.isBaseLayer = false;
            } 
            
            // jpegs can never be transparent, so intelligently switch the 
            //  format, depending on the browser's capabilities
            if (this.params.FORMAT == "jpg") {
                this.params.FORMAT = HGIS.Util.alphaHack() ? "gif"
                                                                 : "png";
            }
        }
    },    

    /**
         * Method: clone
         * Create a clone of this layer
         *
         * Returns:
         * {<HGIS.Layer.ArcGIS93Rest>} An exact clone of this layer
         */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new HGIS.Layer.ArcGIS93Rest(this.name,
                                           this.url,
                                           this.params,
                                           this.getOptions());
        }

        //get all additions from superclasses
        obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },
    
    
    /**
     * Method: getURL
     * Return an image url this layer.
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>} A bounds representing the bbox for the
     *                                request.
     *
     * Returns:
     * {String} A string with the map image's url.
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);

        // ArcGIS Server only wants the numeric portion of the projection ID.
        var projWords = this.projection.getCode().split(":");
        var srid = projWords[projWords.length - 1];

        var imageSize = this.getImageSize(); 
        var newParams = {
            'BBOX': bounds.toBBOX(),
            'SIZE': imageSize.w + "," + imageSize.h,
            // We always want image, the other options were json, image with a whole lotta html around it, etc.
            'F': "image",
            'BBOXSR': srid,
            'IMAGESR': srid
        };

        // Now add the filter parameters.
        if (this.layerDefs) {
            var layerDefStrList = [];
            var layerID;
            for(layerID in this.layerDefs) {
                if (this.layerDefs.hasOwnProperty(layerID)) {
                    if (this.layerDefs[layerID]) {
                        layerDefStrList.push(layerID);
                        layerDefStrList.push(":");
                        layerDefStrList.push(this.layerDefs[layerID]);
                        layerDefStrList.push(";");
                    }
                }
            }
            if (layerDefStrList.length > 0) {
                newParams['LAYERDEFS'] = layerDefStrList.join("");
            }
        }
        var requestString = this.getFullRequestString(newParams);
        return requestString;
    },
    
    /**
     * Method: setLayerFilter
     * addTile creates a tile, initializes it, and adds it to the layer div. 
     *
     * Parameters:
     * id - {String} The id of the layer to which the filter applies.
     * queryDef - {String} A sql-ish query filter, for more detail see the ESRI
     *                     documentation at http://sampleserver1.arcgisonline.com/ArcGIS/SDK/REST/export.html
     */
    setLayerFilter: function ( id, queryDef ) {
        if (!this.layerDefs) {
            this.layerDefs = {};
        }
        if (queryDef) {
            this.layerDefs[id] = queryDef;
        } else {
            delete this.layerDefs[id];
        }
    },
    
    /**
     * Method: clearLayerFilter
     * Clears layer filters, either from a specific layer,
     * or all of them.
     *
     * Parameters:
     * id - {String} The id of the layer from which to remove any
     *               filter.  If unspecified/blank, all filters
     *               will be removed.
     */
    clearLayerFilter: function ( id ) {
        if (id) {
            delete this.layerDefs[id];
        } else {
            delete this.layerDefs;
        }
    },
    
    /**
     * APIMethod: mergeNewParams
     * Catch changeParams and uppercase the new params to be merged in
     *     before calling changeParams on the super class.
     * 
     *     Once params have been changed, the tiles will be reloaded with
     *     the new parameters.
     * 
     * Parameters:
     * newParams - {Object} Hashtable of new params to use
     */
    mergeNewParams:function(newParams) {
        var upperParams = HGIS.Util.upperCaseObject(newParams);
        var newArguments = [upperParams];
        return HGIS.Layer.Grid.prototype.mergeNewParams.apply(this, 
                                                             newArguments);
    },

    CLASS_NAME: "HGIS.Layer.ArcGIS93Rest"
});
/* ======================================================================
    HGIS/Layer/ArcGISCache.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/** 
 * @requires HGIS/Layer/XYZ.js
 */ 

/** 
 * Class: HGIS.Layer.ArcGISCache   
 * Layer for accessing cached map tiles from an ArcGIS Server style mapcache. 
 * Tile must already be cached for this layer to access it. This does not require 
 * ArcGIS Server itself.
 * 
 * A few attempts have been made at this kind of layer before. See 
 * http://trac.osgeo.org/HGIS/ticket/1967 
 * and 
 * http://trac.osgeo.org/HGIS/browser/sandbox/tschaub/arcgiscache/lib/HGIS/Layer/ArcGISCache.js
 *
 * Typically the problem encountered is that the tiles seem to "jump around".
 * This is due to the fact that the actual max extent for the tiles on AGS layers
 * changes at each zoom level due to the way these caches are constructed.
 * We have attempted to use the resolutions, tile size, and tile origin
 * from the cache meta data to make the appropriate changes to the max extent
 * of the tile to compensate for this behavior.  This must be done as zoom levels change
 * and before tiles are requested, which is why methods from base classes are overridden.
 *
 * For reference, you can access mapcache meta data in two ways. For accessing a 
 * mapcache through ArcGIS Server, you can simply go to the landing page for the
 * layer. (ie. http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer)
 * For accessing it directly through HTTP, there should always be a conf.xml file
 * in the root directory. 
 * (ie. http://serverx.esri.com/arcgiscache/DG_County_roads_yesA_backgroundDark/Layers/conf.xml)
 *  
 *Inherits from: 
 *  - <HGIS.Layer.XYZ>             
 */    
HGIS.Layer.ArcGISCache = HGIS.Class(HGIS.Layer.XYZ, {  

    /**
     * APIProperty: url
     * {String | Array} The base URL for the layer cache.  You can also
     *     provide a list of URL strings for the layer if your cache is
     *     available from multiple origins.  This must be set before the layer
     *     is drawn.
     */
    url: null,
    
   /**
    * APIProperty: tileOrigin
    * {<HGIS.LonLat>} The location of the tile origin for the cache.
    *     An ArcGIS cache has it's origin at the upper-left (lowest x value
    *     and highest y value of the coordinate system).  The units for the
    *     tile origin should be the same as the units for the cached data.
    */
    tileOrigin: null, 
   
   /**
    * APIProperty: tileSize
    * {<HGIS.Size>} This size of each tile. Defaults to 256 by 256 pixels.
    */
    tileSize: new HGIS.Size(256, 256),
    
   /**
    * APIProperty: useAGS
    * {Boolean} Indicates if we are going to be accessing the ArcGIS Server (AGS)
    *     cache via an AGS MapServer or directly through HTTP. When accessing via
    *     AGS the path structure uses a standard z/y/x structure. But AGS actually
    *     stores the tile images on disk using a hex based folder structure that looks
    *     like "http://example.com/mylayer/L00/R00000000/C00000000.png".  Learn more
    *     about this here:
    *     http://blogs.esri.com/Support/blogs/mappingcenter/archive/2010/08/20/Checking-Your-Local-Cache-Folders.aspx
    *     Defaults to true;
    */    
    useArcGISServer: true,

   /**
    * APIProperty: type
    * {String} Image type for the layer.  This becomes the filename extension
    *     in tile requests.  Default is "png" (generating a url like
    *     "http://example.com/mylayer/L00/R00000000/C00000000.png").
    */
    type: 'png',
    
    /**
    * APIProperty: useScales
    * {Boolean} Optional override to indicate that the layer should use 'scale' information
    *     returned from the server capabilities object instead of 'resolution' information.
    *     This can be important if your tile server uses an unusual DPI for the tiles.
    */
    useScales: false,
    
   /**
    * APIProperty: overrideDPI
    * {Boolean} Optional override to change the HGIS.DOTS_PER_INCH setting based 
    *     on the tile information in the server capabilities object.  This can be useful 
    *     if your server has a non-standard DPI setting on its tiles, and you're only using 
    *     tiles with that DPI.  This value is used while HGIS is calculating resolution
    *     using scales, and is not necessary if you have resolution information. (This is
    *     typically the case)  Regardless, this setting can be useful, but is dangerous
    *     because it will impact other layers while calculating resolution.  Only use this
    *     if you know what you are doing.  (See HGIS.Util.getResolutionFromScale)
    */
    overrideDPI: false,
    
   /**
    * Constructor: HGIS.Layer.ArcGISCache 
    * Creates a new instance of this class 
    * 
    * Parameters: 
    * name - {String} 
    * url - {String} 
    * options - {Object} extra layer options
    */ 
    initialize: function(name, url, options) { 
        HGIS.Layer.XYZ.prototype.initialize.apply(this, arguments);

        if (this.resolutions) {        
            this.serverResolutions = this.resolutions;
            this.maxExtent = this.getMaxExtentForResolution(this.resolutions[0]);
        }

        // this block steps through translating the values from the server layer JSON 
        // capabilities object into values that we can use.  This is also a helpful
        // reference when configuring this layer directly.
        if (this.layerInfo) {
            // alias the object
            var info = this.layerInfo;
            
            // build our extents
            var startingTileExtent = new HGIS.Bounds(
                info.fullExtent.xmin, 
                info.fullExtent.ymin, 
                info.fullExtent.xmax, 
                info.fullExtent.ymax  
            );

            // set our projection based on the given spatial reference.
            // esri uses slightly different IDs, so this may not be comprehensive
            this.projection = 'EPSG:' + info.spatialReference.wkid;
            this.sphericalMercator = (info.spatialReference.wkid == 102100);
            
            // convert esri units into HGIS units (basic feet or meters only)
            this.units = (info.units == "esriFeet") ? 'ft' : 'm';

            // optional extended section based on whether or not the server returned
            // specific tile information
            if (!!info.tileInfo) {            
                // either set the tiles based on rows/columns, or specific width/height
                this.tileSize = new HGIS.Size(
                    info.tileInfo.width || info.tileInfo.cols, 
                    info.tileInfo.height || info.tileInfo.rows
                );
                
                // this must be set when manually configuring this layer
                this.tileOrigin = new HGIS.LonLat(
                    info.tileInfo.origin.x, 
                    info.tileInfo.origin.y
                );

                var upperLeft = new HGIS.Geometry.Point(
                    startingTileExtent.left, 
                    startingTileExtent.top
                );
                
                var bottomRight = new HGIS.Geometry.Point(
                    startingTileExtent.right, 
                    startingTileExtent.bottom
                );            
                
                if (this.useScales) {
                    this.scales = [];
                } else {
                    this.resolutions = [];
                }
                
                this.lods = [];
                for(var key in info.tileInfo.lods) {
                    if (info.tileInfo.lods.hasOwnProperty(key)) {
                        var lod = info.tileInfo.lods[key];
                        if (this.useScales) {
                            this.scales.push(lod.scale);
                        } else {
                            this.resolutions.push(lod.resolution);
                        }
                    
                        var start = this.getContainingTileCoords(upperLeft, lod.resolution);
                        lod.startTileCol = start.x;
                        lod.startTileRow = start.y;
                    
                        var end = this.getContainingTileCoords(bottomRight, lod.resolution);
                        lod.endTileCol = end.x;
                        lod.endTileRow = end.y;    
                        this.lods.push(lod);
                    }
                }

                this.maxExtent = this.calculateMaxExtentWithLOD(this.lods[0]);
                this.serverResolutions = this.resolutions;
                if (this.overrideDPI && info.tileInfo.dpi) {
                    // see comment above for 'overrideDPI'
                    HGIS.DOTS_PER_INCH = info.tileInfo.dpi;
                }
            } 
       }
    }, 

   /** 
    * Method: getContainingTileCoords
    * Calculates the x/y pixel corresponding to the position of the tile
    *     that contains the given point and for the for the given resolution.
    * 
    * Parameters:
    * point - {<HGIS.Geometry.Point>} 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<HGIS.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getContainingTileCoords: function(point, res) {
        return new HGIS.Pixel(
           Math.max(Math.floor((point.x - this.tileOrigin.lon) / (this.tileSize.w * res)),0),
           Math.max(Math.floor((this.tileOrigin.lat - point.y) / (this.tileSize.h * res)),0)
        );
    },
    
   /** 
    * Method: calculateMaxExtentWithLOD
    * Given a Level of Detail object from the server, this function
    *     calculates the actual max extent
    * 
    * Parameters: 
    * lod - {Object} a Level of Detail Object from the server capabilities object 
            representing a particular zoom level
    * 
    * Returns: 
    * {<HGIS.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithLOD: function(lod) {
        // the max extent we're provided with just overlaps some tiles
        // our real extent is the bounds of all the tiles we touch

        var numTileCols = (lod.endTileCol - lod.startTileCol) + 1;
        var numTileRows = (lod.endTileRow - lod.startTileRow) + 1;        

        var minX = this.tileOrigin.lon + (lod.startTileCol * this.tileSize.w * lod.resolution);
        var maxX = minX + (numTileCols * this.tileSize.w * lod.resolution);

        var maxY = this.tileOrigin.lat - (lod.startTileRow * this.tileSize.h * lod.resolution);
        var minY = maxY - (numTileRows * this.tileSize.h * lod.resolution);
        return new HGIS.Bounds(minX, minY, maxX, maxY);
   },
    
   /** 
    * Method: calculateMaxExtentWithExtent
    * Given a 'suggested' max extent from the server, this function uses
    *     information about the actual tile sizes to determine the actual
    *     extent of the layer.
    * 
    * Parameters: 
    * extent - {<HGIS.Bounds>} The 'suggested' extent for the layer
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<HGIS.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithExtent: function(extent, res) {
        var upperLeft = new HGIS.Geometry.Point(extent.left, extent.top);
        var bottomRight = new HGIS.Geometry.Point(extent.right, extent.bottom);
        var start = this.getContainingTileCoords(upperLeft, res);
        var end = this.getContainingTileCoords(bottomRight, res);
        var lod = {
            resolution: res,
            startTileCol: start.x,
            startTileRow: start.y,
            endTileCol: end.x,
            endTileRow: end.y
        };
        return this.calculateMaxExtentWithLOD(lod);
   },
    
    /** 
    * Method: getUpperLeftTileCoord
    * Calculates the x/y pixel corresponding to the position 
    *     of the upper left tile for the given resolution.
    * 
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<HGIS.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getUpperLeftTileCoord: function(res) {
        var upperLeft = new HGIS.Geometry.Point(
            this.maxExtent.left,
            this.maxExtent.top);
        return this.getContainingTileCoords(upperLeft, res);
    },

    /** 
    * Method: getLowerRightTileCoord
    * Calculates the x/y pixel corresponding to the position 
    *     of the lower right tile for the given resolution.
    *  
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<HGIS.Pixel>} The x/y pixel corresponding to the position
    * of the lower right tile for the given resolution.
    */
    getLowerRightTileCoord: function(res) {
        var bottomRight = new HGIS.Geometry.Point(
            this.maxExtent.right,
            this.maxExtent.bottom);
        return this.getContainingTileCoords(bottomRight, res);
    },
    
   /** 
    * Method: getMaxExtentForResolution
    * Since the max extent of a set of tiles can change from zoom level
    *     to zoom level, we need to be able to calculate that max extent 
    *     for a given resolution.
    *
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<HGIS.Bounds>} The extent for this resolution
    */ 
    getMaxExtentForResolution: function(res) {
        var start = this.getUpperLeftTileCoord(res);
        var end = this.getLowerRightTileCoord(res);

        var numTileCols = (end.x - start.x) + 1;
        var numTileRows = (end.y - start.y) + 1;

        var minX = this.tileOrigin.lon + (start.x * this.tileSize.w * res);
        var maxX = minX + (numTileCols * this.tileSize.w * res);
        
        var maxY = this.tileOrigin.lat - (start.y * this.tileSize.h * res);
        var minY = maxY - (numTileRows * this.tileSize.h * res);
        return new HGIS.Bounds(minX, minY, maxX, maxY);
    },
    
   /** 
    * APIMethod: clone 
    * Returns an exact clone of this HGIS.Layer.ArcGISCache
    * 
    * Parameters: 
    * [obj] - {Object} optional object to assign the cloned instance to.
    *  
    * Returns: 
    * {<HGIS.Layer.ArcGISCache>} clone of this instance 
    */ 
    clone: function (obj) { 
        if (obj == null) { 
            obj = new HGIS.Layer.ArcGISCache(this.name, this.url, this.options);
        }
        return HGIS.Layer.XYZ.prototype.clone.apply(this, [obj]);
    },

    /**
     * Method: initGriddedTiles
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     */
    initGriddedTiles: function(bounds) {
        delete this._tileOrigin;
        HGIS.Layer.XYZ.prototype.initGriddedTiles.apply(this, arguments);
    },
    
    /**
     * Method: getMaxExtent
     * Get this layer's maximum extent.
     *
     * Returns:
     * {<HGIS.Bounds>}
     */
    getMaxExtent: function() {
        var resolution = this.map.getResolution();
        return this.maxExtent = this.getMaxExtentForResolution(resolution);
    },

    /**
     * Method: getTileOrigin
     * Determine the origin for aligning the grid of tiles.  
     *     The origin will be derived from the layer's <maxExtent> property. 
     *
     * Returns:
     * {<HGIS.LonLat>} The tile origin.
     */
    getTileOrigin: function() {
        if (!this._tileOrigin) {
            var extent = this.getMaxExtent();
            this._tileOrigin = new HGIS.LonLat(extent.left, extent.bottom);
        }
        return this._tileOrigin;
    },

   /**
    * Method: getURL
    * Determine the URL for a tile given the tile bounds.  This is should support
    *     urls that access tiles through an ArcGIS Server MapServer or directly through
    *     the hex folder structure using HTTP.  Just be sure to set the useArcGISServer
    *     property appropriately!  This is basically the same as 
    *     'HGIS.Layer.TMS.getURL',  but with the addition of hex addressing,
    *     and tile rounding.
    *
    * Parameters:
    * bounds - {<HGIS.Bounds>}
    *
    * Returns:
    * {String} The URL for a tile based on given bounds.
    */
    getURL: function (bounds) {
        var res = this.getResolution(); 

        // tile center
        var originTileX = (this.tileOrigin.lon + (res * this.tileSize.w/2)); 
        var originTileY = (this.tileOrigin.lat - (res * this.tileSize.h/2));

        var center = bounds.getCenterLonLat();
        var point = { x: center.lon, y: center.lat };
        var x = (Math.round(Math.abs((center.lon - originTileX) / (res * this.tileSize.w)))); 
        var y = (Math.round(Math.abs((originTileY - center.lat) / (res * this.tileSize.h)))); 
        var z = this.map.getZoom();

        // this prevents us from getting pink tiles (non-existant tiles)
        if (this.lods) {        
            var lod = this.lods[this.map.getZoom()];
            if ((x < lod.startTileCol || x > lod.endTileCol) 
                || (y < lod.startTileRow || y > lod.endTileRow)) {
                    return null;
            }
        }
        else {
            var start = this.getUpperLeftTileCoord(res);
            var end = this.getLowerRightTileCoord(res);
            if ((x < start.x || x >= end.x)
                || (y < start.y || y >= end.y)) {
                    return null;
            }        
        }

        // Construct the url string
        var url = this.url;
        var s = '' + x + y + z;

        if (HGIS.Util.isArray(url)) {
            url = this.selectUrl(s, url);
        }

        // Accessing tiles through ArcGIS Server uses a different path
        // structure than direct access via the folder structure.
        if (this.useArcGISServer) {
            // AGS MapServers have pretty url access to tiles
            url = url + '/tile/${z}/${y}/${x}';
        } else {
            // The tile images are stored using hex values on disk.
            x = 'C' + HGIS.Number.zeroPad(x, 8, 16);
            y = 'R' + HGIS.Number.zeroPad(y, 8, 16);
            z = 'L' + HGIS.Number.zeroPad(z, 2, 10);
            url = url + '/${z}/${y}/${x}.' + this.type;
        }

        // Write the values into our formatted url
        url = HGIS.String.format(url, {'x': x, 'y': y, 'z': z});

        return HGIS.Util.urlAppend(
            url, HGIS.Util.getParameterString(this.params)
        );
    },

    CLASS_NAME: 'HGIS.Layer.ArcGISCache' 
}); 
/* ======================================================================
    HGIS/Control/WMSGetFeatureInfo.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Control.js
 * @requires HGIS/Handler/Click.js
 * @requires HGIS/Handler/Hover.js
 * @requires HGIS/Request.js
 * @requires HGIS/Format/WMSGetFeatureInfo.js
 */

/**
 * Class: HGIS.Control.WMSGetFeatureInfo
 * The WMSGetFeatureInfo control uses a WMS query to get information about a point on the map.  The
 * information may be in a display-friendly format such as HTML, or a machine-friendly format such
 * as GML, depending on the server's capabilities and the client's configuration.  This control
 * handles click or hover events, attempts to parse the results using an HGIS.Format, and
 * fires a 'getfeatureinfo' event with the click position, the raw body of the response, and an
 * array of features if it successfully read the response.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.WMSGetFeatureInfo = HGIS.Class(HGIS.Control, {

   /**
     * APIProperty: hover
     * {Boolean} Send GetFeatureInfo requests when mouse stops moving.
     *     Default is false.
     */
    hover: false,

    /**
     * APIProperty: drillDown
     * {Boolean} Drill down over all WMS layers in the map. When
     *     using drillDown mode, hover is not possible, and an infoFormat that
     *     returns parseable features is required. Default is false.
     */
    drillDown: false,

    /**
     * APIProperty: maxFeatures
     * {Integer} Maximum number of features to return from a WMS query. This
     *     sets the feature_count parameter on WMS GetFeatureInfo
     *     requests.
     */
    maxFeatures: 10,

    /**
     * APIProperty: clickCallback
     * {String} The click callback to register in the
     *     {<HGIS.Handler.Click>} object created when the hover
     *     option is set to false. Default is "click".
     */
    clickCallback: "click",

    /**
     * APIProperty: output
     * {String} Either "features" or "object". When triggering a getfeatureinfo
     *     request should we pass on an array of features or an object with with
     *     a "features" property and other properties (such as the url of the
     *     WMS). Default is "features".
     */
    output: "features",

    /**
     * APIProperty: layers
     * {Array(<HGIS.Layer.WMS>)} The layers to query for feature info.
     *     If omitted, all map WMS layers with a url that matches this <url> or
     *     <layerUrls> will be considered.
     */
    layers: null,

    /**
     * APIProperty: queryVisible
     * {Boolean} If true, filter out hidden layers when searching the map for
     *     layers to query.  Default is false.
     */
    queryVisible: false,

    /**
     * APIProperty: url
     * {String} The URL of the WMS service to use.  If not provided, the url
     *     of the first eligible layer will be used.
     */
    url: null,

    /**
     * APIProperty: layerUrls
     * {Array(String)} Optional list of urls for layers that should be queried.
     *     This can be used when the layer url differs from the url used for
     *     making GetFeatureInfo requests (in the case of a layer using cached
     *     tiles).
     */
    layerUrls: null,

    /**
     * APIProperty: infoFormat
     * {String} The mimetype to request from the server. If you are using
     *     drillDown mode and have multiple servers that do not share a common
     *     infoFormat, you can override the control's infoFormat by providing an
     *     INFO_FORMAT parameter in your <HGIS.Layer.WMS> instance(s).
     */
    infoFormat: 'text/html',

    /**
     * APIProperty: vendorParams
     * {Object} Additional parameters that will be added to the request, for
     *     WMS implementations that support them. This could e.g. look like
     * (start code)
     * {
     *     radius: 5
     * }
     * (end)
     */
    vendorParams: {},

    /**
     * APIProperty: format
     * {<HGIS.Format>} A format for parsing GetFeatureInfo responses.
     *     Default is <HGIS.Format.WMSGetFeatureInfo>.
     */
    format: null,

    /**
     * APIProperty: formatOptions
     * {Object} Optional properties to set on the format (if one is not provided
     *     in the <format> property.
     */
    formatOptions: null,

    /**
     * APIProperty: handlerOptions
     * {Object} Additional options for the handlers used by this control, e.g.
     * (start code)
     * {
     *     "click": {delay: 100},
     *     "hover": {delay: 300}
     * }
     * (end)
     */

    /**
     * Property: handler
     * {Object} Reference to the <HGIS.Handler> for this control
     */
    handler: null,

    /**
     * Property: hoverRequest
     * {<HGIS.Request>} contains the currently running hover request
     *     (if any).
     */
    hoverRequest: null,

    /**
     * APIProperty: events
     * {<HGIS.Events>} Events instance for listeners and triggering
     *     control specific events.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types (in addition to those from <HGIS.Control.events>):
     * beforegetfeatureinfo - Triggered before the request is sent.
     *      The event object has an *xy* property with the position of the
     *      mouse click or hover event that triggers the request.
     * nogetfeatureinfo - no queryable layers were found.
     * getfeatureinfo - Triggered when a GetFeatureInfo response is received.
     *      The event object has a *text* property with the body of the
     *      response (String), a *features* property with an array of the
     *      parsed features, an *xy* property with the position of the mouse
     *      click or hover event that triggered the request, and a *request*
     *      property with the request itself. If drillDown is set to true and
     *      multiple requests were issued to collect feature info from all
     *      layers, *text* and *request* will only contain the response body
     *      and request object of the last request.
     */

    /**
     * Constructor: <HGIS.Control.WMSGetFeatureInfo>
     *
     * Parameters:
     * options - {Object}
     */
    initialize: function(options) {
        options = options || {};
        options.handlerOptions = options.handlerOptions || {};

        HGIS.Control.prototype.initialize.apply(this, [options]);

        if(!this.format) {
            this.format = new HGIS.Format.WMSGetFeatureInfo(
                options.formatOptions
            );
        }

        if(this.drillDown === true) {
            this.hover = false;
        }

        if(this.hover) {
            this.handler = new HGIS.Handler.Hover(
                   this, {
                       'move': this.cancelHover,
                       'pause': this.getInfoForHover
                   },
                   HGIS.Util.extend(this.handlerOptions.hover || {}, {
                       'delay': 250
                   }));
        } else {
            var callbacks = {};
            callbacks[this.clickCallback] = this.getInfoForClick;
            this.handler = new HGIS.Handler.Click(
                this, callbacks, this.handlerOptions.click || {});
        }
    },

    /**
     * Method: getInfoForClick
     * Called on click
     *
     * Parameters:
     * evt - {<HGIS.Event>}
     */
    getInfoForClick: function(evt) {
        this.events.triggerEvent("beforegetfeatureinfo", {xy: evt.xy});
        // Set the cursor to "wait" to tell the user we're working on their
        // click.
        HGIS.Element.addClass(this.map.viewPortDiv, "olCursorWait");
        this.request(evt.xy, {});
    },

    /**
     * Method: getInfoForHover
     * Pause callback for the hover handler
     *
     * Parameters:
     * evt - {Object}
     */
    getInfoForHover: function(evt) {
        this.events.triggerEvent("beforegetfeatureinfo", {xy: evt.xy});
        this.request(evt.xy, {hover: true});
    },

    /**
     * Method: cancelHover
     * Cancel callback for the hover handler
     */
    cancelHover: function() {
        if (this.hoverRequest) {
            this.hoverRequest.abort();
            this.hoverRequest = null;
        }
    },

    /**
     * Method: findLayers
     * Internal method to get the layers, independent of whether we are
     *     inspecting the map or using a client-provided array
     */
    findLayers: function() {

        var candidates = this.layers || this.map.layers;
        var layers = [];
        var layer, url;
        for(var i = candidates.length - 1; i >= 0; --i) {
            layer = candidates[i];
            if(layer instanceof HGIS.Layer.WMS &&
               (!this.queryVisible || layer.getVisibility())) {
                url = HGIS.Util.isArray(layer.url) ? layer.url[0] : layer.url;
                // if the control was not configured with a url, set it
                // to the first layer url
                if(this.drillDown === false && !this.url) {
                    this.url = url;
                }
                if(this.drillDown === true || this.urlMatches(url)) {
                    layers.push(layer);
                }
            }
        }
        return layers;
    },

    /**
     * Method: urlMatches
     * Test to see if the provided url matches either the control <url> or one
     *     of the <layerUrls>.
     *
     * Parameters:
     * url - {String} The url to test.
     *
     * Returns:
     * {Boolean} The provided url matches the control <url> or one of the
     *     <layerUrls>.
     */
    urlMatches: function(url) {
        var matches = HGIS.Util.isEquivalentUrl(this.url, url);
        if(!matches && this.layerUrls) {
            for(var i=0, len=this.layerUrls.length; i<len; ++i) {
                if(HGIS.Util.isEquivalentUrl(this.layerUrls[i], url)) {
                    matches = true;
                    break;
                }
            }
        }
        return matches;
    },

    /**
     * Method: buildWMSOptions
     * Build an object with the relevant WMS options for the GetFeatureInfo request
     *
     * Parameters:
     * url - {String} The url to be used for sending the request
     * layers - {Array(<HGIS.Layer.WMS)} An array of layers
     * clickPosition - {<HGIS.Pixel>} The position on the map where the mouse
     *     event occurred.
     * format - {String} The format from the corresponding GetMap request
     */
    buildWMSOptions: function(url, layers, clickPosition, format) {
        var layerNames = [], styleNames = [];
        for (var i = 0, len = layers.length; i < len; i++) {
            if (layers[i].params.LAYERS != null) {
                layerNames = layerNames.concat(layers[i].params.LAYERS);
                styleNames = styleNames.concat(this.getStyleNames(layers[i]));
            }
        }
        var firstLayer = layers[0];
        // use the firstLayer's projection if it matches the map projection -
        // this assumes that all layers will be available in this projection
        var projection = this.map.getProjection();
        var layerProj = firstLayer.projection;
        if (layerProj && layerProj.equals(this.map.getProjectionObject())) {
            projection = layerProj.getCode();
        }
        var params = HGIS.Util.extend({
            service: "WMS",
            version: firstLayer.params.VERSION,
            request: "GetFeatureInfo",
            exceptions: firstLayer.params.EXCEPTIONS,
            bbox: this.map.getExtent().toBBOX(null,
                firstLayer.reverseAxisOrder()),
            feature_count: this.maxFeatures,
            height: this.map.getSize().h,
            width: this.map.getSize().w,
            format: format,
            info_format: firstLayer.params.INFO_FORMAT || this.infoFormat
        }, (parseFloat(firstLayer.params.VERSION) >= 1.3) ?
            {
                crs: projection,
                i: parseInt(clickPosition.x),
                j: parseInt(clickPosition.y)
            } :
            {
                srs: projection,
                x: parseInt(clickPosition.x),
                y: parseInt(clickPosition.y)
            }
        );
        if (layerNames.length != 0) {
            params = HGIS.Util.extend({
                layers: layerNames,
                query_layers: layerNames,
                styles: styleNames
            }, params);
        }
        HGIS.Util.applyDefaults(params, this.vendorParams);
        return {
            url: url,
            params: HGIS.Util.upperCaseObject(params),
            callback: function(request) {
                this.handleResponse(clickPosition, request, url);
            },
            scope: this
        };
    },

    /**
     * Method: getStyleNames
     * Gets the STYLES parameter for the layer. Make sure the STYLES parameter
     * matches the LAYERS parameter
     *
     * Parameters:
     * layer - {<HGIS.Layer.WMS>}
     *
     * Returns:
     * {Array(String)} The STYLES parameter
     */
    getStyleNames: function(layer) {
        // in the event of a WMS layer bundling multiple layers but not
        // specifying styles,we need the same number of commas to specify
        // the default style for each of the layers.  We can't just leave it
        // blank as we may be including other layers that do specify styles.
        var styleNames;
        if (layer.params.STYLES) {
            styleNames = layer.params.STYLES;
        } else {
            if (HGIS.Util.isArray(layer.params.LAYERS)) {
                styleNames = new Array(layer.params.LAYERS.length);
            } else { // Assume it's a String
                styleNames = layer.params.LAYERS.replace(/[^,]/g, "");
            }
        }
        return styleNames;
    },

    /**
     * Method: request
     * Sends a GetFeatureInfo request to the WMS
     *
     * Parameters:
     * clickPosition - {<HGIS.Pixel>} The position on the map where the
     *     mouse event occurred.
     * options - {Object} additional options for this method.
     *
     * Valid options:
     * - *hover* {Boolean} true if we do the request for the hover handler
     */
    request: function(clickPosition, options) {
        var layers = this.findLayers();
        if(layers.length == 0) {
            this.events.triggerEvent("nogetfeatureinfo");
            // Reset the cursor.
            HGIS.Element.removeClass(this.map.viewPortDiv, "olCursorWait");
            return;
        }

        options = options || {};
        if(this.drillDown === false) {
            var wmsOptions = this.buildWMSOptions(this.url, layers,
                clickPosition, layers[0].params.FORMAT);
            var request = HGIS.Request.GET(wmsOptions);

            if (options.hover === true) {
                this.hoverRequest = request;
            }
        } else {
            this._requestCount = 0;
            this._numRequests = 0;
            this.features = [];
            // group according to service url to combine requests
            var services = {}, url;
            for(var i=0, len=layers.length; i<len; i++) {
                var layer = layers[i];
                var service, found = false;
                url = HGIS.Util.isArray(layer.url) ? layer.url[0] : layer.url;
                if(url in services) {
                    services[url].push(layer);
                } else {
                    this._numRequests++;
                    services[url] = [layer];
                }
            }
            var layers;
            for (var url in services) {
                layers = services[url];
                var wmsOptions = this.buildWMSOptions(url, layers,
                    clickPosition, layers[0].params.FORMAT);
                HGIS.Request.GET(wmsOptions);
            }
        }
    },

    /**
     * Method: triggerGetFeatureInfo
     * Trigger the getfeatureinfo event when all is done
     *
     * Parameters:
     * request - {XMLHttpRequest} The request object
     * xy - {<HGIS.Pixel>} The position on the map where the
     *     mouse event occurred.
     * features - {Array(<HGIS.Feature.Vector>)} or
     *     {Array({Object}) when output is "object". The object has a url and a
     *     features property which contains an array of features.
     */
    triggerGetFeatureInfo: function(request, xy, features) {
        this.events.triggerEvent("getfeatureinfo", {
            text: request.responseText,
            features: features,
            request: request,
            xy: xy
        });

        // Reset the cursor.
        HGIS.Element.removeClass(this.map.viewPortDiv, "olCursorWait");
    },

    /**
     * Method: handleResponse
     * Handler for the GetFeatureInfo response.
     *
     * Parameters:
     * xy - {<HGIS.Pixel>} The position on the map where the
     *     mouse event occurred.
     * request - {XMLHttpRequest} The request object.
     * url - {String} The url which was used for this request.
     */
    handleResponse: function(xy, request, url) {

        var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        var features = this.format.read(doc);
        if (this.drillDown === false) {
            this.triggerGetFeatureInfo(request, xy, features);
        } else {
            this._requestCount++;
            if (this.output === "object") {
                this._features = (this._features || []).concat(
                    {url: url, features: features}
                );
            } else {
            this._features = (this._features || []).concat(features);
            }
            if (this._requestCount === this._numRequests) {
                this.triggerGetFeatureInfo(request, xy, this._features.concat());
                delete this._features;
                delete this._requestCount;
                delete this._numRequests;
            }
        }
    },

    CLASS_NAME: "HGIS.Control.WMSGetFeatureInfo"
});
/* ======================================================================
    HGIS/Format/WMSCapabilities/v1_3_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WMSCapabilities/v1_3.js
 */

/**
 * Class: HGIS.Format.WMSCapabilities/v1_3_0
 * Read WMS Capabilities version 1.3.0. 
 * SLD 1.1.0 adds in the extra operations DescribeLayer and GetLegendGraphic, 
 * see: http://schemas.opengis.net/sld/1.1.0/sld_capabilities.xsd
 * 
 * Inherits from:
 *  - <HGIS.Format.WMSCapabilities.v1_3>
 */
HGIS.Format.WMSCapabilities.v1_3_0 = HGIS.Class(
    HGIS.Format.WMSCapabilities.v1_3, {
    
    /**
     * Property: version
     * {String} The specific parser version.
     */
    version: "1.3.0",
    
    CLASS_NAME: "HGIS.Format.WMSCapabilities.v1_3_0" 

});
/* ======================================================================
    HGIS/Format/SOSGetFeatureOfInterest.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */
 
/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/GML/v3.js
 */

/**
 * Class: HGIS.Format.SOSGetFeatureOfInterest
 * Read and write SOS GetFeatureOfInterest. This is used to get to
 * the location of the features (stations). The stations can have 1 or more
 * sensors.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.SOSGetFeatureOfInterest = HGIS.Class(
    HGIS.Format.XML, {
    
    /**
     * Constant: VERSION
     * {String} 1.0.0
     */
    VERSION: "1.0.0",

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        sos: "http://www.opengis.net/sos/1.0",
        gml: "http://www.opengis.net/gml",
        sa: "http://www.opengis.net/sampling/1.0",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Property: schemaLocation
     * {String} Schema location
     */
    schemaLocation: "http://www.opengis.net/sos/1.0 http://schemas.opengis.net/sos/1.0.0/sosAll.xsd",

    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "sos",

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },
    
    /**
     * Constructor: HGIS.Format.SOSGetFeatureOfInterest
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * APIMethod: read
     * Parse a GetFeatureOfInterest response and return an array of features
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Array(<HGIS.Feature.Vector>)} An array of features. 
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }

        var info = {features: []};
        this.readNode(data, info);
       
        var features = [];
        for (var i=0, len=info.features.length; i<len; i++) {
            var container = info.features[i];
            // reproject features if needed
            if(this.internalProjection && this.externalProjection &&
                container.components[0]) {
                    container.components[0].transform(
                        this.externalProjection, this.internalProjection
                    );
            }             
            var feature = new HGIS.Feature.Vector(
                container.components[0], container.attributes);
            features.push(feature);
        }
        return features;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "sa": {
            "SamplingPoint": function(node, obj) {
                // sampling point can also be without a featureMember if 
                // there is only 1
                if (!obj.attributes) {
                    var feature = {attributes: {}};
                    obj.features.push(feature);
                    obj = feature;
                }
                obj.attributes.id = this.getAttributeNS(node, 
                    this.namespaces.gml, "id");
                this.readChildNodes(node, obj);
            },
            "position": function (node, obj) {
                this.readChildNodes(node, obj);
            }
        },
        "gml": HGIS.Util.applyDefaults({
            "FeatureCollection": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "featureMember": function(node, obj) {
                var feature = {attributes: {}};
                obj.features.push(feature);
                this.readChildNodes(node, feature);
            },
            "name": function(node, obj) {
                obj.attributes.name = this.getChildValue(node);
            },
            "pos": function(node, obj) {
                // we need to parse the srsName to get to the 
                // externalProjection, that's why we cannot use
                // GML v3 for this
                if (!this.externalProjection) {
                    this.externalProjection = new HGIS.Projection(
                        node.getAttribute("srsName"));
                }
             HGIS.Format.GML.v3.prototype.readers.gml.pos.apply(
                    this, [node, obj]);
            }
        }, HGIS.Format.GML.v3.prototype.readers.gml)
    },
    
    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "sos": {
            "GetFeatureOfInterest": function(options) {
                var node = this.createElementNSPlus("GetFeatureOfInterest", {
                    attributes: {
                        version: this.VERSION,
                        service: 'SOS',
                        "xsi:schemaLocation": this.schemaLocation
                    } 
                }); 
                for (var i=0, len=options.fois.length; i<len; i++) {
                    this.writeNode("FeatureOfInterestId", {foi: options.fois[i]}, node);
                }
                return node; 
            },
            "FeatureOfInterestId": function(options) {
                var node = this.createElementNSPlus("FeatureOfInterestId", {value: options.foi});
                return node;
            }
        }
    },

    CLASS_NAME: "HGIS.Format.SOSGetFeatureOfInterest" 

});
/* ======================================================================
    HGIS/Format/SOSGetObservation.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/SOSGetFeatureOfInterest.js
 */

/**
 * Class: HGIS.Format.SOSGetObservation
 * Read and write SOS GetObersation (to get the actual values from a sensor) 
 *     version 1.0.0
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.SOSGetObservation = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows",
        gml: "http://www.opengis.net/gml",
        sos: "http://www.opengis.net/sos/1.0",
        ogc: "http://www.opengis.net/ogc",
        om: "http://www.opengis.net/om/1.0",
        sa: "http://www.opengis.net/sampling/1.0",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Property: regExes
     * Compiled regular expressions for manipulating strings.
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * Constant: VERSION
     * {String} 1.0.0
     */
    VERSION: "1.0.0",

    /**
     * Property: schemaLocation
     * {String} Schema location
     */
    schemaLocation: "http://www.opengis.net/sos/1.0 http://schemas.opengis.net/sos/1.0.0/sosGetObservation.xsd",

    /**
     * Property: defaultPrefix
     */
    defaultPrefix: "sos",

    /**
     * Constructor: HGIS.Format.SOSGetObservation
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Method: read
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} An object containing the measurements
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var info = {measurements: [], observations: []};
        this.readNode(data, info);
        return info;
    },

    /**
     * Method: write
     *
     * Parameters:
     * options - {Object} Optional object.
     *
     * Returns:
     * {String} An SOS GetObservation request XML string.
     */
    write: function(options) {
        var node = this.writeNode("sos:GetObservation", options);
        node.setAttribute("xmlns:om", this.namespaces.om);
        node.setAttribute("xmlns:ogc", this.namespaces.ogc);
        this.setAttributeNS(
            node, this.namespaces.xsi,
            "xsi:schemaLocation", this.schemaLocation
        );
        return HGIS.Format.XML.prototype.write.apply(this, [node]);
    }, 

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "om": {
            "ObservationCollection": function(node, obj) {
                obj.id = this.getAttributeNS(node, this.namespaces.gml, "id");
                this.readChildNodes(node, obj);
            },
            "member": function(node, observationCollection) {
                this.readChildNodes(node, observationCollection);
            },
            "Measurement": function(node, observationCollection) {
                var measurement = {};
                observationCollection.measurements.push(measurement);
                this.readChildNodes(node, measurement);
            },
            "Observation": function(node, observationCollection) {
                var observation = {};
                observationCollection.observations.push(observation);
                this.readChildNodes(node, observation);
            },
            "samplingTime": function(node, measurement) {
                var samplingTime = {};
                measurement.samplingTime = samplingTime;
                this.readChildNodes(node, samplingTime);
            },
            "observedProperty": function(node, measurement) {
                measurement.observedProperty = 
                    this.getAttributeNS(node, this.namespaces.xlink, "href");
                this.readChildNodes(node, measurement);
            },
            "procedure": function(node, measurement) {
                measurement.procedure = 
                    this.getAttributeNS(node, this.namespaces.xlink, "href");
                this.readChildNodes(node, measurement);
            },
            "featureOfInterest": function(node, observation) {
                var foi = {features: []};
                observation.fois = [];
                observation.fois.push(foi);
                this.readChildNodes(node, foi);
                // postprocessing to get actual features
                var features = [];
                for (var i=0, len=foi.features.length; i<len; i++) {
                    var feature = foi.features[i];
                    features.push(new HGIS.Feature.Vector(
                        feature.components[0], feature.attributes));
                }
                foi.features = features;
            },
            "result": function(node, measurement) {
                var result = {};
                measurement.result = result;
                if (this.getChildValue(node) !== '') {
                    result.value = this.getChildValue(node);
                    result.uom = node.getAttribute("uom");
                } else {
                    this.readChildNodes(node, result);
                }
            }
        },
        "sa": HGIS.Format.SOSGetFeatureOfInterest.prototype.readers.sa,
        "gml": HGIS.Util.applyDefaults({
            "TimeInstant": function(node, samplingTime) {
               var timeInstant = {};
                samplingTime.timeInstant = timeInstant;
                this.readChildNodes(node, timeInstant);
            },
            "timePosition": function(node, timeInstant) {
                timeInstant.timePosition = this.getChildValue(node);
            }
        }, HGIS.Format.SOSGetFeatureOfInterest.prototype.readers.gml)
    },

    /**
     * Property: writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     */
    writers: {
        "sos": {
            "GetObservation": function(options) {
                var node = this.createElementNSPlus("GetObservation", {
                    attributes: {
                        version: this.VERSION,
                        service: 'SOS'
                    } 
                }); 
                this.writeNode("offering", options, node);
                if (options.eventTime) {
                    this.writeNode("eventTime", options, node);
                }
                for (var procedure in options.procedures) {
                    this.writeNode("procedure", options.procedures[procedure], node);
                }
                for (var observedProperty in options.observedProperties) {
                    this.writeNode("observedProperty", options.observedProperties[observedProperty], node);
                }
                if (options.foi) {
                    this.writeNode("featureOfInterest", options.foi, node);
                }
                this.writeNode("responseFormat", options, node);
                if (options.resultModel) {
                    this.writeNode("resultModel", options, node);
                }
                if (options.responseMode) {
                    this.writeNode("responseMode", options, node);
                }
                return node; 
            },
            "featureOfInterest": function(foi) {
                var node = this.createElementNSPlus("featureOfInterest");
                this.writeNode("ObjectID", foi.objectId, node);
                return node;
            },
            "ObjectID": function(options) {
                return this.createElementNSPlus("ObjectID",
                    {value: options});
            },
            "responseFormat": function(options) {
                return this.createElementNSPlus("responseFormat", 
                    {value: options.responseFormat});
            },
            "procedure": function(procedure) {
                return this.createElementNSPlus("procedure", 
                    {value: procedure});
            },
            "offering": function(options) {
                return this.createElementNSPlus("offering", {value: 
                    options.offering});
            },
            "observedProperty": function(observedProperty) {
                return this.createElementNSPlus("observedProperty", 
                    {value: observedProperty});
            },
            "eventTime": function(options) {
                var node = this.createElementNSPlus("eventTime");
                if (options.eventTime === 'latest') {
                    this.writeNode("ogc:TM_Equals", options, node);
                }
                return node;
            },
            "resultModel": function(options) {
                return this.createElementNSPlus("resultModel", {value: 
                    options.resultModel});
            },
            "responseMode": function(options) {
                return this.createElementNSPlus("responseMode", {value: 
                    options.responseMode});
            }
        },
        "ogc": {
            "TM_Equals": function(options) {
                var node = this.createElementNSPlus("ogc:TM_Equals");
                this.writeNode("ogc:PropertyName", {property: 
                    "urn:ogc:data:time:iso8601"}, node);
                if (options.eventTime === 'latest') {
                    this.writeNode("gml:TimeInstant", {value: 'latest'}, node);
                }
                return node;
            },
            "PropertyName": function(options) {
                return this.createElementNSPlus("ogc:PropertyName", 
                    {value: options.property});
            }
        },
        "gml": {
            "TimeInstant": function(options) {
                var node = this.createElementNSPlus("gml:TimeInstant");
                this.writeNode("gml:timePosition", options, node);
                return node;
            },
            "timePosition": function(options) {
                var node = this.createElementNSPlus("gml:timePosition", 
                    {value: options.value});
                return node;
            }
        }
    },
    
    CLASS_NAME: "HGIS.Format.SOSGetObservation" 

});
/* ======================================================================
    HGIS/Control/UTFGrid.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Handler/Hover.js
 * @requires HGIS/Handler/Click.js
 */

/**
 * Class: HGIS.Control.UTFGrid
 *
 * This Control provides behavior associated with UTFGrid Layers.
 * These 'hit grids' provide underlying feature attributes without
 * calling the server (again). This control allows Mousemove, Hovering 
 * and Click events to trigger callbacks that use the attributes in 
 * whatever way you need. 
 *
 * The most common example may be a UTFGrid layer containing feature
 * attributes that are displayed in a div as you mouseover.
 *
 * Example Code:
 *
 * (start code)
 * var world_utfgrid = new HGIS.Layer.UTFGrid( 
 *     'UTFGrid Layer', 
 *     "http://tiles/world_utfgrid/${z}/${x}/${y}.json"
 * );
 * map.addLayer(world_utfgrid);
 * 
 * var control = new HGIS.Control.UTFGrid({
 *     layers: [world_utfgrid],
 *     handlerMode: 'move',
 *     callback: function(infoLookup) {
 *         // do something with returned data
 *
 *     }
 * })
 * (end code)
 *
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.UTFGrid = HGIS.Class(HGIS.Control, {
    
    /**
     * APIProperty: autoActivate
     * {Boolean} Activate the control when it is added to a map.  Default is
     *     true.
     */
    autoActivate: true,

    /** 
     * APIProperty: Layers
     * List of layers to consider. Must be Layer.UTFGrids
     * `null` is the default indicating all UTFGrid Layers are queried.
     * {Array} <HGIS.Layer.UTFGrid> 
     */
    layers: null,

    /* Property: defaultHandlerOptions
     * The default opts passed to the handler constructors
     */
    defaultHandlerOptions: {
        'delay': 300,
        'pixelTolerance': 4,
        'stopMove': false,
        'single': true,
        'double': false,
        'stopSingle': false,
        'stopDouble': false
    },

    /* APIProperty: handlerMode
     * Defaults to 'click'. Can be 'hover' or 'move'.
     */
    handlerMode: 'click',

    /**
     * APIMethod: setHandler
     * sets this.handlerMode and calls resetHandler()
     *
     * Parameters:
     * hm - {String} Handler Mode string; 'click', 'hover' or 'move'.
     */
    setHandler: function(hm) {
        this.handlerMode = hm;
        this.resetHandler();
    },

    /**
     * Method: resetHandler
     * Deactivates the old hanlder and creates a new
     * <HGIS.Handler> based on the mode specified in
     * this.handlerMode
     *
     */
    resetHandler: function() {
        if (this.handler) {
            this.handler.deactivate();
            this.handler.destroy();
            this.handler = null;
        }
   
        if (this.handlerMode == 'hover') {
            // Handle this event on hover
            this.handler = new HGIS.Handler.Hover(
                this,
                {'pause': this.handleEvent, 'move': this.reset},
                this.handlerOptions
            );
        } else if (this.handlerMode == 'click') {
            // Handle this event on click
            this.handler = new HGIS.Handler.Click(
                this, {
                    'click': this.handleEvent
                }, this.handlerOptions
            );
        } else if (this.handlerMode == 'move') {
            this.handler = new HGIS.Handler.Hover(
                this,
                // Handle this event while hovering OR moving
                {'pause': this.handleEvent, 'move': this.handleEvent},
                this.handlerOptions
            );
        }
        if (this.handler) {
            return true;
        } else {
            return false;
        }
    },

    /**
     * Constructor: <HGIS.Control.UTFGrid>
     *
     * Parameters:
     * options - {Object} 
     */
    initialize: function(options) {
        options = options || {};
        options.handlerOptions = options.handlerOptions || this.defaultHandlerOptions;
        HGIS.Control.prototype.initialize.apply(this, [options]);
        this.resetHandler();
    }, 

    /**
     * Method: handleEvent
     * Internal method called when specified event is triggered.
     * 
     * This method does several things:
     *
     * Gets the lonLat of the event.
     *
     * Loops through the appropriate hit grid layers and gathers the attributes.
     *
     * Passes the attributes to the callback
     *
     * Parameters:
     * evt - {<HGIS.Event>} 
     */
    handleEvent: function(evt) {
        if (evt == null) {
            this.reset();
            return;
        }

        var lonLat = this.map.getLonLatFromPixel(evt.xy);
        if (!lonLat) { 
            return;
        }    
        
        var layers = this.findLayers();
        if (layers.length > 0) {
            var infoLookup = {};
            var layer, idx;
            for (var i=0, len=layers.length; i<len; i++) {
                layer = layers[i];
                idx = HGIS.Util.indexOf(this.map.layers, layer);
                infoLookup[idx] = layer.getFeatureInfo(lonLat);
            }
            this.callback(infoLookup, lonLat, evt.xy);
        }
    },

    /**
     * APIMethod: callback
     * Function to be called when a mouse event corresponds with a location that
     *     includes data in one of the configured UTFGrid layers.
     *
     * Parameters:
     * infoLookup - {Object} Keys of this object are layer indexes and can be
     *     used to resolve a layer in the map.layers array.  The structure of
     *     the property values depend on the data included in the underlying
     *     UTFGrid and may be any valid JSON type.  
     */
    callback: function(infoLookup) {
        // to be provided in the constructor
    },

    /**
     * Method: reset
     * Calls the callback with null.
     */
    reset: function(evt) {
        this.callback(null);
    },

    /**
     * Method: findLayers
     * Internal method to get the layers, independent of whether we are
     *     inspecting the map or using a client-provided array
     *
     * The default value of this.layers is null; this causes the 
     * findLayers method to return ALL UTFGrid layers encountered.
     *
     * Parameters:
     * None
     *
     * Returns:
     * {Array} Layers to handle on each event
     */
    findLayers: function() {
        var candidates = this.layers || this.map.layers;
        var layers = [];
        var layer;
        for (var i=candidates.length-1; i>=0; --i) {
            layer = candidates[i];
            if (layer instanceof HGIS.Layer.UTFGrid ) { 
                layers.push(layer);
            }
        }
        return layers;
    },

    CLASS_NAME: "HGIS.Control.UTFGrid"
});
/* ======================================================================
    HGIS/Format/CQL.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WKT.js
 * @requires HGIS/Filter/Comparison.js
 * @requires HGIS/Filter/Logical.js
 * @requires HGIS/Filter/Spatial.js
 */

/**
 * Class: HGIS.Format.CQL
 * Read CQL strings to get <HGIS.Filter> objects.  Write 
 *     <HGIS.Filter> objects to get CQL strings. Create a new parser with 
 *     the <HGIS.Format.CQL> constructor.
 *
 * Inherits from:
 *  - <HGIS.Format>
 */
HGIS.Format.CQL = (function() {
    
    var tokens = [
        "PROPERTY", "COMPARISON", "VALUE", "LOGICAL"
    ],

    patterns = {
        PROPERTY: /^[_a-zA-Z]\w*/,
        COMPARISON: /^(=|<>|<=|<|>=|>|LIKE)/i,
        IS_NULL: /^IS NULL/i,
        COMMA: /^,/,
        LOGICAL: /^(AND|OR)/i,
        VALUE: /^('([^']|'')*'|\d+(\.\d*)?|\.\d+)/,
        LPAREN: /^\(/,
        RPAREN: /^\)/,
        SPATIAL: /^(BBOX|INTERSECTS|DWITHIN|WITHIN|CONTAINS)/i,
        NOT: /^NOT/i,
        BETWEEN: /^BETWEEN/i,
        GEOMETRY: function(text) {
            var type = /^(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION)/.exec(text);
            if (type) {
                var len = text.length;
                var idx = text.indexOf("(", type[0].length);
                if (idx > -1) {
                    var depth = 1;
                    while (idx < len && depth > 0) {
                        idx++;
                        switch(text.charAt(idx)) {
                            case '(':
                                depth++;
                                break;
                            case ')':
                                depth--;
                                break;
                            default:
                                // in default case, do nothing
                        }
                    }
                }
                return [text.substr(0, idx+1)];
            }
        },
        END: /^$/
    },

    follows = {
        LPAREN: ['GEOMETRY', 'SPATIAL', 'PROPERTY', 'VALUE', 'LPAREN'],
        RPAREN: ['NOT', 'LOGICAL', 'END', 'RPAREN'],
        PROPERTY: ['COMPARISON', 'BETWEEN', 'COMMA', 'IS_NULL'],
        BETWEEN: ['VALUE'],
        IS_NULL: ['END'],
        COMPARISON: ['VALUE'],
        COMMA: ['GEOMETRY', 'VALUE', 'PROPERTY'],
        VALUE: ['LOGICAL', 'COMMA', 'RPAREN', 'END'],
        SPATIAL: ['LPAREN'],
        LOGICAL: ['NOT', 'VALUE', 'SPATIAL', 'PROPERTY', 'LPAREN'],
        NOT: ['PROPERTY', 'LPAREN'],
        GEOMETRY: ['COMMA', 'RPAREN']
    },

    operators = {
        '=': HGIS.Filter.Comparison.EQUAL_TO,
        '<>': HGIS.Filter.Comparison.NOT_EQUAL_TO,
        '<': HGIS.Filter.Comparison.LESS_THAN,
        '<=': HGIS.Filter.Comparison.LESS_THAN_OR_EQUAL_TO,
        '>': HGIS.Filter.Comparison.GREATER_THAN,
        '>=': HGIS.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO,
        'LIKE': HGIS.Filter.Comparison.LIKE,
        'BETWEEN': HGIS.Filter.Comparison.BETWEEN,
        'IS NULL': HGIS.Filter.Comparison.IS_NULL
    },

    operatorReverse = {},

    logicals = {
        'AND': HGIS.Filter.Logical.AND,
        'OR': HGIS.Filter.Logical.OR
    },

    logicalReverse = {},

    precedence = {
        'RPAREN': 3,
        'LOGICAL': 2,
        'COMPARISON': 1
    };

    var i;
    for (i in operators) {
        if (operators.hasOwnProperty(i)) {
            operatorReverse[operators[i]] = i;
        }
    }

    for (i in logicals) {
        if (logicals.hasOwnProperty(i)) {
            logicalReverse[logicals[i]] = i;
        }
    }

    function tryToken(text, pattern) {
        if (pattern instanceof RegExp) {
            return pattern.exec(text);
        } else {
            return pattern(text);
        }
    }

    function nextToken(text, tokens) {
        var i, token, len = tokens.length;
        for (i=0; i<len; i++) {
            token = tokens[i];
            var pat = patterns[token];
            var matches = tryToken(text, pat);
            if (matches) {
                var match = matches[0];
                var remainder = text.substr(match.length).replace(/^\s*/, "");
                return {
                    type: token,
                    text: match,
                    remainder: remainder
                };
            }
        }

        var msg = "ERROR: In parsing: [" + text + "], expected one of: ";
        for (i=0; i<len; i++) {
            token = tokens[i];
            msg += "\n    " + token + ": " + patterns[token];
        }

        throw new Error(msg);
    }

    function tokenize(text) {
        var results = [];
        var token, expect = ["NOT", "GEOMETRY", "SPATIAL", "PROPERTY", "LPAREN"];

        do {
            token = nextToken(text, expect);
            text = token.remainder;
            expect = follows[token.type];
            if (token.type != "END" && !expect) {
                throw new Error("No follows list for " + token.type);
            }
            results.push(token);
        } while (token.type != "END");

        return results;
    }

    function buildAst(tokens) {
        var operatorStack = [],
            postfix = [];

        while (tokens.length) {
            var tok = tokens.shift();
            switch (tok.type) {
                case "PROPERTY":
                case "GEOMETRY":
                case "VALUE":
                    postfix.push(tok);
                    break;
                case "COMPARISON":
                case "BETWEEN":
                case "IS_NULL":
                case "LOGICAL":
                    var p = precedence[tok.type];

                    while (operatorStack.length > 0 &&
                        (precedence[operatorStack[operatorStack.length - 1].type] <= p)
                    ) {
                        postfix.push(operatorStack.pop());
                    }

                    operatorStack.push(tok);
                    break;
                case "SPATIAL":
                case "NOT":
                case "LPAREN":
                    operatorStack.push(tok);
                    break;
                case "RPAREN":
                    while (operatorStack.length > 0 &&
                        (operatorStack[operatorStack.length - 1].type != "LPAREN")
                    ) {
                        postfix.push(operatorStack.pop());
                    }
                    operatorStack.pop(); // toss out the LPAREN

                    if (operatorStack.length > 0 &&
                        operatorStack[operatorStack.length-1].type == "SPATIAL") {
                        postfix.push(operatorStack.pop());
                    }
                case "COMMA":
                case "END":
                    break;
                default:
                    throw new Error("Unknown token type " + tok.type);
            }
        }

        while (operatorStack.length > 0) {
            postfix.push(operatorStack.pop());
        }

        function buildTree() {
            var tok = postfix.pop();
            switch (tok.type) {
                case "LOGICAL":
                    var rhs = buildTree(),
                        lhs = buildTree();
                    return new HGIS.Filter.Logical({
                        filters: [lhs, rhs],
                        type: logicals[tok.text.toUpperCase()]
                    });
                case "NOT":
                    var operand = buildTree();
                    return new HGIS.Filter.Logical({
                        filters: [operand],
                        type: HGIS.Filter.Logical.NOT
                    });
                case "BETWEEN":
                    var min, max, property;
                    postfix.pop(); // unneeded AND token here
                    max = buildTree();
                    min = buildTree();
                    property = buildTree();
                    return new HGIS.Filter.Comparison({
                        property: property,
                        lowerBoundary: min,
                        upperBoundary: max,
                        type: HGIS.Filter.Comparison.BETWEEN
                    });
                case "COMPARISON":
                    var value = buildTree(),
                        property = buildTree();
                    return new HGIS.Filter.Comparison({
                        property: property,
                        value: value,
                        type: operators[tok.text.toUpperCase()]
                    });
                case "IS_NULL":
                    var property = buildTree();
                    return new HGIS.Filter.Comparison({
                        property: property,
                        type: operators[tok.text.toUpperCase()]
                    });
                case "VALUE":
                    var match = tok.text.match(/^'(.*)'$/);
                    if (match) {
                        return match[1].replace(/''/g, "'");
                    } else {
                        return Number(tok.text);
                    }
                case "SPATIAL":
                    switch(tok.text.toUpperCase()) {
                        case "BBOX":
                            var maxy = buildTree(),
                                maxx = buildTree(),
                                miny = buildTree(),
                                minx = buildTree(),
                                prop = buildTree();

                            return new HGIS.Filter.Spatial({
                                type: HGIS.Filter.Spatial.BBOX,
                                property: prop,
                                value: HGIS.Bounds.fromArray(
                                    [minx, miny, maxx, maxy]
                                )
                            });
                        case "INTERSECTS":
                            var value = buildTree(),
                                property = buildTree();
                            return new HGIS.Filter.Spatial({
                                type: HGIS.Filter.Spatial.INTERSECTS,
                                property: property,
                                value: value
                            });
                        case "WITHIN":
                            var value = buildTree(),
                                property = buildTree();
                            return new HGIS.Filter.Spatial({
                                type: HGIS.Filter.Spatial.WITHIN,
                                property: property,
                                value: value
                            });
                        case "CONTAINS":
                            var value = buildTree(),
                                property = buildTree();
                            return new HGIS.Filter.Spatial({
                                type: HGIS.Filter.Spatial.CONTAINS,
                                property: property,
                                value: value
                            });
                        case "DWITHIN":
                            var distance = buildTree(),
                                value = buildTree(),
                                property = buildTree();
                            return new HGIS.Filter.Spatial({
                                type: HGIS.Filter.Spatial.DWITHIN,
                                value: value,
                                property: property,
                                distance: Number(distance)
                            });
                    }
                case "GEOMETRY":
                    return HGIS.Geometry.fromWKT(tok.text);
                default:
                    return tok.text;
            }
        }

        var result = buildTree();
        if (postfix.length > 0) {
            var msg = "Remaining tokens after building AST: \n";
            for (var i = postfix.length - 1; i >= 0; i--) {
                msg += postfix[i].type + ": " + postfix[i].text + "\n";
            }
            throw new Error(msg);
        }

        return result;
    }

    return HGIS.Class(HGIS.Format, {
        /**
         * APIMethod: read
         * Generate a filter from a CQL string.

         * Parameters:
         * text - {String} The CQL text.
         *
         * Returns:
         * {<HGIS.Filter>} A filter based on the CQL text.
         */
        read: function(text) { 
            var result = buildAst(tokenize(text));
            if (this.keepData) {
                this.data = result;
            }
            return result;
        },

        /**
         * APIMethod: write
         * Convert a filter into a CQL string.

         * Parameters:
         * filter - {<HGIS.Filter>} The filter.
         *
         * Returns:
         * {String} A CQL string based on the filter.
         */
        write: function(filter) {
            if (filter instanceof HGIS.Geometry) {
                return filter.toString();
            }
            switch (filter.CLASS_NAME) {
                case "HGIS.Filter.Spatial":
                    switch(filter.type) {
                        case HGIS.Filter.Spatial.BBOX:
                            return "BBOX(" +
                                filter.property + "," +
                                filter.value.toBBOX() +
                                ")";
                        case HGIS.Filter.Spatial.DWITHIN:
                            return "DWITHIN(" +
                                filter.property + ", " +
                                this.write(filter.value) + ", " +
                                filter.distance + ")";
                        case HGIS.Filter.Spatial.WITHIN:
                            return "WITHIN(" +
                                filter.property + ", " +
                                this.write(filter.value) + ")";
                        case HGIS.Filter.Spatial.INTERSECTS:
                            return "INTERSECTS(" +
                                filter.property + ", " +
                                this.write(filter.value) + ")";
                        case HGIS.Filter.Spatial.CONTAINS:
                            return "CONTAINS(" +
                                filter.property + ", " +
                                this.write(filter.value) + ")";
                        default:
                            throw new Error("Unknown spatial filter type: " + filter.type);
                    }
                case "HGIS.Filter.Logical":
                    if (filter.type == HGIS.Filter.Logical.NOT) {
                        // TODO: deal with precedence of logical operators to 
                        // avoid extra parentheses (not urgent)
                        return "NOT (" + this.write(filter.filters[0]) + ")";
                    } else {
                        var res = "(";
                        var first = true;
                        for (var i = 0; i < filter.filters.length; i++) {
                            if (first) {
                                first = false;
                            } else {
                                res += ") " + logicalReverse[filter.type] + " (";
                            }
                            res += this.write(filter.filters[i]);
                        }
                        return res + ")";
                    }
                case "HGIS.Filter.Comparison":
                    if (filter.type == HGIS.Filter.Comparison.BETWEEN) {
                        return filter.property + " BETWEEN " + 
                            this.write(filter.lowerBoundary) + " AND " + 
                            this.write(filter.upperBoundary);
                    } else {
                        return (filter.value !== null) ? filter.property +
                            " " + operatorReverse[filter.type] + " " + 
                            this.write(filter.value) : filter.property +
                            " " + operatorReverse[filter.type];
                    }
                case undefined:
                    if (typeof filter === "string") {
                        return "'" + filter.replace(/'/g, "''") + "'";
                    } else if (typeof filter === "number") {
                        return String(filter);
                    }
                default:
                    throw new Error("Can't encode: " + filter.CLASS_NAME + " " + filter);
            }
        },

        CLASS_NAME: "HGIS.Format.CQL"

    });
})();

/* ======================================================================
    HGIS/Control/Split.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Handler/Path.js
 * @requires HGIS/Layer/Vector.js
 */

/**
 * Class: HGIS.Control.Split
 * Acts as a split feature agent while editing vector features.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.Split = HGIS.Class(HGIS.Control, {

    /** 
     * APIProperty: events
     * {<HGIS.Events>} Events instance for listeners and triggering
     *     control specific events.
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * Supported event types (in addition to those from <HGIS.Control.events>):
     * beforesplit - Triggered before a split occurs.  Listeners receive an
     *     event object with *source* and *target* properties.
     * split - Triggered when a split occurs.  Listeners receive an event with
     *     an *original* property and a *features* property.  The original
     *     is a reference to the target feature that the sketch or modified
     *     feature intersects.  The features property is a list of all features
     *     that result from this single split.  This event is triggered before
     *     the resulting features are added to the layer (while the layer still
     *     has a reference to the original).
     * aftersplit - Triggered after all splits resulting from a single sketch
     *     or feature modification have occurred.  The original features
     *     have been destroyed and features that result from the split
     *     have already been added to the layer.  Listeners receive an event
     *     with a *source* and *features* property.  The source references the
     *     sketch or modified feature used as a splitter.  The features
     *     property is a list of all resulting features.
     */
    
    /**
     * APIProperty: layer
     * {<HGIS.Layer.Vector>} The target layer with features to be split.
     *     Set at construction or after construction with <setLayer>.
     */
    layer: null,
    
    /**
     * Property: source
     * {<HGIS.Layer.Vector>} Optional source layer.  Any newly created
     *     or modified features from this layer will be used to split features
     *     on the target layer.  If not provided, a temporary sketch layer will
     *     be created.
     */
    source: null,
    
    /**
     * Property: sourceOptions
     * {Options} If a temporary sketch layer is created, these layer options
     *     will be applied.
     */
    sourceOptions: null,

    /**
     * APIProperty: tolerance
     * {Number} Distance between the calculated intersection and a vertex on
     *     the source geometry below which the existing vertex will be used
     *     for the split.  Default is null.
     */
    tolerance: null,
    
    /**
     * APIProperty: edge
     * {Boolean} Allow splits given intersection of edges only.  Default is
     *     true.  If false, a vertex on the source must be within the
     *     <tolerance> distance of the calculated intersection for a split
     *     to occur.
     */
    edge: true,
    
    /**
     * APIProperty: deferDelete
     * {Boolean} Instead of removing features from the layer, set feature
     *     states of split features to DELETE.  This assumes a save strategy
     *     or other component is in charge of removing features from the
     *     layer.  Default is false.  If false, split features will be
     *     immediately deleted from the layer.
     */
    deferDelete: false,
    
    /**
     * APIProperty: mutual
     * {Boolean} If source and target layers are the same, split source
     *     features and target features where they intersect.  Default is
     *     true.  If false, only target features will be split.
     */
    mutual: true,
    
    /**
     * APIProperty: targetFilter
     * {<HGIS.Filter>} Optional filter that will be evaluated
     *     to determine if a feature from the target layer is eligible for
     *     splitting.
     */
    targetFilter: null,
    
    /**
     * APIProperty: sourceFilter
     * {<HGIS.Filter>} Optional filter that will be evaluated
     *     to determine if a feature from the source layer is eligible for
     *     splitting.
     */
    sourceFilter: null,
    
    /**
     * Property: handler
     * {<HGIS.Handler.Path>} The temporary sketch handler created if
     *     no source layer is provided.
     */
    handler: null,

    /**
     * Constructor: HGIS.Control.Split
     * Creates a new split control. A control is constructed with a target
     *     layer and an optional source layer. While the control is active,
     *     creating new features or modifying existing features on the source
     *     layer will result in splitting any eligible features on the target
     *     layer.  If no source layer is provided, a temporary sketch layer will
     *     be created to create lines for splitting features on the target.
     *
     * Parameters:
     * options - {Object} An object containing all configuration properties for
     *     the control.
     *
     * Valid options:
     * layer - {<HGIS.Layer.Vector>} The target layer.  Features from this
     *     layer will be split by new or modified features on the source layer
     *     or temporary sketch layer.
     * source - {<HGIS.Layer.Vector>} Optional source layer.  If provided
     *     newly created features or modified features will be used to split
     *     features on the target layer.  If not provided, a temporary sketch
     *     layer will be created for drawing lines.
     * tolerance - {Number} Optional value for the distance between a source
     *     vertex and the calculated intersection below which the split will
     *     occur at the vertex.
     * edge - {Boolean} Allow splits given intersection of edges only.  Default
     *     is true.  If false, a vertex on the source must be within the
     *     <tolerance> distance of the calculated intersection for a split
     *     to occur.
     * mutual - {Boolean} If source and target are the same, split source
     *     features and target features where they intersect.  Default is
     *     true.  If false, only target features will be split.
     * targetFilter - {<HGIS.Filter>} Optional filter that will be evaluated
     *     to determine if a feature from the target layer is eligible for
     *     splitting.
     * sourceFilter - {<HGIS.Filter>} Optional filter that will be evaluated
     *     to determine if a feature from the target layer is eligible for
     *     splitting.
     */
    initialize: function(options) {
        HGIS.Control.prototype.initialize.apply(this, [options]);
        this.options = options || {}; // TODO: this could be done by the super
        
        // set the source layer if provided
        if(this.options.source) {
            this.setSource(this.options.source);
        }
    },
    
    /**
     * APIMethod: setSource
     * Set the source layer for edits layer.
     *
     * Parameters:
     * layer - {<HGIS.Layer.Vector>}  The new source layer layer.  If
     *     null, a temporary sketch layer will be created.
     */
    setSource: function(layer) {
        if(this.active) {
            this.deactivate();
            if(this.handler) {
                this.handler.destroy();
                delete this.handler;
            }
            this.source = layer;
            this.activate();
        } else {
            this.source = layer;
        }
    },
    
    /**
     * APIMethod: activate
     * Activate the control.  Activating the control registers listeners for
     *     editing related events so that during feature creation and
     *     modification, features in the target will be considered for
     *     splitting.
     */
    activate: function() {
        var activated = HGIS.Control.prototype.activate.call(this);
        if(activated) {
            if(!this.source) {
                if(!this.handler) {
                    this.handler = new HGIS.Handler.Path(this,
                        {done: function(geometry) {
                            this.onSketchComplete({
                                feature: new HGIS.Feature.Vector(geometry)
                            });
                        }},
                        {layerOptions: this.sourceOptions}
                    );
                }
                this.handler.activate();
            } else if(this.source.events) {
                this.source.events.on({
                    sketchcomplete: this.onSketchComplete,
                    afterfeaturemodified: this.afterFeatureModified,
                    scope: this
                });
            }
        }
        return activated;
    },
    
    /**
     * APIMethod: deactivate
     * Deactivate the control.  Deactivating the control unregisters listeners
     *     so feature editing may proceed without engaging the split agent.
     */
    deactivate: function() {
        var deactivated = HGIS.Control.prototype.deactivate.call(this);
        if(deactivated) {
            if(this.source && this.source.events) {
                this.source.events.un({
                    sketchcomplete: this.onSketchComplete,
                    afterfeaturemodified: this.afterFeatureModified,
                    scope: this
                });
            }
        }
        return deactivated;
    },
    
    /**
     * Method: onSketchComplete
     * Registered as a listener for the sketchcomplete event on the editable
     *     layer.
     *
     * Parameters:
     * event - {Object} The sketch complete event.
     *
     * Returns:
     * {Boolean} Stop the sketch from being added to the layer (it has been
     *     split).
     */
    onSketchComplete: function(event) {
        this.feature = null;
        return !this.considerSplit(event.feature);
    },
    
    /**
     * Method: afterFeatureModified
     * Registered as a listener for the afterfeaturemodified event on the
     *     editable layer.
     *
     * Parameters:
     * event - {Object} The after feature modified event.
     */
    afterFeatureModified: function(event) {
        if(event.modified) {
            var feature = event.feature;
            if (typeof feature.geometry.split === "function") {
                this.feature = event.feature;
                this.considerSplit(event.feature);
            }
        }
    },
    
    /**
     * Method: removeByGeometry
     * Remove a feature from a list based on the given geometry.
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} A list of features.
     * geometry - {<HGIS.Geometry>} A geometry.
     */
    removeByGeometry: function(features, geometry) {
        for(var i=0, len=features.length; i<len; ++i) {
            if(features[i].geometry === geometry) {
                features.splice(i, 1);
                break;
            }
        }
    },
    
    /**
     * Method: isEligible
     * Test if a target feature is eligible for splitting.
     *
     * Parameters:
     * target - {<HGIS.Feature.Vector>} The target feature.
     *
     * Returns:
     * {Boolean} The target is eligible for splitting.
     */
    isEligible: function(target) {
        if (!target.geometry) {
            return false;
        } else {
            return (
                target.state !== HGIS.State.DELETE
            ) && (
                typeof target.geometry.split === "function"
            ) && (
                this.feature !== target
            ) && (
                !this.targetFilter ||
                this.targetFilter.evaluate(target.attributes)
            );
        }
    },

    /**
     * Method: considerSplit
     * Decide whether or not to split target features with the supplied
     *     feature.  If <mutual> is true, both the source and target features
     *     will be split if eligible.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} The newly created or modified
     *     feature.
     *
     * Returns:
     * {Boolean} The supplied feature was split (and destroyed).
     */
    considerSplit: function(feature) {
        var sourceSplit = false;
        var targetSplit = false;
        if(!this.sourceFilter ||
           this.sourceFilter.evaluate(feature.attributes)) {
            var features = this.layer && this.layer.features || [];
            var target, results, proceed;
            var additions = [], removals = [];
            var mutual = (this.layer === this.source) && this.mutual;
            var options = {
                edge: this.edge,
                tolerance: this.tolerance,
                mutual: mutual
            };
            var sourceParts = [feature.geometry];
            var targetFeature, targetParts;
            var source, parts;
            for(var i=0, len=features.length; i<len; ++i) {
                targetFeature = features[i];
                if(this.isEligible(targetFeature)) {
                    targetParts = [targetFeature.geometry];
                    // work through source geoms - this array may change
                    for(var j=0; j<sourceParts.length; ++j) { 
                        source = sourceParts[j];
                        // work through target parts - this array may change
                        for(var k=0; k<targetParts.length; ++k) {
                            target = targetParts[k];
                            if(source.getBounds().intersectsBounds(target.getBounds())) {
                                results = source.split(target, options);
                                if(results) {
                                    proceed = this.events.triggerEvent(
                                        "beforesplit", {source: feature, target: targetFeature}
                                    );
                                    if(proceed !== false) {
                                        if(mutual) {
                                            parts = results[0];
                                            // handle parts that result from source splitting
                                            if(parts.length > 1) {
                                                // splice in new source parts
                                                parts.unshift(j, 1); // add args for splice below
                                                Array.prototype.splice.apply(sourceParts, parts);
                                                j += parts.length - 3;
                                            }
                                            results = results[1];
                                        }
                                        // handle parts that result from target splitting
                                        if(results.length > 1) {
                                            // splice in new target parts
                                            results.unshift(k, 1); // add args for splice below
                                            Array.prototype.splice.apply(targetParts, results);
                                            k += results.length - 3;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if(targetParts && targetParts.length > 1) {
                        this.geomsToFeatures(targetFeature, targetParts);
                        this.events.triggerEvent("split", {
                            original: targetFeature,
                            features: targetParts
                        });
                        Array.prototype.push.apply(additions, targetParts);
                        removals.push(targetFeature);
                        targetSplit = true;
                    }
                }
            }
            if(sourceParts && sourceParts.length > 1) {
                this.geomsToFeatures(feature, sourceParts);
                this.events.triggerEvent("split", {
                    original: feature,
                    features: sourceParts
                });
                Array.prototype.push.apply(additions, sourceParts);
                removals.push(feature);
                sourceSplit = true;
            }
            if(sourceSplit || targetSplit) {
                // remove and add feature events are suppressed
                // listen for split event on this control instead
                if(this.deferDelete) {
                    // Set state instead of removing.  Take care to avoid
                    // setting delete for features that have not yet been
                    // inserted - those should be destroyed immediately.
                    var feat, destroys = [];
                    for(var i=0, len=removals.length; i<len; ++i) {
                        feat = removals[i];
                        if(feat.state === HGIS.State.INSERT) {
                            destroys.push(feat);
                        } else {
                            feat.state = HGIS.State.DELETE;
                            this.layer.drawFeature(feat);
                        }
                    }
                    this.layer.destroyFeatures(destroys, {silent: true});
                    for(var i=0, len=additions.length; i<len; ++i) {
                        additions[i].state = HGIS.State.INSERT;
                    }
                } else {
                    this.layer.destroyFeatures(removals, {silent: true});
                }
                this.layer.addFeatures(additions, {silent: true});
                this.events.triggerEvent("aftersplit", {
                    source: feature,
                    features: additions
                });
            }
        }
        return sourceSplit;
    },
    
    /**
     * Method: geomsToFeatures
     * Create new features given a template feature and a list of geometries.
     *     The list of geometries is modified in place.  The result will be
     *     a list of new features.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} The feature to be cloned.
     * geoms - {Array(<HGIS.Geometry>)} List of goemetries.  This will
     *     become a list of new features.
     */
    geomsToFeatures: function(feature, geoms) {
        var clone = feature.clone();
        delete clone.geometry;
        var newFeature;
        for(var i=0, len=geoms.length; i<len; ++i) {
            // turn results list from geoms to features
            newFeature = clone.clone();
            newFeature.geometry = geoms[i];
            newFeature.state = HGIS.State.INSERT;
            geoms[i] = newFeature;
        }
    },
    
    /**
     * Method: destroy
     * Clean up the control.
     */
    destroy: function() {
        if(this.active) {
            this.deactivate(); // TODO: this should be handled by the super
        }
        HGIS.Control.prototype.destroy.call(this);
    },

    CLASS_NAME: "HGIS.Control.Split"
});
/* ======================================================================
    HGIS/Layer/WMTS.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer/Grid.js
 */

/**
 * Class: HGIS.Layer.WMTS
 * Instances of the WMTS class allow viewing of tiles from a service that 
 *     implements the OGC WMTS specification version 1.0.0.
 * 
 * Inherits from:
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.WMTS = HGIS.Class(HGIS.Layer.Grid, {
    
    /**
     * APIProperty: isBaseLayer
     * {Boolean} The layer will be considered a base layer.  Default is true.
     */
    isBaseLayer: true,

    /**
     * Property: version
     * {String} WMTS version.  Default is "1.0.0".
     */
    version: "1.0.0",
    
    /**
     * APIProperty: requestEncoding
     * {String} Request encoding.  Can be "REST" or "KVP".  Default is "KVP".
     */
    requestEncoding: "KVP",
    
    /**
     * APIProperty: url
     * {String|Array(String)} The base URL or request URL template for the WMTS
     * service. Must be provided. Array is only supported for base URLs, not
     * for request URL templates. URL templates are only supported for
     * REST <requestEncoding>.
     */
    url: null,

    /**
     * APIProperty: layer
     * {String} The layer identifier advertised by the WMTS service.  Must be 
     *     provided.
     */
    layer: null,
    
    /** 
     * APIProperty: matrixSet
     * {String} One of the advertised matrix set identifiers.  Must be provided.
     */
    matrixSet: null,

    /** 
     * APIProperty: style
     * {String} One of the advertised layer styles.  Must be provided.
     */
    style: null,
    
    /** 
     * APIProperty: format
     * {String} The image MIME type.  Default is "image/jpeg".
     */
    format: "image/jpeg",
    
    /**
     * APIProperty: tileOrigin
     * {<HGIS.LonLat>} The top-left corner of the tile matrix in map 
     *     units.  If the tile origin for each matrix in a set is different,
     *     the <matrixIds> should include a topLeftCorner property.  If
     *     not provided, the tile origin will default to the top left corner
     *     of the layer <maxExtent>.
     */
    tileOrigin: null,
    
    /**
     * APIProperty: tileFullExtent
     * {<HGIS.Bounds>}  The full extent of the tile set.  If not supplied,
     *     the layer's <maxExtent> property will be used.
     */
    tileFullExtent: null,

    /**
     * APIProperty: formatSuffix
     * {String} For REST request encoding, an image format suffix must be 
     *     included in the request.  If not provided, the suffix will be derived
     *     from the <format> property.
     */
    formatSuffix: null,    

    /**
     * APIProperty: matrixIds
     * {Array} A list of tile matrix identifiers.  If not provided, the matrix
     *     identifiers will be assumed to be integers corresponding to the 
     *     map zoom level.  If a list of strings is provided, each item should
     *     be the matrix identifier that corresponds to the map zoom level.
     *     Additionally, a list of objects can be provided.  Each object should
     *     describe the matrix as presented in the WMTS capabilities.  These
     *     objects should have the propertes shown below.
     * 
     * Matrix properties:
     * identifier - {String} The matrix identifier (required).
     * scaleDenominator - {Number} The matrix scale denominator.
     * topLeftCorner - {<HGIS.LonLat>} The top left corner of the 
     *     matrix.  Must be provided if different than the layer <tileOrigin>.
     * tileWidth - {Number} The tile width for the matrix.  Must be provided 
     *     if different than the width given in the layer <tileSize>.
     * tileHeight - {Number} The tile height for the matrix.  Must be provided 
     *     if different than the height given in the layer <tileSize>.
     */
    matrixIds: null,
    
    /**
     * APIProperty: dimensions
     * {Array} For RESTful request encoding, extra dimensions may be specified.
     *     Items in this list should be property names in the <params> object.
     *     Values of extra dimensions will be determined from the corresponding
     *     values in the <params> object.
     */
    dimensions: null,
    
    /**
     * APIProperty: params
     * {Object} Extra parameters to include in tile requests.  For KVP 
     *     <requestEncoding>, these properties will be encoded in the request 
     *     query string.  For REST <requestEncoding>, these properties will
     *     become part of the request path, with order determined by the 
     *     <dimensions> list.
     */
    params: null,
    
    /**
     * APIProperty: zoomOffset
     * {Number} If your cache has more levels than you want to provide
     *     access to with this layer, supply a zoomOffset.  This zoom offset
     *     is added to the current map zoom level to determine the level
     *     for a requested tile.  For example, if you supply a zoomOffset
     *     of 3, when the map is at the zoom 0, tiles will be requested from
     *     level 3 of your cache.  Default is 0 (assumes cache level and map
     *     zoom are equivalent).  Additionally, if this layer is to be used
     *     as an overlay and the cache has fewer zoom levels than the base
     *     layer, you can supply a negative zoomOffset.  For example, if a
     *     map zoom level of 1 corresponds to your cache level zero, you would
     *     supply a -1 zoomOffset (and set the maxResolution of the layer
     *     appropriately).  The zoomOffset value has no effect if complete
     *     matrix definitions (including scaleDenominator) are supplied in
     *     the <matrixIds> property.  Defaults to 0 (no zoom offset).
     */
    zoomOffset: 0,

    /**
     * APIProperty: serverResolutions
     * {Array} A list of all resolutions available on the server.  Only set this
     *     property if the map resolutions differ from the server. This
     *     property serves two purposes. (a) <serverResolutions> can include
     *     resolutions that the server supports and that you don't want to
     *     provide with this layer; you can also look at <zoomOffset>, which is
     *     an alternative to <serverResolutions> for that specific purpose.
     *     (b) The map can work with resolutions that aren't supported by
     *     the server, i.e. that aren't in <serverResolutions>. When the
     *     map is displayed in such a resolution data for the closest
     *     server-supported resolution is loaded and the layer div is
     *     stretched as necessary.
     */
    serverResolutions: null,

    /**
     * Property: formatSuffixMap
     * {Object} a map between WMTS 'format' request parameter and tile image file suffix
     */
    formatSuffixMap: {
        "image/png": "png",
        "image/png8": "png",
        "image/png24": "png",
        "image/png32": "png",
        "png": "png",
        "image/jpeg": "jpg",
        "image/jpg": "jpg",
        "jpeg": "jpg",
        "jpg": "jpg"
    },
    
    /**
     * Property: matrix
     * {Object} Matrix definition for the current map resolution.  Updated by
     *     the <updateMatrixProperties> method.
     */
    matrix: null,
    
    /**
     * Constructor: HGIS.Layer.WMTS
     * Create a new WMTS layer.
     *
     * Example:
     * (code)
     * var wmts = new HGIS.Layer.WMTS({
     *     name: "My WMTS Layer",
     *     url: "http://example.com/wmts", 
     *     layer: "layer_id",
     *     style: "default",
     *     matrixSet: "matrix_id"
     * });
     * (end)
     *
     * Parameters:
     * config - {Object} Configuration properties for the layer.
     *
     * Required configuration properties:
     * url - {String} The base url for the service.  See the <url> property.
     * layer - {String} The layer identifier.  See the <layer> property.
     * style - {String} The layer style identifier.  See the <style> property.
     * matrixSet - {String} The tile matrix set identifier.  See the <matrixSet>
     *     property.
     *
     * Any other documented layer properties can be provided in the config object.
     */
    initialize: function(config) {

        // confirm required properties are supplied
        var required = {
            url: true,
            layer: true,
            style: true,
            matrixSet: true
        };
        for (var prop in required) {
            if (!(prop in config)) {
                throw new Error("Missing property '" + prop + "' in layer configuration.");
            }
        }

        config.params = HGIS.Util.upperCaseObject(config.params);
        var args = [config.name, config.url, config.params, config];
        HGIS.Layer.Grid.prototype.initialize.apply(this, args);
        

        // determine format suffix (for REST)
        if (!this.formatSuffix) {
            this.formatSuffix = this.formatSuffixMap[this.format] || this.format.split("/").pop();            
        }

        // expand matrixIds (may be array of string or array of object)
        if (this.matrixIds) {
            var len = this.matrixIds.length;
            if (len && typeof this.matrixIds[0] === "string") {
                var ids = this.matrixIds;
                this.matrixIds = new Array(len);
                for (var i=0; i<len; ++i) {
                    this.matrixIds[i] = {identifier: ids[i]};
                }
            }
        }

    },
    
    /**
     * Method: setMap
     */
    setMap: function() {
        HGIS.Layer.Grid.prototype.setMap.apply(this, arguments);
    },
    
    /**
     * Method: updateMatrixProperties
     * Called when map resolution changes to update matrix related properties.
     */
    updateMatrixProperties: function() {
        this.matrix = this.getMatrix();
        if (this.matrix) {
            if (this.matrix.topLeftCorner) {
                this.tileOrigin = this.matrix.topLeftCorner;
            }
            if (this.matrix.tileWidth && this.matrix.tileHeight) {
                this.tileSize = new HGIS.Size(
                    this.matrix.tileWidth, this.matrix.tileHeight
                );
            }
            if (!this.tileOrigin) { 
                this.tileOrigin = new HGIS.LonLat(
                    this.maxExtent.left, this.maxExtent.top
                );
            }   
            if (!this.tileFullExtent) { 
                this.tileFullExtent = this.maxExtent;
            }
        }
    },
    
    /**
     * Method: moveTo
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     * zoomChanged - {Boolean} Tells when zoom has changed, as layers have to
     *     do some init work in that case.
     * dragging - {Boolean}
     */
    moveTo:function(bounds, zoomChanged, dragging) {
        if (zoomChanged || !this.matrix) {
            this.updateMatrixProperties();
        }
        return HGIS.Layer.Grid.prototype.moveTo.apply(this, arguments);
    },

    /**
     * APIMethod: clone
     * 
     * Parameters:
     * obj - {Object}
     * 
     * Returns:
     * {<HGIS.Layer.WMTS>} An exact clone of this <HGIS.Layer.WMTS>
     */
    clone: function(obj) {
        if (obj == null) {
            obj = new HGIS.Layer.WMTS(this.options);
        }
        //get all additions from superclasses
        obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);
        // copy/set any non-init, non-simple values here
        return obj;
    },

    /**
     * Method: getIdentifier
     * Get the current index in the matrixIds array.
     */
    getIdentifier: function() {
        return this.getServerZoom();
    },
    
    /**
     * Method: getMatrix
     * Get the appropriate matrix definition for the current map resolution.
     */
    getMatrix: function() {
        var matrix;
        if (!this.matrixIds || this.matrixIds.length === 0) {
            matrix = {identifier: this.getIdentifier()};
        } else {
            // get appropriate matrix given the map scale if possible
            if ("scaleDenominator" in this.matrixIds[0]) {
                // scale denominator calculation based on WMTS spec
                var denom = 
                    HGIS.METERS_PER_INCH * 
                    HGIS.INCHES_PER_UNIT[this.units] * 
                    this.getServerResolution() / 0.28E-3;
                var diff = Number.POSITIVE_INFINITY;
                var delta;
                for (var i=0, ii=this.matrixIds.length; i<ii; ++i) {
                    delta = Math.abs(1 - (this.matrixIds[i].scaleDenominator / denom));
                    if (delta < diff) {
                        diff = delta;
                        matrix = this.matrixIds[i];
                    }
                }
            } else {
                // fall back on zoom as index
                matrix = this.matrixIds[this.getIdentifier()];
            }
        }
        return matrix;
    },
    
    /** 
     * Method: getTileInfo
     * Get tile information for a given location at the current map resolution.
     *
     * Parameters:
     * loc - {<HGIS.LonLat} A location in map coordinates.
     *
     * Returns:
     * {Object} An object with "col", "row", "i", and "j" properties.  The col
     *     and row values are zero based tile indexes from the top left.  The
     *     i and j values are the number of pixels to the left and top 
     *     (respectively) of the given location within the target tile.
     */
    getTileInfo: function(loc) {
        var res = this.getServerResolution();
        
        var fx = (loc.lon - this.tileOrigin.lon) / (res * this.tileSize.w);
        var fy = (this.tileOrigin.lat - loc.lat) / (res * this.tileSize.h);

        var col = Math.floor(fx);
        var row = Math.floor(fy);
        
        return {
            col: col, 
            row: row,
            i: Math.floor((fx - col) * this.tileSize.w),
            j: Math.floor((fy - row) * this.tileSize.h)
        };
    },
    
    /**
     * Method: getURL
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     * 
     * Returns:
     * {String} A URL for the tile corresponding to the given bounds.
     */
    getURL: function(bounds) {
        bounds = this.adjustBounds(bounds);
        var url = "";
        if (!this.tileFullExtent || this.tileFullExtent.intersectsBounds(bounds)) {            

            var center = bounds.getCenterLonLat();            
            var info = this.getTileInfo(center);
            var matrixId = this.matrix.identifier;
            var dimensions = this.dimensions, params;

            if (HGIS.Util.isArray(this.url)) {
                url = this.selectUrl([
                    this.version, this.style, this.matrixSet,
                    this.matrix.identifier, info.row, info.col
                ].join(","), this.url);
            } else {
                url = this.url;
            }

            if (this.requestEncoding.toUpperCase() === "REST") {
                params = this.params;
                if (url.indexOf("{") !== -1) {
                    var template = url.replace(/\{/g, "${");
                    var context = {
                        // spec does not make clear if capital S or not
                        style: this.style, Style: this.style,
                        TileMatrixSet: this.matrixSet,
                        TileMatrix: this.matrix.identifier,
                        TileRow: info.row,
                        TileCol: info.col
                    };
                    if (dimensions) {
                        var dimension, i;
                        for (i=dimensions.length-1; i>=0; --i) {
                            dimension = dimensions[i];
                            context[dimension] = params[dimension.toUpperCase()];
                        }
                    }
                    url = HGIS.String.format(template, context);
                } else {
                    // include 'version', 'layer' and 'style' in tile resource url
                    var path = this.version + "/" + this.layer + "/" + this.style + "/";

                    // append optional dimension path elements
                    if (dimensions) {
                        for (var i=0; i<dimensions.length; i++) {
                            if (params[dimensions[i]]) {
                                path = path + params[dimensions[i]] + "/";
                            }
                        }
                    }

                    // append other required path elements
                    path = path + this.matrixSet + "/" + this.matrix.identifier + 
                        "/" + info.row + "/" + info.col + "." + this.formatSuffix;

                    if (!url.match(/\/$/)) {
                        url = url + "/";
                    }
                    url = url + path;
                }
            } else if (this.requestEncoding.toUpperCase() === "KVP") {

                // assemble all required parameters
                params = {
                    SERVICE: "WMTS",
                    REQUEST: "GetTile",
                    VERSION: this.version,
                    LAYER: this.layer,
                    STYLE: this.style,
                    TILEMATRIXSET: this.matrixSet,
                    TILEMATRIX: this.matrix.identifier,
                    TILEROW: info.row,
                    TILECOL: info.col,
                    FORMAT: this.format
                };
                url = HGIS.Layer.Grid.prototype.getFullRequestString.apply(this, [params]);

            }
        }
        return url;    
    },
    
    /**
     * APIMethod: mergeNewParams
     * Extend the existing layer <params> with new properties.  Tiles will be
     *     reloaded with updated params in the request.
     * 
     * Parameters:
     * newParams - {Object} Properties to extend to existing <params>.
     */
    mergeNewParams: function(newParams) {
        if (this.requestEncoding.toUpperCase() === "KVP") {
            return HGIS.Layer.Grid.prototype.mergeNewParams.apply(
                this, [HGIS.Util.upperCaseObject(newParams)]
            );
        }
    },

    CLASS_NAME: "HGIS.Layer.WMTS"
});
/* ======================================================================
    HGIS/Protocol/SOS/v1_0_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Protocol/SOS.js
 * @requires HGIS/Format/SOSGetFeatureOfInterest.js
 */

/**
 * Class: HGIS.Protocol.SOS.v1_0_0
 * An SOS v1.0.0 Protocol for vector layers.  Create a new instance with the
 *     <HGIS.Protocol.SOS.v1_0_0> constructor.
 *
 * Inherits from:
 *  - <HGIS.Protocol>
 */
 HGIS.Protocol.SOS.v1_0_0 = HGIS.Class(HGIS.Protocol, {

    /**
     * APIProperty: fois
     * {Array(String)} Array of features of interest (foi)
     */
    fois: null,

    /**
     * Property: formatOptions
     * {Object} Optional options for the format.  If a format is not provided,
     *     this property can be used to extend the default format options.
     */
    formatOptions: null,
   
    /**
     * Constructor: HGIS.Protocol.SOS
     * A class for giving layers an SOS protocol.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties:
     * url - {String} URL to send requests to (required).
     * fois - {Array} The features of interest (required).
     */
    initialize: function(options) {
        HGIS.Protocol.prototype.initialize.apply(this, [options]);
        if(!options.format) {
            this.format = new HGIS.Format.SOSGetFeatureOfInterest(
                this.formatOptions);
        }
    },
   
    /**
     * APIMethod: destroy
     * Clean up the protocol.
     */
    destroy: function() {
        if(this.options && !this.options.format) {
            this.format.destroy();
        }
        this.format = null;
        HGIS.Protocol.prototype.destroy.apply(this);
    },

    /**
     * APIMethod: read
     * Construct a request for reading new sensor positions. This is done by
     *     issuing one GetFeatureOfInterest request.
     */
    read: function(options) {
        options = HGIS.Util.extend({}, options);
        HGIS.Util.applyDefaults(options, this.options || {});
        var response = new HGIS.Protocol.Response({requestType: "read"});
        var format = this.format;
        var data = HGIS.Format.XML.prototype.write.apply(format,
            [format.writeNode("sos:GetFeatureOfInterest", {fois: this.fois})]
        );
        response.priv = HGIS.Request.POST({
            url: options.url,
            callback: this.createCallback(this.handleRead, response, options),
            data: data
        });
        return response;
    },
   
    /**
     * Method: handleRead
     * Deal with response from the read request.
     *
     * Parameters:
     * response - {<HGIS.Protocol.Response>} The response object to pass
     *     to the user callback.
     * options - {Object} The user options passed to the read call.
     */
    handleRead: function(response, options) {
        if(options.callback) {
            var request = response.priv;
            if(request.status >= 200 && request.status < 300) {
                // success
                response.features = this.parseFeatures(request);
                response.code = HGIS.Protocol.Response.SUCCESS;
            } else {
                // failure
                response.code = HGIS.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, response);
        }
    },

    /**
     * Method: parseFeatures
     * Read HTTP response body and return features
     *
     * Parameters:
     * request - {XMLHttpRequest} The request object
     *
     * Returns:
     * {Array({<HGIS.Feature.Vector>})} Array of features
     */
    parseFeatures: function(request) {
        var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc || doc.length <= 0) {
            return null;
        }
        return this.format.read(doc);
    },

    CLASS_NAME: "HGIS.Protocol.SOS.v1_0_0"
});
/* ======================================================================
    HGIS/Layer/KaMapCache.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */


/**
 * @requires HGIS/Layer/Grid.js
 * @requires HGIS/Layer/KaMap.js
 */

/**
 * Class: HGIS.Layer.KaMapCache
 * 
 * This class is designed to talk directly to a web-accessible ka-Map
 * cache generated by the precache2.php script.
 * 
 * To create a a new KaMapCache layer, you must indicate also the "i" parameter
 * (that will be used to calculate the file extension), and another special
 * parameter, object names "metaTileSize", with "h" (height) and "w" (width)
 * properties.
 * 
 *     // Create a new kaMapCache layer. 
 *     var kamap_base = new HGIS.Layer.KaMapCache(
 *         "Satellite",
 *         "http://www.example.org/web/acessible/cache",
 *         {g: "satellite", map: "world", i: 'png24', metaTileSize: {w: 5, h: 5} }
 *       );
 *    
 *     // Create an kaMapCache overlay layer (using "isBaseLayer: false"). 
 *     // Forces the output to be a "gif", using the "i" parameter.
 *     var kamap_overlay = new HGIS.Layer.KaMapCache(
 *         "Streets",
 *         "http://www.example.org/web/acessible/cache",
 *         {g: "streets", map: "world", i: "gif", metaTileSize: {w: 5, h: 5} },
 *         {isBaseLayer: false}
 *       );
 *
 * The cache URLs must look like: 
 *   var/cache/World/50000/Group_Name/def/t-440320/l20480
 * 
 * This means that the cache generated via tile.php will *not* work with
 *     this class, and should instead use the KaMap layer.
 *
 * More information is available in Ticket #1518.
 * 
 * Inherits from:
 *  - <HGIS.Layer.KaMap>
 *  - <HGIS.Layer.Grid>
 */
HGIS.Layer.KaMapCache = HGIS.Class(HGIS.Layer.KaMap, {

    /**
     * Constant: IMAGE_EXTENSIONS
     * {Object} Simple hash map to convert format to extension.
     */
    IMAGE_EXTENSIONS: {
        'jpeg': 'jpg',
        'gif' : 'gif',
        'png' : 'png',
        'png8' : 'png',
        'png24' : 'png',
        'dithered' : 'png'
    },
    
    /**
     * Constant: DEFAULT_FORMAT
     * {Object} Simple hash map to convert format to extension.
     */
    DEFAULT_FORMAT: 'jpeg',
    
    /**
     * Constructor: HGIS.Layer.KaMapCache
     * 
     * Parameters:
     * name - {String}
     * url - {String}
     * params - {Object} Parameters to be sent to the HTTP server in the
     *    query string for the tile. The format can be set via the 'i'
     *    parameter (defaults to jpg) , and the map should be set via 
     *    the 'map' parameter. It has been reported that ka-Map may behave
     *    inconsistently if your format parameter does not match the format
     *    parameter configured in your config.php. (See ticket #327 for more
     *    information.)
     * options - {Object} Additional options for the layer. Any of the 
     *     APIProperties listed on this layer, and any layer types it
     *     extends, can be overridden through the options parameter. 
     */
    initialize: function(name, url, params, options) {
        HGIS.Layer.KaMap.prototype.initialize.apply(this, arguments);
        this.extension = this.IMAGE_EXTENSIONS[this.params.i.toLowerCase() || this.DEFAULT_FORMAT];
    },

    /**
     * Method: getURL
     * 
     * Parameters:
     * bounds - {<HGIS.Bounds>} 
     * 
     * Returns:
     * {String} A string with the layer's url and parameters and also the 
     *          passed-in bounds and appropriate tile size specified as 
     *          parameters
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);
        var mapRes = this.map.getResolution();
        var scale = Math.round((this.map.getScale() * 10000)) / 10000;
        var pX = Math.round(bounds.left / mapRes);
        var pY = -Math.round(bounds.top / mapRes);

        var metaX = Math.floor(pX / this.tileSize.w / this.params.metaTileSize.w) * this.tileSize.w * this.params.metaTileSize.w;
        var metaY = Math.floor(pY / this.tileSize.h / this.params.metaTileSize.h) * this.tileSize.h * this.params.metaTileSize.h;
    
        var components = [
            "/",
            this.params.map,
            "/",
            scale,
            "/",
            this.params.g.replace(/\s/g, '_'),
            "/def/t", 
            metaY,
            "/l",
            metaX,
            "/t",
            pY,
            "l",
            pX,
            ".",
            this.extension
          ];

        var url = this.url;

        if (HGIS.Util.isArray(url)) {
            url = this.selectUrl(components.join(''), url);
        }
        return url + components.join("");
    },

    CLASS_NAME: "HGIS.Layer.KaMapCache"
});
/* ======================================================================
    HGIS/Protocol/WFS/v1_1_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Protocol/WFS/v1.js
 * @requires HGIS/Format/WFST/v1_1_0.js
 */

/**
 * Class: HGIS.Protocol.WFS.v1_1_0
 * A WFS v1.1.0 protocol for vector layers.  Create a new instance with the
 *     <HGIS.Protocol.WFS.v1_1_0> constructor.
 *
 * Differences from the v1.0.0 protocol:
 *  - uses Filter Encoding 1.1.0 instead of 1.0.0
 *  - uses GML 3 instead of 2 if no format is provided
 *  
 * Inherits from:
 *  - <HGIS.Protocol.WFS.v1>
 */
HGIS.Protocol.WFS.v1_1_0 = HGIS.Class(HGIS.Protocol.WFS.v1, {
    
    /**
     * Property: version
     * {String} WFS version number.
     */
    version: "1.1.0",
    
    /**
     * Constructor: HGIS.Protocol.WFS.v1_1_0
     * A class for giving layers WFS v1.1.0 protocol.
     *
     * Parameters:
     * options - {Object} Optional object whose properties will be set on the
     *     instance.
     *
     * Valid options properties:
     * featureType - {String} Local (without prefix) feature typeName (required).
     * featureNS - {String} Feature namespace (optional).
     * featurePrefix - {String} Feature namespace alias (optional - only used
     *     if featureNS is provided).  Default is 'feature'.
     * geometryName - {String} Name of geometry attribute.  Default is 'the_geom'.
     * outputFormat - {String} Optional output format to use for WFS GetFeature
     *     requests. This can be any format advertized by the WFS's
     *     GetCapabilities response. If set, an appropriate readFormat also
     *     has to be provided, unless outputFormat is GML3, GML2 or JSON.
     * readFormat - {<HGIS.Format>} An appropriate format parser if
     *     outputFormat is none of GML3, GML2 or JSON.
     */
    initialize: function(options) {
        HGIS.Protocol.WFS.v1.prototype.initialize.apply(this, arguments);
        if (this.outputFormat && !this.readFormat) {
            if (this.outputFormat.toLowerCase() == "gml2") {
                this.readFormat = new HGIS.Format.GML.v2({
                    featureType: this.featureType,
                    featureNS: this.featureNS,
                    geometryName: this.geometryName
                });
            } else if (this.outputFormat.toLowerCase() == "json") {
                this.readFormat = new HGIS.Format.GeoJSON();
            }
        }
    },
   
    CLASS_NAME: "HGIS.Protocol.WFS.v1_1_0"
});
/* ======================================================================
    HGIS/Format/WMSCapabilities/v1_1_1.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WMSCapabilities/v1_1.js
 */

/**
 * Class: HGIS.Format.WMSCapabilities/v1_1_1
 * Read WMS Capabilities version 1.1.1.
 *
 * Note on <ScaleHint> parsing: If the 'min' attribute is set to "0", no
 * maxScale will be set on the layer object. If the 'max' attribute is set to
 * "Infinity", no minScale will be set. This makes it easy to create proper
 * {<HGIS.Layer.WMS>} configurations directly from the layer object
 * literals returned by this format, because no minScale/maxScale modifications
 * need to be made.
 * 
 * Inherits from:
 *  - <HGIS.Format.WMSCapabilities.v1_1>
 */
HGIS.Format.WMSCapabilities.v1_1_1 = HGIS.Class(
    HGIS.Format.WMSCapabilities.v1_1, {
    
    /**
     * Property: version
     * {String} The specific parser version.
     */
    version: "1.1.1",
    
    /**
     * Constructor: HGIS.Format.WMSCapabilities.v1_1_1
     * Create a new parser for WMS capabilities version 1.1.1.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wms": HGIS.Util.applyDefaults({
            "SRS": function(node, obj) {
                obj.srs[this.getChildValue(node)] = true;
            }
        }, HGIS.Format.WMSCapabilities.v1_1.prototype.readers["wms"])
    },

    CLASS_NAME: "HGIS.Format.WMSCapabilities.v1_1_1" 

});
/* ======================================================================
    HGIS/Format/WMSCapabilities/v1_1_1_WMSC.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WMSCapabilities/v1_1_1.js
 */

/**
 * Class: HGIS.Format.WMSCapabilities/v1_1_1_WMSC
 * Read WMS-C Capabilities version 1.1.1.
 * 
 * Inherits from:
 *  - <HGIS.Format.WMSCapabilities.v1_1_1>
 */
HGIS.Format.WMSCapabilities.v1_1_1_WMSC = HGIS.Class(
    HGIS.Format.WMSCapabilities.v1_1_1, {
    
    /**
     * Property: version
     * {String} The specific parser version.
     */
    version: "1.1.1",
    
    /**
     * Property: profile
     * {String} The specific profile
     */
    profile: "WMSC",
    
    /**
     * Constructor: HGIS.Format.WMSCapabilities.v1_1_1
     * Create a new parser for WMS-C capabilities version 1.1.1.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {
        "wms": HGIS.Util.applyDefaults({
            "VendorSpecificCapabilities": function(node, obj) {
                obj.vendorSpecific = {tileSets: []};
                this.readChildNodes(node, obj.vendorSpecific);
            },
            "TileSet": function(node, vendorSpecific) {
                var tileset = {srs: {}, bbox: {}, resolutions: []};
                this.readChildNodes(node, tileset);
                vendorSpecific.tileSets.push(tileset);
            },
            "Resolutions": function(node, tileset) {
                var res = this.getChildValue(node).split(" ");
                for (var i=0, len=res.length; i<len; i++) {
                    if (res[i] != "") {
                        tileset.resolutions.push(parseFloat(res[i]));
                    }
                }
            },
            "Width": function(node, tileset) {
                tileset.width = parseInt(this.getChildValue(node));
            },
            "Height": function(node, tileset) {
                tileset.height = parseInt(this.getChildValue(node));
            },
            "Layers": function(node, tileset) {
                tileset.layers = this.getChildValue(node);
            },
            "Styles": function(node, tileset) {
                tileset.styles = this.getChildValue(node);
            }
        }, HGIS.Format.WMSCapabilities.v1_1_1.prototype.readers["wms"])
    },

    CLASS_NAME: "HGIS.Format.WMSCapabilities.v1_1_1_WMSC" 

});
/* ======================================================================
    HGIS/Control/LayerSwitcher.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Lang.js
 * @requires HGIS/Util.js
 * @requires HGIS/Events/buttonclick.js
 */

/**
 * Class: HGIS.Control.LayerSwitcher
 * The LayerSwitcher control displays a table of contents for the map. This
 * allows the user interface to switch between BaseLasyers and to show or hide
 * Overlays. By default the switcher is shown minimized on the right edge of
 * the map, the user may expand it by clicking on the handle.
 *
 * To create the LayerSwitcher outside of the map, pass the Id of a html div
 * as the first argument to the constructor.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.LayerSwitcher = HGIS.Class(HGIS.Control, {

    /**  
     * Property: layerStates 
     * {Array(Object)} Basically a copy of the "state" of the map's layers 
     *     the last time the control was drawn. We have this in order to avoid
     *     unnecessarily redrawing the control.
     */
    layerStates: null,

  // DOM Elements

    /**
     * Property: layersDiv
     * {DOMElement}
     */
    layersDiv: null,

    /**
     * Property: baseLayersDiv
     * {DOMElement}
     */
    baseLayersDiv: null,

    /**
     * Property: baseLayers
     * {Array(Object)}
     */
    baseLayers: null,


    /**
     * Property: dataLbl
     * {DOMElement}
     */
    dataLbl: null,

    /**
     * Property: dataLayersDiv
     * {DOMElement}
     */
    dataLayersDiv: null,

    /**
     * Property: dataLayers
     * {Array(Object)}
     */
    dataLayers: null,


    /**
     * Property: minimizeDiv
     * {DOMElement}
     */
    minimizeDiv: null,

    /**
     * Property: maximizeDiv
     * {DOMElement}
     */
    maximizeDiv: null,

    /**
     * APIProperty: ascending
     * {Boolean}
     */
    ascending: true,

    /**
     * Constructor: HGIS.Control.LayerSwitcher
     *
     * Parameters:
     * options - {Object}
     */
    initialize: function(options) {
        HGIS.Control.prototype.initialize.apply(this, arguments);
        this.layerStates = [];
    },

    /**
     * APIMethod: destroy
     */
    destroy: function() {

        //clear out layers info and unregister their events
        this.clearLayersArray("base");
        this.clearLayersArray("data");

        this.map.events.un({
            buttonclick: this.onButtonClick,
            addlayer: this.redraw,
            changelayer: this.redraw,
            removelayer: this.redraw,
            changebaselayer: this.redraw,
            scope: this
        });
        this.events.unregister("buttonclick", this, this.onButtonClick);

        HGIS.Control.prototype.destroy.apply(this, arguments);
    },

    /**
     * Method: setMap
     *
     * Properties:
     * map - {<HGIS.Map>}
     */
    setMap: function(map) {
        HGIS.Control.prototype.setMap.apply(this, arguments);

        this.map.events.on({
            addlayer: this.redraw,
            changelayer: this.redraw,
            removelayer: this.redraw,
            changebaselayer: this.redraw,
            scope: this
        });
        if (this.outsideViewport) {
            this.events.attachToElement(this.div);
            this.events.register("buttonclick", this, this.onButtonClick);
        } else {
            this.map.events.register("buttonclick", this, this.onButtonClick);
        }
    },

    /**
     * Method: draw
     *
     * Returns:
     * {DOMElement} A reference to the DIV DOMElement containing the
     *     switcher tabs.
     */
    draw: function() {
        HGIS.Control.prototype.draw.apply(this);

        // create layout divs
        this.loadContents();

        // set mode to minimize
        if(!this.outsideViewport) {
            this.minimizeControl();
        }

        // populate div with current info
        this.redraw();

        return this.div;
    },

    /**
     * Method: onButtonClick
     *
     * Parameters:
     * evt - {Event}
     */
    onButtonClick: function(evt) {
        var button = evt.buttonElement;
        if (button === this.minimizeDiv) {
            this.minimizeControl();
        } else if (button === this.maximizeDiv) {
            this.maximizeControl();
        } else if (button._layerSwitcher === this.id) {
            if (button["for"]) {
                button = document.getElementById(button["for"]);
            }
            if (!button.disabled) {
                if (button.type == "radio") {
                    button.checked = true;
                    this.map.setBaseLayer(this.map.getLayer(button._layer));
                } else {
                    button.checked = !button.checked;
                    this.updateMap();
                }
            }
        }
    },

    /**
     * Method: clearLayersArray
     * User specifies either "base" or "data". we then clear all the
     *     corresponding listeners, the div, and reinitialize a new array.
     *
     * Parameters:
     * layersType - {String}
     */
    clearLayersArray: function(layersType) {
        this[layersType + "LayersDiv"].innerHTML = "";
        this[layersType + "Layers"] = [];
    },


    /**
     * Method: checkRedraw
     * Checks if the layer state has changed since the last redraw() call.
     *
     * Returns:
     * {Boolean} The layer state changed since the last redraw() call.
     */
    checkRedraw: function() {
        if ( !this.layerStates.length ||
             (this.map.layers.length != this.layerStates.length) ) {
            return true;
        }

        for (var i = 0, len = this.layerStates.length; i < len; i++) {
            var layerState = this.layerStates[i];
            var layer = this.map.layers[i];
            if ( (layerState.name != layer.name) ||
                 (layerState.inRange != layer.inRange) ||
                 (layerState.id != layer.id) ||
                 (layerState.visibility != layer.visibility) ) {
                return true;
            }
        }

        return false;
    },

    /**
     * Method: redraw
     * Goes through and takes the current state of the Map and rebuilds the
     *     control to display that state. Groups base layers into a
     *     radio-button group and lists each data layer with a checkbox.
     *
     * Returns:
     * {DOMElement} A reference to the DIV DOMElement containing the control
     */
    redraw: function() {
        //if the state hasn't changed since last redraw, no need
        // to do anything. Just return the existing div.
        if (!this.checkRedraw()) {
            return this.div;
        }

        //clear out previous layers
        this.clearLayersArray("base");
        this.clearLayersArray("data");

        var containsOverlays = false;
        var containsBaseLayers = false;

        // Save state -- for checking layer if the map state changed.
        // We save this before redrawing, because in the process of redrawing
        // we will trigger more visibility changes, and we want to not redraw
        // and enter an infinite loop.
        var len = this.map.layers.length;
        this.layerStates = new Array(len);
        for (var i=0; i <len; i++) {
            var layer = this.map.layers[i];
            this.layerStates[i] = {
                'name': layer.name,
                'visibility': layer.visibility,
                'inRange': layer.inRange,
                'id': layer.id
            };
        }

        var layers = this.map.layers.slice();
        if (!this.ascending) { layers.reverse(); }
        for(var i=0, len=layers.length; i<len; i++) {
            var layer = layers[i];
            var baseLayer = layer.isBaseLayer;

            if (layer.displayInLayerSwitcher) {

                if (baseLayer) {
                    containsBaseLayers = true;
                } else {
                    containsOverlays = true;
                }

                // only check a baselayer if it is *the* baselayer, check data
                //  layers if they are visible
                var checked = (baseLayer) ? (layer == this.map.baseLayer)
                                          : layer.getVisibility();

                // create input element
                var inputElem = document.createElement("input"),
                    // The input shall have an id attribute so we can use
                    // labels to interact with them.
                    inputId = HGIS.Util.createUniqueID(
                        this.id + "_input_"
                    );

                inputElem.id = inputId;
                inputElem.name = (baseLayer) ? this.id + "_baseLayers" : layer.name;
                inputElem.type = (baseLayer) ? "radio" : "checkbox";
                inputElem.value = layer.name;
                inputElem.checked = checked;
                inputElem.defaultChecked = checked;
                inputElem.className = "olButton";
                inputElem._layer = layer.id;
                inputElem._layerSwitcher = this.id;

                if (!baseLayer && !layer.inRange) {
                    inputElem.disabled = true;
                }

                // create span
                var labelSpan = document.createElement("label");
                // this isn't the DOM attribute 'for', but an arbitrary name we
                // use to find the appropriate input element in <onButtonClick>
                labelSpan["for"] = inputElem.id;
                HGIS.Element.addClass(labelSpan, "labelSpan olButton");
                labelSpan._layer = layer.id;
                labelSpan._layerSwitcher = this.id;
                if (!baseLayer && !layer.inRange) {
                    labelSpan.style.color = "gray";
                }
                labelSpan.innerHTML = layer.name;
                labelSpan.style.verticalAlign = (baseLayer) ? "bottom"
                                                            : "baseline";
                // create line break
                var br = document.createElement("br");


                var groupArray = (baseLayer) ? this.baseLayers
                                             : this.dataLayers;
                groupArray.push({
                    'layer': layer,
                    'inputElem': inputElem,
                    'labelSpan': labelSpan
                });


                var groupDiv = (baseLayer) ? this.baseLayersDiv
                                           : this.dataLayersDiv;
                groupDiv.appendChild(inputElem);
                groupDiv.appendChild(labelSpan);
                groupDiv.appendChild(br);
            }
        }

        // if no overlays, dont display the overlay label
        this.dataLbl.style.display = (containsOverlays) ? "" : "none";

        // if no baselayers, dont display the baselayer label
        this.baseLbl.style.display = (containsBaseLayers) ? "" : "none";

        return this.div;
    },

    /**
     * Method: updateMap
     * Cycles through the loaded data and base layer input arrays and makes
     *     the necessary calls to the Map object such that that the map's
     *     visual state corresponds to what the user has selected in
     *     the control.
     */
    updateMap: function() {

        // set the newly selected base layer
        for(var i=0, len=this.baseLayers.length; i<len; i++) {
            var layerEntry = this.baseLayers[i];
            if (layerEntry.inputElem.checked) {
                this.map.setBaseLayer(layerEntry.layer, false);
            }
        }

        // set the correct visibilities for the overlays
        for(var i=0, len=this.dataLayers.length; i<len; i++) {
            var layerEntry = this.dataLayers[i];
            layerEntry.layer.setVisibility(layerEntry.inputElem.checked);
        }

    },

    /**
     * Method: maximizeControl
     * Set up the labels and divs for the control
     *
     * Parameters:
     * e - {Event}
     */
    maximizeControl: function(e) {

        // set the div's width and height to empty values, so
        // the div dimensions can be controlled by CSS
        this.div.style.width = "";
        this.div.style.height = "";

        this.showControls(false);

        if (e != null) {
            HGIS.Event.stop(e);
        }
    },

    /**
     * Method: minimizeControl
     * Hide all the contents of the control, shrink the size,
     *     add the maximize icon
     *
     * Parameters:
     * e - {Event}
     */
    minimizeControl: function(e) {

        // to minimize the control we set its div's width
        // and height to 0px, we cannot just set "display"
        // to "none" because it would hide the maximize
        // div
        this.div.style.width = "0px";
        this.div.style.height = "0px";

        this.showControls(true);

        if (e != null) {
            HGIS.Event.stop(e);
        }
    },

    /**
     * Method: showControls
     * Hide/Show all LayerSwitcher controls depending on whether we are
     *     minimized or not
     *
     * Parameters:
     * minimize - {Boolean}
     */
    showControls: function(minimize) {

        this.maximizeDiv.style.display = minimize ? "" : "none";
        this.minimizeDiv.style.display = minimize ? "none" : "";

        this.layersDiv.style.display = minimize ? "none" : "";
    },

    /**
     * Method: loadContents
     * Set up the labels and divs for the control
     */
    loadContents: function() {

        // layers list div
        this.layersDiv = document.createElement("div");
        this.layersDiv.id = this.id + "_layersDiv";
        HGIS.Element.addClass(this.layersDiv, "layersDiv");

        this.baseLbl = document.createElement("div");
        this.baseLbl.innerHTML = HGIS.i18n("Base Layer");
        HGIS.Element.addClass(this.baseLbl, "baseLbl");

        this.baseLayersDiv = document.createElement("div");
        HGIS.Element.addClass(this.baseLayersDiv, "baseLayersDiv");

        this.dataLbl = document.createElement("div");
        this.dataLbl.innerHTML = HGIS.i18n("Overlays");
        HGIS.Element.addClass(this.dataLbl, "dataLbl");

        this.dataLayersDiv = document.createElement("div");
        HGIS.Element.addClass(this.dataLayersDiv, "dataLayersDiv");

        if (this.ascending) {
            this.layersDiv.appendChild(this.baseLbl);
            this.layersDiv.appendChild(this.baseLayersDiv);
            this.layersDiv.appendChild(this.dataLbl);
            this.layersDiv.appendChild(this.dataLayersDiv);
        } else {
            this.layersDiv.appendChild(this.dataLbl);
            this.layersDiv.appendChild(this.dataLayersDiv);
            this.layersDiv.appendChild(this.baseLbl);
            this.layersDiv.appendChild(this.baseLayersDiv);
        }

        this.div.appendChild(this.layersDiv);

        // maximize button div
        var img = HGIS.Util.getImageLocation('layer-switcher-maximize.png');
        this.maximizeDiv = HGIS.Util.createAlphaImageDiv(
                                    "HGIS_Control_MaximizeDiv",
                                    null,
                                    null,
                                    img,
                                    "absolute");
        HGIS.Element.addClass(this.maximizeDiv, "maximizeDiv olButton");
        this.maximizeDiv.style.display = "none";

        this.div.appendChild(this.maximizeDiv);

        // minimize button div
        var img = HGIS.Util.getImageLocation('layer-switcher-minimize.png');
        this.minimizeDiv = HGIS.Util.createAlphaImageDiv(
                                    "HGIS_Control_MinimizeDiv",
                                    null,
                                    null,
                                    img,
                                    "absolute");
        HGIS.Element.addClass(this.minimizeDiv, "minimizeDiv olButton");
        this.minimizeDiv.style.display = "none";

        this.div.appendChild(this.minimizeDiv);
    },

    CLASS_NAME: "HGIS.Control.LayerSwitcher"
});
/* ======================================================================
    HGIS/Format/Atom.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/XML.js
 * @requires HGIS/Format/GML/v3.js
 * @requires HGIS/Feature/Vector.js
 */

/**
 * Class: HGIS.Format.Atom
 * Read/write Atom feeds. Create a new instance with the
 *     <HGIS.Format.AtomFeed> constructor.
 *
 * Inherits from:
 *  - <HGIS.Format.XML>
 */
HGIS.Format.Atom = HGIS.Class(HGIS.Format.XML, {
    
    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.  Properties
     *     of this object should not be set individually.  Read-only.  All
     *     XML subclasses should have their own namespaces object.  Use
     *     <setNamespace> to add or set a namespace alias after construction.
     */
    namespaces: {
        atom: "http://www.w3.org/2005/Atom",
        georss: "http://www.georss.org/georss"
    },
    
    /**
     * APIProperty: feedTitle
     * {String} Atom feed elements require a title.  Default is "untitled".
     */
    feedTitle: "untitled",

    /**
     * APIProperty: defaultEntryTitle
     * {String} Atom entry elements require a title.  In cases where one is
     *     not provided in the feature attributes, this will be used.  Default
     *     is "untitled".
     */
    defaultEntryTitle: "untitled",

    /**
     * Property: gmlParse
     * {Object} GML Format object for parsing features
     * Non-API and only created if necessary
     */
    gmlParser: null,
    
    /**
     * APIProperty: xy
     * {Boolean} Order of the GML coordinate: true:(x,y) or false:(y,x)
     * For GeoRSS the default is (y,x), therefore: false
     */
    xy: false,
    
    /**
     * Constructor: HGIS.Format.AtomEntry
     * Create a new parser for Atom.
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    
    /**
     * APIMethod: read
     * Return a list of features from an Atom feed or entry document.
     
     * Parameters:
     * doc - {Element} or {String}
     *
     * Returns:
     * Array({<HGIS.Feature.Vector>})
     */
    read: function(doc) {
        if (typeof doc == "string") {
            doc = HGIS.Format.XML.prototype.read.apply(this, [doc]);
        }
        return this.parseFeatures(doc);
    },
    
    /**
     * APIMethod: write
     * Serialize or more feature nodes to Atom documents.
     *
     * Parameters:
     * features - {<HGIS.Feature.Vector>} or Array({<HGIS.Feature.Vector>})
     *
     * Returns:
     * {String} an Atom entry document if passed one feature node, or a feed
     * document if passed an array of feature nodes.
     */
    write: function(features) {
        var doc;
        if (HGIS.Util.isArray(features)) {
            doc = this.createElementNSPlus("atom:feed");
            doc.appendChild(
                this.createElementNSPlus("atom:title", {
                    value: this.feedTitle
                })
            );
            for (var i=0, ii=features.length; i<ii; i++) {
                doc.appendChild(this.buildEntryNode(features[i]));
            }
        }
        else {
            doc = this.buildEntryNode(features);
        }
        return HGIS.Format.XML.prototype.write.apply(this, [doc]);
    },
    
    /**
     * Method: buildContentNode
     *
     * Parameters:
     * content - {Object}
     *
     * Returns:
     * {DOMElement} an Atom content node.
     *
     * TODO: types other than text.
     */
    buildContentNode: function(content) {
        var node = this.createElementNSPlus("atom:content", {
            attributes: {
                type: content.type || null
            }
        });
        if (content.src) {
            node.setAttribute("src", content.src);
        } else {
            if (content.type == "text" || content.type == null) {
                node.appendChild(
                    this.createTextNode(content.value)
                );
            } else if (content.type == "html") {
                if (typeof content.value != "string") {
                    throw "HTML content must be in form of an escaped string";
                }
                node.appendChild(
                    this.createTextNode(content.value)
                );
            } else if (content.type == "xhtml") {
                node.appendChild(content.value);
            } else if (content.type == "xhtml" ||
                           content.type.match(/(\+|\/)xml$/)) {
                node.appendChild(content.value);
            }
            else { // MUST be a valid Base64 encoding
                node.appendChild(
                    this.createTextNode(content.value)
                );
            }
        }
        return node;
    },
    
    /**
     * Method: buildEntryNode
     * Build an Atom entry node from a feature object.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     *
     * Returns:
     * {DOMElement} an Atom entry node.
     *
     * These entries are geared for publication using AtomPub.
     *
     * TODO: support extension elements
     */
    buildEntryNode: function(feature) {
        var attrib = feature.attributes;
        var atomAttrib = attrib.atom || {};
        var entryNode = this.createElementNSPlus("atom:entry");
        
        // atom:author
        if (atomAttrib.authors) {
            var authors = HGIS.Util.isArray(atomAttrib.authors) ?
                atomAttrib.authors : [atomAttrib.authors];
            for (var i=0, ii=authors.length; i<ii; i++) {
                entryNode.appendChild(
                    this.buildPersonConstructNode(
                        "author", authors[i]
                    )
                );
            }
        }
        
        // atom:category
        if (atomAttrib.categories) {
            var categories = HGIS.Util.isArray(atomAttrib.categories) ?
                atomAttrib.categories : [atomAttrib.categories];
            var category;
            for (var i=0, ii=categories.length; i<ii; i++) {
                category = categories[i];
                entryNode.appendChild(
                    this.createElementNSPlus("atom:category", {
                        attributes: {
                            term: category.term,
                            scheme: category.scheme || null,
                            label: category.label || null
                        }
                    })
                );
            }
        }
        
        // atom:content
        if (atomAttrib.content) {
            entryNode.appendChild(this.buildContentNode(atomAttrib.content));
        }
        
        // atom:contributor
        if (atomAttrib.contributors) {
            var contributors = HGIS.Util.isArray(atomAttrib.contributors) ?
                atomAttrib.contributors : [atomAttrib.contributors];
            for (var i=0, ii=contributors.length; i<ii; i++) {
                entryNode.appendChild(
                    this.buildPersonConstructNode(
                        "contributor",
                        contributors[i]
                        )
                    );
            }
        }
        
        // atom:id
        if (feature.fid) {
            entryNode.appendChild(
                this.createElementNSPlus("atom:id", {
                    value: feature.fid
                })
            );
        }
        
        // atom:link
        if (atomAttrib.links) {
            var links = HGIS.Util.isArray(atomAttrib.links) ?
                atomAttrib.links : [atomAttrib.links];
            var link;
            for (var i=0, ii=links.length; i<ii; i++) {
                link = links[i];
                entryNode.appendChild(
                    this.createElementNSPlus("atom:link", {
                        attributes: {
                            href: link.href,
                            rel: link.rel || null,
                            type: link.type || null,
                            hreflang: link.hreflang || null,
                            title: link.title || null,
                            length: link.length || null
                        }
                    })
                );
            }
        }
        
        // atom:published
        if (atomAttrib.published) {
            entryNode.appendChild(
                this.createElementNSPlus("atom:published", {
                    value: atomAttrib.published
                })
            );
        }
        
        // atom:rights
        if (atomAttrib.rights) {
            entryNode.appendChild(
                this.createElementNSPlus("atom:rights", {
                    value: atomAttrib.rights
                })
            );
        }
        
        // atom:source not implemented
        
        // atom:summary
        if (atomAttrib.summary || attrib.description) {
            entryNode.appendChild(
                this.createElementNSPlus("atom:summary", {
                    value: atomAttrib.summary || attrib.description
                })
            );
        }
        
        // atom:title
        entryNode.appendChild(
            this.createElementNSPlus("atom:title", {
                value: atomAttrib.title || attrib.title || this.defaultEntryTitle
            })
        );
        
        // atom:updated
        if (atomAttrib.updated) {
            entryNode.appendChild(
                this.createElementNSPlus("atom:updated", {
                    value: atomAttrib.updated
                })
            );
        }
        
        // georss:where
        if (feature.geometry) {
            var whereNode = this.createElementNSPlus("georss:where");
            whereNode.appendChild(
                this.buildGeometryNode(feature.geometry)
            );
            entryNode.appendChild(whereNode);
        }
        
        return entryNode;
    },
    
    /**
     * Method: initGmlParser
     * Creates a GML parser.
     */
    initGmlParser: function() {
        this.gmlParser = new HGIS.Format.GML.v3({
            xy: this.xy,
            featureNS: "http://example.com#feature",
            internalProjection: this.internalProjection,
            externalProjection: this.externalProjection
        });
    },
    
    /**
     * Method: buildGeometryNode
     * builds a GeoRSS node with a given geometry
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     *
     * Returns:
     * {DOMElement} A gml node.
     */
    buildGeometryNode: function(geometry) {
        if (!this.gmlParser) {
            this.initGmlParser();
        }
        var node = this.gmlParser.writeNode("feature:_geometry", geometry);
        return node.firstChild;
    },
    
    /**
     * Method: buildPersonConstructNode
     *
     * Parameters:
     * name - {String}
     * value - {Object}
     *
     * Returns:
     * {DOMElement} an Atom person construct node.
     *
     * Example:
     * >>> buildPersonConstructNode("author", {name: "John Smith"})
     * {<author><name>John Smith</name></author>}
     *
     * TODO: how to specify extension elements? Add to the oNames array?
     */
    buildPersonConstructNode: function(name, value) {
        var oNames = ["uri", "email"];
        var personNode = this.createElementNSPlus("atom:" + name);
        personNode.appendChild(
            this.createElementNSPlus("atom:name", {
                value: value.name
            })
        );
        for (var i=0, ii=oNames.length; i<ii; i++) {
            if (value[oNames[i]]) {
                personNode.appendChild(
                    this.createElementNSPlus("atom:" + oNames[i], {
                        value: value[oNames[i]]
                    })
                );
            }
        }
        return personNode;
    },
    
    /**
     * Method: getFirstChildValue
     *
     * Parameters:
     * node - {DOMElement}
     * nsuri - {String} Child node namespace uri ("*" for any).
     * name - {String} Child node name.
     * def - {String} Optional string default to return if no child found.
     *
     * Returns:
     * {String} The value of the first child with the given tag name.  Returns
     *     default value or empty string if none found.
     */
    getFirstChildValue: function(node, nsuri, name, def) {
        var value;
        var nodes = this.getElementsByTagNameNS(node, nsuri, name);
        if (nodes && nodes.length > 0) {
            value = this.getChildValue(nodes[0], def);
        } else {
            value = def;
        }
        return value;
    },
    
    /**
     * Method: parseFeature
     * Parse feature from an Atom entry node..
     *
     * Parameters:
     * node - {DOMElement} An Atom entry or feed node.
     *
     * Returns:
     * {<HGIS.Feature.Vector>}
     */
    parseFeature: function(node) {
        var atomAttrib = {};
        var value = null;
        var nodes = null;
        var attval = null;
        var atomns = this.namespaces.atom;
        
        // atomAuthor*
        this.parsePersonConstructs(node, "author", atomAttrib);
        
        // atomCategory*
        nodes = this.getElementsByTagNameNS(node, atomns, "category");
        if (nodes.length > 0) {
            atomAttrib.categories = [];
        }
        for (var i=0, ii=nodes.length; i<ii; i++) {
            value = {};
            value.term = nodes[i].getAttribute("term");
            attval = nodes[i].getAttribute("scheme");
            if (attval) { value.scheme = attval; }
            attval = nodes[i].getAttribute("label");
            if (attval) { value.label = attval; }
            atomAttrib.categories.push(value);
        }
        
        // atomContent?
        nodes = this.getElementsByTagNameNS(node, atomns, "content");
        if (nodes.length > 0) {
            value = {};
            attval = nodes[0].getAttribute("type");
            if (attval) {
                value.type = attval;
            }
            attval = nodes[0].getAttribute("src");
            if (attval) {
                value.src = attval;
            } else {
                if (value.type == "text" || 
                    value.type == "html" || 
                    value.type == null ) {
                    value.value = this.getFirstChildValue(
                                        node,
                                        atomns,
                                        "content",
                                        null
                                        );
                } else if (value.type == "xhtml" ||
                           value.type.match(/(\+|\/)xml$/)) {
                    value.value = this.getChildEl(nodes[0]);
                } else { // MUST be base64 encoded
                    value.value = this.getFirstChildValue(
                                        node,
                                        atomns,
                                        "content",
                                        null
                                        );
                }
                atomAttrib.content = value;
            }
        }
        
        // atomContributor*
        this.parsePersonConstructs(node, "contributor", atomAttrib);
        
        // atomId
        atomAttrib.id = this.getFirstChildValue(node, atomns, "id", null);
        
        // atomLink*
        nodes = this.getElementsByTagNameNS(node, atomns, "link");
        if (nodes.length > 0) {
            atomAttrib.links = new Array(nodes.length);
        }
        var oAtts = ["rel", "type", "hreflang", "title", "length"];
        for (var i=0, ii=nodes.length; i<ii; i++) {
            value = {};
            value.href = nodes[i].getAttribute("href");
            for (var j=0, jj=oAtts.length; j<jj; j++) {
                attval = nodes[i].getAttribute(oAtts[j]);
                if (attval) {
                    value[oAtts[j]] = attval;
                }
            }
            atomAttrib.links[i] = value;
        }
        
        // atomPublished?
        value = this.getFirstChildValue(node, atomns, "published", null);
        if (value) {
            atomAttrib.published = value;
        }
        
        // atomRights?
        value = this.getFirstChildValue(node, atomns, "rights", null);
        if (value) {
            atomAttrib.rights = value;
        }
        
        // atomSource? -- not implemented
        
        // atomSummary?
        value = this.getFirstChildValue(node, atomns, "summary", null);
        if (value) {
            atomAttrib.summary = value;
        }
        
        // atomTitle
        atomAttrib.title = this.getFirstChildValue(
                                node, atomns, "title", null
                                );
        
        // atomUpdated
        atomAttrib.updated = this.getFirstChildValue(
                                node, atomns, "updated", null
                                );
        
        var featureAttrib = {
            title: atomAttrib.title,
            description: atomAttrib.summary,
            atom: atomAttrib
        };
        var geometry = this.parseLocations(node)[0];
        var feature = new HGIS.Feature.Vector(geometry, featureAttrib);
        feature.fid = atomAttrib.id;
        return feature;
    },
    
    /**
     * Method: parseFeatures
     * Return features from an Atom entry or feed.
     *
     * Parameters:
     * node - {DOMElement} An Atom entry or feed node.
     *
     * Returns:
     * Array({<HGIS.Feature.Vector>})
     */
    parseFeatures: function(node) {
        var features = [];
        var entries = this.getElementsByTagNameNS(
            node, this.namespaces.atom, "entry"
        );
        if (entries.length == 0) {
            entries = [node];
        }
        for (var i=0, ii=entries.length; i<ii; i++) {
            features.push(this.parseFeature(entries[i]));
        }
        return features;
    },
    
    /**
     * Method: parseLocations
     * Parse the locations from an Atom entry or feed.
     *
     * Parameters:
     * node - {DOMElement} An Atom entry or feed node.
     *
     * Returns:
     * Array({<HGIS.Geometry>})
     */
    parseLocations: function(node) {
        var georssns = this.namespaces.georss;

        var locations = {components: []};
        var where = this.getElementsByTagNameNS(node, georssns, "where");
        if (where && where.length > 0) {
            if (!this.gmlParser) {
                this.initGmlParser();
            }
            for (var i=0, ii=where.length; i<ii; i++) {
                this.gmlParser.readChildNodes(where[i], locations);
            }
        }
        
        var components = locations.components;
        var point = this.getElementsByTagNameNS(node, georssns, "point");
        if (point && point.length > 0) {
            for (var i=0, ii=point.length; i<ii; i++) {
                var xy = HGIS.String.trim(
                            point[i].firstChild.nodeValue
                            ).split(/\s+/);
                if (xy.length !=2) {
                    xy = HGIS.String.trim(
                                point[i].firstChild.nodeValue
                                ).split(/\s*,\s*/);
                }
                components.push(new HGIS.Geometry.Point(xy[1], xy[0]));
            }
        }

        var line = this.getElementsByTagNameNS(node, georssns, "line");
        if (line && line.length > 0) {
            var coords;
            var p;
            var points;
            for (var i=0, ii=line.length; i<ii; i++) {
                coords = HGIS.String.trim(
                                line[i].firstChild.nodeValue
                                ).split(/\s+/);
                points = [];
                for (var j=0, jj=coords.length; j<jj; j+=2) {
                    p = new HGIS.Geometry.Point(coords[j+1], coords[j]);
                    points.push(p);
                }
                components.push(
                    new HGIS.Geometry.LineString(points)
                );
            }
        }        

        var polygon = this.getElementsByTagNameNS(node, georssns, "polygon");
        if (polygon && polygon.length > 0) {
            var coords;
            var p;
            var points;
            for (var i=0, ii=polygon.length; i<ii; i++) {
                coords = HGIS.String.trim(
                            polygon[i].firstChild.nodeValue
                            ).split(/\s+/);
                points = [];
                for (var j=0, jj=coords.length; j<jj; j+=2) {
                    p = new HGIS.Geometry.Point(coords[j+1], coords[j]);
                    points.push(p);
                }
                components.push(
                    new HGIS.Geometry.Polygon(
                        [new HGIS.Geometry.LinearRing(points)]
                    )
                );
            }
        }
        
        if (this.internalProjection && this.externalProjection) {
            for (var i=0, ii=components.length; i<ii; i++) {
                if (components[i]) {
                    components[i].transform(
                        this.externalProjection,
                        this.internalProjection
                    );
                }
            }
        }
        
        return components;
    },
    
    /**
     * Method: parsePersonConstruct
     * Parse Atom person constructs from an Atom entry node.
     *
     * Parameters:
     * node - {DOMElement} An Atom entry or feed node.
     * name - {String} Construcy name ("author" or "contributor")
     * data = {Object} Object in which to put parsed persons.
     *
     * Returns:
     * An {Object}.
     */
    parsePersonConstructs: function(node, name, data) {
        var persons = [];
        var atomns = this.namespaces.atom;
        var nodes = this.getElementsByTagNameNS(node, atomns, name);
        var oAtts = ["uri", "email"];
        for (var i=0, ii=nodes.length; i<ii; i++) {
            var value = {};
            value.name = this.getFirstChildValue(
                            nodes[i],
                            atomns,
                            "name",
                            null
                            );
            for (var j=0, jj=oAtts.length; j<jj; j++) {
                var attval = this.getFirstChildValue(
                            nodes[i],
                            atomns,
                            oAtts[j],
                            null);
                if (attval) {
                    value[oAtts[j]] = attval;
                }
            }
            persons.push(value);
        }
        if (persons.length > 0) {
            data[name + "s"] = persons;
        }
    },

    CLASS_NAME: "HGIS.Format.Atom"
});
/* ======================================================================
    HGIS/Control/KeyboardDefaults.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Control.js
 * @requires HGIS/Handler/Keyboard.js
 * @requires HGIS/Events.js
 */

/**
 * Class: HGIS.Control.KeyboardDefaults
 * The KeyboardDefaults control adds panning and zooming functions, controlled
 * with the keyboard. By default arrow keys pan, +/- keys zoom & Page Up/Page
 * Down/Home/End scroll by three quarters of a page.
 * 
 * This control has no visible appearance.
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.KeyboardDefaults = HGIS.Class(HGIS.Control, {

    /**
     * APIProperty: autoActivate
     * {Boolean} Activate the control when it is added to a map.  Default is
     *     true.
     */
    autoActivate: true,

    /**
     * APIProperty: slideFactor
     * Pixels to slide by.
     */
    slideFactor: 75,

    /**
     * APIProperty: observeElement
     * {DOMelement|String} The DOM element to handle keys for. You
     *     can use the map div here, to have the navigation keys
     *     work when the map div has the focus. If undefined the
     *     document is used.
     */
    observeElement: null,

    /**
     * Constructor: HGIS.Control.KeyboardDefaults
     */
        
    /**
     * Method: draw
     * Create handler.
     */
    draw: function() {
        var observeElement = this.observeElement || document;
        this.handler = new HGIS.Handler.Keyboard( this,
                {"keydown": this.defaultKeyPress},
                {observeElement: observeElement}
        );
    },
    
    /**
     * Method: defaultKeyPress
     * When handling the key event, we only use evt.keyCode. This holds 
     * some drawbacks, though we get around them below. When interpretting
     * the keycodes below (including the comments associated with them),
     * consult the URL below. For instance, the Safari browser returns
     * "IE keycodes", and so is supported by any keycode labeled "IE".
     * 
     * Very informative URL:
     *    http://unixpapa.com/js/key.html
     *
     * Parameters:
     * evt - {Event} 
     */
    defaultKeyPress: function (evt) {
        var size, handled = true;

        var target = HGIS.Event.element(evt);
        if (target  &&
            (target.tagName == 'INPUT' ||
             target.tagName == 'TEXTAREA' ||
             target.tagName == 'SELECT')) {
            return;
        }

        switch (evt.keyCode) {
            case HGIS.Event.KEY_LEFT:
                this.map.pan(-this.slideFactor, 0);
                break;
            case HGIS.Event.KEY_RIGHT: 
                this.map.pan(this.slideFactor, 0);
                break;
            case HGIS.Event.KEY_UP:
                this.map.pan(0, -this.slideFactor);
                break;
            case HGIS.Event.KEY_DOWN:
                this.map.pan(0, this.slideFactor);
                break;
            
            case 33: // Page Up. Same in all browsers.
                size = this.map.getSize();
                this.map.pan(0, -0.75*size.h);
                break;
            case 34: // Page Down. Same in all browsers.
                size = this.map.getSize();
                this.map.pan(0, 0.75*size.h);
                break; 
            case 35: // End. Same in all browsers.
                size = this.map.getSize();
                this.map.pan(0.75*size.w, 0);
                break; 
            case 36: // Home. Same in all browsers.
                size = this.map.getSize();
                this.map.pan(-0.75*size.w, 0);
                break; 

            case 43:  // +/= (ASCII), keypad + (ASCII, Opera)
            case 61:  // +/= (Mozilla, Opera, some ASCII)
            case 187: // +/= (IE)
            case 107: // keypad + (IE, Mozilla)
                this.map.zoomIn();
                break; 
            case 45:  // -/_ (ASCII, Opera), keypad - (ASCII, Opera)
            case 109: // -/_ (Mozilla), keypad - (Mozilla, IE)
            case 189: // -/_ (IE)
            case 95:  // -/_ (some ASCII)
                this.map.zoomOut();
                break; 
            default:
                handled = false;
        }
        if (handled) {
            // prevent browser default not to move the page
            // when moving the page with the keyboard
            HGIS.Event.stop(evt);
        }
    },

    CLASS_NAME: "HGIS.Control.KeyboardDefaults"
});
/* ======================================================================
    HGIS/Format/WMTSCapabilities/v1_0_0.js
   ====================================================================== */

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Format/WMTSCapabilities.js
 * @requires HGIS/Format/OWSCommon/v1_1_0.js
 */

/**
 * Class: HGIS.Format.WMTSCapabilities.v1_0_0
 * Read WMTS Capabilities version 1.0.0.
 * 
 * Inherits from:
 *  - <HGIS.Format.WMTSCapabilities>
 */
HGIS.Format.WMTSCapabilities.v1_0_0 = HGIS.Class(
    HGIS.Format.OWSCommon.v1_1_0, {
        
    /**
     * Property: version
     * {String} The parser version ("1.0.0").
     */
    version: "1.0.0",

    /**
     * Property: namespaces
     * {Object} Mapping of namespace aliases to namespace URIs.
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wmts: "http://www.opengis.net/wmts/1.0",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * Property: yx
     * {Object} Members in the yx object are used to determine if a CRS URN
     *     corresponds to a CRS with y,x axis order.  Member names are CRS URNs
     *     and values are boolean.  Defaults come from the 
     *     <HGIS.Format.WMTSCapabilities> prototype.
     */
    yx: null,

    /**
     * Property: defaultPrefix
     * {String} The default namespace alias for creating element nodes.
     */
    defaultPrefix: "wmts",

    /**
     * Constructor: HGIS.Format.WMTSCapabilities.v1_0_0
     * Create a new parser for WMTS capabilities version 1.0.0. 
     *
     * Parameters:
     * options - {Object} An optional object whose properties will be set on
     *     this instance.
     */
    initialize: function(options) {
        HGIS.Format.XML.prototype.initialize.apply(this, [options]);
        this.options = options;
        var yx = HGIS.Util.extend(
            {}, HGIS.Format.WMTSCapabilities.prototype.yx
        );
        this.yx = HGIS.Util.extend(yx, this.yx);
    },

    /**
     * APIMethod: read
     * Read capabilities data from a string, and return info about the WMTS.
     * 
     * Parameters: 
     * data - {String} or {DOMElement} data to read/parse.
     *
     * Returns:
     * {Object} Information about the SOS service.
     */
    read: function(data) {
        if(typeof data == "string") {
            data = HGIS.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        capabilities.version = this.version;
        return capabilities;
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {        
        "wmts": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Contents": function(node, obj) {
                obj.contents = {};                
                obj.contents.layers = [];
                obj.contents.tileMatrixSets = {};                
                this.readChildNodes(node, obj.contents);
            },
            "Layer": function(node, obj) {
                var layer = {
                    styles: [],
                    formats: [],
                    dimensions: [],
                    tileMatrixSetLinks: []
                };
                layer.layers = [];
                this.readChildNodes(node, layer);
                obj.layers.push(layer);
            },
            "Style": function(node, obj) {
                var style = {};
                style.isDefault = (node.getAttribute("isDefault") === "true");
                this.readChildNodes(node, style);
                obj.styles.push(style);
            },
            "Format": function(node, obj) {
                obj.formats.push(this.getChildValue(node)); 
            },
            "TileMatrixSetLink": function(node, obj) {
                var tileMatrixSetLink = {};
                this.readChildNodes(node, tileMatrixSetLink);
                obj.tileMatrixSetLinks.push(tileMatrixSetLink);
            },
            "TileMatrixSet": function(node, obj) {
                // node could be child of wmts:Contents or wmts:TileMatrixSetLink
                // duck type wmts:Contents by looking for layers
                if (obj.layers) {
                    // TileMatrixSet as object type in schema
                    var tileMatrixSet = {
                        matrixIds: []
                    };
                    this.readChildNodes(node, tileMatrixSet);
                    obj.tileMatrixSets[tileMatrixSet.identifier] = tileMatrixSet;
                } else {
                    // TileMatrixSet as string type in schema
                    obj.tileMatrixSet = this.getChildValue(node);
                }
            },
            "TileMatrix": function(node, obj) {
                var tileMatrix = {
                    supportedCRS: obj.supportedCRS
                };
                this.readChildNodes(node, tileMatrix);
                obj.matrixIds.push(tileMatrix);
            },
            "ScaleDenominator": function(node, obj) {
                obj.scaleDenominator = parseFloat(this.getChildValue(node)); 
            },
            "TopLeftCorner": function(node, obj) {                
                var topLeftCorner = this.getChildValue(node);
                var coords = topLeftCorner.split(" ");
                // decide on axis order for the given CRS
                var yx;
                if (obj.supportedCRS) {
                    // extract out version from URN
                    var crs = obj.supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):.+:(\w+)$/, 
                        "urn:ogc:def:crs:$1::$2"
                    );
                    yx = !!this.yx[crs];
                }
                if (yx) {
                    obj.topLeftCorner = new HGIS.LonLat(
                        coords[1], coords[0]
                    );
                } else {
                    obj.topLeftCorner = new HGIS.LonLat(
                        coords[0], coords[1]
                    );
                }
            },
            "TileWidth": function(node, obj) {
                obj.tileWidth = parseInt(this.getChildValue(node)); 
            },
            "TileHeight": function(node, obj) {
                obj.tileHeight = parseInt(this.getChildValue(node)); 
            },
            "MatrixWidth": function(node, obj) {
                obj.matrixWidth = parseInt(this.getChildValue(node)); 
            },
            "MatrixHeight": function(node, obj) {
                obj.matrixHeight = parseInt(this.getChildValue(node)); 
            },
            "ResourceURL": function(node, obj) {
                obj.resourceUrl = obj.resourceUrl || {};
                var resourceType = node.getAttribute("resourceType");
                if (!obj.resourceUrls) {
                    obj.resourceUrls = [];
                }
                var resourceUrl = obj.resourceUrl[resourceType] = {
                    format: node.getAttribute("format"),
                    template: node.getAttribute("template"),
                    resourceType: resourceType
                };
                obj.resourceUrls.push(resourceUrl);
            },
            // not used for now, can be added in the future though
            /*"Themes": function(node, obj) {
                obj.themes = [];
                this.readChildNodes(node, obj.themes);
            },
            "Theme": function(node, obj) {
                var theme = {};                
                this.readChildNodes(node, theme);
                obj.push(theme);
            },*/
            "WSDL": function(node, obj) {
                obj.wsdl = {};
                obj.wsdl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <WSDL> element                
            },
            "ServiceMetadataURL": function(node, obj) {
                obj.serviceMetadataUrl = {};
                obj.serviceMetadataUrl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <ServiceMetadataURL> element                
            },
            "LegendURL": function(node, obj) {
                obj.legend = {};
                obj.legend.href = node.getAttribute("xlink:href");
                obj.legend.format = node.getAttribute("format");
            },
            "Dimension": function(node, obj) {
                var dimension = {values: []};
                this.readChildNodes(node, dimension);
                obj.dimensions.push(dimension);
            },
            "Default": function(node, obj) {
                obj["default"] = this.getChildValue(node);
            },
            "Value": function(node, obj) {
                obj.values.push(this.getChildValue(node));
            }
        },
        "ows": HGIS.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "HGIS.Format.WMTSCapabilities.v1_0_0" 

});
/**
 * Class: HGIS.Biz.BayonetTrace
 * 过车轨迹类.
 * 通过给定的路径，模拟出当前车辆的行驶轨迹，通过setPath设置路径,根据给定的数据进行按时间或距离的回放展示
 * - 等距离比例回放：在整段回放轨迹的基础上，根据轨迹回放步数将整段路程分为等距离的n段，在此每一步移动的距离是固定的；
 * - 等时间比例回放：按照传入的位置节点中的时间差值和轨迹回放展示总时间之间的比例，按照时间比例为基准进行轨迹回放。
 * 
 * 示例:
 * (code)
 * var trace=new HGIS.Biz.BayontTrace(map,layer,callbackMiddle,callbackStep);
 * 
 * (end)
 * 
 * Parameters:
 * map: - {<HGIS.MapEx>} 地图对象.
 * layer: - {<HGIS.GraphicLayer>} 轨迹绘制图层.
 * callbackMiddle - {Object} 车辆经过卡口时的回调函数.
 * callbackStep - {Object} 车辆每前进一步的回调函数.
 */
HGIS.Biz = HGIS.Biz || {};
HGIS.Biz.BayonetTrace = function(map, layer, callbackMiddle, callbackStep) {
	var thisObj = this;
	thisObj._distance = 0;// 整个路径的距离
	thisObj._map = map;// 绑定的地图对象
	thisObj._layer = layer;  // 地图图层
	
	thisObj._startPoint = null; 
	thisObj._beginPoint = null;
	thisObj._endPoint = null;
	
	thisObj._currentTempPoint = null;  //小车移动临时点位
	thisObj._stopPoint = null;  // 停留点
	thisObj._stopPointIndex = 1;
	thisObj.lastPointIndex = 1; // 最后一点 点位的编号
	thisObj.steepLength = 0; // 每步所移动的距离
	
	thisObj._timer = null;// 计时器
	
	thisObj._speed = 1;// 速率 *2 *4 *0.5 *0.25
	thisObj.car = null;// 移动目标矢量要素
	thisObj.status = "pre";  //小车的移动状态 pre、complete、start、pause
	thisObj.points = null;// 保存当前轨迹的轨迹集合

	thisObj._currentAngle = 0;  // 小车的旋转角度
	thisObj._stopTime = 1;// 在卡口点的停留时间
	thisObj._stopTimer=null;
	thisObj.completePath = null;  // 走过的路径
	thisObj.showPath = true;      // 展示道路路径
	thisObj.showPoint=true;       //显示数据点

	//时间轴新增项
	thisObj.minTime = 0;      // 播放时间
	thisObj.maxTime = 0;      // 结束时间
	thisObj.curTime = 0;      // 当前时间
	thisObj.timeRatio = 1;    // 运行时间和数据时间差之间的比例
	thisObj.pathSize = 0;     // 轨迹总点数
	
	
	/**
	 * APIProperty: data
	 * 传入点的点位的数据.
	 */
	thisObj.data = null;   //传入的点位数据
	
	/**
	 * APIProperty: _interval
	 * 移动一下的时间 默认每隔60ms.
	 */
	thisObj._interval = 60;// 默认每隔60ms移动一下
	
	/**
	 * APIProperty: _step
	 * 在等距离回放中完成轨迹的步数，默认1000.针对于tranceByDistance为默认值true时有效
	 */
	thisObj._step=1000; //多少步完成轨迹
	
	/**
	 * APIProperty: _pauseTime
	 * 重复卡口的停留时间，默认4000.
	 */
	thisObj._pauseTime=4000;//重复卡口停留时间
	/**
	 * APIProperty: _totalTime
	 * 在以时间比例回放中，轨迹运行的总时间，默认为10000ms
	 */
	thisObj._totalTime = 10000; //多少步完成轨迹
	
	/**
	 * APIProperty: tranceByDistance
	 * true为按等距离规则进行回放，；false为按等时间比例规则进行回放，默认为true
	 * 回放规则不一致，传入的参数也存在不一致，请在setPath接口中进行区分
	 */
	thisObj.tranceByDistance = true;
	
	/**
	 * APIProperty: showCarOnPath
	 * 是否显示车辆，默认true显示，如果卡的话可以将其关闭.
	 */
	thisObj.showCarOnPath = true;
	
	/**
	 * APIProperty: _style
	 * 设置轨迹的样式.
	 * 
	 * 示例:
	 * (code)
	 *   var _style = {
	 *		"PointDraw" : { //传入位置点的显示样式
	 *			pointRadius : 3,
	 *			graphicName : "circle",
	 *			fillColor : "#ffffff",
	 *			fillOpacity : 0.8,
	 *			strokeWidth : 4,
	 *			strokeOpacity : 1,
	 *			strokeColor : "red",
	 *			graphicZIndex : 10
	 *		},
	 *		"Line" : { //根据传入位置点构成道路的道路样式
	 *			strokeWidth : 5,
	 *			strokeOpacity : 1,
	 *			strokeColor : "green",
	 *			graphicZIndex : 5
	 *		},
	 *		"CompleteLine" : {// 走过的路径样式
	 *			strokeWidth : 5,
	 *			strokeOpacity : 1,
	 *			strokeColor : "red",
	 *			graphicZIndex : 5
	 *		}
	 * (end)
	 */
	thisObj._style = {
		"PointDraw" : {
			pointRadius : 3,
			graphicName : "circle",
			fillColor : "#ffffff",
			fillOpacity : 0.8,
			strokeWidth : 4,
			strokeOpacity : 1,
			strokeColor : "red",
			graphicZIndex : 10
		},
		"Line" : {
			strokeWidth : 5,
			strokeOpacity : 1,
			strokeColor : "green",
			graphicZIndex : 5
		},
		"CompleteLine" : {// 走过的路径样式
			strokeWidth : 5,
			strokeOpacity : 1,
			strokeColor : "red",
			graphicZIndex : 5
		}
	};
	
	/**
	 * APIMethod: setInterval
	 * 
	 * 
	 * 设定轨迹每移动一步的默认时间间隔
	 */
	thisObj.setInterval = function(time){
		thisObj._interval = time;	
	}

	/**
	 * APIMethod: setTranceStep
	 * 按距离回放中设定完成轨迹的步数，默认为1000步
	 * 
	 * Parameters:
	 * 
	 * step - {int} 完成轨迹所需的步数.
	 * 
	 */
	thisObj.setTranceStep = function(step){
		thisObj._step = step ;
		thisObj.steepLength = (thisObj._distance / thisObj._step) * thisObj._speed;
	}
	/**
	  * APIMethod: setTotalTime
	 * 按等时间比例回放中设定完成轨迹的总时间
	 * 
	 * Parameters:
	 * 
	 * time - {int} 完成轨迹所需的总时间.
	 * 
	 */
	thisObj.setTotalTime = function(time){
		thisObj._totalTime = time;
		thisObj.timeRatio =   thisObj._totalTime/(thisObj.maxTime - thisObj.minTime);
	}	
	
	
	thisObj.startStyle = {
			externalGraphic : "/hgis/theme/img/startpoint.png",
			graphicWidth : 32,
			graphicHeight : 32,
			graphicXOffset : -16,
			graphicYOffset : -32,
			graphicZIndex : 15
	};
	thisObj.endStyle = {
		externalGraphic : "/hgis/theme/img/terminal.png",
		graphicWidth : 32,
		graphicHeight : 32,
		graphicXOffset : -16,
		graphicYOffset : -32,
		graphicZIndex : 15
	};
	thisObj.moveStyle = {
		externalGraphic : "/hgis/theme/img/rightcar.png",
		graphicWidth : 65,
		graphicHeight : 33,
		graphicXOffset : -32,
		graphicYOffset : -15,
		graphicZIndex : 16,
		labelXOffset : 0,
		labelYOffset : 40,
		fontColor : 'blue'
	};
	/**
	 * APIMethod: setStartStyle
	 * 设置起始点的样式
	 * 
	 * Parameters:
	 * 
	 * style - {Object} 起点样式，设置起始点样式
	 * 
	 * 示例:
	 * (code)
	 * var startStyle = {
	 *	  externalGraphic : "/hgis/theme/img/startpoint.png",
	 *	  graphicWidth : 32,
	 *	  graphicHeight : 32,
	 *    graphicXOffset : -16,
	 *	  graphicYOffset : -32,
	 *	  graphicZIndex : 15
	 *  };
	 * 
	 * (end)
	 */
	this.setStartStyle = function(style) {
		thisObj.startStyle = style;
	};
	
	/**
	 * APIMethod: setendStyle
	 * 设置终点的样式
	 * 
	 * Parameters:
	 * 
	 * style - {Object} 终点样式.
	 * 设置终点样式.
	 */
	this.setendStyle = function(style) {
		thisObj.endStyle = style;
	};
	
	/**
	 * APIMethod: setmoveStyle
	 * 设置移动目标的样式
	 * 
	 * Parameters:
	 * 
	 * style - {Object} 移动点样式.
	 * 设置移动目标的样式.
	 */
	this.setmoveStyle = function(style) {
		thisObj.moveStyle = style;
	};
	
	/**
	 * APIMethod: cleanPath
	 * 清空掉轨迹路径及小车;
	 * 
	 */
	this.cleanPath = function(){
		clearTimeout(thisObj._timer);
		layer.removeAllFeatures();
		thisObj.status = "complete";
	}

	/**
	 * APIMethod: setPathShow
	 * 设置是否显示轨迹线
	 * 
	 * Parameters:
	 * 
	 * b - {Boolean} 是否显示轨迹线，默认true，显示轨迹线.
	 * 
	 */
	this.setPathShow = function(b) {
		thisObj.showPath = (b==true);
	};
	/**
	 * APIMethod: setStopTime
	 * 在卡口点的停留时间设定
	 */
	this.setStopTime = function(timesnap) {
		thisObj._stopTime = timesnap;
	};
	// 设定在卡口点的停留时间 ，为保证兼容性，同上setStopTime功能 一致
	this.stopTime = function(timesnap) {
		thisObj._stopTime = timesnap;
	};
	/**
	 * 关联地图
	 */
	this.bindMap = function(map) {
		thisObj._map = map;
	};
	/**
	 * APIMethod: speed
	 * 设置过车速度
	 * 
	 * Parameters:
	 * 
	 * speedNum - {Number} 过车速度默认1,speedNum大于1表示加速，小于1表示减速，<=0的设置无效.
	 * 设置过车速度.
	 */
	this.speed = function(speedNum) {
		if(speedNum<=0)
			return;
		thisObj._speed = speedNum;
		if(thisObj.tranceByDistance){ //全局设定，计算在按照距离轨迹回放中，每移动一步的距离
			thisObj.steepLength = (thisObj._distance / thisObj._step) * thisObj._speed;
		}
	};
	/**
	 * 不对外公开，添加起点、终点图标 以及移动小车到图层
	 */
	this.addTargetStyle = function(startP, endP) {
		var moveP = new HGIS.Geometry.Point(startP.x, startP.y);
		thisObj.car = new HGIS.Feature.Vector(moveP, thisObj.data[0],
				HGIS.Util.extend(thisObj.moveStyle, {
					label : thisObj.data[0].label  // 添加小车上方的标签
				}));
		thisObj._startPoint = new HGIS.Feature.Vector(startP, null,
				thisObj.startStyle);
		thisObj._endPoint = new HGIS.Feature.Vector(endP, null,
				thisObj.endStyle);
		thisObj._layer.addFeatures([thisObj._endPoint, thisObj._startPoint]);
		
		if(thisObj.showCarOnPath)
		  thisObj._layer.addFeatures([thisObj.car ]);//
	};
 
	/**
	 * APIMethod: setPath
	 * 设置轨迹路径
	 * 
	 * Parameters:
	 * data - {Object} 路径点的数组
	 * 
	 * 示例:
	 * (code)
	 * var data = [ {
	 * 			"id" : "KK1",  //点位id
	 * 			"latitude" : "3656947", //坐标点纬度坐标
	 * 			"longitude" : "13519927", //经度
	 * 			"label" : "111",  //显示的标签
	 * 			"crossTime" :100  // 卡口停留时间
	 * 		}, {
	 * 			"id" : "KK2",
	 * 			"latitude" : "3657090",
	 * 			"longitude" : "13520586",
	 * 			"label" : "222",
	 * 			"crossTime" :100
	 * 		}, {
	 * 			"id" : "KK3",
	 * 			"latitude" : "3658227",
	 * 			"longitude" : "13522277",
	 * 			"label" : "333",
	 * 			"crossTime" :100
	 * 		}];
	 *  trace.setPath(data);
	 * (end)
	 * 如果需要按传入的时间进行
	 * (code)
	 * var data = [ {
	 * 			"id" : "KK1",
	 * 			"latitude" : "3658227",
	 * 			"longitude" : "13522277",
	 * 			"label" : "333",
	 * 			"crossTime" :100,
	 * 			"time" :1523930914207 //数据点位上传时间
	 * 		},{
	 * 			"id" : "KK1",
	 * 			"latitude" : "3658227",
	 * 			"longitude" : "13522277",
	 * 			"label" : "333",
	 * 			"crossTime" :100,
	 * 			"time" :1523930919207
	 * 		}];
	 *  trace.setPath(data);
	 * (end)
	 * 
	 */
	this.setPath = function(data) {
		if (data == null || data == "" || data == undefined) {
			alert( HGIS.language[HGIS.InitParam.language]["track_data_noEmpty"] );//轨迹数据不能为空
			return;
		};
		var dataLen = data.length;
		if (dataLen > 1) {
			thisObj.pathSize = dataLen ;
			thisObj.data = data;
			thisObj._distance = 0;
			if (thisObj.points == null)
				thisObj.points = new Array();
			else
				thisObj.points = [];
			for (var i = 0; i < dataLen; i++) {
				var pt = new HGIS.Geometry.Point(data[i].longitude,
						data[i].latitude);
				thisObj.points.push(pt);
				// 如果为按照距离进行回放，则在处理数据的时候，直接获取路径的总长度
				if (i > 0 && thisObj.tranceByDistance) {
					thisObj._distance += thisObj.points[i]
							.distanceTo(thisObj.points[i - 1]);
				}
			}
			if(thisObj.tranceByDistance){  // 执行按照距离的方式
				//设定 每端 运行的长度
				thisObj.steepLength = (thisObj._distance / thisObj._step) * thisObj._speed;
			}else{  //**    按照时间轴的方式进行回放设定        **
				// 设置轨迹开始时间
				thisObj.minTime = this.data[0].time;
				// 设置当前时间
				thisObj.curTime = thisObj.minTime;
				// 设置轨迹回放结束时间
				thisObj.maxTime = this.data[thisObj.pathSize - 1].time;
				// 设置小车的运行时间上传数据的时间差的比例，达到小车按 时间比例运行的效果
				thisObj.timeRatio =   thisObj._totalTime/(thisObj.maxTime - thisObj.minTime);
			}
			// 计算初始化角度
			thisObj._currentAngle = thisObj.caculateAngle(thisObj.points[0],
					thisObj.points[1]);
			// 初始化起点，当前阶段的终点，以及当前点
			thisObj._beginPoint = new HGIS.Geometry.Point(
					thisObj.points[0].x, thisObj.points[0].y);
			thisObj._startPoint = new HGIS.Geometry.Point(
					thisObj.points[0].x, thisObj.points[0].y);
			thisObj._stopPoint = new HGIS.Geometry.Point(
					thisObj.points[1].x, thisObj.points[1].y);
			thisObj._currentTempPoint = new HGIS.Geometry.Point(
					thisObj.points[0].x, thisObj.points[0].y);
			
			thisObj.lastPointIndex  = thisObj.points.length ; // 设定轨迹终止点的index
			var lineString = new HGIS.Geometry.LineString(thisObj.points);
			var pointsString = new HGIS.Geometry.MultiPoint(
					thisObj.points);
			var lineVector = new HGIS.Feature.Vector(lineString, {},
					thisObj._style["Line"]);
			var traceLineVectors = new Array();
			traceLineVectors.push(lineVector);
			if(thisObj.showPoint){
				var pointVector = new HGIS.Feature.Vector(pointsString, {},
						thisObj._style["PointDraw"]);
				traceLineVectors.push(pointVector);
			}
			layer.addFeatures(traceLineVectors);
			// 添加起点,终点，移动目标
			thisObj.addTargetStyle(thisObj.points[0],
					thisObj.points[dataLen - 1]);
			// 改变小车的初始状态
			if(thisObj.showCarOnPath)
			    thisObj.changeCarStatus();
			// 缩放到相应位置
			var extent = lineString.getBounds();
			map.zoomToExtent(extent);
		} else {
			alert( HGIS.language[HGIS.InitParam.language]["point_noTrack"] );	//一个点不能成为轨迹
			return;
		}
	};

	/**
	 * APIMethod: start
	 * 开始播放轨迹.
	 */
	this.start = function() {
		if(thisObj.status == "complete"){
			thisObj.stop();
		}
		if (thisObj.status != "start"){
			thisObj.status = "start";
			//动起来就触发
			if (callbackMiddle != null) {
				callbackMiddle([ thisObj.data[0],0]);
			}
			if(thisObj.tranceByDistance){
				thisObj.timeFn();
			}else{
				thisObj.play();
			}
		}
	};

	/**
	 * APIMethod: pause
	 * 暂停轨迹.
	 */
	this.pause = function() {
		clearTimeout(thisObj._timer);
		clearTimeout(thisObj._stopTimer);
		thisObj.status = "pause";
	};

	/**
	 * APIMethod: stop
	 * 停止播放轨迹.
	 */
	this.stop = function() {
		clearTimeout(thisObj._timer);
		clearTimeout(thisObj._stopTimer);
		thisObj._stopPointIndex = 1;
		thisObj._currentAngle = thisObj.caculateAngle(thisObj.points[0],
				thisObj.points[1]);
		thisObj._currentTempPoint = new HGIS.Geometry.Point(
				thisObj.points[0].x, thisObj.points[0].y);
		thisObj._beginPoint = new HGIS.Geometry.Point(
				thisObj.points[0].x, thisObj.points[0].y);
		thisObj._stopPoint = new HGIS.Geometry.Point(thisObj.points[1].x,
				thisObj.points[1].y);
		if(!thisObj.tranceByDistance){
			thisObj.curTime = thisObj.minTime;
		}
		thisObj.changeCarStatus();
		thisObj.car.style.label =  thisObj.data[thisObj._stopPointIndex-1].label;
		thisObj.changePosition();
		// 清楚走过的痕迹
		layer.removeFeatures(thisObj.completePath);
		thisObj.completePath = null;
		thisObj.status = "stop";
	};
	
	/**
	 * APIMethod: resume
	 * 暂停后继续播放轨迹.
	 */
	this.resume = function() {
		if(thisObj.status == "pause"){
			thisObj.status = "pre";
			if(thisObj.tranceByDistance){
				thisObj.timeFn();
			}else{
				thisObj.play();
			}
		}
	};

	/**
	 * APIMethod: restart
	 * 重新播放轨迹.不传如参数，默认为从起点到终点；
	 * 
	 *  
	 * Parameters:
	 * startIndex - {int} 开始播放点的下标
	 * endIndex - {int} 开始播放点的下标 
	 */
	this.restart = function(startIndex,endIndex) {
		if(startIndex != undefined && endIndex != undefined ){
			if( isNaN(startIndex) || isNaN(endIndex) || startIndex  < 0 || endIndex < 0){
				alert( HGIS.language[HGIS.InitParam.language]["replay_track_point_err"] );	//"重新播放轨迹点错误"
				return;
			}
			if(endIndex > thisObj.lastPointIndex -1){
				throw "restart failed beacause of the endIndex is out of the range";
				return ;
			}
		}
		thisObj.status = "pre";
		thisObj.stop();
		if(startIndex == undefined || endIndex == undefined){ //针对常规的轨迹回放
			if(thisObj.tranceByDistance){ // 按距离轨迹回放
				thisObj.lastPointIndex = thisObj.points.length ; // 设置全局 终止点的 index
			}else{                       // 按时间轨迹回放
				 thisObj.curTime = thisObj.data[0].time;
				 thisObj.maxTime = thisObj.maxTime = this.data[thisObj.pathSize - 1].time;
			}
			thisObj.lastPointIndex = thisObj.points.length ;
			thisObj.car.style.label =  thisObj.data[0].label;
			thisObj.start();
		}else{ // 针对设定起止点的轨迹回放
			// 用于重新播放的两个标记
			if(thisObj.tranceByDistance){
				thisObj.lastPointIndex = endIndex+1 ; // 设置全局 终止点的 index
			}else{
				thisObj.maxTime = thisObj.data[endIndex].time ;
				thisObj.curTime = thisObj.data[startIndex].time;
			}
			thisObj._beginPoint = new HGIS.Geometry.Point(
					thisObj.points[startIndex].x, thisObj.points[startIndex].y);
			thisObj._startPoint = new HGIS.Geometry.Point(
					thisObj.points[startIndex].x, thisObj.points[startIndex].y);
			thisObj._stopPoint = new HGIS.Geometry.Point(
					thisObj.points[startIndex+1].x, thisObj.points[startIndex+1].y);
			thisObj._stopPointIndex = startIndex+1 ;
			thisObj._currentTempPoint =  thisObj._startPoint;
			thisObj.changePosition();
			thisObj._currentAngle = thisObj.caculateAngle(thisObj.points[startIndex],
					thisObj.points[startIndex+1]);
			thisObj.changeCarStatus();
			thisObj.car.style.label =  thisObj.data[startIndex].label;
			thisObj.start();
		}
	};
	
	// 两个destory 其中一个存在拼写错误；保证兼容下未删除掉
	this.destory = function() {
		clearTimeout(thisObj._timer);
		clearTimeout(thisObj._stopTimer);
		layer.removeAllFeatures();
		thisObj == null;
	};
	
	/**
	 * APIMethod: destroy
	 * 销毁轨迹播放.
	 */
	this.destroy=this.destory;
	/**
	 * Method : timeFn
	 * 按距离进行轨迹回放的
	 */
	this.timeFn = function() {
		//如果轨迹已经播放结束，则继续无效
		if(thisObj.status == "complete"){
			return;
		}
		var curstop = thisObj._stopPointIndex;
		// 如果两个点重合则原点移动
		if (thisObj._beginPoint.x == thisObj._stopPoint.x
				&& thisObj._beginPoint.y == thisObj._stopPoint.y) {  //thisObj._pauseTime  为需要改造项，在此特殊声明
			thisObj._stopTimer=setTimeout(thisObj.moveTheSamePoint, thisObj._pauseTime/thisObj._speed);
			return;
		}
		// 如果起点和终点一样则停留4s直接到下一个点
		thisObj.getNextPoint();
		// 移动目标
		thisObj.changePosition();  
		// 填充已经走过的路线
		thisObj.fillPath();
		// 判断是否移动到地图范围外面，如果则重置地图中心点
		if (map.getExtent().left > thisObj._currentTempPoint.x
				|| map.getExtent().bottom > thisObj._currentTempPoint.y
				|| map.getExtent().right < thisObj._currentTempPoint.x
				|| map.getExtent().top < thisObj._currentTempPoint.y) {
			map.setCenter(new HGIS.LonLat(thisObj._currentTempPoint.x,
					thisObj._currentTempPoint.y));
		}
		//  如果超出，则跳出循环
		if (thisObj._stopPointIndex > thisObj.lastPointIndex - 1) {
			thisObj.status = "complete";
			clearTimeout(thisObj._timer);
			return;
		}
		// if为在卡口点之间的移动，不需要考虑卡口点停留时间，else为在卡口点的移动，需要考虑卡口点停留时间
		if (curstop == thisObj._stopPointIndex){
			thisObj._timer = setTimeout(thisObj.timeFn, thisObj._interval);
		}else{
			var passTime = thisObj.data[thisObj._stopPointIndex-1].crossTime != undefined ? thisObj.data[thisObj._stopPointIndex-1].crossTime :thisObj._stopTime * 1000;
			thisObj._timer = setTimeout(thisObj.timeFn,
					passTime);
		}
	};
	/**
	 * 按距离进行回放时 获取下一个点的点位信息
	 */
	this.getNextPoint = function() {
		// 计算一步移动的距离
		if (thisObj._currentAngle == 0) { // x+轴
			thisObj._currentTempPoint.x += thisObj.steepLength;
		} else if (thisObj._currentAngle < Math.PI / 2) { // 第一象限
			thisObj._currentTempPoint.x += thisObj.steepLength
					* Math.cos(thisObj._currentAngle);
			thisObj._currentTempPoint.y += thisObj.steepLength
					* Math.sin(thisObj._currentAngle);
		} else if (thisObj._currentAngle == Math.PI / 2) { // y+轴
			thisObj._currentTempPoint.y += thisObj.steepLength;

		} else if (thisObj._currentAngle < Math.PI) { // 第二象限
			thisObj._currentTempPoint.x -= thisObj.steepLength
					* Math.cos(Math.PI - thisObj._currentAngle);
			thisObj._currentTempPoint.y += thisObj.steepLength
					* Math.sin(Math.PI - thisObj._currentAngle);
		} else if (thisObj._currentAngle == Math.PI) { // x-轴
			thisObj._currentTempPoint.x -= thisObj.steepLength;

		} else if (thisObj._currentAngle < Math.PI * 3 / 2) { // 第三象限
			thisObj._currentTempPoint.x -= thisObj.steepLength
					* Math.cos(thisObj._currentAngle - Math.PI);
			thisObj._currentTempPoint.y -= thisObj.steepLength
					* Math.sin(thisObj._currentAngle - Math.PI);
		} else if (thisObj._currentAngle == Math.PI * 3 / 2) { // y-轴
			thisObj._currentTempPoint.y -= thisObj.steepLength;
		} else if (thisObj._currentAngle < Math.PI * 2) { // 第四象限
			thisObj._currentTempPoint.x += thisObj.steepLength
					* Math.cos(2 * Math.PI - thisObj._currentAngle);
			thisObj._currentTempPoint.y -= thisObj.steepLength
					* Math.sin(2 * Math.PI - thisObj._currentAngle);
		}
		var dst = thisObj._currentTempPoint.distanceTo(thisObj._stopPoint);
		// 如果离停止点的具体小于分段则下一点直接是停止点
		if (dst <= thisObj.steepLength) {
			thisObj._currentTempPoint.x = thisObj._stopPoint.x;
			thisObj._currentTempPoint.y = thisObj._stopPoint.y;
			// 抛出回调
			if (callbackMiddle != null) {
				callbackMiddle([ thisObj.data[thisObj._stopPointIndex],thisObj._stopPointIndex]);
			}
			//新增设定一个lastPointIndex的参数，
			if (thisObj._stopPointIndex < thisObj.lastPointIndex - 1) {
				thisObj._stopPointIndex++;
				// 更新终止节点
				thisObj._stopPoint = thisObj.points[thisObj._stopPointIndex];
				// 更新该段的开始点
				thisObj._beginPoint = thisObj.points[thisObj._stopPointIndex - 1];
				// 重新计算新的分段的角度
				thisObj._currentAngle = thisObj.caculateAngle(thisObj._currentTempPoint, thisObj._stopPoint);
				// 重新改变移动点的角度
				thisObj.changeCarStatus();
				//改变标签点的样式
				thisObj.car.style.label =  thisObj.data[thisObj._stopPointIndex-1].label;
			} else{
			    thisObj._stopPointIndex++;
			}
		} else {
			if (callbackStep != null) {
				callbackStep([ thisObj.data[thisObj._stopPointIndex - 1],
						thisObj._currentTempPoint,thisObj._stopPointIndex - 1, thisObj._currentAngle ]);
			}
		}
	};
	/**
	 * Method: play
	 * 按给定的时间进行播放轨迹.
	 */
	this.play = function() {
		//如果轨迹已经播放结束，则继续无效
		if(thisObj.status == "complete"){
			return;
		}
		// 当前点是最后一个点，停止
		if (thisObj._stopPointIndex == thisObj.pathSize) {
			return;
		}
		if (thisObj.curTime > thisObj.maxTime) {
			return;
		}
		// 如果两个点重合则原点移动 -------------需要注意的点
		if (thisObj._beginPoint.x == thisObj._stopPoint.x
				&& thisObj._beginPoint.y == thisObj._stopPoint.y) {
			thisObj._stopTimer=setTimeout(thisObj.moveTheSamePoint, thisObj._pauseTime/thisObj._speed*thisObj.timeRatio);
			return;
		}
		var curstop = thisObj._stopPointIndex;
		// 执行回放操作
		thisObj.execute();
		// 移动目标
		thisObj.changePosition();
		// 填充已经走过的路线
		thisObj.fillPath();
		// 判断是否移动到地图范围外面，如果则重置地图中心点
		if (map.getExtent().left > thisObj._currentTempPoint.x
				|| map.getExtent().bottom > thisObj._currentTempPoint.y
				|| map.getExtent().right < thisObj._currentTempPoint.x
				|| map.getExtent().top < thisObj._currentTempPoint.y) {
			map.setCenter(new HGIS.LonLat(thisObj._currentTempPoint.x,thisObj._currentTempPoint.y));
		}
		// 递归调用
		if (thisObj._stopPointIndex > thisObj.pathSize - 1) {
			thisObj.status = "complete";
			clearTimeout(thisObj._timer);
			return;
		}
		// 在卡口之间路段内匀速回放
		if (curstop == thisObj._stopPointIndex){
			thisObj._timer = setTimeout(thisObj.play, thisObj._interval / thisObj._speed*thisObj.timeRatio);
		}else{ // 在卡口点停留
			var passTime = thisObj.data[thisObj._stopPointIndex-1].crossTime != undefined ? thisObj.data[thisObj._stopPointIndex-1].crossTime :thisObj._stopTime * 1000;
			thisObj._timer = setTimeout(thisObj.play, passTime*thisObj.timeRatio);
		}
	};
	/**
	 * Method: execute
	 * 按给定的时间播放轨迹,执行步进距离。
	 */
	this.execute = function() {
		//增添部分时间容错机制
		if(thisObj.data[thisObj._stopPointIndex].time === thisObj.data[thisObj._stopPointIndex-1].time){
			thisObj._currentTempPoint.y = thisObj._stopPoint.y;
			thisObj._currentTempPoint.x = thisObj._stopPoint.x;
		}else{
			var xFactor = (thisObj._stopPoint.x - thisObj._beginPoint.x) / (thisObj.data[thisObj._stopPointIndex].time - thisObj.data[thisObj._stopPointIndex-1].time);
			var yFactor = (thisObj._stopPoint.y - thisObj._beginPoint.y) / (thisObj.data[thisObj._stopPointIndex].time - thisObj.data[thisObj._stopPointIndex-1].time);
			var x = parseFloat(thisObj._beginPoint.x) + xFactor * (thisObj.curTime -  thisObj.data[thisObj._stopPointIndex-1].time)
			var y = parseFloat(thisObj._beginPoint.y) + yFactor * (thisObj.curTime -  thisObj.data[thisObj._stopPointIndex-1].time)
			// 计算当前轨迹位置
			thisObj._currentTempPoint.y = y;
			thisObj._currentTempPoint.x = x;
		}
		// 设置当前回放的时间
		thisObj.curTime  = parseFloat(thisObj.curTime) + parseFloat(thisObj._interval);
		// 如果时间超过当前路段终点的时间，则进行下一路段的回放
		if (thisObj.curTime > thisObj.data[thisObj._stopPointIndex].time) {
			// 抛出回调
			if (callbackMiddle != null) {
				callbackMiddle([ thisObj.data[thisObj._stopPointIndex], thisObj._stopPointIndex]);
			}
			if (thisObj._stopPointIndex < thisObj.pathSize - 1) {
				thisObj._stopPointIndex++;
				// 更新路段终止节点
				thisObj._stopPoint = thisObj.points[thisObj._stopPointIndex];
				// 更新该段的开始节点
				thisObj._beginPoint = thisObj.points[thisObj._stopPointIndex - 1];
				// 重新计算新的分段的角度
				thisObj._currentAngle = thisObj.caculateAngle(thisObj._beginPoint, thisObj._stopPoint);
				// 重新改变移动点的角度
				thisObj.changeCarStatus();
				thisObj.car.style.label =  thisObj.data[thisObj._stopPointIndex-1].label;// 改变移动点的标记点样式
			} else {
				thisObj._stopPointIndex++;
			}
		} else {  // 在当前路段回放
			if (callbackStep != null) {  // 抛出内插点的回调
				callbackStep([ thisObj.data[thisObj._stopPointIndex - 1],thisObj._currentTempPoint,thisObj._stopPointIndex - 1,thisObj._currentAngle]);
			}
		}
		
	};
	/**
	 * 当起止点的位置相同时的特殊情况的处理
	 */
	this.moveTheSamePoint = function() {
		thisObj._currentTempPoint.x = thisObj._stopPoint.x;
		thisObj._currentTempPoint.y = thisObj._stopPoint.y;
		thisObj._beginPoint = thisObj._stopPoint;
		// 抛出回调
		if (callbackMiddle != null) {
			callbackMiddle([ thisObj.data[thisObj._stopPointIndex],thisObj._stopPointIndex ]);
		};
		//如果是最后一个重复点
		if (thisObj._stopPointIndex == thisObj.points.length-1) {
			thisObj.status="complete";
			return;
		};
		if (thisObj._stopPointIndex < thisObj.points.length-1) {
			thisObj._stopPointIndex++;
			thisObj._stopPoint = thisObj.points[thisObj._stopPointIndex];
		};
		thisObj._currentAngle = thisObj.caculateAngle(
				thisObj._currentTempPoint, thisObj._stopPoint);
		  thisObj.changeCarStatus();
		if(thisObj.tranceByDistance){ //
			thisObj.timeFn();
		}else{
			//改变当前点位的当前时间，以适应向下时跳转到下一个点
			thisObj.curTime  =thisObj.data[thisObj._stopPointIndex-1].time ; 
			thisObj.play();
		}
	};

	/**
	 * Method: caculateAngle
	 * 根据传入的两个点，计算路径角度；用于显示移动轨迹的方向
	 */
	this.caculateAngle = function(startPoint, endPoint) {
		var startx = startPoint.x;
		var starty = startPoint.y;
		var endx = endPoint.x;
		var endy = endPoint.y;
		if (startx == endx) {
			if (endy > starty)
				return Math.PI / 2;
			else
				return Math.PI * 3 / 2;
		} else if (starty == endy) {
			if (endx > startx)
				return 0;
			else
				return Math.PI;
		} else {
			var angle = Math.atan(Math.abs((endy - starty) / (endx - startx)));
			if (endx > startx && endy > starty)// 第一象限
			{
				return angle;
			} else if (endx < startx && endy > starty)// 第二象限
			{
				return Math.PI - angle;
			} else if (endx < startx && endy < starty)// 第三象限
			{
				return angle + Math.PI;
			} else {
				return 2 * Math.PI - angle;
			}
		}
	};
	/**
	 * Method: changeCarStatus
	 * 改变小车的车头朝向
	 */
	this.changeCarStatus = function() {
		thisObj.car.style["rotation"] = -thisObj._currentAngle * 180 / Math.PI;
	};
	/**
	 * Metod :changePosition
	 * 用于移动时改变小车的位置，实现移动的效果
	 */
	this.changePosition = function() {
		var toV = new HGIS.LonLat(thisObj._currentTempPoint.x,
				thisObj._currentTempPoint.y);
		thisObj.car.move(toV);
		layer.drawFeature(thisObj.car);
	};
	/**
	 * Method :restPosition
	 * 重新设定小车的位置
	 */
	this.resetPosition = function() {
		var toV = new HGIS.LonLat(thisObj.data[0].longitude,
				thisObj.data[0].latitude);
		thisObj.car.move(toV);
		layer.drawFeature(thisObj.car);
	};
	thisObj.fillpathArr = [];
	/**
	 * Method : fillPath
	 * 填充已走过的路径
	 */
	this.fillPath = function() {
		if (!thisObj.showPath)
			return;
		if (thisObj.completePath != null) {
			layer.removeFeatures(thisObj.completePath);
			thisObj.completePath = null;
		}
		thisObj.fillPathArr = [];
		for (var i = 0; i < thisObj._stopPointIndex; i++) {
			thisObj.fillPathArr.push(thisObj.points[i]);
		}
		thisObj._currentTempPoint.calculateBounds();
		thisObj.fillPathArr.push(thisObj._currentTempPoint);
		var lineString = new HGIS.Geometry.LineString(thisObj.fillPathArr);
		thisObj.completePath = new HGIS.Feature.Vector(lineString, {},
				thisObj._style["CompleteLine"]);
		layer.addFeatures(thisObj.completePath);
	};

};/**
 * Class: HGIS.Biz.CameraNPlusOne
 * 视频N+1.
 * 视频N+1。以某个感兴趣的摄像头为中心，查询指定半径范围内的周边摄像头，并预览最近的N个摄像头.
 * 
 * Parameters:
 * layer - {<HGIS.GraphicLayer>} 展示摄像头的图层.
 * radius - {Number}缓冲半径.
 * numOfNearestCameras - {Number}要打开最近的摄像头数量.
 * cameraStyle - {Object} 地图上的摄像头样式.
 * 
 * 示例:
 * (code)
 *   var camera=new HGIS.Biz.CameraNplusOne(layer,radius,numofNearestCameras,cameraStyle);
 * (end)
 */
HGIS.Biz=HGIS.Biz||{};
HGIS.Biz.CameraNPlusOne = function(layer, radius, numOfNearestCameras, cameraStyle) {
	var thisObj = this;
	thisObj.centerPoint;// {HGIS.Geometry.Point}
						// 视频N+1的中心点。一般情况下，由某个感兴趣的摄像头的经纬度构造而成。
	thisObj._radius = radius;// 缓冲区半径
	thisObj._num = numOfNearestCameras;
	thisObj.queryCameraUrl = tacticsURL.cameraNPlusOne;// 查询地址，对开发者不开放
	thisObj.previewCameras = new Array();// 要预览的摄像头
	thisObj.cameraArr = new Array();// 视频N+1空间查询出来的所有摄像头
	thisObj.onekey = true;// ｛boolean｝为true时表示 查询、地图上显示摄像头、打开预览动作，自动进行，否则需要执行其它方法完成视频N+1。默认true
	thisObj.map = layer.map;
	thisObj.cameraDefaultStyle = {
			externalGraphic : APIAdress+"jsapi/theme/img/res-camera.png",
			graphicWidth : 30,
			graphicHeight : 30,
			labelAlign : "cm",
			labelXOffset : 0,
			labelYOffset : 20,
			fontColor : "#333333",
			fontFamily : "Verdana,Arial,Helvetica,sans-serif",
			fontWeight : "normal",
			label : ""
		}

	// 判断用于存储摄像头的图层是否存在。如果不存在则给出提示
	if (layer.CLASS_NAME != "HGIS.Layer.Vector") {
		alert( HGIS.language[HGIS.InitParam.language]["vectorLayer_noExist"] );	//"矢量图层不存在"
		return;
	}
	// 执行视频N+1任务,填充摄像头数据。该方法首先校验输入参数合法性，合法时查询并填充视频N+1对象中的摄像头数据。不合法时给出提示，不做任何操作
	this.drawCenter = function() {
		var flag = thisObj.checkParams();
		if (!flag) {
			return;
		} else {
			if (thisObj.onekey) {
				thisObj.queryCameras();
			}
		}
	};
	// 执行视频N+1查询任务。该方法首先校验输入参数合法性：不合法给出提示，不做任何操作。
	this.checkParams = function() {
		var flag = false;
		// 判断输入半径
		if (isNaN(thisObj._radius)) {
			alert( HGIS.language[HGIS.InitParam.language]["buff_radius_err"] );	//"缓冲半径错误，请输入正整数"
			flag = false;
		} else {
			flag = true;
		}
		// 判断要打开的摄像头个数
		if (isNaN(thisObj._num)) {
			alert( HGIS.language[HGIS.InitParam.language]["open_camera_needParam"] );	//"要打开最近的N个摄像头，请输入正整数"
			flag = false;
			return;
		} else {
			flag = true;
		}
		return flag;
	};

	/**
	 * Method: queryCameras
	 *  空间查询，获取落在缓冲区内的所有摄像头.
	 */
	this.queryCameras = function() {
		var sucess=function(geom) {
			thisObj.centerPoint = geom;
			var params = {
				"centerLon" : geom.x,
				"centerLat" : geom.y,
				"radius" : thisObj._radius
			};
			//声明回调函数
			var sucessHandler=function(res){
				if (res.ReturnFlag == 1) {
					thisObj.cameraArr=JSON.parse(res.Data);
					if (thisObj.onekey) {
						thisObj.pasteCamerasOnMap();
					}
				} else {
					thisObj.cameraArr = [];// 查询失败，则不填充数据
				}
			};
			var errorHandler=function(a){
				alert(a);
			};
			HGIS.Utils.send( tacticsURL.cameraNPlusOne,JSON.stringify(params),"POST","json",sucessHandler,errorHandler);

		};
		thisObj.map.draw("point", layer,"geometry",null, {"keepOn" : false,"ifClear" : false}, sucess);
	};
	
	/**
	 * Method: pasteCamerasOnMap
	 * 把摄像头添加到地图上.
	 */
	this.pasteCamerasOnMap = function() {
		for ( var i = 0; i < thisObj.cameraArr.length; i = i + 1) {
			var attr = {
				name : thisObj.cameraArr[i].name,
				dist : thisObj.cameraArr[i].dist,
				indexCode : thisObj.cameraArr[i].indexCode
			};
			thisObj.cameraDefaultStyle.label=attr.name;
			var style=cameraStyle?cameraStyle:thisObj.cameraDefaultStyle;
			var geom = new HGIS.Geometry.Point(thisObj.cameraArr[i].lon * 1, thisObj.cameraArr[i].lat * 1);
			var feature = new HGIS.Feature.Vector(geom, attr, style);
			layer.addFeatures([feature]);
		}
		if (thisObj.onekey) {
			thisObj.previewNearstCameras();
		}
	};

	/**
	 * Method: previewNearstCameras
	 * 预览最近N个摄像头.
	 * 如果N大于 查询出来的所有摄像头数量，则查询结果中的摄像头全部摄像头。 注：查询结果中的摄像头已经按中心点位由近及远排序.
	 */
	this.previewNearstCameras = function() {
		if (thisObj._num <= thisObj.cameraArr.length) {
			thisObj.previewCameras = thisObj.cameraArr.slice(0, thisObj._num);
		} else {
			thisObj.previewCameras = thisObj.cameraArr;
		}
	
	};
	/**
	 * 显示中心点
	 * 
	 * @param flag
	 *            true表示显示中心点，
	 * @param pointStyle
	 *            中心点的样式。可选项，当flag为true时生效，flag为false时自动隐藏
	 */
	this.displayCenter = function(flag, pointStyle) {

	};
	
	/**
	 * Method: displayBuffer
	 * 显示缓冲区.
	 * 
	 * Parameters:
	 * flag - {Boolean} true表示显示中心点.
	 * bufferStyle - {Object} 依中心点生成的缓冲区样式。可选项，当flag为true时生效，flag为false时自动隐藏.
	 */
	this.displayBuffer = function(flag, bufferStyle) {
		//获取缓冲区的圆 
		alert(flag);
	}
};/**
 * Class: HGIS.Biz.CameraRelay
 * 视频接力.
 * 以某个摄像头为起点画线，查询落在沿线指定距离缓冲区范围内的摄像头，并预览离起点最近的N个摄像头.
 * 
 * Examples:
 * (code)
 * var instance=new HGIS.CameraRelay(layer);
 * (end)
 * 
 * Parameters:
 * layer - {<HGIS.Layer.GraphicLayer>} 绘制的图层.
 */
HGIS.Biz=HGIS.Biz||{};
HGIS.Biz.CameraRelay = function(layer) {
	var thisObj = this;
	thisObj.centerLon;// 中心点纬度
	thisObj.centerLat;// 中心点经度
	thisObj.radius;// 缓冲区半径
	thisObj.linePoints;// 视频接力画出来的线数据
	thisObj.lineGeom;
	thisObj.queryCameraUrl = tacticsURL.cameraRelayBufferQuery;// 查询地址，对开发者不开放
	thisObj.cameraArr = new Array();// 查询出来的所有摄像头
	// 判断用于存储摄像头的图层是否存在。如果不存在则给出提示
	if (layer.CLASS_NAME != "HGIS.Layer.Vector") {
		alert( HGIS.language[HGIS.InitParam.language]["vectorLayer_noExist"] );	//"矢量图层不存在"
		return;
	}
	var map = layer.map;

	/**
	 * APIMethod: showCameras
	 * 把每次接力动作的查询结果显示到地图上.
	 * 
	 * Parameters:
	 * radius - {Number} 缓冲区半径。单位：米.
	 * numOfNearestCameras - {Number} 要预览的摄像头个数.
	 * clearFlag - {Boolean} 在图层上展示新数据之前，是否要清除掉以前的老数据。true表示要清除，false表示不不清除。默认为true.
	 * lineStyle - {Object} 线样式.
	 * cameraStyle - {Object} 摄像头样式.
	 * bufferStyle - {Object} 缓冲区样式。如果给出了缓冲区样式，按此样式显示缓冲区，否则不显示缓冲区。如果要显示系统缓冲区，传字符串“default”.
	 */
	this.showCameras = function(radius, numOfNearestCameras, clearFlag,
			lineStyle, cameraStyle, bufferStyle) {
		// 判断输入半径是否合理
		if (isNaN(radius)) {
			alert( HGIS.language[HGIS.InitParam.language]["buff_radius_err"] );	//"缓冲半径错误，请输入正整数"				
			return;
		}
		// 是否清除掉以前的数据
		if (clearFlag) {
			var features = layer.getFeaturesByAttribute("tempLayerName",
					layer.name);
			layer.removeFeatures(features);
			map.getLayersByName("系统临时层")[0].removeAllFeatures();
		}
		thisObj.radius = radius;// 缓冲区半径
		var sucess = function(geom) {
			thisObj.lineGeom = geom;
			thisObj.linePoints = "";
			var vertices = geom.getVertices();// 所画线的所有节点
			thisObj.centerLon = vertices[0].x;// 取线的起点作为预览查询中心点经度
			thisObj.centerLat = vertices[0].y;// 取线的起点作为预览查询中心点 纬度
			for (var i = 0; i < vertices.length; i = i + 1) {
				// 拼接线串的节点
				if (i < vertices.length - 1) {
					thisObj.linePoints = vertices[i].toShortString() + ","
							+ thisObj.linePoints;
				} else {
					thisObj.linePoints = thisObj.linePoints
							+ vertices[i].toShortString();
				}
			}
			// 查询成功后的回调函数
			var call = function(res) {
				if (res.ReturnFlag == 1) {
					thisObj.cameraArr = JSON.parse(res.Data);
					thisObj.pasteCamerasOnMap(cameraStyle);
					thisObj.previewNearstCameras(numOfNearestCameras);
				} else {
					thisObj.cameraArr = [];// 查询失败，则不填充数据
				}
				//如果给出了缓冲区样式，那么表示需要显示缓冲区，否则不显示
				if (bufferStyle&&bufferStyle!="default") {
					thisObj.displayBuffer(bufferStyle);
				}
				if(bufferStyle=="default"){
					thisObj.displayBuffer();
				}

			};
			// 组织参数，发起缓冲区查询请求
			var params = {
				"radius" : radius,
				"linePoints" : thisObj.linePoints
			};
			HGIS.Utils.send( tacticsURL.cameraRelayBufferQuery,JSON.stringify(params),"POST","json",call);


		}
		// 画线查询开始
		map.draw("freeline", layer,"geometry",null, {"keepOn" : false,"ifClear" : false}, sucess);
	};

	/**
	 * APIMethod: pasteCamerasOnMap
	 * 把摄像头添加到地图上
	 * 
	 * Parameters:
	 * cameraStyle - {Object} 摄像头样式.
	 */
	this.pasteCamerasOnMap = function(cameraStyle) {
		for (var i = 0; i < thisObj.cameraArr.length; i = i + 1) {
			var attr = {
				name : thisObj.cameraArr[i].name,
				indexCode : thisObj.cameraArr[i].indexCode,
				tempLayerName : layer.name
			};
			var geom = new HGIS.Geometry.Point(
					thisObj.cameraArr[i].lon * 1, thisObj.cameraArr[i].lat * 1);
			var feature = new HGIS.Feature.Vector(geom, attr, cameraStyle);
			layer.addFeatures([ feature ]);
		}
	}

	/**
	 * APIMethod: previewNearstCameras
	 * 预览最近N个摄像头.
	 * 如果N大于 查询出来的所有摄像头数量，则预览全部摄像头。 注：查询结果中的摄像头已经按中心点位由近及远排序.
	 * 
	 * Parameters:
	 * numOfNearestCameras - {Number} 摄像头个数.
	 */
	this.previewNearstCameras = function(numOfNearestCameras) {
		var params = {
			"centerLon" : thisObj.centerLon,
			"centerLat" : thisObj.centerLat,
			"numOfNearestCameras" : numOfNearestCameras,
			"linePoints" : thisObj.linePoints,
			"radius" : thisObj.radius
		};
		HGIS.Utils.send(tacticsURL.cameraRelayPreview,JSON.stringify(params),"POST","json",function(res) {
			if (res.ReturnFlag == 1) {
				var arr = JSON.parse(res.Data);
				alert( HGIS.language[HGIS.InitParam.language]["this"] + numOfNearestCameras + HGIS.language[HGIS.InitParam.language]["camera_preview"] + arr.toString());
				//这 	个摄像头将被预览
			} else {
				alert( HGIS.language[HGIS.InitParam.language]["query_err"] );// 查询失败，则不填充数据
			}
		});

	};

	/**
	 * APIMethod: displayBuffer
	 * 显示缓冲区.
	 * 
	 * Parameters:
	 * bufferStyle - {Object} 依中心点生成的缓冲区样式。可选项，当flag为true时生效，flag为false时自动隐藏.
	 */
	this.displayBuffer = function(bufferStyle) {
		var geomOperate = new HGIS.Geometry.GeomOperation();
		var thisPer = map.degreeSpanToMeter(thisObj.centerLon, "degrees");// 计算此线所在地区，一度能代表多少米。把thisObj.radius计算出来
		var degreeSpan = thisObj.radius / thisPer;// 把缓冲半径换算成地图单位
		geomOperate.buffer(thisObj.lineGeom, degreeSpan, 50, 2, function(
				vecotor) {
			if (bufferStyle) {
				vecotor.style = bufferStyle;
			}
			layer.addFeatures([ vecotor ]);// 考虑显示查询出来的摄像头
		});
	};
}/**
 * Class222: HGIS.Biz.Indoor
 * 室内地图类。 
 * 
 * Parameters:
 * 
 */ 
HGIS.Biz = HGIS.Biz || {};
HGIS.Biz.Indoor = function(){
	var $this=this;	 
	/**
	 * APIAPIMethod: listAll
	 * 列出所有场所和场所信息.
	 * 
	 * Parameters:
	 * successHandler - {Function} 成功时的回调函数
	 * errorHandler - {Function} 失败时的回调函数	 
	 */
	this.listAll=function(successHandler,errorHandler){
		HGIS.Utils.send("/hgis/rest/services/indoor/listAll",null,"GET","json",successHandler,errorHandler);//无参数
	}
	
	/**
	 * APIAPIMethod: deletePlaceById
	 * 通过id删除场所。
	 * 
	 * Parameters:
	 * params - {JSON} JSON对象，格式为{"placeId":placeid}
	 * successHandler - {Function} 成功时的回调函数
	 * errorHandler - {Function} 失败时的回调函数	 
	 */
	this.deletePlaceById=function(params,successHandler,errorHandler){
		HGIS.Utils.send("/hgis/rest/services/indoor/removePlaceById",JSON.stringify(params),"POST","text",successHandler,errorHandler);
	}	
	/**
	 * APIAPIMethod: addPlace
	 * 添加场所。
	 * 
	 * Parameters:
	 * params - {JSON} JSON对象
	 * successHandler - {Function} 成功时的回调函数
	 * errorHandler - {Function} 失败时的回调函数	 
	 */
	this.addPlace=function(params,successHandler,errorHandler){
		HGIS.Utils.send("/hgis/rest/services/indoor/addPlace",JSON.stringify(params),"POST","text",successHandler,errorHandler);
	}
};/**
 * Class: HGIS.Biz.MobileTrack
 * 
 * Parameters:
 * mobileTrackLayer - {<HGIS.Layer.Vector>} 落脚位置将会在这个图层上显示.如果为null,系统会自动创建一个矢量图层，并添加到地图上.
 * stationStyle - {Object} 基站点位样式.
 * footholdStyle - {Object} 通过基站定位后的嫌疑对象落脚点样式.
 * traceStyle - {Object} 轨迹线样式.
 */
HGIS.Biz = HGIS.Biz || {};
HGIS.Biz.MobileTrack = function(mobileTrackLayer, stationStyle,
		footholdStyle, traceStyle) {
	var thisObj = this;
	thisObj.map=mobileTrackLayer.map; // 轨迹图层所属的地图对象
	thisObj.trackData;// 落脚点数据。
	thisObj.timer = 0;// 定时器指针， 用于于动态显示基站点位信息
	thisObj.count = 0;// 一个计数器
	// 轨迹样式
	thisObj.defaultTraceStyle={
			strokeWidth : 3,
			strokeOpacity : 1,
			strokeColor : "red",
			strokeDashstyle : "solid"
		};
	/**
	 * Method: play
	 * 开始推演落脚点(bug~使用了jQuery中的方法,应去掉).
	 * 
	 * Parameters:
	 * duration - {Number} 落脚点移动间隔.
	 * 
	 */
	this.play = function(duration) {
		HGIS.Utils.send(tacticsURL.foothold, JSON.stringify(params), "POST",
				"json", function(res) {
					thisObj.trackData = JSON.parse(res.Data);
					if (thisObj.trackData != null) {
						thisObj.timer = window.setInterval(thisObj.showTrack,
								duration);// policy
					}
				});

	};
	
	this.getDataAndPlay = function(url,data,type,callback,duration){
		HGIS.Utils.send(url,data,"POST",type,function(res) {
			thisObj.trackData = JSON.parse(res.Data);
			if(thisObj.trackData!=null){
				thisObj.timer = window.setInterval(thisObj.showTrack, duration);// policy
			}
			if(typeof callback == 'function'){
				callback(thisObj.trackData);
			}
		});

	};
	
	this.destroy = function() {
		thisObj.trackData = null;
		if(thisObj.timer){
			window.clearInterval(thisObj.timer);
		}
		mobileTrackLayer.removeAllFeatures();
//		mobileTrackLayer.destory();
	};
	
	/**
	 * Method: getTraceData
	 * 获取轨迹数据.
	 */
	this.getTraceData=function(){
		if(thisObj.trackData!=null){
			return thisObj.trackData;
		}else{
			alert( HGIS.language[HGIS.InitParam.language]["track_data_noProducted"] );	//"轨迹数据尚未生成"
		}
	}
	
	/**
	 * APIProperty: traceLine
	 * 落脚点轨迹线.
	 */
	thisObj.traceLine = new HGIS.Geometry.LineString( []);
	thisObj.traceLine.style = (traceStyle != null) ? traceStyle : thisObj.defaultTraceStyle;
	var thisTraceVector = new HGIS.Feature.Vector(thisObj.traceLine);
	thisTraceVector.fid = "traceLine";
	mobileTrackLayer.addFeatures( [ thisTraceVector ]);
	// 如果不是一个矢量图层，那么系统会创建一个默认的图层，添加到地图上
	if (mobileTrackLayer.CLASS_NAME != "HGIS.Layer.Vector") {
		thisObj.mobileTraceLayer = new HGIS.Layer.Vector(
				"移动基站轨迹查询", {
					renderers : thisObj.map.getDefaultRenderer(),
					isFixed : false
				});
		thisObj.map.addLayer(thisObj.mobileTraceLayer);
	} else {
		thisObj.mobileTraceLayer = mobileTrackLayer;
	}
	

	/**
	 * Method: showTrack
	 * 显示轨迹线，基站，与落脚点.
	 */
	this.showTrack = function() {
		for ( var i = 0; i < thisObj.trackData.length; i=i+1) {
			if (thisObj.count == i) {
				// 添加基站点
				var title="第"+(i+1)+"基站";
				thisObj.stationStyle = (stationStyle != null) ? stationStyle
						: thisObj.getDefaultStationStyle(title);
				var stationPoint = new HGIS.Geometry.Point(
						thisObj.trackData[i].lon * 1,
						thisObj.trackData[i].lat * 1);
				var stationVector = new HGIS.Feature.Vector(stationPoint,
						null, thisObj.stationStyle);
				mobileTrackLayer.addFeatures( [ stationVector ]);
				if (thisObj.trackData[i].footholdlat * 1 != 0) {
					// 添加落脚点，首个基站不对应落脚点
					var title =  "落脚时间\n"+thisObj.trackData[i].pass_time ;
					thisObj.footholdStyle = (footholdStyle != null) ? footholdStyle
							:thisObj.getDefaultFootholdStyle(title);

					var lon = thisObj.trackData[i].footholdlon * 1;
					var lat = thisObj.trackData[i].footholdlat * 1;
					var footPoint = new HGIS.Geometry.Point(lon, lat);
					thisObj.map.setCenter( [ lon, lat ], thisObj.map.getZoom(), null, null);
					thisObj.addTracePoint(lon, lat);
					var footholdVector = new HGIS.Feature.Vector(
							footPoint, null, thisObj.footholdStyle);
					mobileTrackLayer.addFeatures( [ footholdVector ])
				}

			}
		}
		thisObj.count = thisObj.count + 1;
		if (thisObj.count == thisObj.trackData.length - 1) {
			window.clearInterval(thisObj.timer);
		}
	}

	/**
	 * Method: addTracePoint
	 * 添加加新的落脚点，此点将被追加的轨迹末尾处
	 * 
	 * Parameters:
	 * lon - {Number} 经度.
	 * lat - {Number} 纬度.
	 */
	this.addTracePoint = function(lon, lat) {
		var oldTrace = mobileTrackLayer.getFeatureByFid("traceLine");
		var newPoint = new HGIS.Geometry.Point(lon, lat);// 添加的新点
		var vertices = oldTrace.geometry.getVertices();
		vertices.push(newPoint);
		// 更新后的轨迹
		var updatedLine = new HGIS.Geometry.LineString(vertices);
		updatedLine.style = thisObj.traceLine.style;
		var updatedTrace = new HGIS.Feature.Vector(updatedLine);
		updatedTrace.fid = "traceLine";
		updatedTrace.sytle= thisObj.defaultTraceStyle;
		mobileTrackLayer.addFeatures( [ updatedTrace ]);
		mobileTrackLayer.removeFeatures( [ oldTrace ]);
	};
	/**
	 * Method: getDefaultStationStyle
	 * 获取默认的基站点位样式.
	 * 
	 * Parameters:
	 * title - {String} 显示的标题文字 支持换行tab键等 \n 、 \t.
	 */
	this.getDefaultStationStyle = function(title) {
		var stationStyle = {
			pointRadius : 6,
			graphicName : "square",
			fillColor : "ff3300",
			fillOpacity : 1,
			strokeWidth : 3,
			strokeOpacity : 1,
			strokeColor : "#ee9900",
			fontFamily : "Verdana,Arial,Helvetica,sans-serif",
			fontWeight : "normal",
			label : title,
			labelXOffset : 0,
			labelYOffset : 20
		};
		return stationStyle;
	};
	/**
	 * Method: getDefaultFootholdStyle
	 * 默认的落脚点样式
	 * 
	 * Parameters:
	 * title - {String} 显示的标题文字 支持换行tab键等 \n 、 \t.
	 */
	this.getDefaultFootholdStyle = function(title) {
		var footholdStyle = {
			pointRadius : 4,
			graphicName : "circle",
			fillColor : "#0000FF",
			fillOpacity : 1,
			strokeWidth : 3,
			strokeOpacity : 1,
			strokeColor : "#0000FF",
			fontFamily : "Verdana,Arial,Helvetica,sans-serif",
			fontWeight : "normal",
			fontColor:"#0000FF",
			label : title,
			labelXOffset : 0,
			labelYOffset : 30
		};
		return footholdStyle;
	}
};

/**
 * Class: HGIS.Biz.MultiCircleBuffer
 * 生成多级圆缓冲的类。
 */
HGIS.Biz=HGIS.Biz||{};
HGIS.Biz.MultiCircleBuffer = function() {
	var thisObj = this;
	thisObj.encirclementNum=0;// 缓冲圆个数
	thisObj.center=null;// 缓冲圆的中心点,HGIS.Geometry.Point
	thisObj.radiusArr=[];// 所有缓冲圆半径的数组，半径按从小到大排序
	thisObj.circleArr=[];// {Array|HGIS.Geometry.LinearRing}
	thisObj.bigCircleArr=null;
	/**
	 * APIMethod: setAllRadius
	 * 设置缓冲圆的所有缓冲半径.
	 * 
	 * Parameters:
	 * radiusArr - {Array} 各个缓冲圆半径数组，参数顺序不影响缓冲圆顺序，但参数个数决定了缓冲圆的个数。
	 */
	thisObj.setAllRadius = function(radiusArr) {
		thisObj.encirclementNum = radiusArr.length;
		function sortNumber(a, b) {
			return a - b;
		}
		thisObj.radiusArr = radiusArr.sort(sortNumber);
	};
	
	/**
	 * APIMethod: setCenter
	 * 设置缓冲圆的中心点
	 * 
	 * Parameters:
	 * point - {<HGIS.Geometry.Point>} 缓冲圆的中心点坐标
	 * 
	 */
	this.setCenter = function(point) {
		if (point.CLASS_NAME = "HGIS.Geometry.Point") {
			thisObj.center = point;
		} else {
			alert( HGIS.language[HGIS.InitParam.language]["center_data_err"] );	//"中心点数据类型错误"
		}
	};

	/**
	 * APIMethod: createCircleBuffers 
	 * 生成圆缓冲区并返回缓冲圆数组.
	 * 
	 * Parameters:
	 *  creatCircleMethod - {String} 生成缓冲圆的方法标识，目前支持两种;similar代表使用常规生产圆方法，equality代表在地理坐标系下使用等距离原则生成圆和圆环；不填默认为常规生成圆方法
	 * 
	 * Returns:
	 * {Array(<HGIS.Geometry.Polygon>)} 返回生成的缓冲圆数组。
	 */
	this.createCircleBuffers = function(creatCircleMethod) {
		// 获取中心点
		if (!thisObj.center) {
			alert( HGIS.language[HGIS.InitParam.language]["center_noExist"] );	//"中心点不存在" 
			return;
		}
		// 遍历半径数组，创建N个圆,返回之
		thisObj.circleArr = new Array();
		thisObj.bigCircleArr= new Array();
        if(creatCircleMethod === undefined || creatCircleMethod !== "equality" ){  // 没定义或者为不等于 equality 取常规生成圆的方式 
        	for (var i = 0;i < thisObj.radiusArr.length;i++) {
    			if(i==0){
    				var circle = HGIS.Utils.createCircle(thisObj.center, thisObj.radiusArr[i]);
    				thisObj.circleArr.push(circle);
    				thisObj.bigCircleArr.push(circle);
    			}else{
    				var circle = HGIS.Utils.createCircleRing(thisObj.center, thisObj.radiusArr[i-1],thisObj.radiusArr[i]);
    				thisObj.circleArr.push(circle);
    				var bigcircle = HGIS.Utils.createCircle(thisObj.center,thisObj.radiusArr[i]);
    				thisObj.bigCircleArr.push(bigcircle);
    			}
    		}
        }else{
        	for (var i = 0;i < thisObj.radiusArr.length;i++) {
    			if(i==0){
    				var circle = HGIS.Utils.createCircleByEquidistance(thisObj.center, thisObj.radiusArr[i]);
    				thisObj.circleArr.push(circle);
    				thisObj.bigCircleArr.push(circle);
    			}else{
    				var circle = HGIS.Utils.createCircleRingByEquidistance(thisObj.center, thisObj.radiusArr[i-1],thisObj.radiusArr[i]);
    				thisObj.circleArr.push(circle);
    				var bigcircle = HGIS.Utils.createCircleByEquidistance(thisObj.center,thisObj.radiusArr[i]);
    				thisObj.bigCircleArr.push(bigcircle);
    			}
    			
    		}
        }
		return thisObj.circleArr;
	};
	
	/**
	 * APIMethod: getMaxCircle
	 * 获取最大的缓冲圆
	 * 
	 * Returns:
	 * maxCircle - {Object} json对象，最大的缓冲圆信息，包含三个有效信息.
	 *         1.geometry: 缓冲圆的geometry对象.
	 *         2.radius:最大缓冲圆的半径.
	 *         3.center:最大缓冲圆的中心点.
	 * 
	 */
	thisObj.getMaxCircle = function() {
		if (thisObj.encirclementNum > 0) {
			var maxCircle = {
				"geometry" : thisObj.bigCircleArr[thisObj.encirclementNum - 1],// 最大缓冲圆的geometry对象
				"radius" : thisObj.radiusArr[thisObj.encirclementNum - 1],// 最大缓冲圆的半径
				"center" : thisObj.center// 最大缓冲圆的中心点			
			};
			return maxCircle;
		} else {
			return null;
		}
	};

	/**
	 * APIMethod: getMinCircle
	 * 获取最小的包围圈
	 * 
	 * Returns:
	 * minCircle - {Object} json对象，最小的缓冲圆信息，包含三个有效信息.
	 *         1 geometry: 最小缓冲圆的geometry对象.
	 *         2 radius:最小缓冲圆的半径.
	 *         3 center:最小缓冲圆的中心点.
	 * 
	 */
	thisObj.getMinCircle = function() {
		if (thisObj.encirclementNum > 0) {
			var minCircle = {
				"geometry" : thisObj.bigCircleArr[0],// 最小缓冲圆的geometry对象
				"radius" : thisObj.radiusArr[0],// 最小缓冲圆的半径
				"center" : thisObj.center// 最小缓冲圆的中心点
			};
			return minCircle;
		} else {
			return null;
		}
	};

	/**
	 * APIMethod: getCircleByN
	 * 获取第n道缓冲圆,参数n为整数，如果小于0或超过了圆的个数，则返回null.
	 * 
	 * Parameters:
	 * n - {Number} 第n道圆的索引，从0开始.
	 * 
	 * Returns:
	 *  nCircle - {Object} 第n道圆的信息，包含三个有效信息.
	 *         1 geometry: 第n道圆的geometry对象.
	 *         2 radius:第n道圆的半径.
	 *         3 center:第n道圆的中心点.
	 */
	thisObj.getCircleByN = function(n) {
		if (n < 0 ||n > thisObj.encirclementNum||thisObj.circleArr.length < 0) {
			return null;
		}
		var nCircle = {
			"geometry" : thisObj.circleArr[n - 1],// 第n道圆的geometry对象
			"radius" : thisObj.radiusArr[n - 1],// 第n道圆的半径
			"center" : thisObj.center	// 第n道圆的中心点	
		};
		return nCircle;

	};
};/**
 * HGIS.Biz.ThreeEncirclement
 * 这个文件用于生成三大包围圈.(本接口保留，文档中不对外暴露)
 */
HGIS.Biz=HGIS.Biz||{};
HGIS.Biz.ThreeEncirclement = function() {
	var thisObj = this;
	thisObj.encirclementNum;// 包围圈个数
	thisObj.center;// 三大包围圈的中心点,HGIS.Geometry.Point
	thisObj.radiusArr;// 所有包围圈半径的数组，半径按从小到大排序
	thisObj.circleArr;// {Array|HGIS.Geometry.LinearRing}
	thisObj.bigCircleArr;
	/**
	 * Method: setAllRadius
	 * 设置各包围圈的半径.
	 * 
	 * Parameters:
	 * radiusArr - {Array} 各大包围圈半径数组，参数顺序不影响包围圈顺序，但参数个数决定了包围圈的个数
	 */
	thisObj.setAllRadius = function(radiusArr) {
		thisObj.encirclementNum = radiusArr.length;
		function sortNumber(a, b) {
			return a - b;
		}
		thisObj.radiusArr = radiusArr.sort(sortNumber);
	};
	
	/**
	 * Method: setCenter
	 * 设置包围圈中心点
	 * 
	 * Parameters:
	 * point - {<HGIS.Geometry.Point>} 包围圈中心点
	 * 
	 * Returns:
	 * Array,包含了多个圆的数组.
	 */
	this.setCenter = function(point) {
		if (point.CLASS_NAME = "HGIS.Geometry.Point") {
			thisObj.center = point;
		} else {
			alert( HGIS.language[HGIS.InitParam.language]["center_data_err"] );	//"中心点数据类型错误"
		}
	};

	/**
	 * Method: createEncirclements 
	 * 生成圆缓冲区并返回缓冲圆数组.
	 * 
	 * Parameters:
	 *  creatCircleMethod - {String} 生成缓冲圆的方法标识，目前支持两种;similar代表使用常规生产圆方法，equality代表在地理坐标系下使用等距离原则生成圆和圆环；不填默认为常规生成圆方法
	 * 
	 * Returns:
	 * {Array(<HGIS.Geometry.Polygon>)} 返回生成的缓冲圆数组。
	 */
	this.createEncirclements = function(creatCircleMethod) {
		// 获取中心点
		if (!thisObj.center) {
			alert( HGIS.language[HGIS.InitParam.language]["center_noExist"] );	//"中心点不存在" 
			return;
		}
		// 遍历半径数组，创建N个圆,返回之
		thisObj.circleArr = new Array();
		thisObj.bigCircleArr= new Array();
        if(creatCircleMethod === undefined || creatCircleMethod === "similar" ){
        	for (var i = 0;i < thisObj.radiusArr.length;i++) {
    			if(i==0){
    				var circle = HGIS.Utils.createCircle(thisObj.center, thisObj.radiusArr[i]);
    				thisObj.circleArr.push(circle);
    				thisObj.bigCircleArr.push(circle);
    			}else{
    				var circle = HGIS.Utils.createCircleRing(thisObj.center, thisObj.radiusArr[i-1],thisObj.radiusArr[i]);
    				thisObj.circleArr.push(circle);
    				var bigcircle = HGIS.Utils.createCircle(thisObj.center,thisObj.radiusArr[i]);
    				thisObj.bigCircleArr.push(bigcircle);
    			}
    		}
        }else{
        	for (var i = 0;i < thisObj.radiusArr.length;i++) {
    			if(i==0){
    				var circle = HGIS.Utils.createCircleByEquidistance(thisObj.center, thisObj.radiusArr[i]);
    				thisObj.circleArr.push(circle);
    				thisObj.bigCircleArr.push(circle);
    			}else{
    				var circle = HGIS.Utils.createCircleRingByEquidistance(thisObj.center, thisObj.radiusArr[i-1],thisObj.radiusArr[i]);
    				thisObj.circleArr.push(circle);
    				var bigcircle = HGIS.Utils.createCircleByEquidistance(thisObj.center,thisObj.radiusArr[i]);
    				thisObj.bigCircleArr.push(bigcircle);
    			}
    			
    		}
        }
		return thisObj.circleArr;
	};
	
	/**
	 * Method: getMaxEncircle
	 * 获取最大的包围圈
	 * 
	 * Returns:
	 * maxCircle - {Object} json对象，最大的包围圈信息，包含三个有效信息.
	 *         1.geometry: 包围圈的geometry对象.
	 *         2.radius:最大包围圈的半径.
	 *         3.center:最大包围圈的中心点.
	 * 
	 */
	thisObj.getMaxEncircle = function() {
		if (thisObj.encirclementNum > 0) {
			var maxCircle = {
				"geometry" : thisObj.bigCircleArr[thisObj.encirclementNum - 1],// 包围圈的geometry对象
				"radius" : thisObj.radiusArr[thisObj.encirclementNum - 1],// 最大包围圈的半径
				"center" : thisObj.center
			// 最大包围圈的中心点
			};
			return maxCircle;
		} else {
			return null;
		}
	};

	/**
	 * Method: getMinCircle
	 * 获取最小的包围圈
	 * 
	 * Returns:
	 * minCircle - {Object} json对象，最小的包围圈信息，包含三个有效信息.
	 *         1 geometry: 最小包围圈的geometry对象.
	 *         2 radius:最小包围圈的半径.
	 *         3 center:最小包围圈的中心点.
	 * 
	 */
	thisObj.getMinCircle = function() {
		if (thisObj.encirclementNum > 0) {
			var minCircle = {
				"geometry" : thisObj.bigCircleArr[0],// 最小包围圈的geometry对象
				"radius" : thisObj.radiusArr[0],// 最小包围圈的半径
				"center" : thisObj.center
			// 最小包围圈的中心点
			};
			return minCircle;
		} else {
			return null;
		}
	};

	/**
	 * Method: getNEncirclement
	 * 获取第N道包围圈,参数N为整数，如果小于0则取最小的包围圈，如果超过了包围圈的个数，则返回最大的包围圈.
	 * 
	 * Parameters:
	 * n - {Number} 第N道包围圈索引.
	 * 
	 * Returns:
	 *  nCircle - {Object} 最小的包围圈信息，包含三个有效信息.
	 *         1 geometry: 第N道包围圈的geometry对象.
	 *         2 radius:第N道包围圈的半径.
	 *         3 center:第N道包围圈的中心点.
	 */
	thisObj.getNEncirclement = function(n) {
		if (n < 0) {
			num = 0;
		} else if (n > thisObj.encirclementNum) {
			n = thisObj.encirclementNum;
		}
		if (thisObj.circleArr.length < 0) {
			alert( HGIS.language[HGIS.InitParam.language]["Encirclement_noFound"] );	//"没有发现包围圈" 
			return;
		}

		var nCircle = {
			"geometry" : thisObj.circleArr[n - 1],// 第N道包围圈的geometry对象
			"radius" : thisObj.radiusArr[n - 1],// 第N道包围圈的半径
			"center" : thisObj.center
		// 第N道包围圈的中心点
		};
		return nCircle;

	};
};HGIS.Cluster = HGIS.Cluster || {};// 聚合对象
/**
 * Class: HGIS.Cluster.Cluster
 * 
 * 聚合类。这个类适用于小规模点状地物（暂定不大于5000个）的情况下，在浏览器端对地物点进行聚合展示。并预留了反聚合方法.
 * 从地理计算角度讲，浏览器的负担加重了，但由于聚合后矢量对象的减少，浏览器整体速度得到了提升.
 * 
 * Parameters:
 * vectorlayer - {HGIS.Layer.Vector} 图层对象，构造聚合对象前，请确保该图层已经添加到地图上.
 * vectors - {Array} 数组。这个数组里面存放HGIS.Feature.Vector地物要素对象.
 * options - {JSON Object} 聚合类的选项.
 *     -   -   可用的选项如下：
 *     -   -   1 startLevel, 聚合起始地图比例级别。若为空值，则聚合将从地图配置最小级别开始，此参数应为在地图显示比例级别范围内的正整数。
 *     -   -   2 endLevel, 聚合结束地图比例级别。若为空值，则聚合将从地图最大级别结束，此参数应为在地图显示比例级别范围内的正整数。
 *     -   -   3 cluterStyle, 聚合点样式。
 *     -   -   4 separateStyle, 单点样式
 *     -   -   5 clusterSize, 聚合比例因子，正整数,默认150。
 *     -   -   6 isInverseCluster, 对于每一聚合点，是否需要反聚合功能。true表示可以反聚合，false表示不反聚合
 *     -   -   7 inverseCenterStyle， 离散模式下中心点样式 clusterRootStyle,聚合点的根样式
 *     -   -   8 isCenter {Boolean}, 聚合点图标显示位置是否在聚合网格内的点对象组成的MultiPoint的质心位置，默认为false，非质心位置
 *     -   -   9 isShowGrid {Boolean}, 是否显示加载聚合网格
 *            
 * 示例:
 * (code)
 * var c=new HGIS.Cluster.Cluster(vectorlayer,vectorArr,options);
 * (end)
 */
HGIS.Cluster.Cluster = function(vectorlayer, vectorArr, options) {
	var thisObj = this;
	thisObj.map = vectorlayer.map;// 地图对象。如果聚散效果存在，那么这个地图对象一定可以从Cluster里获取

	thisObj.clusterSize = !isNaN(options.clusterSize) ? options.clusterSize : 150;
	thisObj.clusterRootStyle = options.clusterRootStyle ? options.clusterRootStyle : clusterRootStyle = {
		externalGraphic : APIAdress + "gisapi/theme/img/jh1.png",
		graphicWidth : 53,
		graphicHeight : 51
	};
	// 离散模式下的连线样式
	thisObj.lineStyle = options.lineStyle ? options.lineStyle : {
		strokeDashstyle : "dot"
	};
	// 离散中心点样式
	thisObj.inverseCenterStyle = options.inverseCenterStyle ? options.inverseCenterStyle : {
		externalGraphic : APIAdress+"/gisapi/theme/img/inverseClusterCenter.gif",
		graphicWidth : 20,
		graphicHeight : 20
	};
	//聚合点是否显示在网格内聚合点所形成图形的质心位置
	thisObj.isCenter = options.isCenter ? options.isCenter :false; 
	//聚合时是否显示聚合网格
	thisObj.isShowGrid = options.isShowGrid ? true : false;
	//设定地图 聚合的起始级别  ，反聚合未进行计算
	thisObj.startLevel = (options.startLevel > 0) ?options.startLevel : HGIS.InitParam.minLevel;
	thisObj.endLevel = (options.endLevel > 0) ? options.endLevel : HGIS.InitParam.maxLevel; 
	
	/**
	 * APIMethod: excute
	 * 执行聚合任务
	 */
	this.excute = function() {
		//首先删除所有要素
		if (vectorlayer != null && vectorlayer.CLASS_NAME == "HGIS.Layer.Vector") {
			vectorlayer.destroyFeatures();
			vectorlayer.removeAllFeatures();
		}
		//判断是否在是否在起止聚合级别之外
		if(thisObj.map.getZoom()<thisObj.startLevel || thisObj.map.getZoom() > thisObj.endLevel || thisObj.endLevel <=0 || thisObj.startLevel <0  ){
			return ;
		}
		var mapDivSize = thisObj.map.getSize();
		var bounds = thisObj.map.getExtent();//vectorlayer.getExtent();// thisObj.map.getExtent();//
		// 当前地图视窗经纬度范围
		var wResolution = (bounds.right - bounds.left) / mapDivSize.w;// 横向分辩率
		var hResolution = (bounds.top - bounds.bottom) / mapDivSize.h;// 纵向分辩率
		var clusterGridWidth = thisObj.clusterSize * wResolution;
		var clusterGridHeight = thisObj.clusterSize * hResolution;
		
		// 起止列
		var startCol = Math.floor(bounds.left / clusterGridWidth);
		var endCol = Math.ceil(bounds.right / clusterGridWidth);
		// 起止行
		var startRow = Math.floor(bounds.bottom / clusterGridHeight);
		var endRow = Math.ceil(bounds.top / clusterGridHeight);
		// 聚合网格进行加载
		if(thisObj.isShowGrid == true ){
			//计算一个网格所占的经纬度
			var startColGrid =  startCol*clusterGridWidth;
			var endColGrid = endCol *clusterGridWidth;
			var startRowGrid = startRow *clusterGridHeight;
			var endRowGrid = endRow*clusterGridHeight;
			var data = new Array();
			//将地图按行列号进行划分，然后计算出在边界上的起始点位置，然后生成线lineString
			for(var i =startCol; i< endCol ; i++){
				var x =  clusterGridWidth*i;
				var p1 = new HGIS.Geometry.Point(x ,startRowGrid);
				var p2 = new HGIS.Geometry.Point(x ,endRowGrid);
				var line = new HGIS.Geometry.LineString([p1,p2]);
				data.push(line);
			}
			for(var j = startRow ;j < endRow ;j++){
				var y =  clusterGridHeight*j;
				var p3 = new HGIS.Geometry.Point(startColGrid  ,y);
				var p4 = new HGIS.Geometry.Point(endColGrid ,y);
				var line = new HGIS.Geometry.LineString([p3,p4]);
				data.push(line); 
			}
			var multi = new HGIS.Geometry.MultiLineString(data);
			var vector = new HGIS.Feature.Vector(multi);
			vectorlayer.addFeatures([vector]);
		}
		
		var gridsData = {};
		// 对于vectors中的每一个矢量要素进行并网计算。gridsData这个json对象里放了众多data
		for ( var i = 0; i < vectorArr.length; i = i + 1) {
			var geometry = vectorArr[i].geometry;
			var col = Math.floor(geometry.x / clusterGridWidth);
			var row = Math.floor(geometry.y / clusterGridHeight);
			// 保证在可视范围内进行聚合，可以在不影响视觉的情况下，缩减参与聚合的数据量
			if (col >= startCol && col <= endCol && row >= startRow && row <= endRow) {
				var key = col + "-" + row;
				if (!gridsData[key]) {
					gridsData[key] = [];
				}
				gridsData[key].push(geometry);
			}
		}

		// 对于 每一个网格的所有features地物要素。如果只有一个feature，那么直接打到地图上，如果多个，则给出数量;//
		// 聚合层次，首次点开为第1级。依次类推，每点开一次，聚合级别加1。对于顶级节点，其父节点为空
		var firstClusterVectors = new Array();// 首次 聚合后的矢量要素
		for ( var key in gridsData) {
			var gridData = gridsData[key];// 这里取出的是一个数组，数组里确定最少有一个feature
			if (gridData.length == 1) {
				var style = (options.separateStyle) ? options.separateStyle : null;
				var attrs = {
					"num" : 1,
					"clusterLevel" : 1,//表示反聚合的基数，没反聚合时基数为1，第一次反聚合为2，依次类推
					"ownkey" : key,
					"fatherkey":null,
					"type":"singleEntity"
				};
				var vector = new HGIS.Feature.Vector(gridData[0], attrs, style);
				firstClusterVectors.push(vector);
			} else {
				//这种情况是需要在当前网格进行聚合的， 添加一些特征，为后续的反聚合铺路
				var attributes = {
					"num" : gridData.length.toString(),// 聚合点所包含地理要数的数量
					"geomCollection" : gridData,// 该网格中所有的聚合点要素
					"expand" : false,// 该聚合点是否被展开过，没进行反聚合前，这些点都是没有展开过的
					"clusterLevel" : 1,//反聚合次数，初始化为1
					"ownkey" : key,
					"fatherkey":null,
					"type":"clusterEntity"
				};
				// 设置根聚合点样式
				var style = JSON.parse(JSON.stringify(thisObj.clusterRootStyle)); 
				style.label = gridData.length.toString();
				var vector;
				if( thisObj.isCenter ){
					var center = new HGIS.Geometry.MultiPoint(gridData).getCentroid(true);
					vector = new HGIS.Feature.Vector(center, attributes, style);
				}else{
					vector = new HGIS.Feature.Vector(gridData[0], attributes, style);
				}
				firstClusterVectors.push(vector);
			}
		}
		//把聚合好的地理要素添加到地图上
		vectorlayer.addFeatures(firstClusterVectors);
	};

	/**
	 * APIMethod: activeInverseCluster
	 * 激活反聚合效果
	 */
	this.activeInverseCluster = function() {
		// 聚合点选择控件
		var selectCluster = new HGIS.Control.SelectFeature(vectorlayer, {
			clickout : false,
			toggle : false,
			multiple : false,
			hover : false,
			toggleKey : "ctrlKey", // ctrl key removes from selection
			box : false,
			clickFeature : function(feature) {
				//确保此feature不是线状地图时才能点击
				//var objClass=feature.
				if(feature.geometry.CLASS_NAME!="HGIS.Geometry.Point"){
					return;
				}
				thisObj.inverseCluster(feature);// 散开聚合点
		}
		});
		thisObj.map.addControl(selectCluster);
		selectCluster.activate();
	};

	/**
	 * APIMethod: inverseCluster
	 * 对于每个聚合点，单击触发反聚合。直到反聚合到一个
	 * 
	 * Parameters:
	 * feature - {<HGIS.Feature>} 要反聚合的要素
	 */
	this.inverseCluster = function(feature) {
		// 如果gridData中的数据大于1，才有机会进行反聚合。否则不处理
		if (feature.attributes.num * 1 > 1) {
			var mapDivSize = thisObj.map.getSize();// 当前地图窗口大小
			var bounds = thisObj.map.getExtent();// 当前地图视窗经纬度范围
			var wResolution = (bounds.right - bounds.left) / mapDivSize.w;// 横向分辩率
			var hResolution = (bounds.top - bounds.bottom) / mapDivSize.h;// 纵向分辩率
			var thisGridFeatures = feature.attributes.geomCollection;
			// 对gridBound进行重新划网。划网比因子降为nextClusterLevel。
			//该聚合点的元素是否已展开。如果未展开，点击时就把它展开
			if (feature.attributes.expand == false) {
				var clusterSize = Math.ceil(thisObj.clusterSize / (feature.attributes.clusterLevel + 1));
				var clusterGridWidth = clusterSize * wResolution, clusterGridHeight = clusterSize * hResolution;
				var childData = {};
				for ( var i = 0; i < thisGridFeatures.length; i = i + 1) {
					var geom = thisGridFeatures[i];
					var col = Math.floor(geom.x / clusterGridWidth), row = Math.floor(geom.y / clusterGridHeight);
					// 此时不再考虑是否为在当前地图视窗范围
					var key = col + "-" + row;
					if (!childData[key]) {
						childData[key] = [];
					}
					childData[key].push(geom);
				}
				//展开聚合点
				thisObj.expandCluster(feature,childData)
			} else {
				thisObj.closeCluster(feature);
			}
			//删除点击的feature
			vectorlayer.removeFeatures([feature])
			if(feature){
				// 销毁这个临时点
				feature.destroy();
			}
			vectorlayer.refresh();
		}
	};
	/**关闭聚合点
	 * 
	 */
	thisObj.closeCluster=function(_feature){
		var feature=_feature;
		// 遍历所有features,根据聚合属性值的比较来做收缩动作:收单点，聚合点，连接线
		var removedFeatures=new Array();
		for(var c=0;c<vectorlayer.features.length;c++){
			var featureN=vectorlayer.features[c];
			
			if(featureN.attributes){
				if(featureN.attributes.ownkey&&featureN.attributes.ownkey.indexOf(_feature.attributes.ownkey)!=-1){
					removedFeatures.push(featureN);
		    	}
				 if(featureN.attributes.type=="joinedLine"){//删除连接线
			    	//本级连接线与上级连接线
			    	if(featureN.attributes.fatherkey == _feature.attributes.ownkey||featureN.attributes.ownkey == _feature.attributes.ownkey){
			    		removedFeatures.push(featureN);
			    	}
			    }
			}
		}
		//删除符合条件的要素
		vectorlayer.removeFeatures(removedFeatures);

		// 恢复原聚合点的图标及属性
		var geome = feature.attributes.oldCenter;
		//上级节点
		var arr = feature.attributes.ownkey.split(",");
		var lastFeatureKey = arr.slice(0, arr.length - 1).join(",");
		var attributes = {
			"num" : feature.attributes.num,// 聚合点的数量
			"geomCollection" : feature.attributes.geomCollection,// 该网格中所有的聚合要点要素
			"expand" : false,// 该聚合点是收回后要关闭
			"clusterLevel" : feature.attributes.clusterLevel,//聚合级别要减少一级
			"ownkey" : feature.attributes.ownkey,//唯一标识恢复
			"type":"clusterEntity",
			"fatherkey":lastFeatureKey
		};
		
		// 设置聚合点样式
		if (options.cluterStyle) {
			style = options.cluterStyle;
		} else {
			var img;
			if (feature.attributes.clusterLevel > 1) {
				img = APIAdress+"gisapi/theme/img/jh1.png";
			} else {
				img =APIAdress+ "gisapi/theme/img/jh1.png";
			}
			style = {
				externalGraphic : img,
				graphicWidth : 53,
				graphicHeight : 51,
				label : feature.attributes.num.toString()
			};
		}
		var vector = new HGIS.Feature.Vector(geome, attributes, style);
		vectorlayer.addFeatures([vector]);

		// 如果不是根节点的话，那么要 恢复原来的聚合点与上级聚合点之间的连线
		if (feature.attributes.clusterLevel > 1) {
			var lastFeatures = vectorlayer.getFeaturesByAttribute("ownkey", lastFeatureKey);
			//判断必须是聚合点，根据type
			var clusterCenter=null;
			for(var m=0;m<lastFeatures.length;m++){
				if(lastFeatures[m].attributes.type=="clusterCenter"){
					clusterCenter=lastFeatures[m].geometry;
				}
			}
			if(clusterCenter==null){
				return
			}
			var lineString = new HGIS.Geometry.LineString([geome, clusterCenter]);// 连接线
			var attrs = {
					"clusterLevel" : feature.attributes.clusterLevel + 1,
					"ownkey" :feature.attributes.ownkey,
					"type":"joinedLine",
					"fatherkey": lastFeatureKey
				};
			var lineVector = new HGIS.Feature.Vector(lineString, attrs, thisObj.lineStyle);
			vectorlayer.addFeatures(lineVector);
		}
	}
	
	/** 展开聚合点
	 * 
	 */
	thisObj.expandCluster=function(feature,childData){

		// 对于 每一个网格的所有features地物要素。如果只有一个feature，那么直接打到地图上，如果多个，则给出数量
		var clusteredVectors = [];// 散点重新聚合后的矢量要素
		for ( var key in childData) {
			var childKey = feature.attributes.ownkey + "," + key;
			var childGeometrys = childData[key];// 这里取出的是一个数组，数组里确定最少有一个feature
			var vector, geom, style, attrs;// 散点或聚合点样式
			if (childGeometrys.length == 1) {// 一个几何体，就打一个对象
				style = (options.separateStyle) ? options.separateStyle : null;
				attrs = {
					"num" : 1,
					"clusterLevel" : feature.attributes.clusterLevel + 1,
					"ownkey" : childKey,
					"type":"singleEntity",
					"fatherkey":feature.attributes.ownkey
				};
				vector = new HGIS.Feature.Vector(childGeometrys[0], attrs, style);
				clusteredVectors.push(vector);
			} else {// 设置聚合点相关属性
				attrs = {
					"num" : childGeometrys.length.toString(),
					"geomCollection" : childGeometrys,
					"expand" : false,//
					"clusterLevel" : feature.attributes.clusterLevel + 1,
					"ownkey" : childKey,
					"type":"clusterEntity",
					"fatherkey":feature.attributes.ownkey
				};
				// 设置聚合点样式
				var style=null;
				if (options.cluterStyle) {
					style = options.cluterStyle;
				} else {
					style = {
						externalGraphic : APIAdress+"gisapi/theme/img/jh1.png",
						graphicWidth : 53,
						graphicHeight : 51,
						label : attrs.num.toString()
					};
				}
				vector = new HGIS.Feature.Vector(childGeometrys[1], attrs, style);
				clusteredVectors.push(vector);
			}
		}
		// 聚合后的新点添加到地图上
		vectorlayer.addFeatures(clusteredVectors); 
		//添加聚合点
		var expandCenter=thisObj.addInverseCenter(feature,clusteredVectors)
		// 聚合后中心点与这些散开后点进行连线
		thisObj.setClusterLine(feature, clusteredVectors,expandCenter);
	
		
	}

	/**
	 * Method: setClusterLine
	 * 生成新的离散中心和它与新聚合点的连线
	 * 
	 * Parameters:
	 * feature - {<HGIS.Feature>} 要反聚合的要素.
	 * clusteredVectors - {Array} 聚合的要素数组
	 * 
	 * Returns:
	 * 以聚合中心散开的点集合
	 */
	this.setClusterLine = function(feature, clusteredVectors,expandCenter) {
		// 在地图上添加扩散中心到各点的连线
		var lineArr = new Array();
		var featureKeyArr = feature.attributes.ownkey.split(",");
		//上级节点。线与点
		var lastFeatureKey = featureKeyArr.slice(0, featureKeyArr.length - 1).join(",");
		for ( var i = 0; i < clusteredVectors.length; i = i + 1) {
			var endPoint = clusteredVectors[i].geometry;// 边点
			var lineString = new HGIS.Geometry.LineString([expandCenter, endPoint]);// 连接线
			var attrs = {
				"clusterLevel" : feature.attributes.clusterLevel + 1,
				"ownkey" :clusteredVectors[i].attributes.ownkey ,
				"type":"joinedLine",
				"fatherkey": feature.attributes.ownkey
			};
			var lineVector = new HGIS.Feature.Vector(lineString, attrs, thisObj.lineStyle);
			lineArr.push(lineVector);
		}
		vectorlayer.addFeatures(lineArr);
		// 修正扩散中心与上级中心的连线。若扩散中心不是起始点，那么有两个与线相关的问题需要处理。一个是生成扩散中心到下级节点新连线。另一个是要删除扩散中心到上级节点之间的旧连线。
		if (feature.attributes.clusterLevel > 1) {
			//添加上级线，获取连接到父节点、且为线的要素，删除之
			var lines=vectorlayer.getFeaturesByAttribute("type","joinedLine");
			for(var k=0;k<lines.length;k++){
				if(lines[k].attributes.fatherkey==lastFeatureKey&&lines[k].attributes.ownkey==feature.attributes.ownkey){
					vectorlayer.removeFeatures([lines[k]]);
				}
			}
			//增加新的连接线：首先获取属性ownkey为lastFeatureKey点要素，根据网格聚合原理，只有一个
			var clusterCenters=vectorlayer.getFeaturesByAttribute("type","clusterCenter");
			for(var j=0;j<clusterCenters.length;j++){
				if(clusterCenters[j].attributes.ownkey==lastFeatureKey&&clusterCenters[j].attributes.expand==true){
					// 生成离散中心到上级节点新连线。那么这条连线的属性应与feature或离散中心的属性保持一致
					var lineString = new HGIS.Geometry.LineString([expandCenter, clusterCenters[j].geometry]);// 连接线
					var newLineAttr = {
						"clusterLevel" : feature.attributes.clusterLevel,
						"ownkey" : feature.attributes.ownkey,
						"type":"joinedLine",
						"fatherkey":lastFeatureKey
					};
					//添加新线
					var lineVector = new HGIS.Feature.Vector(lineString, newLineAttr, thisObj.lineStyle);
					vectorlayer.addFeatures(lineVector);
				}
			}
		}
	};

	/**
	 * APIMethod: addInverseCenter
	 * 添加聚合点的散开中心，也是众点质心，虚拟的中心，散则成形，聚则消失。
	 * 
	 * Parameters:
	 * expandCenter - {<HGIS.Geometry.Point>}
	 * feature - {<HGIS.Feature>} 
	 */
	this.addInverseCenter = function(feature,clusteredVectors) {
		// 计算离散中心点,并将扩散中心添加到地图上
		var lon = 0, lat = 0;
		for ( var j = 0; j < clusteredVectors.length; j = j + 1) {
			lon = lon + clusteredVectors[j].geometry.x;
			lat = lat + clusteredVectors[j].geometry.y;
		}
		var centerLon = lon / clusteredVectors.length;
		var centerLat = lat / clusteredVectors.length;
		//扩散开来后的中心点expandCenter
		var expandCenter = new HGIS.Geometry.Point(centerLon, centerLat);
		// 设置聚合点相关属性
		var attrs = {
			"num" : feature.attributes.geomCollection.length,
			"geomCollection" : feature.attributes.geomCollection,
			"expand" : true,
			"clusterLevel" : feature.attributes.clusterLevel,
			"oldCenter" : feature.geometry,
			"ownkey" : feature.attributes.ownkey,
			"type":"clusterCenter"
		};
		 
		var exchangeVector = new HGIS.Feature.Vector(expandCenter, attrs, thisObj.inverseCenterStyle);
		vectorlayer.addFeatures(exchangeVector);
		return exchangeVector.geometry;
	};

	/**
	 * APIMethod: reClusterFlag
	 * 地图状态变化时，给出是否要重新聚合的提示
	 * 
	 * Parameters:
	 * oldMapExt - {<HGIS.Bounds>} 前一地图范围
	 * newMapExt - {<HGIS.Bounds>} 新地图范围
	 * scale - {Number} 地图比例尺
	 */
	this.reClusterFlag = function(oldMapExt, newMapExt, scale) {
		var curMapExt = newMapExt ? newMapExt : vectorlayer.map.getExtent();
		var scale = isNaN(scale) ? scale : 0.2;
	};

	/**
	 * APIMethod: destory
	 * 销毁聚合对象
	 */
	this.destory = function() {
		// 地物要素从图层中清除
		vectorlayer.removeAllFeatures();
		// 图层从地图中清除
		thisObj.map.removeLayer(vectorlayer);
		thisObj = null;
	};
};
HGIS.Cluster = HGIS.Cluster || {};
/**
 * Class: HGIS.Cluster.GridHeatLayer
 * 
 * 网格热力图类。这个类适用于小规模点状地物的情况下，在浏览器端对地物点进行聚合，将聚合的内容通过网格颜色差异的方式展示出来.
 * 从地理计算角度讲，浏览器的负担加重了，但由于聚合后矢量对象的减少，浏览器整体速度得到了提升.
 * 
 * Parameters: vectorlayer - {HGIS.Layer.Vector} 图层对象，构造聚合对象前，请确保该图层已经添加到地图上.
 * Vector - {Array} 数组。这个数组里面存放HGIS.Feature.Vector地物要素对象. 
 * options - {JSON Object} 聚合类的选项.
 *     -   -   可用的选项如下：
 *     -   -   1 startLevel, {int} 网格热力图聚合起始地图级别。若为空值，则聚合将从地图配置最小级别开始，此参数应为在地图显示比例级别范围内的正整数。
 *     -   -   2 endLevel {int}  网格热力图聚合结束地图级别。若为空值，则聚合将从地图最大级别结束，此参数应为在地图显示比例级别范围内的正整数。
 *     -   -   3 gridSize {double} 热力图聚合网格大小。
 *     -   -   4 gradient {JSONObject} 热力图网格聚合色带
 *     -   -   5 style, {json} 热力图网格样式。
 *     -   -   6 displayLabel {bollean} 是否显示网格聚合数量标签    
 * 
 * 示例:
 * (code)
 * var gridHeatLayer = new HGIS.Cluster.GridHeatLayer(layer,dataArr,options);
 * (end)
 */
HGIS.Cluster.GridHeatLayer = function(layer, dataArr, options) {
	var thisObj = this;
	var hmap = layer.map;
	//网格热力图尺寸
	thisObj.gridSize = !isNaN(options.gridSize) ? options.gridSize : 100;
	
	thisObj.startLevel = options.startLevel ?options.startLevel : HGIS.InitParam.minLevel;
	thisObj.endLevel = options.endLevel? options.endLevel : HGIS.InitParam.maxLevel;
	var style ={
		fill : true,
		fillOpacity:0.4 ,	
		stroke : true ,
		strokeColor : 'red',
		strokeOpacity : 0.5
	};
	
	thisObj.style = options.style ? options.style : style ;
	//热力色带
	thisObj.gradient =  options.gradient || {"1": "rgb(0,0,255)", "2": "rgb(0,255,255)", "3": "rgb(0,255,0)", "4": "yellow", "5": "rgb(255,0,0)"}; 
	//是否显示网格热力图标签，默认为不显示
	thisObj.displayLabel = options.displayLabel == true ? true:false; 
	/**
	 * APIMethod: excute 
	 * 执行聚合任务
	 */
	this.mesher = function() {
		//判断是否在是否在起止聚合级别之外
		if(hmap.getZoom()<thisObj.startLevel || hmap.getZoom() > thisObj.endLevel || thisObj.endLevel <=0 || thisObj.startLevel <0  ){
			return ;
		}
		var mapDivSize = hmap.getSize(), bounds = hmap.getExtent();
		// 当前地图视窗经纬度范围
		var bounds = hmap.getExtent();
		var wResolution = (bounds.right - bounds.left) / mapDivSize.w;// 横向分辩率
		var hResolution = (bounds.top - bounds.bottom) / mapDivSize.h;// 纵向分辩率
		var clusterGridWidth = thisObj.gridSize * wResolution;
		var clusterGridHeight = thisObj.gridSize * hResolution;
		// 起止列
		var startCol = Math.floor(bounds.left / clusterGridWidth);
		var endCol = Math.floor(bounds.right / clusterGridWidth);
		// 起止行
		var startRow = Math.floor(bounds.bottom / clusterGridHeight);
		var endRow = Math.ceil(bounds.top / clusterGridHeight);
		// 网络集，每个格子都有一个值
		var gridsData = {};
		for (var i = 0; i < dataArr.length; i = i + 1) {
			var col = Math.floor(dataArr[i].geometry.x / clusterGridWidth);
			var row = Math.floor(dataArr[i].geometry.y / clusterGridHeight);
			// 保证在可视范围内进行聚合，可以在不影响视觉的情况下，缩减参与聚合的数据量
			if (col >= startCol && col <= endCol && row >= startRow
					&& row <= endRow) {
				var key = col + "-" + row;
				if (!gridsData[key]) {
					gridsData[key] = [];
				}
				gridsData[key].push(dataArr[i].geometry);
			}
		}
		// 将gridDat 中的length进行获取 存放于数组中，为下一步求取最大和最小值 进行权重值的计算
		var lengthArray =[];
		for ( var key in gridsData) {
			lengthArray.push(gridsData[key].length);
		}
		var maxLength = Math.max.apply(null, lengthArray);
		var minLength = Math.min.apply(null, lengthArray);
		var space = maxLength - minLength;
		// 遍历gridsData,画矩形
		var vectors = new Array();
		for ( var key in gridsData) {
			//这里进行业务判断，
			var gridData = gridsData[key];// 这里取出的是一个数组，数组里确定最少有一个feature
			var gridLength = gridData.length;
			if(gridLength<=0){
				return;
			}
			var vStyle = {};
			var j,filledColor;
			// 对 样式进行深度 克隆
			for( j in thisObj.style){
				vStyle[j] = thisObj.style[j] ;  
			}
			// 分段取值[0.2:red,0.4:green]
			if(space == 0 ){
				vStyle['fillColor'] = thisObj.gradient["1"];	
			}else if((gridLength-minLength)/space <= 0.25   ){
				vStyle['fillColor'] = thisObj.gradient["2"];
			}else if((gridLength-minLength)/space <= 0.5   ){
				vStyle['fillColor'] = thisObj.gradient["3"];
			}else if((gridLength-minLength)/space <= 0.75   ){
				vStyle['fillColor'] = thisObj.gradient["4"];
			}else if((gridLength-minLength)/space <= 1   ){
				vStyle['fillColor'] = thisObj.gradient["5"];
			}
			//设定热力网格的数字标签
			if(thisObj.displayLabel === true ){
				vStyle['label'] = gridLength.toString();
			}
			// 根据当前行列号计算起绘位置
			var col = key.split("-")[0], row = key.split("-")[1];
			// 计算当前网格四至，构建矩形
			var minX = col * thisObj.gridSize * wResolution;
			var maxX = minX + thisObj.gridSize * wResolution;
			var minY = row * thisObj.gridSize * hResolution;
			var maxY = minY + thisObj.gridSize * hResolution;
			var points = new Array();
			points.push(new HGIS.Geometry.Point(minX, minY));
			points.push(new HGIS.Geometry.Point(maxX, minY));
			points.push(new HGIS.Geometry.Point(maxX, maxY));
			points.push(new HGIS.Geometry.Point(minX, maxY));
			points.push(new HGIS.Geometry.Point(minX, minY));
			var linearRing = new HGIS.Geometry.LinearRing(points);
			var ployGeom = new HGIS.Geometry.Polygon([ linearRing ]);
			
			var ployVector = new HGIS.Feature.Vector(ployGeom, {}, vStyle);
			vectors.push(ployVector);
		}	
		layer.addFeatures(vectors);
	}
};

/**
 * Class: HGIS.Control.CopyRight
 * 版权说明控件类,在地图界面上加一个版权说明。
 */
HGIS.Control = HGIS.Control || {};
HGIS.Control.CopyRight = HGIS.Class(HGIS.Control, {
	element : null,
	copyRightText : "Copyright @2016 海康威视  All rights reserved.",
	color : "",
	left : "",
	right: "",
	bottom : "5px",
	width : "0px",
	height : "0px",
	/**
	 * Constructor: HGIS.Control.CopyRight
	 * 构造函数
	 * 
	 * Parameters:
	 * options: - {Object}  参数对象，可以设置以下参数：
	 *   - copyRightText：版权说明文字；
	 *   - color：颜色；
	 *   - left:靠左的距离>=0的整数；  如果left 和right都不设置的话就是横向居中。 left 和 right 同时设置以left为主
	 *   - right:靠右的距离>=0的整数;  如果left 和right都不设置的话就是横向居中。 left 和 right 同时设置以left为主
	 *   - bottom:靠底部的距离，默认5px；
	 *   - width:控件的宽度；
	 *   - height:控件的高度。
	 *   
	 *   示例:
	 *   (code)
	 *   var options={
	 *   	copyRightText:"Copyright @2016 海康威视  All rights reserved.",
	 *   	left:20,
	 *   	bottom:5,
	 *   	width:150,
	 *   	height:25
	 *   }
	 *   var control=new HGIS.Control.CopyRight(options);
	 *   (end)
	 */
	initialize : function(options) {
		HGIS.Control.prototype.initialize.apply(this, arguments);
		if (options.hasOwnProperty("copyRightText"))
			this.copyRightText = options.copyRightText;
		if (options.hasOwnProperty("color"))
			this.color = options.color;
		if (options.hasOwnProperty("left"))
			this.left = options.left;
		if (options.hasOwnProperty("right"))
			this.right = options.right;
		if (options.hasOwnProperty("bottom")){
			this.bottom = options.bottom;
		}else{
			this.bottom="5px";
		}
		if (options.hasOwnProperty("width"))
			this.width = options.width;
		if (options.hasOwnProperty("height"))
			this.height = options.height;
	},
	draw : function() {
		HGIS.Control.prototype.draw.apply(this, arguments);
		if (!this.element) {
			this.element = document.createElement("div");
			this.element.innerHTML = this.copyRightText;			
			
			if (this.color == "") {
				this.element.style.color = "#7b7777";
			} else {
				this.element.style.color = this.color;
			}
			if (this.width == "0px") {
				this.element.style.width = this.map.div.style.width;
			} else {
				this.element.style.width = this.width;
			}
			if (this.height == "0px") {
				this.element.style.height = 20 + "px";
			} else {
				this.element.style.height = this.height;
			}
			this.element.style.textAlign = "center";
			//设置纵向位置
			this.element.style.bottom = this.bottom;
			//设置横向位置
			if (this.left != "" || this.left === 0) {
				this.element.style.left = this.left;
			}else if(this.right != ""|| this.right === 0) {
				this.element.style.right = this.right;
			}else{
				this.element.style.left = "50%";
				this.element.style.marginLeft=-(this.width/2);
			}
			this.div.style.width="100%";
			this.div.style.height="100%";
			this.element.style.fontWeight = "bold";
			this.element.style.position = "absolute";			
		}
		return this.element;
	},

	/**
	 * APIMethod: destroy
	 * 控件的销毁方法。
	 */
	destroy : function() {
		// delete private elements here ...
		HGIS.Control.prototype.destroy.apply(this);
	},
	CLASS_NAME : "HGIS.Control.CopyRight"
});/**
 * Class: HGIS.Control.LayerSwitch
 * 矢量地图和影像地图切换的控件类。
 * 
 * 示例:
 * (code)
 * map.addControl(new HGIS.Control.LayerSwitch());
 * (end)
 */
HGIS.Control = HGIS.Control || {};
HGIS.Control.LayerSwitch = HGIS.Class(HGIS.Control, {
	element : null,
	_m:null,
	_firstShowMap:null,
	isLayerExist:null,
	initialize : function(options) {
		HGIS.Control.prototype.initialize.apply(this, arguments);
	},
	setMap:function(ob){
		this._m=ob;
	},
	setFrontMapShow:function(mapStr){
		this._firstShowMap = mapStr;
	},
	/**
	 * 获取当前类的上下文
	 */
	getThisClassContext: function(){
		var that = this;
		return that;
	},
	/**
	 * 判断当前加载的图层是否存在
	 */
	isLayerExist: function(){
		var imglayers=this._m.getLayersByName("img");
		var veclayers=this._m.getLayersByName("vec");
		var hvtlayers=this._m.getLayersByName("Vector");
		var tfwlayers=this._m.getLayersByName("tfw");
		var mixedlayers=this._m.getLayersByName("mixed");
		//判断图层是否存在
		var isLayerExist = {
				'hvtlayers': hvtlayers.length >0,
				'veclayers': veclayers.length>0&&veclayers[0].url !== "" && veclayers[0].url !== undefined,
				'imglayers': imglayers.length>0&&imglayers[0].url !== "" && imglayers[0].url !== undefined,
				'tfwlayers': tfwlayers.length>00&&tfwlayers[0].url !== "" && tfwlayers[0].url !== undefined,
				'mixedlayers': mixedlayers.length!==0&&mixedlayers[0].url !== "" && mixedlayers[0].url !== undefined,
		};
		return isLayerExist;
	},
	doSwitch:function(e){
		//保证用户不能连续的点击
		//document.getElementById("id_layerswitch").removeEventListener("click", this.doSwitch, false);
		//setTimeout(document.getElementById("id_layerswitch").addEventListener("click", this.doSwitch, false),3000);
		//如果当前是矢量则切换到影像
		var imglayers=this._m.getLayersByName("img");
		var veclayers=this._m.getLayersByName("vec");
		var hvtlayers=this._m.getLayersByName("Vector");
		var tfwlayers=this._m.getLayersByName("tfw");
		var mixedlayers=this._m.getLayersByName("mixed");
		
		//改组数据，方便处理,格式为: 数组>对象>数组
		var arrLayer =[
			{
				"layerName": 'img',	
				'layers': imglayers
			},{
				'layerName': 'vec',	
				'layers': veclayers
			},{
				'layerName': 'hvt',
				'layers': hvtlayers
			},{
				'layerName': 'tfw',
				'layers': tfwlayers
			},{
				'layerName': 'mix',	
				'layers': mixedlayers
			}];
		var imgId=this._m.id+"switch";
		var imgEle = document.getElementById(imgId);
		var _isLayerExist = this.isLayerExist();
		//第一次加载的是矢量地图
		if(imgEle.src.indexOf("gisapi/theme/image/img.png")>-1){
			//切换到影像
			for(j=0; j<arrLayer.length; j++){
				if(arrLayer[j].layerName=="img"){
					var tmpLayerOne = arrLayer[j].layers;
					for(k=0; k<tmpLayerOne.length; k++){
						if(k==0){
							this._m.setBaseLayer(tmpLayerOne[k]);
						}
						tmpLayerOne[k].setVisibility(true);
					}
				}else{
					var tmpLayerTwo = arrLayer[j].layers;
					for(m=0; m<tmpLayerTwo.length; m++){
						tmpLayerTwo[m].setVisibility(false);
					}
				}
			}
			 if(_isLayerExist.tfwlayers){
				//判断多图层中切换2.5d
				imgEle.src=APIAdress+"gisapi/theme/image/25.png";
			}else if( _isLayerExist.mixedlayers ){ 
				imgEle.src=APIAdress+"gisapi/theme/image/mix.png";
			}else if( _isLayerExist.veclayers){ 
				imgEle.src=APIAdress+"gisapi/theme/image/vec.png";
			}else if(_isLayerExist.hvtlayers&&this._m.enableVtMap ){
				imgEle.src=APIAdress+"gisapi/theme/image/vc_hvt.png";
			}else{
				imgEle.src=APIAdress+"gisapi/theme/image/img.png";
			}
		}else if(imgEle.src.indexOf("gisapi/theme/image/25.png")>-1){
			//切换到 2.5维
			for(j=0; j<arrLayer.length; j++){
				if(arrLayer[j].layerName=="tfw"){
					var tmpLayerOne = arrLayer[j].layers;
					for(k=0; k<tmpLayerOne.length; k++){
						if(k==0){
							this._m.setBaseLayer(tmpLayerOne[k]);
						}
						tmpLayerOne[k].setVisibility(true);
					}
				}else{
					var tmpLayerTwo = arrLayer[j].layers;
					for(m=0; m<tmpLayerTwo.length; m++){
						tmpLayerTwo[m].setVisibility(false);
					}
				}
			}
			 if( _isLayerExist.mixedlayers ){
				//判断多图层中
				imgEle.src=APIAdress+"gisapi/theme/image/mix.png";
			}else if( _isLayerExist.veclayers ){
				imgEle.src=APIAdress+"gisapi/theme/image/vec.png";
			}else if( _isLayerExist.hvtlayers&&this._m.enableVtMap ){
				imgEle.src=APIAdress+"gisapi/theme/image/vc_hvt.png";
			}else if( _isLayerExist.imglayers ){
				imgEle.src=APIAdress+"gisapi/theme/image/img.png";
			}else{
				imgEle.src=APIAdress+"gisapi/theme/image/25.png";
			}
		}else if(imgEle.src.indexOf("gisapi/theme/image/mix.png")>-1){
			for(j=0; j<arrLayer.length; j++){
				if(arrLayer[j].layerName=="mix"){
					var tmpLayerOne = arrLayer[j].layers;
					for(k=0; k<tmpLayerOne.length; k++){
						if(k==0){
							this._m.setBaseLayer(tmpLayerOne[k]);
						}
						tmpLayerOne[k].setVisibility(true);
					}
				}else{
					var tmpLayerTwo = arrLayer[j].layers;
					for(m=0; m<tmpLayerTwo.length; m++){
						tmpLayerTwo[m].setVisibility(false);
					}
				}
			}
			//切换到 mix
			if( _isLayerExist.veclayers ){
				imgEle.src=APIAdress+"gisapi/theme/image/vec.png";
			}else if( _isLayerExist.hvtlayers&&this._m.enableVtMap ){
				imgEle.src=APIAdress+"gisapi/theme/image/vc_hvt.png";
			}else if( _isLayerExist.imglayers ){
				imgEle.src=APIAdress+"gisapi/theme/image/img.png";
			}else if(_isLayerExist.tfwlayers){
				imgEle.src=APIAdress+"gisapi/theme/image/25.png";
			}else{
				imgEle.src=APIAdress+"gisapi/theme/image/mix.png";
			}
		}else if(imgEle.src.indexOf("gisapi/theme/image/vec.png")>-1){
			for(j=0; j<arrLayer.length; j++){
				if(arrLayer[j].layerName=="vec"){
					var tmpLayerOne = arrLayer[j].layers;
					for(k=0; k<tmpLayerOne.length; k++){
						if(k==0){
							this._m.setBaseLayer(tmpLayerOne[k]);
						}
						tmpLayerOne[k].setVisibility(true);
					}
				}else{
					var tmpLayerTwo = arrLayer[j].layers;
					for(m=0; m<tmpLayerTwo.length; m++){
						tmpLayerTwo[m].setVisibility(false);
					}
				}
			}
			//切换到矢量
			if( _isLayerExist.hvtlayers&&this._m.enableVtMap){
				imgEle.src=APIAdress+"gisapi/theme/image/vc_hvt.png";
			}else if( _isLayerExist.imglayers ){
				imgEle.src=APIAdress+"gisapi/theme/image/img.png";
			}else if(_isLayerExist.tfwlayers){
				imgEle.src=APIAdress+"gisapi/theme/image/25.png";
			}else if( _isLayerExist.mixedlayers ){
				imgEle.src=APIAdress+"gisapi/theme/image/mix.png";
			}else{
				imgEle.src=APIAdress+"gisapi/theme/image/vec.png";
			}
		}else if(imgEle.src.indexOf("gisapi/theme/image/vc_hvt.png")>-1){
			for(j=0; j<arrLayer.length; j++){
				if(arrLayer[j].layerName=="hvt"){
					var tmpLayerOne = arrLayer[j].layers;
					for(k=0; k<tmpLayerOne.length; k++){
						if(k==0){
							this._m.setBaseLayer(tmpLayerOne[k]);
						}
						tmpLayerOne[k].setVisibility(true);
					}
				}else{
					var tmpLayerTwo = arrLayer[j].layers;
					for(m=0; m<tmpLayerTwo.length; m++){
						tmpLayerTwo[m].setVisibility(false);
					}
				}
			}
			//切换到矢量
			 if( _isLayerExist.imglayers ){
				imgEle.src=APIAdress+"gisapi/theme/image/img.png";
			}else if(_isLayerExist.tfwlayers){
				imgEle.src=APIAdress+"gisapi/theme/image/25.png";
			}else if(_isLayerExist.mixedlayers ){
				imgEle.src=APIAdress+"gisapi/theme/image/mix.png";
			}else if( _isLayerExist.veclayers ){
				imgEle.src=APIAdress+"gisapi/theme/image/vec.png";
			}else if(this._m.enableVtMap){
				imgEle.src=APIAdress+"gisapi/theme/image/vc_hvt.png";
			}	
		}
	},
	draw : function() {
		HGIS.Control.prototype.draw.apply(this, arguments);
		var _isLayerExist = this.isLayerExist();
		//其他人调用map.addControl(new HGIS.Control.LayerSwitch());获取不到layer的url下的处理方式
		if(!(_isLayerExist.imglayers||_isLayerExist.tfwlayers||_isLayerExist.mixedlayers||_isLayerExist.veclayers)){
			return ;
		}
		if(this.div == null) {
			this.div = HGIS.Util.createDiv(this.id);
		}
		this.div.className = this.displayClass+"Ex";
		var img=document.createElement("img");
		//默认先加载矢量地图，如果有矢量切片优先加载，然后判断有没有其他图层可切换，确定img
		var _isLayerExist = this.isLayerExist();
		if(_isLayerExist.imglayers){
			img.src=APIAdress+"gisapi/theme/image/img.png";
		}else if(_isLayerExist.tfwlayers){
			img.src=APIAdress+"gisapi/theme/image/25.png";
		}else if(_isLayerExist.mixedlayers){
			img.src=APIAdress+"gisapi/theme/image/mix.png";
		}else if(_isLayerExist.veclayers){
			img.src=APIAdress+"gisapi/theme/image/vec.png";
		}else if(_isLayerExist.hvtlayers&&this._m.enableVtMap){
			img.src=APIAdress+"gisapi/theme/image/vc_hvt.png";
		}
		//如果配置了前端优先显示的图层
		img.id=this._m.id+"switch";
		//使用call函数绑定执行上下文，应当绑定到LayerSwitch上下文，然后可以通过 其获取map的上下文
		this.attachEvt(img,"click",this.doSwitch,this);
//		if(img.attachEvent){
//			img.attachEvent("onclick", this.doSwitch);
//		}
//		else{
//			img.addEventListener("click",this.doSwitch,false);
//		}
		this.div.appendChild(img);
		return this.div;
	},
	attachEvt:function(target, eventName, handler, argsObject)  
	{  
	    var eventHandler = handler;  
	    if(argsObject)  
	    {  
	        eventHandler = function(e)  
	        {  
	            handler.call(argsObject, e);  
	        }  
	    }  
	    if(window.attachEvent)//IE  
	        target.attachEvent("on" + eventName, eventHandler );  
	    else//FF  
	        target.addEventListener(eventName, eventHandler, false);  
	},
	/**
	 * Method : display
	 * 控件的显示与否
	 */
	display : function(isDisplay){
		if(!isDisplay){
			this.div.style.display = "none"
		}else{
			this.div.style.display = "block"
		}
	},

	/**
	 * APIMethod: destroy
	 * 控件的销毁方法。
	 */
	destroy : function() {
		// delete private elements here ...
		HGIS.Control.prototype.destroy.apply(this);
	},
	CLASS_NAME : "HGIS.Control.LayerSwitch"
});
/**
 * @requires HGIS/Control.js
 * @requires HGIS/Lang.js
 * @requires HGIS/Util.js
 * @requires HGIS/Events/buttonclick.js
 */
HGIS.Control = HGIS.Control || {};
/**
 * Class: HGIS.Control.LayerSwitcherEx
 *用于 图层可见性控制的控件类. 
 * 用于地图中的图层可见性控制。 在地图div之外创建该控件，实例化时参数传入一个html div的ID
 *
 * Inherits from:
 *  - <HGIS.Control>
 */
HGIS.Control.LayerSwitcherEx =HGIS.Class(HGIS.Control, {
    /**  
     * Property: layerStates 
     * {Array(Object)} Basically a copy of the "state" of the map's layers 
     *     the last time the control was drawn. We have this in order to avoid
     *     unnecessarily redrawing the control.
     */
    layerStates: null,

  // DOM Elements

    /**
     * Property: layersDiv
     * {DOMElement}
     */
    layersDiv: null,

    /**
     * Property: baseLayersDiv
     * {DOMElement}
     */
    baseLayersDiv: null,

    /**
     * Property: baseLayers
     * {Array(Object)}
     */
    baseLayers: null,


    /**
     * Property: dataLbl
     * {DOMElement}
     */
    dataLbl: null,

    /**
     * Property: dataLayersDiv
     * {DOMElement}
     */
    dataLayersDiv: null,

    /**
     * Property: dataLayers
     * {Array(Object)}
     */
    dataLayers: null,


    /**
     * Property: minimizeDiv
     * {DOMElement}
     */
    minimizeDiv: null,

    /**
     * Property: maximizeDiv
     * {DOMElement}
     */
    maximizeDiv: null,

    /**
     * APIProperty: ascending
     * {Boolean}  图层在控件中的显示顺序，默认false.
     * 叠加图层显示在上面，底图显示在下面。
     */
    ascending: true,

    /**
     * Constructor: HGIS.Control.LayerSwitcherEx
     * 图层选择控件类.
     * 
     * Parameters:
     * options - {Object}设置该类开放的属性.
     * 
     * 示例:
     * (code)
     * 第一种方法,在初始化Map时,通过Map的controls属性添加控件.
     * var map = new HGIS.Map('map',{controls:[
     *     new HGIS.Control.LayerSwitcherEx()
     *  ]});
     *  
     * 第二种方法,在Map构造完成后,调用Map的addControl()方法添加控件.
     * var map = new HGIS.Map('map');
     * map.addControl(new HGIS.Control.LayerSwitcherEx());
     * (end)
     */
    initialize: function(options) {
        HGIS.Control.prototype.initialize.apply(this, arguments);
        this.layerStates = [];
    },

    /**
     * APIMethod: destroy
     * 解构控件,释放控件所占有的资源.
     */
    destroy: function() {

        //clear out layers info and unregister their events
        this.clearLayersArray("base");
        this.clearLayersArray("data");

        this.map.events.un({
            buttonclick: this.onButtonClick,
            addlayer: this.redraw,
            changelayer: this.redraw,
            removelayer: this.redraw,
            changebaselayer: this.redraw,
            scope: this
        });
        this.events.unregister("buttonclick", this, this.onButtonClick);

        HGIS.Control.prototype.destroy.apply(this, arguments);
    },

    /**
     * Method: setMap
     *
     * Properties:
     * map - {<HGIS.Map>}
     */
    setMap: function(map) {
        HGIS.Control.prototype.setMap.apply(this, arguments);

        this.map.events.on({
            addlayer: this.redraw,
            changelayer: this.redraw,
            removelayer: this.redraw,
            changebaselayer: this.redraw,
            scope: this
        });
        if (this.outsideViewport) {
            this.events.attachToElement(this.div);
            this.events.register("buttonclick", this, this.onButtonClick);
        } else {
            this.map.events.register("buttonclick", this, this.onButtonClick);
        }
    },

    /**
     * Method: draw
     *
     * Returns:
     * {DOMElement} A reference to the DIV DOMElement containing the
     *     switcher tabs.
     */
    draw: function() {
        HGIS.Control.prototype.draw.apply(this);

        // create layout divs
        this.loadContents();

        // set mode to minimize
        if(!this.outsideViewport) {
            this.minimizeControl();
        }

        // populate div with current info
        this.redraw();

        return this.div;
    },

    /**
     * Method: onButtonClick
     *
     * Parameters:
     * evt - {Event}
     */
    onButtonClick: function(evt) {
        var button = evt.buttonElement;
        if (button === this.minimizeDiv) {
            this.minimizeControl();
        } else if (button === this.maximizeDiv) {
            this.maximizeControl();
        } else if (button._layerSwitcher === this.id) {
            if (button["for"]) {
                button = document.getElementById(button["for"]);
            }
            if (!button.disabled) {
                if (button.type == "radio") {
                    button.checked = true;
                    this.map.setBaseLayer(this.map.getLayer(button._layer));
                } else {
                    button.checked = !button.checked;
                    this.updateMap();
                }
            }
        }
    },

    /**
     * Method: clearLayersArray
     * User specifies either "base" or "data". we then clear all the
     *     corresponding listeners, the div, and reinitialize a new array.
     *
     * Parameters:
     * layersType - {String}
     */
    clearLayersArray: function(layersType) {
        this[layersType + "LayersDiv"].innerHTML = "";
        this[layersType + "Layers"] = [];
    },


    /**
     * Method: checkRedraw
     * Checks if the layer state has changed since the last redraw() call.
     *
     * Returns:
     * {Boolean} The layer state changed since the last redraw() call.
     */
    checkRedraw: function() {
        if ( !this.layerStates.length ||
             (this.map.layers.length != this.layerStates.length) ) {
            return true;
        }

        for (var i = 0, len = this.layerStates.length; i < len; i++) {
            var layerState = this.layerStates[i];
            var layer = this.map.layers[i];
            if ( (layerState.name != layer.name) ||
                 (layerState.inRange != layer.inRange) ||
                 (layerState.id != layer.id) ||
                 (layerState.visibility != layer.visibility) ) {
                return true;
            }
        }

        return false;
    },

    /**
     * Method: redraw
     * Goes through and takes the current state of the Map and rebuilds the
     *     control to display that state. Groups base layers into a
     *     radio-button group and lists each data layer with a checkbox.
     *
     * Returns:
     * {DOMElement} A reference to the DIV DOMElement containing the control
     */
    redraw: function() {
        //if the state hasn't changed since last redraw, no need
        // to do anything. Just return the existing div.
        if (!this.checkRedraw()) {
            return this.div;
        }

        //clear out previous layers
        this.clearLayersArray("base");
        this.clearLayersArray("data");

        var containsOverlays = false;
        var containsBaseLayers = false;

        // Save state -- for checking layer if the map state changed.
        // We save this before redrawing, because in the process of redrawing
        // we will trigger more visibility changes, and we want to not redraw
        // and enter an infinite loop.
        var len = this.map.layers.length;
        this.layerStates = new Array(len);
        for (var i=0; i <len; i++) {
            var layer = this.map.layers[i];
            this.layerStates[i] = {
                'name': layer.name,
                'visibility': layer.visibility,
                'inRange': layer.inRange,
                'id': layer.id
            };
        }

        var layers = this.map.layers.slice();
        if (!this.ascending) { layers.reverse(); }
        for(var i=0, len=layers.length; i<len; i++) {
            var layer = layers[i];
            var baseLayer = layer.isBaseLayer;

            if (layer.displayInLayerSwitcher) {

                if (baseLayer) {
                    containsBaseLayers = true;
                } else {
                    containsOverlays = true;
                }

                // only check a baselayer if it is *the* baselayer, check data
                //  layers if they are visible
                var checked = (baseLayer) ? (layer == this.map.baseLayer)
                                          : layer.getVisibility();

                // create input element
                var inputElem = document.createElement("input"),                   
                    inputId = HGIS.Util.createUniqueID(
                        this.id + "_input_"
                    );


                inputElem.id = inputId;
                inputElem.name = (baseLayer) ? this.id + "_baseLayers" : layer.name;
                inputElem.type = (baseLayer) ? "radio" : "checkbox";
                inputElem.value = layer.name;
                inputElem.checked = checked;
                inputElem.defaultChecked = checked;
                inputElem.className = (baseLayer) ? "olButton olradio": "olcheckbox olButton";
                inputElem._layer = layer.id;
                inputElem._layerSwitcher = this.id;

                if (!baseLayer && !layer.inRange) {
                    inputElem.disabled = true;
                }

                // 创建label容器，其中包含input span 和只显示文本的label
                var labelSpan = document.createElement("label");                
                labelSpan["for"] = inputElem.id;                
                HGIS.Element.addClass(labelSpan, "olButton labelSpan");                
                labelSpan._layer = layer.id;
                labelSpan._layerSwitcher = this.id;
                if (!baseLayer && !layer.inRange) {
                    labelSpan.style.color = "#666666";//"gray";
                }              
                labelSpan.style.verticalAlign = "bottom";          
                
                labelSpan.appendChild(inputElem);
                //创建单选和复选按钮的图标
                var span = document.createElement("span");
                span.className =  (baseLayer) ? "radioInput":"checkbox checkInput";               
                labelSpan.appendChild(span);
                //负责显示图层名称的文本标签
                var textLabel = document.createElement("label");
                textLabel.innerHTML = layer.name;
                textLabel["for"] = inputElem.id;               
                
                labelSpan.appendChild(textLabel);  

                var groupArray = (baseLayer) ? this.baseLayers
                                             : this.dataLayers;
                groupArray.push({
                    'layer': layer,
                    'inputElem': inputElem,
                    'labelSpan': labelSpan
                });


                var groupDiv = (baseLayer) ? this.baseLayersDiv
                                           : this.dataLayersDiv;            
                groupDiv.appendChild(labelSpan);              
            }
        }

        // if no overlays, dont display the overlay label
        this.dataLbl.style.display = (containsOverlays) ? "" : "none";

        // if no baselayers, dont display the baselayer label
        this.baseLbl.style.display = (containsBaseLayers) ? "" : "none";

        return this.div;
    },

    /**
     * Method: updateMap
     * Cycles through the loaded data and base layer input arrays and makes
     *     the necessary calls to the Map object such that that the map's
     *     visual state corresponds to what the user has selected in
     *     the control.
     */
    updateMap: function() {

        // set the newly selected base layer
        for(var i=0, len=this.baseLayers.length; i<len; i++) {
            var layerEntry = this.baseLayers[i];
            if (layerEntry.inputElem.checked) {
                this.map.setBaseLayer(layerEntry.layer, false);
            }
        }

        // set the correct visibilities for the overlays
        for(var i=0, len=this.dataLayers.length; i<len; i++) {
            var layerEntry = this.dataLayers[i];
            layerEntry.layer.setVisibility(layerEntry.inputElem.checked);
        }

    },

    /**
     * Method: maximizeControl
     * Set up the labels and divs for the control
     *
     * Parameters:
     * e - {Event}
     */
    maximizeControl: function(e) {

        // set the div's width and height to empty values, so
        // the div dimensions can be controlled by CSS
        this.div.style.width = "";
        this.div.style.height = "";

        this.showControls(false);

        if (e != null) {
            HGIS.Event.stop(e);
        }
    },

    /**
     * Method: minimizeControl
     * Hide all the contents of the control, shrink the size,
     *     add the maximize icon
     *
     * Parameters:
     * e - {Event}
     */
    minimizeControl: function(e) {

        // to minimize the control we set its div's width
        // and height to 0px, we cannot just set "display"
        // to "none" because it would hide the maximize
        // div
        this.div.style.width = "0px";
        this.div.style.height = "0px";

        this.showControls(true);

        if (e != null) {
            HGIS.Event.stop(e);
        }
    },

    /**
     * Method: showControls
     * Hide/Show all LayerSwitcher controls depending on whether we are
     *     minimized or not
     *
     * Parameters:
     * minimize - {Boolean}
     */
    showControls: function(minimize) {

        this.maximizeDiv.style.display = minimize ? "" : "none";
        this.minimizeDiv.style.display = minimize ? "none" : "";

        this.layersDiv.style.display = minimize ? "none" : "";
    },

    /**
     * Method: loadContents
     * Set up the labels and divs for the control
     */
    loadContents: function() {

        // layers list div
        this.layersDiv = document.createElement("div");
        this.layersDiv.id = this.id + "_layersDiv";
        HGIS.Element.addClass(this.layersDiv, "layersDiv");        
        
        this.baseLbl = document.createElement("div");
        this.baseLbl.innerHTML = HGIS.i18n("底图图层");
        HGIS.Element.addClass(this.baseLbl, "baseLbl");

        this.baseLayersDiv = document.createElement("div");
        HGIS.Element.addClass(this.baseLayersDiv, "baseLayersDiv");

        this.dataLbl = document.createElement("div");
        this.dataLbl.innerHTML = HGIS.i18n("叠加层");
        HGIS.Element.addClass(this.dataLbl, "dataLbl");

        this.dataLayersDiv = document.createElement("div");
        HGIS.Element.addClass(this.dataLayersDiv, "dataLayersDiv");

        if (this.ascending) {
            this.layersDiv.appendChild(this.baseLbl);
            this.layersDiv.appendChild(this.baseLayersDiv);
            this.layersDiv.appendChild(this.dataLbl);
            this.layersDiv.appendChild(this.dataLayersDiv);
        } else {
            this.layersDiv.appendChild(this.dataLbl);
            this.layersDiv.appendChild(this.dataLayersDiv);
            this.layersDiv.appendChild(this.baseLbl);
            this.layersDiv.appendChild(this.baseLayersDiv);
        }

        this.div.appendChild(this.layersDiv);     
        // maximize button div
        var img = APIAdress+"gisapi/theme/image/layer-switcherEx-maximize.png";
        var pos = new HGIS.Pixel(this.map.div.offsetWidth-50,70);
        this.maximizeDiv = HGIS.Util.createAlphaImageDiv(
                                    "HGIS_Control_MaximizeDiv",
                                    null,
                                    null,
                                    img,
                                    "absolute");
        HGIS.Element.addClass(this.maximizeDiv, "maximizeDiv olButton");
        this.maximizeDiv.style.display = "none";

        this.div.appendChild(this.maximizeDiv);

        // minimize button div
        var img = APIAdress+"gisapi/theme/image/layer-switcherEx-minimize.png";
        this.minimizeDiv = HGIS.Util.createAlphaImageDiv(
                                    "HGIS_Control_MinimizeDiv",
                                    null,
                                    null,
                                    img,
                                    "absolute");
        HGIS.Element.addClass(this.minimizeDiv, "minimizeDiv olButton");
        this.minimizeDiv.style.display = "none";

        this.div.appendChild(this.minimizeDiv);
    },   
    /**
     * APIMethod: setBackgroundColor
     * 设置图层控制面板的背景色.
     * 
     * 参数:
     * color - {String} 颜色值.格式可以是："red"、"yellow"或"#ff0000"或rgba(255,0,0,0.5).
     * 
     */
    setBackgroundColor:function(color){
    	if(color)
    		this.layersDiv.style.backgroundColor = color;
    },
    /**
     * APIMethod: setPosition
     * 设置图层控制面板的位置.
     * 
     * 参数:
     * pos - {Object} 格式为{top:10,left:20}或{top:20,right:10}或{right:10,bottom:20}等
     */
    setPosition:function(pos){ 
    	if(pos.top)
    		this.div.style.top = pos.top + "px";
    	if(pos.right)
    		this.div.style.right = pos.right + "px";
    	if(pos.left)
    		this.div.style.left = pos.left + "px";
    	if(pos.bottom)
    		this.div.style.bottom = pos.bottom + "px";
    },
    /**
     * APIMethod: setMaximizeDiv
     * 设置点击后可以展开面板的图标.
     * 
     * 参数:
     * src - {String} 图片的路径
     */
    setMaximizeDiv:function(src){
    	if(this.maximizeDiv.childNodes[0])
    		this.maximizeDiv.childNodes[0].src = src;
    },
    /**
     * APIMethod: setMinimizeDiv
     * 设置点击后可以收缩面板的图标.
     * 
     * 参数:
     * src - {String} 图片的路径
     */
    setMinimizeDiv:function(src){
    	if(this.minimizeDiv.childNodes[0])
    		this.minimizeDiv.childNodes[0].src = src;
    },
    /**
     * APIMethod: setFont
     * 设置图层面板的字体样式.
     * 
     * 参数:
     * fontStyle - {Object} 格式为{color:"red",fontWeight:"bold",fontFamily:"宋体",fontSize:"18px"}
     */
    setFont:function(fontStyle){
    	if(fontStyle.fontFamily)
    		this.div.style.fontFamily = fontStyle.fontFamily;
    	if(fontStyle.fontWeight)
    		this.div.style.fontWeight = fontStyle.fontWeight;
    	if(fontStyle.color)
    		this.div.style.color = fontStyle.color;
    	if(fontStyle.fontSize)
    		this.div.style.fontSize = fontStyle.fontSize;
    		
    },
    CLASS_NAME: "HGIS.Control.LayerSwitcherEx"
});
/**
 * Class: HGIS.Control.MouseTipControl
 * 鼠标提示控件。
 * 
 * 继承自: 
 *  - <HGIS.Control.MousePosition>
 */
HGIS.Control = HGIS.Control || {};
HGIS.Control.MouseTipControl = HGIS.Class(HGIS.Control.MousePosition, {
	tipContent : null,// 提示信息
	/**
	 * Constructor: HGIS.Control.MouseTipControl
	 * 
	 * Parameters:
	 * options - {Object} 包含提示控件内容的对象。
	 * 
	 * 示例:
	 * (code)
	 * var opts={"tipContent":"我是鼠标提示"};
	 * var mouseTip=new HGIS.Control.MouseTipControl(opts);
	 * mouseTip.show();
	 * (end)
	 */
	initialize : function(options) {
		HGIS.Control.MousePosition.prototype.initialize.apply(this, arguments);		 
		this.tipContent = options.tipContent == undefined ? ''
				: options.tipContent;
	},
	/**
	 * APIMethod: draw
	 * 父类方法，构建tip内容。
	 */	
	draw : function() {
		HGIS.Control.prototype.draw.apply(this, arguments);
		if(this.div == null) {
			this.div = HGIS.Util.createDiv(this.id);
		}	
		
		if (!this.element) {
			this.div.left = "";
			this.div.top = "";
			this.element = this.div;
		}
		this.div.setAttribute('style' , 'box-sizing:content-box !important' ) ;
		this.div.style['max-width'] = '500px';
		this.div.style['min-width'] = '10px';
		this.div.style['float'] = 'none';
		this.div.style['white-space'] = 'nowrap';
		this.div.style['word-break'] = 'normal';
		this.div.style.border = '1px solid #BD6060'; // '1px solid #999999';
		this.div.style.position = 'absolute';
		this.div.style.backgroundColor = "#FFFFFF";// "#FFEBCD";
		this.div.style.padding = '2px';
		this.div.style['line-height'] = '14px';
		this.div.innerHTML = this.tipContent;
		var contentWidth=this.computeStringWidth(this.tipContent);
		this.div.style['width']=contentWidth+"px";
		var hs=this.tipContent.split("<br>").length;
		this.div.style['line-height'] = '14px';

		this.div.innerHTML = this.tipContent;
		return this.div;
	},

	/**
	 * 计算字符的长度
	 * 
	 * @param v
	 *            字符串
	 * @retrun {float} 长度
	 */
	computeStringWidth : function(v) {
		var word=v.split("<br>");
		var maxWordLen=0;
		var maxWord="";
		for(var i=0;i<word.length;i++){
			if(word[i].length>maxWordLen){
				maxWordLen=word[i].length;
				maxWord=word[i];
			}	
		}
		if(maxWord=="")
			maxWord=v;
		var w = 0;
		try {
			var span = document.createElement("span");
			span.id = "__getwidth";
			document.body.appendChild(span);
			span.style.visibility = "hidden";
			span.style.whiteSpace = "nowrap";
			span.innerHTML = maxWord;
			w = span.offsetWidth;
			span.parentNode.removeChild(span);
			if (w == 0)
				w = v.length * 13 + 'px';
		} catch (err) {
			w = v.length * 13 + 'px';
		}
		return w;

	},
	// 计算字符串的宽度
	/**
	 * APIMethod: redraw
	 */
	redraw : function(evt) {
		if (evt == null || evt==undefined) {			
			this.reset();
			return;
		} else {
			if (this.lastXy == null
					|| Math.abs(evt.xy.x - this.lastXy.x) > this.granularity
					|| Math.abs(evt.xy.y - this.lastXy.y) > this.granularity) {
				this.lastXy = evt.xy;				
				return;
			}
			this.lastXy = evt.xy;
		
			this.div.style.top = (evt.xy.y + 5) + 'px';
			this.div.style.left = (evt.xy.x + 5) + 'px';
			var contentWidth=this.computeStringWidth(this.tipContent);
			this.div.style['width']=contentWidth+"px";		
		}
	},
	/**
	 * APIMethod: setTipContent
	 * 设置提示内容。
	 * 
	 * Parameters:
	 * content - {String} 提示的内容
	 */	
	setTipContent : function(content) {
		this.div.style['width'] = this.computeStringWidth(content) + 'px';
		this.div.innerHTML = content;
		this.tipContent = content;
	},
	
	/**
	 * APIMethod: hide
	 * 隐藏MouseTipControl
	 */
	hide : function() {
		this.div.style['display'] = 'none';
	},
	
	/**
	 * APIMethod: show
	 * 显示MouseTipControl
	 */
	show : function() {
		this.div.style['display'] = 'block';
	},
	/**
	 * APIMethod: setPosition
	 * 设置提示框的位置。
	 */
	setPosition:function(x,y){
		this.div.style.top = (y + 5) + 'px';
		this.div.style.left = (x + 5) + 'px';
	},
	CLASS_NAME : "HGIS.Control.MouseTipControl"
});/**
 * Class: HGIS.Control.OverviewMapEx
 * 鹰眼图控件
 * 
 * 继承自:
 * - <HGIS.Control.OverviewMap>
 */
HGIS.Control = HGIS.Control || {};
HGIS.Control.OverviewMapEx = HGIS.Class(HGIS.Control.OverviewMap, {	

	/**
	 * Constructor: HGIS.Control.OverviewMapEx
	 * HGIS.Control.OverviewMapEx 构造方法
	 * 
	 * Parameters:
	 * options - {Object} 鹰眼图
	 * 
	 * Examples:
	 * (code)
	 * var oelement = document.getElementById("overview");
	 * var ovsize = new HGIS.Size(800, 900);
	 * var ovmap = new HGIS.Control.OverviewMapEx({
	 * 												size : ovsize,
	 * 												element : oelement
	 * 											});
	 * map.addControl(ovmap);
	 * (end)
	 */
	initialize : function(options) {
		this.minRatio = 10;
		this.maxRatio = 10;
		this.minRectSize = 10;
		this.size = new HGIS.Size(180, 120);
		this.maximized = true;
		options = HGIS.Util.extend({
			mapOptions : {
				projection : new HGIS.Projection("EPSG:4326"),
				displayProjection : new HGIS.Projection("EPSG:4326"),
				units : "degrees",
				maxResolution : 'auto',
				maxExtent : new HGIS.Bounds(-180, -90, 180, 90),
			}
		}, options);
		HGIS.Control.OverviewMap.prototype.initialize.apply(this, [ options ]);
		//this.displayClass="olControlOverviewMap";
	},
	
	/**
	 * APIMethod: setOvMapCenter
	 * 将鹰眼中心点设置和Map相同
	 */
	setOvMapCenter : function() {
		if(this.map.getZoom()>=(this.map.minLevel + 4))
		    this.ovmap.setCenter(this.map.getExtent().getCenterLonLat());
		else{
		    this.ovmap.zoomTo(this.map.minLevel);
		}
	},
	
	/**
	 * APIMethod: updateMapToRect
	 * 更新地图范围到鹰眼图的图框
	 */
	updateMapToRect : function() {
		HGIS.Control.OverviewMap.prototype.updateMapToRect.apply(this,
				arguments);
	},
	
	/**
	 * APIMethod: createMap
	 * 创建Map对象
	 */
	createMap : function() {
		HGIS.Control.OverviewMap.prototype.createMap.apply(this, arguments);
		this.ovmap.events.register('moveend', this, this.updateRectToMap);
		this.ovmap.events.register('zoomend', this, this.updateRectToMap);
		this.ovmap.events.register('mouseup', this,this.map_mouseup);
	},
	//避免鼠标事件冲突，当拉框缩放在鹰眼控件上导致 地图的mouseup事件无法触发的时候，这里主动触发
	map_mouseup:function(){
		this.map.events.triggerEvent("mouseup", {map: this.map});
	},
	/**
	 * APIMethod: draw
	 * 绘制鹰眼图控件
	 */
	draw : function() {
		HGIS.Control.prototype.draw.apply(this, arguments);
		if (!(this.layers.length > 0)) {
			if (this.map.baseLayer) {
				var layer = this.map.baseLayer.clone();
				this.layers = [ layer ];
			} else {
				this.map.events.register("changebaselayer", this,
						this.baseLayerDraw);
				return this.div;
			}
		}

		this.element = document.createElement('div');
		this.element.className = this.displayClass + 'Element';
		this.element.style.display = 'none';

		this.mapDiv = document.createElement('div');
		this.mapDiv.style.width = this.size.w + 'px';
		this.mapDiv.style.height = this.size.h + 'px';
		this.mapDiv.style.position = 'relative';
		this.mapDiv.style.overflow = 'hidden';
		this.mapDiv.id = HGIS.Util.createUniqueID('overviewMap');

		this.extentRectangle = document.createElement('div');
		this.extentRectangle.style.position = 'absolute';
		this.extentRectangle.style.zIndex = 1000; // HACK
		this.extentRectangle.className = this.displayClass + 'ExtentRectangle';
		this.mapDiv.appendChild(this.extentRectangle);

		this.element.appendChild(this.mapDiv);

		this.div.appendChild(this.element);
		if (!this.outsideViewport) {
			this.div.className += " " + this.displayClass + 'Container';
			// maximize button div
			var img = APIAdress + 'gisapi/theme/image/overviewOpen.png';
			this.maximizeDiv = HGIS.Util.createAlphaImageDiv(this.displayClass
					+ 'MaximizeButton', null, new HGIS.Size(18, 18), img,
					'absolute');
			this.maximizeDiv.style.display = 'none';
			this.maximizeDiv.className = this.displayClass + 'MaximizeButton';
			HGIS.Event.observe(this.maximizeDiv, 'click', HGIS.Function
					.bindAsEventListener(this.maximizeControl, this));
			this.div.appendChild(this.maximizeDiv);
			// 最小化按钮
			var img = APIAdress + 'gisapi/theme/image/overviewClose.png';
			this.minimizeDiv = HGIS.Util.createAlphaImageDiv(
					'OpenLayers_Control_minimizeDiv', null, new HGIS.Size(18,
							18), img, 'absolute');
			this.minimizeDiv.style.display = 'none';
			this.minimizeDiv.className = this.displayClass + 'MinimizeButton';
			HGIS.Event.observe(this.minimizeDiv, 'click', HGIS.Function
					.bindAsEventListener(this.minimizeControl, this));
			this.div.appendChild(this.minimizeDiv);

			var eventsToStop = [ 'dblclick', 'mousedown'];
			for (var i = 0, len = eventsToStop.length; i < len; i = i + 1) {
				HGIS.Event.observe(this.maximizeDiv, eventsToStop[i],
						HGIS.Event.stop);
				HGIS.Event.observe(this.minimizeDiv, eventsToStop[i],
						HGIS.Event.stop);
			}
			
			this.minimizeControl();
		} else {
			this.element.style.display = '';
		}
		if (this.map.getExtent()) {
			this.update();
		}

		this.map.events.register('moveend', this, this.update);
		this.map.events.register('zoomend', this, this.update);
		this.map.events.register('dragend', this, this.update);

		this.map.events.register('moveend', this, this.setOvMapCenter);
		this.map.events.register('zoomend', this, this.setOvMapCenter);
		this.map.events.register('dragend', this, this.setOvMapCenter);
		
		if (this.maximized) {
			this.maximizeControl();
		}
		return this.div;
	},
	
	/**
	 * APIMethod: showToggle
	 * 是否最小化鹰眼(true--最小化,隐藏;false--最大化,显示)
	 * 
	 * Parameters:
     * minimize - {Boolean} true或者false．true表示最小化/隐藏;false表示最大化/显示.
	 */
    showToggle: function(minimize) {
        if (minimize==true) {
            this.maximizeDiv.style.display =   '';
            this.minimizeDiv.style.display =  'none';
            this.element.style.display = 'none';
        }else if (minimize==false) {
        	this.maximizeDiv.style.display =   'none';
            this.minimizeDiv.style.display =  '';
            this.element.style.display = '';
        }
    },
//	 setRectPxBounds: function(pxBounds) {
//	        var top = Math.max(pxBounds.top, 0);
//	        var left = Math.max(pxBounds.left, 0);
//	        var bottom = Math.min(pxBounds.top + Math.abs(pxBounds.getHeight()),
//	                              this.ovmap.size.h - this.hComp);
//	        var right = Math.min(pxBounds.left + pxBounds.getWidth(),
//	                             this.ovmap.size.w - this.wComp);
//	        var width = Math.max(right - left, 0);
//	        var height = Math.max(bottom - top, 0);
//	        if(width < this.minRectSize || height < this.minRectSize) {
//	            this.extentRectangle.className = this.displayClass +
//	                                             this.minRectDisplayClass;
//	            var rLeft = left + (width / 2) - (this.minRectSize / 2);
//	            var rTop = top + (height / 2) - (this.minRectSize / 2);
//	            this.extentRectangle.style.top = Math.round(rTop) + 'px';
//	            this.extentRectangle.style.left = Math.round(rLeft) + 'px';
//	            this.extentRectangle.style.height = this.minRectSize + 'px';
//	            this.extentRectangle.style.width = this.minRectSize + 'px';
//	        } else {
//	            this.extentRectangle.className = this.displayClass +
//	                                             'ExtentRectangle';
//	            this.extentRectangle.style.top = Math.round(top) + 'px';
//	            this.extentRectangle.style.left = Math.round(left) + 'px';
//	            this.extentRectangle.style.height = Math.round(height) + 'px';
//	            this.extentRectangle.style.width = Math.round(width) + 'px';
//	        }
//	        this.rectPxBounds = new HGIS.Bounds(
//	            Math.round(left), Math.round(bottom),
//	            Math.round(right), Math.round(top)
//	        );
//	    },
	CLASS_NAME : "HGIS.Control.OverviewMapEx"
});/**
 * Class: HGIS.Control.PanZoomBarEx
 * 默认情况下，它是显示在地图的左上角由4个方向箭头和带有滑块的垂直刻度条组成的控件。由HGIS.Control.PanPanel与HGIS.Control.ZoomBar组合而成。
 * 
 * 继承自: 
 * - <HGIS.Control.PanZoom>
 * 
 * 示例:
 * (code)
 * var panZoomBar = new HGIS.Control.PanZoomBarEx();
 * map.addControl(panZoomBar);
 * (end)
 */
HGIS.Control = HGIS.Control || {};
HGIS.Control.PanZoomBarEx= HGIS.Class(HGIS.Control.PanZoom,
		{
			zoomStopWidth : 12,// 考虑从初始化参数中获取
			zoomStopHeight : 8,// 考虑从初始化参数中获取
			slider : null,
			sliderEvents : null,
			zoombarDiv : null,
			zoomWorldIcon : false,// 一张大的背景图
			panIcons : true,// 分开的小图片
			forceFixedZoomLevel : false,
			mouseDragStart : null,
			deltaY : null,
			imgPath : APIAdress + "gisapi/theme/img/gis/navi/",
			zoomStart : null,// 最小比例级别，考虑从初始化参数中获取
			fixedLeftBottom : false,
			/**
			 * 方向盘div
			 */
			directDiv : null,

			/**
			 * 方向盘图片
			 */
			directImg : null,

			imgLocation : APIAdress + "gisapi/theme/img/gis/navi/normal.png",

			directDivID : '',
			
			minLevel : 0,
			
			destroy : function() {
				this._removeZoomBar();
				this.map.events.un({
					"changebaselayer" : this.redraw,
					"updatesize" : this.redraw,
					scope : this
				});
				HGIS.Control.PanZoom.prototype.destroy.apply(this, arguments);
				delete this.mouseDragStart;
				delete this.zoomStart;
			},
			setMap : function(map) {
				HGIS.Control.PanZoom.prototype.setMap.apply(this, arguments);
				this.map.events.on({
					"changebaselayer" : this.redraw,
					"updatesize" : this.redraw,
					scope : this
				});
			},

			/**
			 * APIMethod: redraw
			 * 重绘：清除div并重新绘制。
			 */
			redraw : function() {
				if (this.div != null) {
					this.removeButtons();
					this._removeZoomBar();
				}
				this.draw();
			},
			/**
			 * APIMethod: draw
			 * 绘制导航条
			 */
			draw : function(px) {
				HGIS.Control.prototype.draw.apply(this, arguments);
				px = this.position.clone();
				if(this.fixedLeftBottom){
					var msz = this.map.getSize();
					if(msz){
						this.minLevel = this.map.minLevel?this.map.minLevel:this.map.getMinZoom();
						px = new HGIS.Pixel(4, msz.h - this.zoomStopHeight * (this.map.getNumZoomLevels() - this.minLevel) - 160);
					}
				}
				this.buttons = [];
				var sz = {
					w : 15,
					h : 15
				};
				if (this.panIcons) {
					var centered = new HGIS.Pixel(px.x + 48.0 / 2, px.y);
					var wposition = sz.w;
					if (this.zoomWorldIcon) {
						centered = new HGIS.Pixel(px.x + sz.w, px.y);
					}
					var allSize = {
						w : 40,
						h : 40
					};
					var directSize = {
						w : sz.w + 33,
						h : sz.h + 33
					};
					this._addButton("all", this.imgLocation, px.add(sz.w - 7, 0), directSize);// 添加方向盘大图标

					// 添加方向按钮div
					this._addPanButton("panup", px.add(22, 0), new HGIS.Size(26, 13),
							new HGIS.Pixel(-15, 0)); // 上移按钮
					this._addPanButton("panleft", px.add(8, 17), new HGIS.Size(13, 26), new HGIS.Pixel(0,
							-15)); // 左移按钮
					if (this.zoomWorldIcon) {
						this._addButton("zoomworld", px.add(sz.w, 0), sz, new HGIS.Pixel(0, -25));
						wposition *= 2;
					}
					this._addPanButton("panright", px.add(40, 15), new HGIS.Size(13, 26), new HGIS.Pixel(
							-30, -15)); // 右移按钮
					this._addPanButton("pandown", px.add(18, 35), new HGIS.Size(26, 13), new HGIS.Pixel(
							-15, -30)); // 下移按钮
					this._addButton("zoomin", this.imgPath + "zoomin.png", centered.add(0, sz.h * 3 + 5), sz);// 放大
					centered = this._addZoomBar(centered.add(-2, sz.h * 4 + 5));
					this._addButton("zoomout", this.imgPath + "zoomout.png", centered.add(2, 1), sz);// 缩小
				} else {
					this._addButton("zoomin", "zoom-plus-mini.png", px, sz);
					centered = this._addZoomBar(px.add(0, sz.h));
					this._addButton("zoomout", "zoom-minus-mini.png", centered, sz);
					if (this.zoomWorldIcon) {
						centered = centered.add(0, sz.h + 3);
						this._addButton("zoomworld", "zoom-world-mini.png", centered, sz);
					}
				}
				return this.div;
			},

			/**
			 * APIMethod: _addButton
			 * 添加导航条按钮
			 * 
			 * Parameters:
			 * id - {String} 按钮唯一标志
			 * img - {String} 按扭图标
			 * xy - {<HGIS.Pixel>} 按钮位置
			 * sz - {<HGIS.Size>} 按钮大小
			 */
			_addButton : function(id, img, xy, sz) {
				var btn = HGIS.Util.createAlphaImageDiv(this.id + "_" + id, xy, sz, img, "absolute");

				btn.style.cursor = "pointer";
				this.div.appendChild(btn);
				btn.action = id;
				btn.className = "olButton";
				this.buttons.push(btn);

				return btn;
			},

			_addDirect : function(id, img, xy, sz) {
				directImg = HGIS.Util.createAlphaImageDiv(this.id + "_" + id, xy, sz, img, "absolute");
				directImg.style.cursor = "pointer";
				this.div.appendChild(directImg);
				directImg.action = id;
				directImg.className = "olButton";
				this.buttons.push(directImg);
				return directImg;

			},
			_changeDirectImage : function(imgName) {
				this.imgLocation = this.imgPath + imgName;
				this.redraw();
			},

			
			_creatbtn : function(divId, xy, sz, position) {
				directDiv = HGIS.Util.createDiv(divId, xy, sz, null, "absolute", null, "hidden", null);
				return directDiv;
			},
			/** 改变移动圆盘地图* */
			_creatimg : function(left, top) {
				this.directImg.style.left = left + 'px';
				this.directImg.style.top = top + 'px';
			},

			/**
			 * 添加拖动条按钮
			 */
			_addPanButton : function(id, xy, sz, position) {
				var btn = this._creatbtn(this.id + "_" + id, xy, sz, position);
				btn.style.cursor = "pointer";
				btn.style.background = "url(about:blank)";// 解决IE下不能选中四个小箭头div的问题。
				this.div.appendChild(btn);
				btn.action = id;
				btn.className = "olButton";
				this.buttons.push(btn);
				return btn;
			},

			/** 鼠标移到向上向下小按钮上时的响应事件 */
			buttonMouseOver : function(evt) {
				var action = "";
				if (navigator.userAgent.indexOf("Firefox") > 0) {
					action = evt.currentTarget.action;
				} else {
					action = evt.srcElement.id.split("_")[3];
				}

				switch (action) {
					case "panup" :
						this._changeDirectImage("panup.png");
						break;
					case "pandown" :
						this._changeDirectImage("pandown.png");
						break;
					case "panleft" :
						this._changeDirectImage("panleft.png");
						break;
					case "panright" :
						this._changeDirectImage("panright.png");
						break;
					default :
						break;
				}
			},

			buttonMouseOut : function(evt) {
				this._changeDirectImage("normal.png");
				this.redraw();
			},

			onPanBtnClick : function(evt) {
				HGIS.Control.PanZoom.prototype.onButtonClick.apply(this, arguments);
			},

			/**
			 * 添加缩放工具条
			 * 
			 * @param centered - {
			 *            <HGIS.Pixel>} 缩放从此处开始绘制
			 */
			_addZoomBar : function(centered) {
				var imgLocation = this.imgPath + "bar-hover.png";
				var id = this.id + "_" + this.map.id;
				var zoomsToEnd = (this.map.getNumZoomLevels() - 1) - this.map.getZoom();
				var slider = HGIS.Util.createAlphaImageDiv(id,
						centered.add(-1, zoomsToEnd * this.zoomStopHeight), {
							w : 20,
							h : 11
						}, imgLocation, "absolute");
				slider.style.cursor = "pointer";
				slider.style['line-height'] = "12px";
				
				this.slider = slider;

				this.sliderEvents = new HGIS.Events(this, slider, null, true, {
					includeXY : true
				});
				this.sliderEvents.on({
					"touchstart" : this.zoomBarDown,
					"touchmove" : this.zoomBarDrag,
					"touchend" : this.zoomBarUp,
					"mousedown" : this.zoomBarDown,
					"mousemove" : this.zoomBarDrag,
					"mouseup" : this.zoomBarUp,
					"mouseout": this.zoomBarUp
				});

				var sz = {
					w : this.zoomStopWidth,
					h : this.zoomStopHeight * (this.map.getNumZoomLevels() - this.minLevel - 1) + 12
				};

				var imgLocation = this.imgPath + "ruler-sel.png";
				var div = null;
				if (HGIS.Util.alphaHack()) {
					var id = this.id + "_" + this.map.id;
					div = HGIS.Util.createAlphaImageDiv(id, centered, {
						w : sz.w,
						h : this.zoomStopHeight
					}, imgLocation, "absolute", null, "crop");
					div.style.height = sz.h + "px";
				} else {
					div = HGIS.Util.createDiv('HGIS_Control_PanZoomBar_Zoombar' + this.map.id, centered,
							sz, imgLocation);
				}
				div.style.cursor = "pointer";
				div.className = "olButton";
				this.zoombarDiv = div;
				this.div.appendChild(div);
				this.startTop = parseInt(div.style.top);
				this.div.appendChild(slider);
				this.map.events.register("zoomend", this, this.moveZoomBar);
				centered = centered.add(0, this.zoomStopHeight * (this.map.getNumZoomLevels() - this.minLevel -1) + 12);
				return centered;
			},

			/**
			 * 删除缩放条
			 */
			_removeZoomBar : function() {
				if (this.sliderEvents != undefined) {
					this.sliderEvents.un({
						"touchstart" : this.zoomBarDown,
						"touchmove" : this.zoomBarDrag,
						"touchend" : this.zoomBarUp,
						"mousedown" : this.zoomBarDown,
						"mousemove" : this.zoomBarDrag,
						"mouseup" : this.zoomBarUp,
						"mouseout": this.zoomBarUp
					});
					this.sliderEvents.destroy();

					this.div.removeChild(this.zoombarDiv);
					this.zoombarDiv = null;
					this.div.removeChild(this.slider);
					this.slider = null;

					this.map.events.unregister("zoomend", this, this.moveZoomBar);
				}
			},

			/**
			 * APIMethod: onButtonClick
			 * 导航条按钮的触发事件
			 * 
			 * Parameters:
			 * evt - {<HGIS.Events>} 用来监听或者触发该控件上的事件。
			 */
			onButtonClick : function(evt) {
				HGIS.Control.PanZoom.prototype.onButtonClick.apply(this, arguments);
				if (evt.buttonElement === this.zoombarDiv) {
					var levels = evt.buttonXY.y / this.zoomStopHeight;
					if (this.forceFixedZoomLevel || !this.map.fractionalZoom) {
						levels = Math.floor(levels);
					}
					var zoom = (this.map.getNumZoomLevels() - 1) - levels;
					zoom = Math.min(Math.max(zoom, this.minLevel), this.map.getNumZoomLevels() - 1);
					this.map.zoomTo(zoom);
				}
			},

			/**
			 * APIMethod: passEventToSlider
			 * 这个函数通过滑块传递div或地图上发生的事件，然后移动
			 * 
			 * Parameters:
			 * evt - {<HGIS.Events>} 用来监听或者触发该控件上的事件。
			 */
			passEventToSlider : function(evt) {
				this.sliderEvents.handleBrowserEvent(evt);
			},

			/**
			 * APIMethod: zoomBarDown
			 * 点击滑块的事件监听器
			 * 
			 * Parameters:
			 * evt - {<HGIS.Events>} 用来监听或者触发该控件上的事件。
			 */
			zoomBarDown : function(evt) {
				if (!HGIS.Event.isLeftClick(evt) && !HGIS.Event.isSingleTouch(evt)) {
					return;
				}
				this.map.events.on({
					"touchmove" : this.passEventToSlider,
					"touchend" : this.passEventToSlider,
					"mousemove" : this.passEventToSlider,
					"mouseup" : this.passEventToSlider,
					"mouseout": this.passEventToSlider,
					scope : this
				});
				this.mouseDragStart = evt.xy.clone();
				this.zoomStart = evt.xy.clone();
				this.div.style.cursor = "pointer";
				this.zoombarDiv.offsets = null;
				HGIS.Event.stop(evt);
			},

			/**
			 * APIMethod: zoomBarDrag
			 * 客户点击后触发这个事件。必须确保滑块不超越缩放条div的底部或顶部，以及移动滑块以其新的视觉定位。
			 * 
			 * Parameters:
			 * evt - {<HGIS.Events>} 用来监听或者触发该控件上的事件。
			 */
			zoomBarDrag : function(evt) {
				if (this.mouseDragStart != null) {
					var deltaY = this.mouseDragStart.y - evt.xy.y;
					var newTop = parseInt(this.slider.style.top) - deltaY;
					if(newTop >= this.startTop && newTop <= this.startTop+parseInt(this.zoombarDiv.style.height)-12){
						this.slider.style.top = newTop + "px";
						this.mouseDragStart = evt.xy.clone();
					}
					this.deltaY = this.zoomStart.y - evt.xy.y;
					HGIS.Event.stop(evt);
				}
			},

			/**
			 * APIMethod: zoomBarUp
			 * 执行清理当MouseUp事件:发现新的缩放级别并切换到它。
			 * 
			 * Parameters:
			 * evt - {<HGIS.Events>} 用来监听或者触发该控件上的事件。
			 */
			zoomBarUp : function(evt) {
				if (!HGIS.Event.isLeftClick(evt) && evt.type !== "touchend") {
					return;
				}
				if(evt.type=="mouseout"){
					if(evt.xy.x<70 && evt.xy.x>-50 && evt.xy.y>-70 && evt.xy.y<80){
						return;
					}
				}
				if (this.mouseDragStart) {
					this.div.style.cursor = "";
					this.map.events.un({
						"touchmove" : this.passEventToSlider,
						"touchend" : this.passEventToSlider,
						"mouseup" : this.passEventToSlider,
						"mousemove" : this.passEventToSlider,
						"mouseout": this.passEventToSlider,
						scope : this
					});
					var zoomLevel = this.map.zoom + Math.round(this.deltaY / this.zoomStopHeight);
					zoomLevel = Math.min(Math.max(zoomLevel, this.minLevel), this.map.getNumZoomLevels() - 1);
					this.map.zoomTo(zoomLevel);
					this.mouseDragStart = null;
					this.zoomStart = null;
					this.deltaY = 0;
					HGIS.Event.stop(evt);
				}
			},
			/**
			 * APIMethod: moveZoomBar
			 * 改变滑块的位置来匹配当前的缩放级别
			 */
			moveZoomBar : function() {
				var newTop = ((this.map.getNumZoomLevels() - 1) - this.map.getZoom()) * this.zoomStopHeight
						+ this.startTop;
				this.slider.style.top = newTop + "px";
				this.slider.title = this.map.getZoom();
			},
			CLASS_NAME : "HGIS.Control.PanZoomBarEx"
		});/**
 * Class: HGIS.Control.RightMenu
 * 鼠标右键菜单类。
 * 这个类提供了两个选项：地图或feature的右键菜单，二者至少选其一,暂只支持一级菜单。
 * 
 */       
HGIS.Control = HGIS.Control || {};
HGIS.Control.RightMenu = function(_map, mapMenus, featureMenus,
		mapMenusContainerSize, featureMenusContainerSize) {
	
	var _rself = this;
	
	/**
	 * APIProperty: pixelTolerance
	 * 鼠标右键单击位置与意图位置之间的像素容差。
	 * 特别地，对于地物要素feature，在距离该要素pixelTolerance个像素以内，我们都认为触发了该要素的右键事件，默认15个像素。
	 */
	_rself.pixelTolerance = 15;// 
	
	/**
	 * APIProperty: postion
	 * {pixel} 菜单窗口所在右上角的位置。
	 */
	_rself.postion;
	
	
		
	/**
	 * Constructor: HGIS.Control.RightMenu
	 * 构造一个右键菜单对象。
	 * 
	 * Parameters:
	 *  _map - {<HGIS.MapEx>} 对图对象
	 *  mapMenusContainerSize - {<HGIS.Size>} 地图菜单窗口大小,可选参数。
	 *  featureMenusContainerSize - {<HGIS.Size>} 要素菜单窗口大小 可选参数。
	 *  mapMenus - {Object} 地图上的菜单数组，需符合以下格式:
	 *   [{ "itemText" : "菜单项名称", "itemID" : "菜单项ID",	"evt":自定义处理器];
	 *  
	 *  featureMenus - {Object} 矢量要素的菜单项，需符合以下格式：
	 *  (code)
	 *   [ {"layer" : {HGIS.Layer.Vector},//矢量要素所在的图层
	 *       "featureMenus" : [
	 *       	{ "itemText" : "地物操作1", "itemID" : "zoomInL", "evt" : function(feature) { alert("这个地物要素的标识为:" + feature.id);},
	 *    	    { "itemText" : "地物操作2","itemID" : "zoomIn2L", "evt" :	 function(feature) { alert("feature~地理要素已经获取，可以进行下一步操作");},
	 *    			......
	 *    		],
	 *        "pixTolerance" : 15
	 *       }
	 *    ];
	 *  (end)
	 * 
	 * 
	 * 
	 *             
	 *            
	 *  参考示例: 
	 *  (code)
	 *  var mapMenus = [ {
	 *		"itemText" : "放大测试",
	 *		"itemID" : "zoomInId",
	 *		"cssText" : "width:50px;height:30px;color:blue",
	 *		"evt" : function() {
	 *			map.zoomIn();
	 *		}
	 *	}, {
	 *		"itemText" : "放大再测试",
	 *		"itemID" : "zoomIn2Id",
	 *		"cssText" : "width:80px;height:30px;color:red",
	 *		"evt" : function() {
	 *			map.zoomIn();
	 *		}
	 *	} ];
	 *	// 地物要素的的菜单项
	 *	var featureMenus = [ {
	 *		"layer" : vlayer,// 矢量要素所在的图层
	 *		"featureMenus" : [ {
	 *			"itemText" : "地物操作1",
	 *			"itemID" : "zoomInL",
	 *			"evt" : function(feature) {
	 *				alert("这个地物要素的标识为:" + feature.id);
	 *
	 *			}
	 *		}, {
	 *			"itemText" : "地物操作1",
	 *			"itemID" : "zoomIn2L",
	 *			"evt" : function(feature) {
	 *				alert("feature~地理要素已经获取，可以进行下一步操作");
	 *			}
	 *		} ],
	 *		"pixTolerance" : 30
	 *	} ];
	 *	var mapMenusContainerSize = new HGIS.Size(200, 70);
	 *	var featureMenusContainerSize = new HGIS.Size(200, 300);
	 *	var rightMenu = new HGIS.Control.RightMenu(map, mapMenus, featureMenus, mapMenusContainerSize, featureMenusContainerSize);//注册右键菜单对象
	 *	rightMenu.show(function(p) {//启用并显示
	 *		//alert(p);
	 *	});
	 *	rightMenu.hide();
	 * (end)
	 */

	_map.events.register("mousemove", _map, function(e) {
		_rself.postion = this.events.getMousePosition(e);
	});
	this.popup = null;
	
	/**
	 * APIProperty: defaultMenuItemStyle
	 * {Object} 默认的菜单样式,json对象。
	 * 可自行设定，示例：
	 * 
	 * (code)
	 * var rightMenu = new HGIS.RightMenu(map, mapMenus, featureMenus,size);
	 * rightMenu.defaultMenuItemStyle={
	 *	    fontSize : "12px",
	 *	    height : "16px",
	 *	    paddingLeft : "22px",
	 *	    background : "#red",
	 *	    margin : "2px",
	 *	    opacity : "0.7",
	 *	    cursor : "default",
	 *	    listStyleType : "square"
	 *  };
	 * (end)
	 */
	_rself.defaultMenuItemStyle = {// 默认的菜单项样式
		fontSize : "50px",
		height : "50px",
		paddingLeft : "2px",
		background : "#red",
		listStyleType : "square"
	};

	/**
	 * APIMethod: hide
	 * 隐藏右键菜单
	 * 
	 * 示例：
	 * (code)
	 *   var rightMenu = new HGIS.RightMenu(map, mapMenus, featureMenus,size);
	 *   rightMenu.show(function(pixel){
     *  	 alert(pixel);
	 *    });
	 * (end)
	 */
	_rself.hide = function() {
		if (_rself.popup != null) {
			_map.removePopup(_rself.popup);
		}
	};
	// 创建右键菜单页面元素
	_rself.creatMenuHtml = function(menus, style) {
		var div = document.createElement("div");
		var ul = document.createElement("ul");
		for (var m = 0; m < menus.length; m = m + 1) {
			var subItem = document.createElement("li");
			subItem.id = menus[m].itemID;
			subItem.innerHTML = menus[m].itemText;
			subItem.style.cssText = menus[m].cssText;
			ul.appendChild(subItem);
		}
		div.appendChild(ul);
		return div.innerHTML;

	};
	/**
	 * APIMethod: unRegister
	 * 注销右键菜单
	 */
	_rself.unRegister = function() {
		_map.div.oncontextmenu = null;
	};


	
	
	_rself.show = function(callback) {
		_map.events.register("click", _map, function(evt) {
			_rself.hide();
		});
		_map.div.oncontextmenu = function(e) {
			e = e || event;
			var thisObj = this;
			// var flag = size ? false : true;// 弹框样式，大小
			var currentFeature;
			// 获取鼠标当前位置的经纬度及其几何信息,考虑到浏览器的兼容性。需对IE特别处理

			var pixel = null;
			var browersType = HGIS.Utils.getExploreType();// 浏览器类型

			var pixel = {};
			var lonlat;

			if (browersType == "MSIE") {
				pixel = _rself.postion;// 鼠标移动的当前位置就是pixel
				lonlat = _map.getLonLatFromPixel(pixel);
			} else {
				// 其它浏览器
				pixel = _rself.postion;// 鼠标移动的当前位置就是pixel
				lonlat = _map.getLonLatFromViewPortPx(pixel);
			}
			callback(pixel);
			_rself.evtPxy = pixel;
			_rself.postion = new HGIS.Geometry.Point(lonlat.lon, lonlat.lat);
			// 显示地图菜单，而非图层相关的菜单
			this.showMapMenus = function() {
				if (mapMenus != null) {
					var htmlContent = _rself.creatMenuHtml(mapMenus,
							"font-color:red");
					if (_rself.popup != null) {
						_map.removePopup(_rself.popup);
					}
					_rself.popup = new HGIS.Popup("tempPopue", lonlat, null,
							htmlContent, false);
					if (mapMenusContainerSize) {
						_rself.popup.setSize(mapMenusContainerSize);
					} else {
						_rself.popup.autoSize = true;
					}

					// popup.autoSize = flag;
					_map.addPopup(_rself.popup);
					for (var m = 0; m < mapMenus.length; m = m + 1) {// 菜单项事件注册注册
						var menuId = mapMenus[m].itemID;
						document.getElementById(menuId).onclick = function(e) {
							for (var p = 0; p < mapMenus.length; p = p + 1) {
								if (mapMenus[p].itemID == this.id) {
									mapMenus[p].evt(e);
									_rself.hide();
								}
							}
						}
					}
				}
			};
			
			this.showLayerMenus = function(features, layerMenu, pixTolerance) {
				var thisObj = this;
				var curFeature;
				var flag = false;
				// var features = points;//////////////
				// / 这块要换下，判断图层类型，用geometry点状组装features,

				// 判断图层中的地理要素所在像素位置与当前鼠标像素位置之间的关系
				for (var k = 0; k < features.length; k = k + 1) {
					// 鼠标位置与当前矢量要素的地理距离，地图单位
					var geoDis = _rself.postion.distanceTo(
							features[k].geometry, {
								edge : false
							});
					var pixDis = Math.round(geoDis / _map.resolution);// 转换成像素距离
					if (pixDis <= pixTolerance) {// 若鼠标位置像素小于或者等于用户容差值，则认为鼠标单击的是某一图层上的某个要素
						flag = true;
						var htmlContent = _rself.creatMenuHtml(layerMenu);
						if (_rself.popup != null) {
							_map.removePopup(_rself.popup);
						}
						_rself.popup = new HGIS.Popup("tempPopue", lonlat,
								null, htmlContent, false);
						if (featureMenusContainerSize) {
							_rself.popup.setSize(featureMenusContainerSize);
						} else {
							_rself.popup.autoSize = flag;
						}

						_map.addPopup(_rself.popup);
						currentFeature = features[k];// 目前右击的的就是这个feature
						break;
					}
				}
				if (flag) {// 在右击选中的情况下，注册菜单项事件
					for (var o = 0; o < layerMenu.length; o = o + 1) {
						var menuId = layerMenu[o].itemID;
						document.getElementById(menuId).onclick = function(e) {
							for (var p = 0; p < layerMenu.length; p = p + 1) {
								if (layerMenu[p].itemID == this.id) {
									layerMenu[p].evt(currentFeature);
									_rself.hide();
								}
							}
						};
					}
				}
				return flag;
			};

			
			/**
			 * APIMethod: show
			 * 显示右键菜单。
			 * 根据鼠标位置确定要显示的右键菜单类型--地图菜单还是矢量图层菜单。如果没有选中地物，则默认显示地图右键菜单，否则显示矢量图层上某一地理要素的相关菜单。
			 */
			this.show = function() {
				// 首先清除掉其它右键菜单，并确定图层选项存在
				_rself.hide();
				if (featureMenus && featureMenus.length > 0) {
					for (var i = 0; i < featureMenus.length; i = i + 1) {
						// 获取图层选项中的相关信息
						var vlayer = featureMenus[i].layer;
						var layerMenu = featureMenus[i].featureMenus;
						var thisPixBuffer = vlayer.pixTolerance ? vlayer.pixTolerance
								: _rself.pixelTolerance;
						if (vlayer.CLASS_NAME == "HGIS.Layer.Vector"
								|| "HGIS.Layer.Markers" == vlayer.CLASS_NAME) {// 首先确定当前图层是个矢量图层。
							var features = [];
							if (vlayer.CLASS_NAME == "HGIS.Layer.Vector") {
								features = vlayer.features;
							}
							if ("HGIS.Layer.Markers" == vlayer.CLASS_NAME) {
								var markers = vlayer.markers;
								for (var m = 0; m < vlayer.markers.length; m = m + 1) {
									var lonlat = vlayer.markers[i].lonlat;
									var geom = new HGIS.Geometry.Point(
											lonlat.lon, lonlat.lat);
									var vector = new HGIS.Feature.Vector(geom);
									features.push(vector);
								}
							}

							var flag = this.showLayerMenus(features, layerMenu,
									thisPixBuffer);
							if (!flag) {// 已找到，并且注册了右键菜单事件，则推测退出循环。否则继续寻找下一个右键菜单事件
								this.showMapMenus();
							}
							break;
						} else { // 图层的菜单为空时，所有单击都显示右键菜单
							this.showMapMenus();
						}
					}
				} else {
					// 图层选项不设置时，显示地图右键菜单
					this.showMapMenus();
				}
			};
			this.show();// 直接调用
			return false;
		};
	};
};/**
 * Class: HGIS.Control.ScaleLineEx 
 * 地图比例尺控件,比例尺显示单位的语言按照初始化时设置的语言显示。
 * 
 * 继承自: 
 * - <HGIS.Control.ScaleLine>
 * 
 * Examples: 
 * (code) 
 * var scaleLine=new HGIS.Control.ScaleLineEx(); 
 * var mapOption = { controls : [scaleLine],
 * 					 numZoomLevels : 18 }; 
 * map = new HGIS.MapEx("hmap", mapOption); 
 * (end)
 */
HGIS.Control = HGIS.Control || {};
HGIS.Control.ScaleLineEx = HGIS.Class(HGIS.Control.ScaleLine, {
	/**
	 * Constructor: HGIS.Control.ScaleLineEx 
	 * 构造方法
	 *  
	 */
	initialize : function() {
		// 比例尺显示单位按照初始化时设置的语言显示		
		var opts = {
			topOutUnits : HGIS.language[HGIS.InitParam.language]["km"],
			topInUnits : HGIS.language[HGIS.InitParam.language]["m"],
			bottomOutUnits : "",
			bottomInUnits : ""
		};		

		HGIS.Control.ScaleLine.prototype.initialize.apply(this, [ opts ]);
	},
    draw: function() {    	
    	this.displayClass="olControlScaleLine";
        HGIS.Control.prototype.draw.apply(this, arguments);
        if (!this.eTop) {
            // stick in the top bar
            this.eTop = document.createElement("div");
            this.eTop.className = this.displayClass + "Top";
            var theLen = this.topInUnits.length;
            this.div.appendChild(this.eTop);
            if((this.topOutUnits == "") || (this.topInUnits == "")) {
                this.eTop.style.visibility = "hidden";
            } else {
                this.eTop.style.visibility = "visible";
            }

            // and the bottom bar
            this.eBottom = document.createElement("div");
            this.eBottom.className = this.displayClass + "Bottom";
            this.div.appendChild(this.eBottom);
            if((this.bottomOutUnits == "") || (this.bottomInUnits == "")) {
                this.eBottom.style.visibility = "hidden";
            } else {
                this.eBottom.style.visibility = "visible";
            }
        }
        this.map.events.register('moveend', this, this.update);
        this.update();
        return this.div;
    },
	CLASS_NAME : "HGIS.Control.ScaleLineEx "
});/**
 * Class: HGIS.Control.ZoomAnimation
 * 用鼠标滚轮滚动来缩放地图时的动画效果控件,添加该控件后在使用鼠标进行缩放时在地图中心点会出现缩放的动画效果
 * 
 * 继承自:
 *  - <HGIS.Control.Navigation>
 * 
 * Examples:
 * (code)
 * var map = new HGIS.MapEx("hmap");
 * var options= {
 * 		map: map // 需要在此绑定地图对象
 * };
 * var zoomAnimation = new HGIS.Control.ZoomAnimation({});
 * map.addControl( zoomAnimation );
 * (end)
 */
HGIS.Control = HGIS.Control || {};
HGIS.Control.ZoomAnimation = HGIS.Class(HGIS.Control.Navigation, {
	size:null,
	offset:null,
	uricon:null,
	ulicon:null,
	bricon:null,
	blicon:null,
	imgPath:APIAdress + "gisapi/theme/img/gis/navi/",
    // 拖动的滑动效果必须使enableKinetic为true
	dragPanOptions: {enableKinetic: false},
	isCenterMouseWheel:true,
	isCartoonPlay:false,
	markers : null,
	marker1: null,
	marker2: null,
	marker3: null,
	marker4: null,
	initialize: function(options) {
		if(options == undefined){
			if(map !== undefined){this.map = map}
		}else{
			if(options.map == undefined){
				if(map !== undefined){this.map = map}
			}else{
				this.map = options.map;
			}
		}
        HGIS.Control.Navigation.prototype.initialize.apply(this, arguments);  
        if(this.map){			
    		this.size = new HGIS.Size(7,7);//10,6
    		this.offset = new HGIS.Pixel(-(this.size.w/2), -(this.size.h/2));
    		    
    		this.uricon = new HGIS.Icon(this.imgPath+"ur.png",this.size,this.offset);
    		this.ulicon = new HGIS.Icon(this.imgPath+"ul.png",this.size,this.offset);
    		this.bricon = new HGIS.Icon(this.imgPath+"br.png",this.size,this.offset);
    		this.blicon = new HGIS.Icon(this.imgPath+"bl.png",this.size,this.offset);
    	    
    		this.markers=new HGIS.Layer.Markers("Zoomin",{displayInLayerSwitcher: false});
    		
    		this.marker1 = new HGIS.Marker(this.map.getCenter(),this.bricon);
    		this.marker2 = new HGIS.Marker(this.map.getCenter(),this.blicon);
    		this.marker3 = new HGIS.Marker(this.map.getCenter(),this.uricon);
    		this.marker4 = new HGIS.Marker(this.map.getCenter(),this.ulicon); 
    		this.marker1.map = this.map ;
    		this.marker2.map = this.map ;
    		this.marker3.map = this.map ;
    		this.marker4.map = this.map ;
    		 
    		this.markers.addMarker(this.marker1);
    		this.markers.addMarker(this.marker2);
    		this.markers.addMarker(this.marker3);
    		this.markers.addMarker(this.marker4);
    		this.markers.setVisibility(false);
    		this.map.addLayer(this.markers);
    	  }
    },
	destroy : function() {
		HGIS.Control.prototype.destroy.apply(this);
	},
    
    wheelUp: function(evt) {
	    if(!(this.map&&this.markers))
		   return;
        var newZoom = this.map.getZoom();
        if (newZoom<this.map.getNumZoomLevels()-1 && !this.isCartoonPlay) {  
        	 this.isCartoonPlay = true;	  
             this.markers.setVisibility(true);			 
	        var x=evt.xy.x;
	        var y=evt.xy.y;	  
			if(this.marker1&&this.marker2&&this.marker3&&this.marker4){				  
			    this.marker1.icon = this.bricon;
		        this.marker2.icon = this.blicon;
		        this.marker3.icon = this.uricon;
		        this.marker4.icon = this.ulicon;	
				
			    this.marker1.draw(new HGIS.Pixel(x+30,y+23));
		        this.marker2.draw(new HGIS.Pixel(x-30,y+23));
		        this.marker3.draw(new HGIS.Pixel(x+30,y-23));
		        this.marker4.draw(new HGIS.Pixel(x-30,y-23));			
			}	 
		 
		    var j=0;
		    var t;
		   
		    var _self = this;
		    var movemarker=function(){
			       j++;
		           _self.marker1.moveTo(new HGIS.Pixel(x+30+6*j,y+23+4*j));
		           _self.marker2.moveTo(new HGIS.Pixel(x-30-6*j,y+23+4*j));
		           _self.marker3.moveTo(new HGIS.Pixel(x+30+6*j,y-23-4*j));
		           _self.marker4.moveTo(new HGIS.Pixel(x-30-6*j,y-23-4*j));
		            if(j==5){	   
		            	_self.isCartoonPlay = false;  
						_self.markers.setVisibility(false);
				        window.clearInterval(t);
			        }
		    };
		    t=window.setInterval(function(){movemarker();}, 100);
        }
        this.wheelChange(evt, 1);  
    },

  
    wheelDown: function(evt) {
	    if(!(this.map&&this.markers))
		   return;
        var newZoom = this.map.getZoom();
        if (newZoom>this.map.minLevel && !this.isCartoonPlay) {                   
        	this.isCartoonPlay = true;	
            this.markers.setVisibility(true);			 			
	        var x=evt.xy.x;
	        var y=evt.xy.y;		
			if(this.marker1&&this.marker2&&this.marker3&&this.marker4){
			    this.marker1.icon = this.ulicon;
		        this.marker2.icon = this.uricon;
		        this.marker3.icon = this.blicon;
		        this.marker4.icon = this.bricon;
				
			    this.marker1.draw(new HGIS.Pixel(x+60,y+45));
		        this.marker2.draw(new HGIS.Pixel(x-60,y+45));
		        this.marker3.draw(new HGIS.Pixel(x+60,y-45));
		        this.marker4.draw(new HGIS.Pixel(x-60,y-45));			
			}		   	   
		    var j=0;
		    var t;
		    var _self = this;		       		   
		    var movemarker=function(){
			       j++;
		           _self.marker1.moveTo(new HGIS.Pixel(x+60-6*j,y+45-4*j));
		           _self.marker2.moveTo(new HGIS.Pixel(x-60+6*j,y+45-4*j));
		           _self.marker3.moveTo(new HGIS.Pixel(x+60-6*j,y-45+4*j));
		           _self.marker4.moveTo(new HGIS.Pixel(x-60+6*j,y-45+4*j));
		           if(j==5){	       
		        	   _self.isCartoonPlay = false;	
						_self.markers.setVisibility(false);			 					   
				        window.clearInterval(t);
			        }
		    };
		    t=window.setInterval(function(){movemarker();}, 100);
	    } 
	    this.wheelChange(evt, -1); 
    },
    wheelChange: function(evt, deltaZ) {
        var currentZoom = this.map.getZoom();
        var newZoom = this.map.getZoom() + Math.round(deltaZ);
        //修改达到最小级别时，不进行操作
        if(HGIS.InitParam.minLevel){
			newZoom = Math.max(newZoom, HGIS.InitParam.minLevel);
		}else{
			newZoom = Math.max(newZoom, 0);
		}
        newZoom = Math.min(newZoom, this.map.getNumZoomLevels());
        if (newZoom === currentZoom) {
            return;
        }
        var size    = this.map.getSize();
        var deltaX  = size.w/2 - evt.xy.x;
        var deltaY  = evt.xy.y - size.h/2;
        var newRes  = this.map.baseLayer.getResolutionForZoom(newZoom);
        var zoomPoint = this.map.getLonLatFromPixel(evt.xy);
        var newCenter = new HGIS.LonLat(
                            zoomPoint.lon + deltaX * newRes,
                            zoomPoint.lat + deltaY * newRes );
        if(this.isCenterMouseWheel)
            this.map.setCenter( newCenter, newZoom );
        else
            this.map.setCenter(this.map.getCenter(),  this.map.getZoom() + Math.round(deltaZ));
        
    },
	CLASS_NAME : "HGIS.Control.ZoomAnimation"
});
/**
 * 
 */
HGIS.Converter=HGIS.Converter||{};
HGIS.Converter.BaiduConverter={
	lonlat2Merctor:function(p){
		var arr = null;
		var n_lat = p[1] > 74 ? 74 : p[1];
		n_lat = n_lat < -74 ? -74 : n_lat;
		for (var i = 0; i < HGIS.Converter.BaiduConverter.array1.length; i++) {
			if (p[1] >= HGIS.Converter.BaiduConverter.array1[i]) {
				arr = HGIS.Converter.BaiduConverter.array2[i];
				break;
			}
		}
		if (arr == null) {
			for (var i = HGIS.Converter.BaiduConverter.array1.length - 1; i >= 0; i--) {
				if (p[1] <= -HGIS.Converter.BaiduConverter.array1[i]) {
					arr = HGIS.Converter.BaiduConverter.array2[i];
					break;
				}
			}
		}
		var res = this.convertor(p[0], p[1], arr);
		return res;
	},
	convertor:function(x, y, param) {
		var T = param[0] + param[1] * Math.abs(x);
		var cC = Math.abs(y) / param[9];
		var cF = param[2] + param[3] * cC + param[4] * cC * cC + param[5]
				* cC * cC * cC + param[6] * cC * cC * cC * cC + param[7] * cC
				* cC * cC * cC * cC + param[8] * cC * cC * cC * cC * cC * cC;
		T *= (x < 0 ? -1 : 1);
		cF *= (y < 0 ? -1 : 1);
		return [T, cF];
	}
};
HGIS.Converter.BaiduConverter.array1=[75, 60, 45, 30, 15, 0];
HGIS.Converter.BaiduConverter.array3=[ 12890594.86, 8362377.87, 5591021,3481989.83, 1678043.12, 0 ];
HGIS.Converter.BaiduConverter.array2=[
    	[-0.0015702102444, 111320.7020616939,
		1704480524535203.0, -10338987376042340.0,
		26112667856603880.0, -35149669176653700.0,
		26595700718403920.0, -10725012454188240.0,
		1800819912950474.0, 82.5],
		[0.0008277824516172526, 111320.7020463578,
		647795574.6671607, -4082003173.641316, 10774905663.51142,
		-15171875531.51559, 12053065338.62167, -5124939663.577472,
		913311935.9512032, 67.5],
		[ 0.00337398766765, 111320.7020202162,
			4481351.045890365, -23393751.19931662, 79682215.47186455,
			-115964993.2797253, 97236711.15602145, -43661946.33752821,
			8477230.501135234, 52.5],
		[0.00220636496208, 111320.7020209128,
			51751.86112841131, 3796837.749470245, 992013.7397791013,
			-1221952.21711287, 1340652.697009075, -620943.6990984312,
			144416.9293806241, 37.5],
		[-0.0003441963504368392, 111320.7020576856,
			278.2353980772752, 2485758.690035394, 6070.750963243378,
			54821.18345352118, 9540.606633304236, -2710.55326746645,
			1405.483844121726, 22.5],
		[-0.0003218135878613132, 111320.7020701615,
			0.00369383431289, 823725.6402795718, 0.46104986909093,
			2351.343141331292, 1.58060784298199, 8.77738589078284,
			0.37238884252424, 7.45]
   ];
HGIS.Converter.BaiduConverter.array4=[
     	[1.410526172116255e-8, 0.00000898305509648872,
			-1.9939833816331, 200.9824383106796, -187.2403703815547,
			91.6087516669843, -23.38765649603339, 2.57121317296198,
			-0.03801003308653, 17337981.2],
		[-7.435856389565537e-9, 0.000008983055097726239,
			-0.78625201886289, 96.32687599759846, -1.85204757529826,
			-59.36935905485877, 47.40033549296737, -16.50741931063887,
			2.28786674699375, 10260144.86],
		[-3.030883460898826e-8, 0.00000898305509983578,
			0.30071316287616, 59.74293618442277, 7.357984074871,
			-25.38371002664745, 13.45380521110908, -3.29883767235584,
			0.32710905363475, 6856817.37],
		[-1.981981304930552e-8, 0.000008983055099779535,
			0.03278182852591, 40.31678527705744, 0.65659298677277,
			-4.44255534477492, 0.85341911805263, 0.12923347998204,
			-0.04625736007561, 4482777.06],
		[3.09191371068437e-9, 0.000008983055096812155,
			0.00006995724062, 23.10934304144901, -0.00023663490511,
			-0.6321817810242, -0.00663494467273, 0.03430082397953,
			-0.00466043876332, 2555164.4],
		[2.890871144776878e-9, 0.000008983055095805407,
			-3.068298e-8, 7.47137025468032, -0.00000353937994,
			-0.02145144861037, -0.00001234426596, 0.00010322952773,
			-0.00000323890364, 826088.5]
     ];/**
 * 
 */
var HGIS=HGIS||{};
HGIS.Converter=HGIS.Converter||{};
/**
 * Method: encryToGCJ02
 * 将数据加密到gcj02火星坐标系下
 */
HGIS.Converter.encryToGCJ02=function(point){
	var num=point.x*3686400.0;
	var num2=point.y*3686400.0;
	var num3=0.0;
	var num4=0.0;
	var num5=0.0;
	var newpoint=HGIS.Converter.wgtochina_lb(1,Math.floor(num), Math.floor(num2), Math.floor(num5), Math.floor(num3), Math.floor(num4));
	var num6=newpoint.x;
	var num7=newpoint.y;
	num6 /= 3686400.0;
	num7 /= 3686400.0;
	point.x=num6;
	point.y=num7;
	return point;
}
/**
 * 转换方法中的常量
 */
HGIS.Converter.params={
	casm_f :0.0,
	casm_rr:0.0,
	casm_t1:0.0,
	casm_t2:0.0,
	casm_x1:0.0,
	casm_x2:0.0,
	casm_y1:0.0,
	casm_y2:0.0
}
HGIS.Converter.wgtochina_lb=function(wg_flag,wg_lng,wg_lat,wg_heit,wg_week,wg_time){
	var point= new HGIS.Geometry.Point();
	point.x=wg_lng;
	point.y=wg_lat;
	if(wg_heit<=5000){
		var num=wg_lng;
		num=num/3686400.0;
		var x=wg_lat;
		x=x/3686400.0;
		if(num<72.004000000000005){
			return point;
		}
		if (num > 137.8347) {
			return point;
		}
		if (x < 0.8293) {
			return point;
		}
		if (x > 55.827100000000002) {
			return point;
		}
		if (wg_flag == 0) {
			HGIS.Converter.iniCasm(wg_time, wg_lng, wg_lat);
			point = new HGIS.Geometry.Point();
			point.x=wg_lng;
			point.y=wg_lat;
			return point;
		}
		HGIS.Converter.params.casm_t2=wg_time;
		var num3=(HGIS.Converter.params.casm_t2-HGIS.Converter.params.casm_t1)/1000.0;
		if(num3<=0.0){
			HGIS.Converter.params.casm_t1 = HGIS.Converter.params.casm_t2;
			HGIS.Converter.params.casm_f += 1.0;
			HGIS.Converter.params.casm_x1 = HGIS.Converter.params.casm_x2;
			HGIS.Converter.params.casm_f += 1.0;
			HGIS.Converter.params.casm_y1 = HGIS.Converter.params.casm_y2;
			HGIS.Converter.params.casm_f += 1.0;
		}else if(num3 > 120.0){
			if (HGIS.Converter.params.casm_f == 3.0) {
				HGIS.Converter.params.casm_f = 0.0;
				HGIS.Converter.params.casm_x2 = wg_lng;
				HGIS.Converter.params.casm_y2 = wg_lat;
				var num4 = HGIS.Converter.params.casm_x2 - HGIS.Converter.params.casm_x1;
				var num5 = HGIS.Converter.params.casm_y2 - HGIS.Converter.params.casm_y1;
				var num6 = Math.sqrt(num4 * num4 + num5 * num5) / num3;
				if (num6 > 3185.0) {
					return point;
				}
			}
			HGIS.Converter.params.casm_t1 = HGIS.Converter.params.casm_t2;
			HGIS.Converter.params.casm_f += 1.0;
			HGIS.Converter.params.casm_x1 = HGIS.Converter.params.casm_x2;
			HGIS.Converter.params.casm_f += 1.0;
			HGIS.Converter.params.casm_y1 = HGIS.Converter.params.casm_y2;
			HGIS.Converter.params.casm_f += 1.0;
		}
		var xx = HGIS.Converter.transform_yj5(num - 105.0, x - 35.0);
		var yy = HGIS.Converter.transform_yjy5(num - 105.0, x - 35.0);
		var num9 = wg_heit;
		xx = xx + num9 * 0.001 + HGIS.Converter.yj_sin2(wg_time * 0.0174532925199433) + HGIS.Converter.random_yj();
		yy = yy + num9 * 0.001 + HGIS.Converter.yj_sin2(wg_time * 0.0174532925199433) + HGIS.Converter.random_yj();
		point = new HGIS.Geometry.Point();
		point.x=(num + HGIS.Converter.transform_jy5(x, xx)) * 3686400.0;
		point.y=(x + HGIS.Converter.transform_jyj5(x, yy)) * 3686400.0;
	}
	return point;
}
HGIS.Converter.transform_jy5=function(x, xx) {
	var num = 6378245.0;
	var num2 = 0.00669342;
	var num3 = Math.sqrt(1.0 - num2 * HGIS.Converter.yj_sin2(x * 0.0174532925199433) * HGIS.Converter.yj_sin2(x * 0.0174532925199433));
	return xx * 180.0 / (num / num3 * Math.cos(x * 0.0174532925199433) * 3.1415926);
}
HGIS.Converter.transform_jyj5=function(x, yy) {
	var num = 6378245.0;
	var num2 = 0.00669342;
	var d = 1.0 - num2 * HGIS.Converter.yj_sin2(x * 0.0174532925199433) * HGIS.Converter.yj_sin2(x * 0.0174532925199433);
	var num4 = num * (1.0 - num2) / (d * Math.sqrt(d));
	return yy * 180.0 / (num4 * 3.1415926);
}
HGIS.Converter.transform_yj5=function(x,y) {
	var num = 300.0 + 1.0 * x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.sqrt(x * x));
	num = num + (20.0 * HGIS.Converter.yj_sin2(18.849555921538762 * x) + 20.0 * HGIS.Converter.yj_sin2(6.283185307179588 * x)) * 0.6667;
	num = num + (20.0 * HGIS.Converter.yj_sin2(3.141592653589794 * x) + 40.0 * HGIS.Converter.yj_sin2(1.047197551196598 * x)) * 0.6667;
	return num + (150.0 * HGIS.Converter.yj_sin2(0.2617993877991495 * x) + 300.0 * HGIS.Converter.yj_sin2(0.1047197551196598 * x)) * 0.6667;
}

HGIS.Converter.transform_yjy5=function(x,y) {
	var num = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.sqrt(x * x));
	num = num + (20.0 * HGIS.Converter.yj_sin2(18.849555921538762 * x) + 20.0 * HGIS.Converter.yj_sin2(6.283185307179588 * x)) * 0.6667;
	num = num + (20.0 * HGIS.Converter.yj_sin2(3.141592653589794 * y) + 40.0 * HGIS.Converter.yj_sin2(1.047197551196598 * y)) * 0.6667;
	return num + (160.0 * HGIS.Converter.yj_sin2(0.2617993877991495 * y) + 320.0 * HGIS.Converter.yj_sin2(0.1047197551196598 * y)) * 0.6667;
}
HGIS.Converter.yj_sin2=function(x) {
	var num = 0.0;
	if (x < 0.0) {
		x = -x;
		num = 1.0;
	}
	var num2 = Math.floor(x / 6.28318530717959);
	var num3 = x - num2 * 6.28318530717959;
	if (num3 > 3.141592653589793) {
		num3 -= 3.141592653589793;
		if (num == 1.0) 
			num = 0.0;
		else if (num == 0.0) {
			num = 1.0;
		}
	}
	x = num3;
	var num4 = x;
	var num5 = x;
	num3 *= num3;
	num5 *= num3;
	num4 -= num5 * 0.166666666666667;
	num5 *= num3;
	num4 += num5 * 0.00833333333333333;
	num5 *= num3;
	num4 -= num5 * 0.000198412698412698;
	num5 *= num3;
	num4 += num5 * 2.75573192239859E-006;
	num5 *= num3;
	num4 -= num5 * 2.50521083854417E-008;
	if (num == 1.0) {
		num4 = -num4;
	}
	return num4;
}
HGIS.Converter.random_yj=function() {
	var num = 314159269.0;
	var num2 = 453806245.0;
	HGIS.Converter.params.casm_rr = (num * HGIS.Converter.params.casm_rr + num2);
	var num3 = Math.floor(HGIS.Converter.params.casm_rr / 2.0);
	HGIS.Converter.params.casm_rr -= num3 * 2.0;
	HGIS.Converter.params.casm_rr /= 2.0;
	return HGIS.Converter.params.casm_rr;
}
HGIS.Converter.iniCasm=function(w_time, w_lng, w_lat) {
	HGIS.Converter.params.casm_t1 = w_time;
	HGIS.Converter.params.casm_t2 = w_time;
	var num = Math.floor(w_time / 0.357);
	HGIS.Converter.casm_rr = (w_time - num * 0.357);
	if (w_time == 0.0) {
		HGIS.Converter.casm_rr = 0.3;
	}
	HGIS.Converter.casm_x1 = w_lng;
	HGIS.Converter.casm_y1 = w_lat;
	HGIS.Converter.casm_x2 = w_lng;
	HGIS.Converter.casm_y2 = w_lat;
	HGIS.Converter.casm_f = 3.0;
};
HGIS.Converter = HGIS.Converter || {};
/**
 * Class: HGIS.Converter.Factor
 * 纠偏因子类
 */
HGIS.Converter.Factor = [ [ {
	"A" : 1.0684326783338971E-4,
	"B" : 8.66051312220506E-7,
	"C" : -8.752274616163902E-8,
	"D" : 0.9840204669920354,
	"E" : -6.944341288317446E-5,
	"F" : 0.5947895040908406,
	"H" : 1.1212168679997081E-5,
	"I" : -1.0503773125170035E-6,
	"J" : 1.0560942402842999E-4,
	"K" : -0.00161184354311672,
	"L" : 0.996267577676818,
	"M" : 0.09388707350672121
}, {
	"A" : 5.759953320083611E-6,
	"B" : 2.2826780754492404E-6,
	"C" : -1.626050349923247E-8,
	"D" : 0.999568552288622,
	"E" : -1.8362384490444583E-4,
	"F" : -0.003429403448535595,
	"H" : 1.1227426281928965E-5,
	"I" : -1.050486978515508E-6,
	"J" : 1.0560906793163904E-4,
	"K" : -0.0016590360327271014,
	"L" : 0.9962678919030559,
	"M" : 0.09727297328254281
}, {
	"A" : -9.695696775802176E-5,
	"B" : -3.253948595016709E-7,
	"C" : 1.7551849196273395E-8,
	"D" : 1.015589076650997,
	"E" : 1.866867629018998E-5,
	"F" : -0.6283507979096612,
	"H" : 1.1225813956322606E-5,
	"I" : -1.0502324916394912E-6,
	"J" : 1.0560870945997003E-4,
	"K" : -0.0017037141246589727,
	"L" : 0.9962681776334108,
	"M" : 0.10065511394509485
}, {
	"A" : 1.4045741890811314E-4,
	"B" : -5.54610415814949E-7,
	"C" : -7.375443911161739E-8,
	"D" : 0.9770161067678487,
	"E" : 3.7143692480867685E-5,
	"F" : 0.9380414753304649,
	"H" : 1.1204368821238209E-5,
	"I" : -1.0503129804773081E-6,
	"J" : 1.0560834661085816E-4,
	"K" : -0.0017451028476003216,
	"L" : 0.9962684904125432,
	"M" : 0.10399078643899884
}, {
	"A" : 4.643430893191969E-5,
	"B" : 1.7716330074080133E-6,
	"C" : -6.397600360585898E-8,
	"D" : 0.9925919041861562,
	"E" : -1.5870662470263142E-4,
	"F" : 0.2926152573818399,
	"H" : 1.12226336606569E-5,
	"I" : -1.0505567750174194E-6,
	"J" : 1.0560798828457285E-4,
	"K" : -0.0017929433971914932,
	"L" : 0.9962688167503835,
	"M" : 0.10767826023948146
}, {
	"A" : -6.147909858533751E-5,
	"B" : 9.586730032040691E-8,
	"C" : -3.241237345186221E-8,
	"D" : 1.0107141937760957,
	"E" : -1.9890926324706015E-5,
	"F" : -0.4684633264041622,
	"H" : 1.1225182811436252E-5,
	"I" : -1.0503995322430626E-6,
	"J" : 1.0560762982889105E-4,
	"K" : -0.0018382824889968674,
	"L" : 0.9962691094932303,
	"M" : 0.1113561774000118
}, {
	"A" : 1.603393008764442E-4,
	"B" : 5.425488196486583E-7,
	"C" : -7.434987270293902E-8,
	"D" : 0.9719954817576877,
	"E" : -6.065823077960886E-5,
	"F" : 1.2207928190655366,
	"H" : 1.120793084125049E-5,
	"I" : -1.0505168812624532E-6,
	"J" : 1.0560726895392225E-4,
	"K" : -0.0018801303229309951,
	"L" : 0.9962694261247051,
	"M" : 0.11497000206691155
}, {
	"A" : 4.4692840880156126E-5,
	"B" : 3.093951814969742E-6,
	"C" : 1.3843630464194234E-8,
	"D" : 0.9925444342214007,
	"E" : -2.934086928689794E-4,
	"F" : 0.3076353470023605,
	"H" : 1.1229294238052079E-5,
	"I" : -1.050731254892412E-6,
	"J" : 1.0560691353850293E-4,
	"K" : -0.0019287451473530837,
	"L" : 0.996269751344748,
	"M" : 0.11897002098339726
}, {
	"A" : -8.491042938807425E-5,
	"B" : 1.111065281556023E-6,
	"C" : 1.2112661584851026E-7,
	"D" : 1.0159129806353917,
	"E" : -1.1940314536218466E-4,
	"F" : -0.7459931200828578,
	"H" : 1.1233117256703729E-5,
	"I" : -1.050491371890061E-6,
	"J" : 1.056065577735299E-4,
	"K" : -0.0019743650051822215,
	"L" : 0.9962700355656189,
	"M" : 0.12293224708764683
}, {
	"A" : 1.2140892689949112E-4,
	"B" : 8.000137075026004E-7,
	"C" : 1.207043709428035E-7,
	"D" : 0.9774271868764117,
	"E" : -9.392455223178331E-5,
	"F" : 1.048412951069622,
	"H" : 1.1215253011648274E-5,
	"I" : -1.0505014974571125E-6,
	"J" : 1.0560619807647997E-4,
	"K" : -0.0020159188832380437,
	"L" : 0.9962703428500248,
	"M" : 0.12679369959414544
}, {
	"A" : 7.712507197332741E-7,
	"B" : 2.339344244983721E-6,
	"C" : 1.9372989457089318E-7,
	"D" : 1.0003272453144518,
	"E" : -2.452609933527583E-4,
	"F" : -0.03868005339245428,
	"H" : 1.1234706231322278E-5,
	"I" : -1.0506191660542008E-6,
	"J" : 1.0560584161500852E-4,
	"K" : -0.002064453903912522,
	"L" : 0.996270660157812,
	"M" : 0.13107142549006312
}, {
	"A" : -1.214177380961523E-4,
	"B" : -6.243407182360272E-7,
	"C" : 2.2170710245461578E-7,
	"D" : 1.0238277709271415,
	"E" : 3.874520709246099E-5,
	"F" : -1.1689172302321822,
	"H" : 1.123706355221632E-5,
	"I" : -1.0503272885875603E-6,
	"J" : 1.0560548211754894E-4,
	"K" : -0.002109853275669593,
	"L" : 0.9962709380520494,
	"M" : 0.1352954155890984
}, {
	"A" : 1.0249636068726531E-4,
	"B" : -1.6144931960226927E-6,
	"C" : 8.880406210387548E-8,
	"D" : 0.9793934172421643,
	"E" : 1.382848230093714E-4,
	"F" : 1.0351413606258575,
	"H" : 1.1221809897488111E-5,
	"I" : -1.0503503562464545E-6,
	"J" : 1.0560511661661387E-4,
	"K" : -0.002151713202664496,
	"L" : 0.9962712470558301,
	"M" : 0.13943145943267155
}, {
	"A" : 5.747904316066865E-6,
	"B" : -2.472491118510334E-7,
	"C" : 1.919367775826686E-9,
	"D" : 0.9989188637771349,
	"E" : 1.0847084297438414E-6,
	"F" : 0.04960703333745187,
	"H" : 1.1260428038450954E-5,
	"I" : -1.0505484493439354E-6,
	"J" : 1.0560475293061589E-4,
	"K" : -0.002204345217492687,
	"L" : 0.996271573820863,
	"M" : 0.14419582406981135
}, {
	"A" : -9.258474589768362E-5,
	"B" : -2.796405473182162E-6,
	"C" : -1.2228168810857198E-7,
	"D" : 1.0189657206996685,
	"E" : 2.658935503916382E-4,
	"F" : -0.9724204923022626,
	"H" : 1.1550048991393336E-5,
	"I" : -1.0503954405161053E-6,
	"J" : 1.0560438569645614E-4,
	"K" : -0.002309190988512455,
	"L" : 0.9962718651344744,
	"M" : 0.151764885378725
}, {
	"A" : 1.4832626502259139E-4,
	"B" : -2.8982093502882833E-6,
	"C" : -3.656386609041107E-7,
	"D" : 0.9682589872228391,
	"E" : 2.822573073899548E-4,
	"F" : 1.6953457753734256,
	"H" : 1.1600158124236426E-5,
	"I" : -1.0507887842070573E-6,
	"J" : 1.0560401860459923E-4,
	"K" : -0.002368078834237508,
	"L" : 0.9962722141260087,
	"M" : 0.15723821594974652
}, {
	"A" : 5.7857420100226875E-5,
	"B" : -3.358222915306186E-7,
	"C" : -4.96294743967951E-7,
	"D" : 0.9875835601778817,
	"E" : 1.0630880808548682E-5,
	"F" : 0.6629842167676543,
	"H" : 1.1237296858201962E-5,
	"I" : -1.0510678051800504E-6,
	"J" : 1.0560365901565727E-4,
	"K" : -0.0023355613601268033,
	"L" : 0.9962725514526269,
	"M" : 0.15775568224580638
}, {
	"A" : -4.685458002118281E-5,
	"B" : -1.6875994841569764E-6,
	"C" : -5.874214206169626E-7,
	"D" : 1.0101829906720923,
	"E" : 1.5901540041340922E-4,
	"F" : -0.5566720585156872,
	"H" : 1.1215702337391553E-5,
	"I" : -1.0510070055369525E-6,
	"J" : 1.0560329909387045E-4,
	"K" : -0.0023756677430242235,
	"L" : 0.9962728524532238,
	"M" : 0.16222638760700647
}, {
	"A" : 1.7721308504459188E-4,
	"B" : -8.775871811472769E-7,
	"C" : -7.302981919199425E-7,
	"D" : 0.9603105270600167,
	"E" : 7.10327504975794E-5,
	"F" : 2.21806964197458,
	"H" : 1.1190821223000524E-5,
	"I" : -1.0512216322422496E-6,
	"J" : 1.0560293733857806E-4,
	"K" : -0.0024148946592319476,
	"L" : 0.9962731843367507,
	"M" : 0.16672967902513847
}, {
	"A" : 6.337061749661643E-5,
	"B" : 2.110983818415235E-6,
	"C" : -7.177971053096144E-7,
	"D" : 0.9859960330040849,
	"E" : -2.694849835052082E-4,
	"F" : 0.7688987630172051,
	"H" : 1.1209136115297724E-5,
	"I" : -1.0515291010149141E-6,
	"J" : 1.0560258175276727E-4,
	"K" : -0.0024637473407267407,
	"L" : 0.9962735269429359,
	"M" : 0.17185876797066157
}, {
	"A" : -6.521667776038242E-5,
	"B" : 6.024724485964583E-7,
	"C" : -6.572896984469168E-7,
	"D" : 1.0153445417197986,
	"E" : -1.0064581914548398E-4,
	"F" : -0.9059644144508638,
	"H" : 1.1211567049917992E-5,
	"I" : -1.051365758286682E-6,
	"J" : 1.0560222681210707E-4,
	"K" : -0.002509133962099952,
	"L" : 0.9962738159742841,
	"M" : 0.1768886519703301
}, {
	"A" : 1.410066115767883E-4,
	"B" : 7.437916291763713E-7,
	"C" : -6.752856163139143E-7,
	"D" : 0.9669680876851316,
	"E" : -1.1994856299679668E-4,
	"F" : 1.9307671882816066,
	"H" : 1.1192582925034777E-5,
	"I" : -1.051434080912017E-6,
	"J" : 1.0560186915326009E-4,
	"K" : -0.002549474987354472,
	"L" : 0.9962741320711785,
	"M" : 0.18171096105243123
}, {
	"A" : 1.9498770979398117E-5,
	"B" : 2.7566742386575527E-6,
	"C" : -5.906788844711741E-7,
	"D" : 0.9958585450575583,
	"E" : -3.6501704758507003E-4,
	"F" : 0.21313673083932372,
	"H" : 1.1210811060174963E-5,
	"I" : -1.0515955917167474E-6,
	"J" : 1.0560151579647181E-4,
	"K" : -0.0025985629928158005,
	"L" : 0.996274459141965,
	"M" : 0.18713687161516646
}, {
	"A" : -1.0441681368944522E-4,
	"B" : 2.338653506406274E-7,
	"C" : -5.221084404816168E-7,
	"D" : 1.025635067718781,
	"E" : -6.473594066847E-5,
	"F" : -1.5759222612105077,
	"H" : 1.121052398878053E-5,
	"I" : -1.051323427314621E-6,
	"J" : 1.056011606157814E-4,
	"K" : -0.002643350442326664,
	"L" : 0.9962747340607834,
	"M" : 0.19240288474975387
}, {
	"A" : 1.1715199730333303E-4,
	"B" : -3.92767223189594E-7,
	"C" : -5.890844507749904E-7,
	"D" : 0.9710221282772409,
	"E" : 1.1372481992566463E-5,
	"F" : 1.7890176596847596,
	"H" : 1.1188193704381177E-5,
	"I" : -1.051345557057104E-6,
	"J" : 1.056008006239395E-4,
	"K" : -0.002682655689476121,
	"L" : 0.9962750450322915,
	"M" : 0.19741776086630125
}, {
	"A" : 1.725742831437671E-5,
	"B" : 1.2996282054977826E-6,
	"C" : -5.883243658910686E-7,
	"D" : 0.9959729976460494,
	"E" : -2.0260205764088823E-4,
	"F" : 0.23064719186368166,
	"H" : 1.1203873816589827E-5,
	"I" : -1.0515299450064575E-6,
	"J" : 1.056004438017566E-4,
	"K" : -0.0027313233203045684,
	"L" : 0.9962753762124947,
	"M" : 0.20309875443126657
}, {
	"A" : -8.49188446629956E-5,
	"B" : -1.0109976966710121E-6,
	"C" : -6.069832396704555E-7,
	"D" : 1.0217125155897975,
	"E" : 8.911653389986895E-5,
	"F" : -1.3906455131145776,
	"H" : 1.1202926037706673E-5,
	"I" : -1.0513380681032025E-6,
	"J" : 1.0560008518328834E-4,
	"K" : -0.002775922073439574,
	"L" : 0.9962756600904186,
	"M" : 0.20862060669878701
}, {
	"A" : 1.5231200938470302E-4,
	"B" : -9.731139387625376E-7,
	"C" : -7.32833169259095E-7,
	"D" : 0.9603906190769749,
	"E" : 8.546152412236552E-5,
	"F" : 2.5717653997016896,
	"H" : 1.1181961889872305E-5,
	"I" : -1.0514688800755678E-6,
	"J" : 1.0559972298301856E-4,
	"K" : -0.002815285014200697,
	"L" : 0.9962759856595937,
	"M" : 0.2138897990789701
}, {
	"A" : 5.794346013465734E-5,
	"B" : 1.6478580679990529E-6,
	"C" : -7.397666035302564E-7,
	"D" : 0.985078795081165,
	"E" : -2.600234244027888E-4,
	"F" : 0.9567066612653434,
	"H" : 1.1200870989713785E-5,
	"I" : -1.0517558058920073E-6,
	"J" : 1.055993659340726E-4,
	"K" : -0.0028649592781846422,
	"L" : 0.9962763317906607,
	"M" : 0.21991519332550524
}, {
	"A" : -5.094208573863668E-5,
	"B" : 2.521459294690942E-7,
	"C" : -7.06801103422805E-7,
	"D" : 1.0138151546440781,
	"E" : -7.80454881805781E-5,
	"F" : -0.9395106994998059,
	"H" : 1.1204025890554359E-5,
	"I" : -1.0516257847870136E-6,
	"J" : 1.055990094143977E-4,
	"K" : -0.002910618413920929,
	"L" : 0.996276623035925,
	"M" : 0.22577459518652176
}, {
	"A" : 1.6934203219998167E-4,
	"B" : 9.086277961145584E-7,
	"C" : -7.319647505887872E-7,
	"D" : 0.9542115223348446,
	"E" : -1.692041951741885E-4,
	"F" : 3.0919782302953536,
	"H" : 1.1187060325212883E-5,
	"I" : -1.0517553833411242E-6,
	"J" : 1.055986511389051E-4,
	"K" : -0.002950804552042996,
	"L" : 0.9962769493449812,
	"M" : 0.23135143412309844
} ], [

{
	"A" : 1.0820084807550145E-4,
	"B" : 1.0542268937818733E-6,
	"C" : -1.007207311998215E-7,
	"D" : 0.9838100274604074,
	"E" : -8.461883928134739E-5,
	"F" : 0.6029638376858202,
	"H" : 1.1209970773778943E-5,
	"I" : -1.0825772903122477E-6,
	"J" : -1.1796970478250568E-4,
	"K" : -0.0016105544997415677,
	"L" : 1.0052788530926904,
	"M" : 0.003265103965986782
}, {
	"A" : 5.833376075292662E-6,
	"B" : 2.6542210513902376E-6,
	"C" : -2.691662770448744E-8,
	"D" : 0.9995493005122285,
	"E" : -2.1357689311685135E-4,
	"F" : -0.0023507764417445287,
	"H" : 1.1225602853104366E-5,
	"I" : -1.0826838107158565E-6,
	"J" : -1.179688255880107E-4,
	"K" : -0.0016577966168824787,
	"L" : 1.0052791857010703,
	"M" : 0.006651115492331883
}, {
	"A" : -9.818794293703359E-5,
	"B" : -2.9100136789139697E-7,
	"C" : 7.49099438035472E-9,
	"D" : 1.0157849266655603,
	"E" : 1.4915501296286493E-5,
	"F" : -0.6361160863325495,
	"H" : 1.1224156151123932E-5,
	"I" : -1.0824291163391564E-6,
	"J" : -1.1796794869137206E-4,
	"K" : -0.0017024940538945543,
	"L" : 1.0052794900334234,
	"M" : 0.010032261664036923
}, {
	"A" : 1.4224075947066872E-4,
	"B" : -5.500987287909709E-7,
	"C" : -8.978722121355531E-8,
	"D" : 0.9767232377222967,
	"E" : 3.600975895778902E-5,
	"F" : 0.9500866559501446,
	"H" : 1.1202004945282118E-5,
	"I" : -1.082519746176125E-6,
	"J" : -1.179670757578688E-4,
	"K" : -0.0017437601461836039,
	"L" : 1.005279822259304,
	"M" : 0.013361143487145455
}, {
	"A" : 4.7024713763277326E-5,
	"B" : 2.077050314852613E-6,
	"C" : -8.069472434701908E-8,
	"D" : 0.9924862581577827,
	"E" : -1.8509357119000924E-4,
	"F" : 0.2973447550975834,
	"H" : 1.1220667131051076E-5,
	"I" : -1.0827674734592563E-6,
	"J" : -1.1796619857173951E-4,
	"K" : -0.0017916578055405807,
	"L" : 1.005280167550005,
	"M" : 0.017049131112798932
}, {
	"A" : -6.225975788665128E-5,
	"B" : 1.846391493032229E-7,
	"C" : -4.8654855477892056E-8,
	"D" : 1.0108462908004299,
	"E" : -2.8279484098447938E-5,
	"F" : -0.47402807281105197,
	"H" : 1.1223441289509584E-5,
	"I" : -1.0826121293883162E-6,
	"J" : -1.1796532168481533E-4,
	"K" : -0.0018370277848731575,
	"L" : 1.0052804790810725,
	"M" : 0.020726558314891008
}, {
	"A" : 1.6237621918069323E-4,
	"B" : 6.891133788045067E-7,
	"C" : -9.398194222853817E-8,
	"D" : 0.9716337538690709,
	"E" : -7.417410489551912E-5,
	"F" : 1.2368705167573353,
	"H" : 1.1205560952076699E-5,
	"I" : -1.0827373715383004E-6,
	"J" : -1.1796444698189412E-4,
	"K" : -0.001878757859898883,
	"L" : 1.0052808150289465,
	"M" : 0.024333404069238895
}, {
	"A" : 4.5261518238692844E-5,
	"B" : 3.5704730070307278E-6,
	"C" : -2.367837592665012E-9,
	"D" : 0.9924321948213333,
	"E" : -3.3704498207498546E-4,
	"F" : 0.3131518873924506,
	"H" : 1.1227395593754741E-5,
	"I" : -1.082951418429623E-6,
	"J" : -1.1796356716906042E-4,
	"K" : -0.0019274479112141307,
	"L" : 1.0052811588381303,
	"M" : 0.028334896450360247
}, {
	"A" : -8.598920174662794E-5,
	"B" : 1.3310433708557667E-6,
	"C" : 1.0936117855742111E-7,
	"D" : 1.016106663489154,
	"E" : -1.4057201215678106E-4,
	"F" : -0.7546575284795836,
	"H" : 1.1231492299812462E-5,
	"I" : -1.0827099679588947E-6,
	"J" : -1.179626879133644E-4,
	"K" : -0.0019731106553990685,
	"L" : 1.0052814615241772,
	"M" : 0.03229727030020513
}, {
	"A" : 1.2295152538399634E-4,
	"B" : 9.800168307982915E-7,
	"C" : 1.0772832381711339E-7,
	"D" : 0.9771332658702079,
	"E" : -1.1172834331318882E-4,
	"F" : 1.0624334750900744,
	"H" : 1.1213009215527148E-5,
	"I" : -1.0827287132419983E-6,
	"J" : -1.179618121643633E-4,
	"K" : -0.0020145415188181914,
	"L" : 1.0052817882079665,
	"M" : 0.03615114522381191
}, {
	"A" : 7.812591935607571E-7,
	"B" : 2.7182161039807085E-6,
	"C" : 1.83386452246026E-7,
	"D" : 1.0003173770976161,
	"E" : -2.8261783276661845E-4,
	"F" : -0.03780110525258351,
	"H" : 1.1232899686963727E-5,
	"I" : -1.0828535700335706E-6,
	"J" : -1.1796093343804936E-4,
	"K" : -0.0020631513027993265,
	"L" : 1.0052821247880814,
	"M" : 0.0404305389597539
}, {
	"A" : -1.229590585078988E-4,
	"B" : -6.29001801311091E-7,
	"C" : 2.1165781971532738E-7,
	"D" : 1.0241295279044493,
	"E" : 3.819851485786785E-5,
	"F" : -1.183661969316745,
	"H" : 1.1235461634284682E-5,
	"I" : -1.0825772976952308E-6,
	"J" : -1.1796005754155514E-4,
	"K" : -0.002108583394480945,
	"L" : 1.005282422776304,
	"M" : 0.0446542893005244
}, {
	"A" : 1.0379703992224876E-4,
	"B" : -1.7466898651896656E-6,
	"C" : 7.06097356140134E-8,
	"D" : 0.9791355986344854,
	"E" : 1.508238463543421E-4,
	"F" : 1.0479368858214002,
	"H" : 1.1219504593124041E-5,
	"I" : -1.0826391559914939E-6,
	"J" : -1.1795918716037135E-4,
	"K" : -0.002150295507092892,
	"L" : 1.0052827542162106,
	"M" : 0.04878110368963462
}, {
	"A" : 5.8210428695026906E-6,
	"B" : -2.029332539787987E-7,
	"C" : -2.2021070966715683E-8,
	"D" : 0.9989026849937659,
	"E" : -3.883714299490748E-6,
	"F" : 0.050514846447185846,
	"H" : 1.1258477983444592E-5,
	"I" : -1.082900166760048E-6,
	"J" : -1.1795831490046815E-4,
	"K" : -0.002202989461054017,
	"L" : 1.0052831059446348,
	"M" : 0.05354661107139691
}, {
	"A" : -9.375876663986205E-5,
	"B" : -3.081964493167888E-6,
	"C" : -1.5389106033936173E-7,
	"D" : 1.0192152069527651,
	"E" : 2.9544459840735726E-4,
	"F" : -0.9856528829059243,
	"H" : 1.1548198583288816E-5,
	"I" : -1.08297659484613E-6,
	"J" : -1.1795744615933357E-4,
	"K" : -0.0023078436460295393,
	"L" : 1.005283439577859,
	"M" : 0.061113991089769115
}, {
	"A" : 1.5020722086678262E-4,
	"B" : -3.1962015505371255E-6,
	"C" : -4.111787750282758E-7,
	"D" : 0.9678658688020505,
	"E" : 3.142536651807859E-4,
	"F" : 1.715891305306286,
	"H" : 1.1597584133882233E-5,
	"I" : -1.0824569349754398E-6,
	"J" : -1.1795657701135775E-4,
	"K" : -0.002366589125792018,
	"L" : 1.005283711342308,
	"M" : 0.06657886008906644
}, {
	"A" : 5.859218784243225E-5,
	"B" : -3.0277955209712104E-7,
	"C" : -5.498947350801586E-7,
	"D" : 0.9874238381772784,
	"E" : 7.798213943033261E-6,
	"F" : 0.6716703237543697,
	"H" : 1.1235192753367151E-5,
	"I" : -1.082988425549214E-6,
	"J" : -1.1795570110761933E-4,
	"K" : -0.0023341576669508868,
	"L" : 1.0052840943110724,
	"M" : 0.06709866107348716
}, {
	"A" : -4.7449014362044295E-5,
	"B" : -1.8296608863543895E-6,
	"C" : -6.469613191839585E-7,
	"D" : 1.010316212128373,
	"E" : 1.756130856733762E-4,
	"F" : -0.5641291812826239,
	"H" : 1.1213834215290097E-5,
	"I" : -1.0829913446031014E-6,
	"J" : -1.1795482557780401E-4,
	"K" : -0.002374306353218003,
	"L" : 1.0052844209721954,
	"M" : 0.07156968280969522
}, {
	"A" : 1.7946269400104242E-4,
	"B" : -9.140480055069844E-7,
	"C" : -7.985234251606244E-7,
	"D" : 0.9598070370195728,
	"E" : 7.643539083801443E-5,
	"F" : 2.246241577202454,
	"H" : 1.1188336084544392E-5,
	"I" : -1.0832465625054688E-6,
	"J" : -1.1795395172339851E-4,
	"K" : -0.0024133867169382484,
	"L" : 1.005284776103693,
	"M" : 0.07606281715834484
}, {
	"A" : 6.417642301892457E-5,
	"B" : 2.460587123831459E-6,
	"C" : -7.866011753066005E-7,
	"D" : 0.985804971716334,
	"E" : -3.0799255569036177E-4,
	"F" : 0.7802077930682572,
	"H" : 1.1207138446350795E-5,
	"I" : -1.0835728705416159E-6,
	"J" : -1.1795307219475415E-4,
	"K" : -0.002462340084839809,
	"L" : 1.0052851395905975,
	"M" : 0.08119556759493207
}, {
	"A" : -6.604502999296713E-5,
	"B" : 7.564621888889178E-7,
	"C" : -7.240850847800573E-7,
	"D" : 1.0155332420334844,
	"E" : -1.1724401343826685E-4,
	"F" : -0.9167056579426571,
	"H" : 1.1209863526151498E-5,
	"I" : -1.083417618341631E-6,
	"J" : -1.1795219219903896E-4,
	"K" : -0.0025077868717957585,
	"L" : 1.005285448299773,
	"M" : 0.08622698941508133
}, {
	"A" : 1.4279812048378915E-4,
	"B" : 9.170531907187751E-7,
	"C" : -7.442162512916184E-7,
	"D" : 0.9665415106725277,
	"E" : -1.3904356310945332E-4,
	"F" : 1.9561582685710164,
	"H" : 1.1190281778983291E-5,
	"I" : -1.083496287246355E-6,
	"J" : -1.1795131472472353E-4,
	"K" : -0.0025479798076162297,
	"L" : 1.0052857843550314,
	"M" : 0.09103866042369191
}, {
	"A" : 1.9746921667174178E-5,
	"B" : 3.189643459133862E-6,
	"C" : -6.563944703330549E-7,
	"D" : 0.9957899687486815,
	"E" : -4.1574821321432864E-4,
	"F" : 0.2177941995614674,
	"H" : 1.120897300757595E-5,
	"I" : -1.083659109057944E-6,
	"J" : -1.1795043321330412E-4,
	"K" : -0.002597169630035978,
	"L" : 1.0052861303180123,
	"M" : 0.09646863864600164
}, {
	"A" : -1.0574288860887293E-4,
	"B" : 3.398747838723182E-7,
	"C" : -5.853770876917963E-7,
	"D" : 1.0259560936766547,
	"E" : -7.654609649421218E-5,
	"F" : -1.5953468533043633,
	"H" : 1.1208918014926628E-5,
	"I" : -1.083387285494286E-6,
	"J" : -1.1794955356447812E-4,
	"K" : -0.002642006478197345,
	"L" : 1.0052864240059805,
	"M" : 0.10173574001328234
}, {
	"A" : 1.1863956941216003E-4,
	"B" : -3.664929670854633E-7,
	"C" : -6.570417705464848E-7,
	"D" : 0.9706523593280281,
	"E" : 9.423267840702465E-6,
	"F" : 1.8119965983532893,
	"H" : 1.1185908885769091E-5,
	"I" : -1.0834189745345668E-6,
	"J" : -1.1794867815134724E-4,
	"K" : -0.0026811367757204607,
	"L" : 1.0052867548782487,
	"M" : 0.10673787556152092
}, {
	"A" : 1.7476888672263158E-5,
	"B" : 1.544123975794065E-6,
	"C" : -6.574559994199092E-7,
	"D" : 0.9959124391684782,
	"E" : -2.3204978293733802E-4,
	"F" : 0.23479379631316988,
	"H" : 1.1201973409563637E-5,
	"I" : -1.0836085332921463E-6,
	"J" : -1.1794779984403148E-4,
	"K" : -0.0027298919655009968,
	"L" : 1.0052871054344905,
	"M" : 0.11242231663891289
}, {
	"A" : -8.59970527844478E-5,
	"B" : -1.0659621099140537E-6,
	"C" : -6.782385673087532E-7,
	"D" : 1.0219892261870882,
	"E" : 9.759141295262452E-5,
	"F" : -1.408399052124878,
	"H" : 1.120120407288594E-5,
	"I" : -1.0834221081390538E-6,
	"J" : -1.1794692326566603E-4,
	"K" : -0.0027745288155074377,
	"L" : 1.005287408737388,
	"M" : 0.11794463786645792
}, {
	"A" : 1.5424549233689078E-4,
	"B" : -1.0215407670877141E-6,
	"C" : -8.118712238047721E-7,
	"D" : 0.9598885675006841,
	"E" : 9.350710854505451E-5,
	"F" : 2.6043521916544705,
	"H" : 1.1179546806988627E-5,
	"I" : -1.0835660076979892E-6,
	"J" : -1.1794604990644775E-4,
	"K" : -0.002813704381168236,
	"L" : 1.0052877547411043,
	"M" : 0.12319970060343621
}, {
	"A" : 5.868015041232688E-5,
	"B" : 1.9377125122232997E-6,
	"C" : -8.204037140746578E-7,
	"D" : 0.9848781637844013,
	"E" : -2.9646569720398475E-4,
	"F" : 0.9703495174253476,
	"H" : 1.1198868221984348E-5,
	"I" : -1.08385777330966E-6,
	"J" : -1.1794517181915043E-4,
	"K" : -0.0028634776198117606,
	"L" : 1.0052881202617172,
	"M" : 0.1292294934128222
}, {
	"A" : -5.158893252210639E-5,
	"B" : 3.607281522377548E-7,
	"C" : -7.868700533375517E-7,
	"D" : 1.0139859449149071,
	"E" : -9.08019831058482E-5,
	"F" : -0.9507854648181819,
	"H" : 1.1202264357912384E-5,
	"I" : -1.0837279039166425E-6,
	"J" : -1.1794429331365985E-4,
	"K" : -0.002909193468127569,
	"L" : 1.0052884302800322,
	"M" : 0.13509067928680452
}, {
	"A" : 1.7149377997660586E-4,
	"B" : 1.1038766045690096E-6,
	"C" : -8.145552181648696E-7,
	"D" : 0.9536220389277332,
	"E" : -1.938629100095568E-4,
	"F" : 3.132343644319917,
	"H" : 1.1184684866327732E-5,
	"I" : -1.0838610141616911E-6,
	"J" : -1.1794341639470574E-4,
	"K" : -0.0029492054415953817,
	"L" : 1.0052887758170215,
	"M" : 0.14065370300340874
} ], [

{
	"A" : 1.0972849616208702E-4,
	"B" : 1.2507875513101396E-6,
	"C" : -1.1953625989047367E-7,
	"D" : 0.9835731774351757,
	"E" : -1.001479557771745E-4,
	"F" : 0.6121623347435161,
	"H" : 1.1203061936804204E-5,
	"I" : -1.0697793079161855E-6,
	"J" : -3.182303528151409E-5,
	"K" : -0.0016094830446959918,
	"L" : 1.0014338696055987,
	"M" : 0.046333683138527704
}, {
	"A" : 5.916000990535686E-6,
	"B" : 3.0449837620238895E-6,
	"C" : -4.236944395330511E-8,
	"D" : 0.9995274422955447,
	"E" : -2.447918337793453E-4,
	"F" : -0.0011248943010286894,
	"H" : 1.1219090875924653E-5,
	"I" : -1.0698685958820953E-6,
	"J" : -3.1822601309877685E-5,
	"K" : -0.0016567597588093008,
	"L" : 1.0014341929445294,
	"M" : 0.04971979072979593
}, {
	"A" : -9.957309357222499E-5,
	"B" : -2.5728570207661505E-7,
	"C" : -7.264794543715425E-9,
	"D" : 1.016005380214665,
	"E" : 1.1446611352994296E-5,
	"F" : -0.6448628242178529,
	"H" : 1.1217812797226223E-5,
	"I" : -1.0696300370427458E-6,
	"J" : -3.182216965566531E-5,
	"K" : -0.0017014579100731453,
	"L" : 1.0014344906070534,
	"M" : 0.053099725807442155
}, {
	"A" : 1.4424746617602846E-4,
	"B" : -5.480486695574882E-7,
	"C" : -1.128303765973726E-7,
	"D" : 0.9763937844344355,
	"E" : 3.5434179068261074E-5,
	"F" : 0.9636281797720585,
	"H" : 1.1194918653645303E-5,
	"I" : -1.069727188718339E-6,
	"J" : -3.1821741746262955E-5,
	"K" : -0.0017425766425702705,
	"L" : 1.0014348154225559,
	"M" : 0.056421330141347426
}, {
	"A" : 4.768909033603386E-5,
	"B" : 2.397776674989416E-6,
	"C" : -1.0479110135186431E-7,
	"D" : 0.9923672345359478,
	"E" : -2.1239066015255048E-4,
	"F" : 0.3026741704707092,
	"H" : 1.1214003438675402E-5,
	"I" : -1.0699556780568997E-6,
	"J" : -3.182130972273489E-5,
	"K" : -0.0017905172776693234,
	"L" : 1.0014351511826192,
	"M" : 0.06010975803474139
}, {
	"A" : -6.313819547842936E-5,
	"B" : 2.7594298845912135E-7,
	"C" : -7.221716524785649E-8,
	"D" : 1.010994963817467,
	"E" : -3.6514618784622144E-5,
	"F" : -0.4802969047850638,
	"H" : 1.121701037698486E-5,
	"I" : -1.0698097608896617E-6,
	"J" : -3.1820878053867574E-5,
	"K" : -0.0018359005186852073,
	"L" : 1.0014354555783669,
	"M" : 0.06378641571791377
}, {
	"A" : 1.646682960600998E-4,
	"B" : 8.415903403058422E-7,
	"C" : -1.2229808277197662E-7,
	"D" : 0.971226698636741,
	"E" : -8.776503315743867E-5,
	"F" : 1.2549582798528718,
	"H" : 1.1198470028561669E-5,
	"I" : -1.069932497155257E-6,
	"J" : -3.1820448400998735E-5,
	"K" : -0.0018774887259951356,
	"L" : 1.001435783369267,
	"M" : 0.06738569861590804
}, {
	"A" : 4.590145417737723E-5,
	"B" : 4.072409884425809E-6,
	"C" : -2.6118735174662788E-8,
	"D" : 0.9923056138787842,
	"E" : -3.8258748242014917E-4,
	"F" : 0.3193800700828433,
	"H" : 1.1220805257561306E-5,
	"I" : -1.0701187898587428E-6,
	"J" : -3.182001377921573E-5,
	"K" : -0.0019262410057052648,
	"L" : 1.0014361167606083,
	"M" : 0.07138854978256859
}, {
	"A" : -8.720311233045841E-5,
	"B" : 1.5613010095893998E-6,
	"C" : 9.157597202769097E-8,
	"D" : 1.0163245353487582,
	"E" : -1.623907113810219E-4,
	"F" : -0.7644042186766455,
	"H" : 1.1225185124530412E-5,
	"I" : -1.0698819412069405E-6,
	"J" : -3.1819579848213486E-5,
	"K" : -0.001971929488775004,
	"L" : 1.0014364119068873,
	"M" : 0.07535070637277386
}, {
	"A" : 1.246873662017478E-4,
	"B" : 1.1679137958964247E-6,
	"C" : 8.817050112241986E-8,
	"D" : 0.9768024836586164,
	"E" : -1.2994855404713235E-4,
	"F" : 1.0782102750818012,
	"H" : 1.1206050206657991E-5,
	"I" : -1.0698986371293628E-6,
	"J" : -3.181914921190909E-5,
	"K" : -0.0020132126263376904,
	"L" : 1.0014367304330918,
	"M" : 0.07919626504008193
}, {
	"A" : 7.925232585748176E-7,
	"B" : 3.1167409995092044E-6,
	"C" : 1.6731547425319349E-7,
	"D" : 1.0003060723661292,
	"E" : -3.215838999039988E-4,
	"F" : -0.03679632151033729,
	"H" : 1.122640296224997E-5,
	"I" : -1.0700015317111067E-6,
	"J" : -3.181871561472316E-5,
	"K" : -0.0020618837547132784,
	"L" : 1.0014370569509197,
	"M" : 0.08347709992267482
}, {
	"A" : -1.2469341908882825E-4,
	"B" : -6.366354239339955E-7,
	"C" : 1.9587203525794905E-7,
	"D" : 1.024469182855114,
	"E" : 3.821943755610846E-5,
	"F" : -1.2002671394875506,
	"H" : 1.1229172317106517E-5,
	"I" : -1.0697390100955495E-6,
	"J" : -3.181828490725347E-5,
	"K" : -0.002107330368559701,
	"L" : 1.0014373482993904,
	"M" : 0.08770009306044813
}, {
	"A" : 1.0526061244453544E-4,
	"B" : -1.8894163860139201E-6,
	"C" : 4.3562908613736795E-8,
	"D" : 0.9788456984404093,
	"E" : 1.648626561632227E-4,
	"F" : 1.0623089259133849,
	"H" : 1.1212470483301651E-5,
	"I" : -1.069806961018216E-6,
	"J" : -3.181785946410054E-5,
	"K" : -0.0021488682760093525,
	"L" : 1.001437672382437,
	"M" : 0.09181674586261579
}, {
	"A" : 5.9033481845105484E-6,
	"B" : -1.5871755443264135E-7,
	"C" : -5.7044998946764736E-8,
	"D" : 0.9988845448750681,
	"E" : -8.273114929124858E-6,
	"F" : 0.05152309649565723,
	"H" : 1.1251810457579836E-5,
	"I" : -1.0700446962386145E-6,
	"J" : -3.181743214414334E-5,
	"K" : -0.0022016093473666842,
	"L" : 1.0014380138170083,
	"M" : 0.09658305748280327
}, {
	"A" : -9.50797813548121E-5,
	"B" : -3.3870523761247995E-6,
	"C" : -1.995270080268341E-7,
	"D" : 1.019496258575316,
	"E" : 3.2775621440350733E-4,
	"F" : -1.0005844501501997,
	"H" : 1.1541508670998013E-5,
	"I" : -1.0700738474200833E-6,
	"J" : -3.1817008268875124E-5,
	"K" : -0.0023064333858400232,
	"L" : 1.0014383346434101,
	"M" : 0.10414735410085996
}, {
	"A" : 1.5232370570639198E-4,
	"B" : -3.5145342383025024E-6,
	"C" : -4.759929830289167E-7,
	"D" : 0.9674238643182207,
	"E" : 3.4942388566605587E-4,
	"F" : 1.7389622172122472,
	"H" : 1.1590103241809757E-5,
	"I" : -1.0699076204989666E-6,
	"J" : -3.181658388790032E-5,
	"K" : -0.0023649765723661176,
	"L" : 1.0014386356366813,
	"M" : 0.10959948551317211
}, {
	"A" : 5.941899386741056E-5,
	"B" : -2.705257720059251E-7,
	"C" : -6.258492519783942E-7,
	"D" : 0.9872441848430071,
	"E" : 6.237512650386634E-6,
	"F" : 0.681423190075293,
	"H" : 1.1228370628502127E-5,
	"I" : -1.0703420574298406E-6,
	"J" : -3.181615307082386E-5,
	"K" : -0.0023326595354262736,
	"L" : 1.001439000370489,
	"M" : 0.11012377072938762
}, {
	"A" : -4.8117881007669894E-5,
	"B" : -1.9827959703011544E-6,
	"C" : -7.311623615446905E-7,
	"D" : 1.0104663291776887,
	"E" : 1.9474146571951678E-4,
	"F" : -0.5725580485377577,
	"H" : 1.1207267491986084E-5,
	"I" : -1.0703430909364542E-6,
	"J" : -3.1815722804223734E-5,
	"K" : -0.0023728372542564102,
	"L" : 1.0014393189729276,
	"M" : 0.11459470586942189
}, {
	"A" : 1.8199405935770407E-4,
	"B" : -9.554649598175757E-7,
	"C" : -8.94723034106093E-7,
	"D" : 0.9592406182709965,
	"E" : 8.388731527020354E-5,
	"F" : 2.2779108357353834,
	"H" : 1.118112557885187E-5,
	"I" : -1.0705921983933386E-6,
	"J" : -3.181529407250694E-5,
	"K" : -0.0024117472314486577,
	"L" : 1.0014396655861688,
	"M" : 0.11907664118734829
}, {
	"A" : 6.508319137221719E-5,
	"B" : 2.828079691319374E-6,
	"C" : -8.837025096131157E-7,
	"D" : 0.9855897956562671,
	"E" : -3.4702839735700763E-4,
	"F" : 0.7929372929575038,
	"H" : 1.1200448338799518E-5,
	"I" : -1.0708898090516783E-6,
	"J" : -3.181485968195563E-5,
	"K" : -0.0024607909013809603,
	"L" : 1.0014400179857788,
	"M" : 0.12421273455947812
}, {
	"A" : -6.69771404286923E-5,
	"B" : 9.168575103579713E-7,
	"C" : -8.185577939912037E-7,
	"D" : 1.0157455571523997,
	"E" : -1.3310974958358202E-4,
	"F" : -0.9288059995596996,
	"H" : 1.1203480319077475E-5,
	"I" : -1.0707375727170287E-6,
	"J" : -3.181442502406262E-5,
	"K" : -0.002506282148289074,
	"L" : 1.0014403191954457,
	"M" : 0.12924499316886795
}, {
	"A" : 1.4481405313215845E-4,
	"B" : 1.0977492093111607E-6,
	"C" : -8.417264201199259E-7,
	"D" : 0.9660614608126252,
	"E" : -1.5749178268720243E-4,
	"F" : 1.9847175831964705,
	"H" : 1.1183271005354989E-5,
	"I" : -1.0708120093960716E-6,
	"J" : -3.18139926731853E-5,
	"K" : -0.002546301508132842,
	"L" : 1.001440646901898,
	"M" : 0.13404472951879143
}, {
	"A" : 2.002616798346679E-5,
	"B" : 3.6454491476600737E-6,
	"C" : -7.496177061305787E-7,
	"D" : 0.9957125567046887,
	"E" : -4.677558300727469E-4,
	"F" : 0.22304834452370415,
	"H" : 1.120245386687646E-5,
	"I" : -1.0709510240292097E-6,
	"J" : -3.18135564477684E-5,
	"K" : -0.0025955817161644745,
	"L" : 1.001440982171438,
	"M" : 0.13947828488835512
}, {
	"A" : -1.0723506182719333E-4,
	"B" : 4.4947826971508675E-7,
	"C" : -6.753736476738936E-7,
	"D" : 1.0263173462178088,
	"E" : -8.737533966041156E-5,
	"F" : -1.6172220546359313,
	"H" : 1.1202637856477793E-5,
	"I" : -1.070690881843639E-6,
	"J" : -3.181312210220888E-5,
	"K" : -0.00264045067623897,
	"L" : 1.0014412694057881,
	"M" : 0.1447455563757103
}, {
	"A" : 1.2031346724628023E-4,
	"B" : -3.414482179220357E-7,
	"C" : -7.535708048678202E-7,
	"D" : 0.9702363565597807,
	"E" : 9.146281854555127E-6,
	"F" : 1.8378270038192568,
	"H" : 1.1178914014586816E-5,
	"I" : -1.0707289859746005E-6,
	"J" : -3.1812691798527304E-5,
	"K" : -0.0026793784853964553,
	"L" : 1.0014415932027276,
	"M" : 0.14973338089112076
}, {
	"A" : 1.772384679665784E-5,
	"B" : 1.8003248869469246E-6,
	"C" : -7.557042989159157E-7,
	"D" : 0.9958442002281345,
	"E" : -2.614235676219323E-4,
	"F" : 0.23945467269368237,
	"H" : 1.1195386616258407E-5,
	"I" : -1.0709045707990583E-6,
	"J" : -3.1812258712904384E-5,
	"K" : -0.002728208770250262,
	"L" : 1.0014419341552028,
	"M" : 0.15542061632186233
}, {
	"A" : -8.721028902192174E-5,
	"B" : -1.126835055043074E-6,
	"C" : -7.795136451882456E-7,
	"D" : 1.0223007347385646,
	"E" : 1.0841967821306753E-4,
	"F" : -1.4284118892610422,
	"H" : 1.1194800168423669E-5,
	"I" : -1.0707359054951127E-6,
	"J" : -3.181182731326615E-5,
	"K" : -0.002772865829385296,
	"L" : 1.0014422318594711,
	"M" : 0.16094233741205244
}, {
	"A" : 1.564211357742984E-4,
	"B" : -1.0756369053233072E-6,
	"C" : -9.239111884440376E-7,
	"D" : 0.9593237776165324,
	"E" : 1.0405005389202415E-4,
	"F" : 2.640982753593562,
	"H" : 1.1172414318416646E-5,
	"I" : -1.0708867779762876E-6,
	"J" : -3.181139897995289E-5,
	"K" : -0.0028118261756588936,
	"L" : 1.001442570921185,
	"M" : 0.16618154375100858
}, {
	"A" : 5.9509139020974544E-5,
	"B" : 2.2419220673253193E-6,
	"C" : -9.347412812665823E-7,
	"D" : 0.9846522675335336,
	"E" : -3.330049010514813E-4,
	"F" : 0.9856990001062513,
	"H" : 1.1192174757812534E-5,
	"I" : -1.0711592565160188E-6,
	"J" : -3.181096597945632E-5,
	"K" : -0.0028616871036177827,
	"L" : 1.0014429260762938,
	"M" : 0.1722150719970159
}, {
	"A" : -5.231679741468653E-5,
	"B" : 4.730352343162991E-7,
	"C" : -9.005500960501678E-7,
	"D" : 1.014178141396883,
	"E" : -1.0226598931240005E-4,
	"F" : -0.9634938843664713,
	"H" : 1.119582157682597E-5,
	"I" : -1.0710373894440295E-6,
	"J" : -3.1810532687276405E-5,
	"K" : -0.0029074432582660847,
	"L" : 1.0014432293191433,
	"M" : 0.17807696712225152
}, {
	"A" : 1.7391508293673752E-4,
	"B" : 1.307818008999817E-6,
	"C" : -9.318002556213401E-7,
	"D" : 0.9529586572940048,
	"E" : -2.178558077616799E-4,
	"F" : 3.1777526915248018,
	"H" : 1.1177597893707869E-5,
	"I" : -1.071165976751498E-6,
	"J" : -3.181010089048364E-5,
	"K" : -0.0029472542859423356,
	"L" : 1.0014435664034096,
	"M" : 0.1836243853522319
} ], [

{
	"A" : 1.1143741622454684E-4,
	"B" : 1.4587148531308713E-6,
	"C" : -1.4265288039716495E-7,
	"D" : 0.9833081086523805,
	"E" : -1.1628248913098105E-4,
	"F" : 0.6224575565611303,
	"H" : 1.1202817473743298E-5,
	"I" : -1.057811959248589E-6,
	"J" : 6.19782072175945E-5,
	"K" : -0.001609412937483512,
	"L" : 0.997130256567516,
	"M" : 0.0958085395091075
}, {
	"A" : 6.008436717941379E-6,
	"B" : 3.461583576891414E-6,
	"C" : -6.129283214306724E-8,
	"D" : 0.9995026466284287,
	"E" : -2.7781633362167213E-4,
	"F" : 2.703694626688957E-4,
	"H" : 1.1219284461239099E-5,
	"I" : -1.057881634847213E-6,
	"J" : 6.197815337055657E-5,
	"K" : -0.0016567574057120282,
	"L" : 0.9971305741586178,
	"M" : 0.09919700618183924
}, {
	"A" : -1.0112256765748562E-4,
	"B" : -2.2431099799824494E-7,
	"C" : -2.515585906248674E-8,
	"D" : 1.0162520641544575,
	"E" : 8.223384995176275E-6,
	"F" : -0.654656037750101,
	"H" : 1.121817728449992E-5,
	"I" : -1.0576578663989977E-6,
	"J" : 6.197809713237579E-5,
	"K" : -0.0017014834647000043,
	"L" : 0.9971308687495153,
	"M" : 0.10257781832115143
}, {
	"A" : 1.464922415614911E-4,
	"B" : -5.491189027928556E-7,
	"C" : -1.4034921291816715E-7,
	"D" : 0.9760253611111125,
	"E" : 3.539694567677998E-5,
	"F" : 0.9787631252984283,
	"H" : 1.1194475802223103E-5,
	"I" : -1.0577650426113472E-6,
	"J" : 6.197803733268281E-5,
	"K" : -0.00174247101981706,
	"L" : 0.9971311901459998,
	"M" : 0.10589383208844083
}, {
	"A" : 4.843231563156358E-5,
	"B" : 2.739118173611388E-6,
	"C" : -1.3335598303410023E-7,
	"D" : 0.9922338251505494,
	"E" : -2.4113297158123714E-4,
	"F" : 0.30865423429349903,
	"H" : 1.1214030547157527E-5,
	"I" : -1.0579742824035065E-6,
	"J" : 6.197798160165191E-5,
	"K" : -0.001790489182752708,
	"L" : 0.9971315200817017,
	"M" : 0.10958519614587203
}, {
	"A" : -6.412084839435561E-5,
	"B" : 3.707937876740175E-7,
	"C" : -9.99434314197245E-8,
	"D" : 1.0111612846407638,
	"E" : -4.47854196750086E-5,
	"F" : -0.4873137716749625,
	"H" : 1.1217282153530572E-5,
	"I" : -1.0578364815772012E-6,
	"J" : 6.197792546036585E-5,
	"K" : -0.0018359145061310755,
	"L" : 0.9971318209372555,
	"M" : 0.11326340215691744
}, {
	"A" : 1.672323372716722E-4,
	"B" : 1.0021327387921275E-6,
	"C" : -1.5546011988831765E-7,
	"D" : 0.9707712828958392,
	"E" : -1.0174535913165528E-4,
	"F" : 1.2751936369531904,
	"H" : 1.1198027565550994E-5,
	"I" : -1.0579583878400634E-6,
	"J" : 6.197786735651079E-5,
	"K" : -0.0018773780731251577,
	"L" : 0.9971321444287966,
	"M" : 0.1168569855590249
}, {
	"A" : 4.661735088085095E-5,
	"B" : 4.608460038024731E-6,
	"C" : -5.3660244136999324E-8,
	"D" : 0.9921635344878155,
	"E" : -4.3094775114127515E-4,
	"F" : 0.32638685068377526,
	"H" : 1.1220918603505048E-5,
	"I" : -1.0581140288401514E-6,
	"J" : 6.197781417138781E-5,
	"K" : -0.0019262292272728132,
	"L" : 0.9971324708519234,
	"M" : 0.12086397280381789
}, {
	"A" : -8.856106273613662E-5,
	"B" : 1.8054534340894435E-6,
	"C" : 7.13168789578944E-8,
	"D" : 1.0165681054459128,
	"E" : -1.8532194968656768E-4,
	"F" : -0.7752955934156489,
	"H" : 1.1225596857122877E-5,
	"I" : -1.0578776156178193E-6,
	"J" : 6.197776025926305E-5,
	"K" : -0.0019719731475191793,
	"L" : 0.9971327617759229,
	"M" : 0.12482844296846451
}, {
	"A" : 1.2662917972883214E-4,
	"B" : 1.3665216438418781E-6,
	"C" : 6.601285584828531E-8,
	"D" : 0.9764323476865115,
	"E" : -1.4899712218152672E-4,
	"F" : 1.0958664138815948,
	"H" : 1.1205753843057664E-5,
	"I" : -1.057892099365354E-6,
	"J" : 6.19777031774793E-5,
	"K" : -0.0020131248616621633,
	"L" : 0.9971330758257793,
	"M" : 0.12866764253794827
}, {
	"A" : 8.051278244103344E-7,
	"B" : 3.5416818406908135E-6,
	"C" : 1.494987873496001E-7,
	"D" : 1.0002930735933546,
	"E" : -3.629617131366558E-4,
	"F" : -0.035640344191051554,
	"H" : 1.1226617503912184E-5,
	"I" : -1.0579703556001796E-6,
	"J" : 6.197764898180358E-5,
	"K" : -0.0020618934009632994,
	"L" : 0.997133395724326,
	"M" : 0.13295286107131687
}, {
	"A" : -1.2663352417696672E-4,
	"B" : -6.480745513570696E-7,
	"C" : 1.7859796774821746E-7,
	"D" : 1.024849256516518,
	"E" : 3.8723353782188497E-5,
	"F" : -1.2188561826988007,
	"H" : 1.1229600666129436E-5,
	"I" : -1.057719814734348E-6,
	"J" : 6.19775918886678E-5,
	"K" : -0.002107382652567935,
	"L" : 0.9971336839527254,
	"M" : 0.13717771795836597
}, {
	"A" : 1.068977937497273E-4,
	"B" : -2.0460402958555335E-6,
	"C" : 1.3132797849202404E-8,
	"D" : 0.9785216960436856,
	"E" : 1.8053529677786173E-4,
	"F" : 1.0783540853044542,
	"H" : 1.1212091314716233E-5,
	"I" : -1.0577978689640943E-6,
	"J" : 6.197752973036152E-5,
	"K" : -0.00214876058082325,
	"L" : 0.9971340047723487,
	"M" : 0.14128618559516326
}, {
	"A" : 5.99542488277649E-6,
	"B" : -1.1446812298032683E-7,
	"C" : -9.673517697983414E-8,
	"D" : 0.9988643166876727,
	"E" : -1.2329438362712608E-5,
	"F" : 0.05264025756150659,
	"H" : 1.1251851686766567E-5,
	"I" : -1.05801395566818E-6,
	"J" : 6.197746938399473E-5,
	"K" : -0.002201586345421447,
	"L" : 0.9971343397855534,
	"M" : 0.14605650168186912
}, {
	"A" : -9.655745251291314E-5,
	"B" : -3.7180614476106655E-6,
	"C" : -2.516033008603813E-7,
	"D" : 1.0198111156378218,
	"E" : 3.63225657821431E-4,
	"F" : -1.0173416818688565,
	"H" : 1.154170205919236E-5,
	"I" : -1.0579931759013839E-6,
	"J" : 6.197740562907672E-5,
	"K" : -0.002306443423222504,
	"L" : 0.9971346512478263,
	"M" : 0.15362232573897927
}, {
	"A" : 1.546912009580126E-4,
	"B" : -3.859864452726569E-6,
	"C" : -5.506180768000135E-7,
	"D" : 0.966929932270773,
	"E" : 3.8815343560827387E-4,
	"F" : 1.7647090308746556,
	"H" : 1.158948390533876E-5,
	"I" : -1.058221595628961E-6,
	"J" : 6.19773425772352E-5,
	"K" : -0.0023648060778498348,
	"L" : 0.997134989525982,
	"M" : 0.15906419751991052
}, {
	"A" : 6.03438974353665E-5,
	"B" : -2.391547622160317E-7,
	"C" : -7.134871489178352E-7,
	"D" : 0.987043296191473,
	"E" : 5.602797870096765E-6,
	"F" : 0.6923151582377614,
	"H" : 1.1228231772242303E-5,
	"I" : -1.0585557695397263E-6,
	"J" : 6.197728550993986E-5,
	"K" : -0.002332592547531931,
	"L" : 0.9971353394329299,
	"M" : 0.15959379308151256
}, {
	"A" : -4.8866075775366724E-5,
	"B" : -2.1505562795010036E-6,
	"C" : -8.283797141572791E-7,
	"D" : 1.0106345475002172,
	"E" : 2.1640472260742172E-4,
	"F" : -0.5820297094542184,
	"H" : 1.1207383076250466E-5,
	"I" : -1.0585564670928527E-6,
	"J" : 6.197722797035565E-5,
	"K" : -0.002372825767537279,
	"L" : 0.997135653892876,
	"M" : 0.16406749113411934
}, {
	"A" : 1.8482572289935106E-4,
	"B" : -1.0033250430474538E-6,
	"C" : -1.0059712307608493E-6,
	"D" : 0.95860717265532,
	"E" : 9.313073434213948E-5,
	"F" : 2.313306277959782,
	"H" : 1.1180540407607076E-5,
	"I" : -1.0588041711168117E-6,
	"J" : 6.19771689919224E-5,
	"K" : -0.0024115792134296044,
	"L" : 0.9971359962669055,
	"M" : 0.16854041994884028
}, {
	"A" : 6.60975789084084E-5,
	"B" : 3.219638140761205E-6,
	"C" : -9.95816329840693E-7,
	"D" : 0.9853487670759478,
	"E" : -3.8773589639617967E-4,
	"F" : 0.8072014604476863,
	"H" : 1.1200439361092052E-5,
	"I" : -1.0590725101344844E-6,
	"J" : 6.197711557284769E-5,
	"K" : -0.0024607524670017256,
	"L" : 0.9971363412814398,
	"M" : 0.17368353421989013
}, {
	"A" : -6.801984238058445E-5,
	"B" : 1.085973516445904E-6,
	"C" : -9.27348486223778E-7,
	"D" : 1.0159829904836215,
	"E" : -1.4895900636702208E-4,
	"F" : -0.9423451175098307,
	"H" : 1.1203795574343811E-5,
	"I" : -1.058920789942519E-6,
	"J" : 6.197706226268584E-5,
	"K" : -0.0025063189586944645,
	"L" : 0.9971366384681488,
	"M" : 0.17871989401464816
}, {
	"A" : 1.4706919251361583E-4,
	"B" : 1.2885504188098196E-6,
	"C" : -9.53916292401047E-7,
	"D" : 0.9655243552901993,
	"E" : -1.7607538507036224E-4,
	"F" : 2.016664980114001,
	"H" : 1.1182904638251667E-5,
	"I" : -1.0589916809022881E-6,
	"J" : 6.197700683496787E-5,
	"K" : -0.002546178772874441,
	"L" : 0.9971369616684882,
	"M" : 0.1835100287989917
}, {
	"A" : 2.0338561942612188E-5,
	"B" : 4.131925824824023E-6,
	"C" : -8.565168612140184E-7,
	"D" : 0.9956255367703761,
	"E" : -5.224514944188741E-4,
	"F" : 0.22896535218751524,
	"H" : 1.1202630286977211E-5,
	"I" : -1.0591039507623634E-6,
	"J" : 6.19769551300775E-5,
	"K" : -0.0025955883176038697,
	"L" : 0.9971372896572177,
	"M" : 0.1889510253449771
}, {
	"A" : -1.0890427016052584E-4,
	"B" : 5.640459677103138E-7,
	"C" : -7.782408282253073E-7,
	"D" : 1.0267214458345393,
	"E" : -9.786929783217602E-5,
	"F" : -1.6417015250917757,
	"H" : 1.120306140334204E-5,
	"I" : -1.0588528094879202E-6,
	"J" : 6.197690162987324E-5,
	"K" : -0.002640518201189934,
	"L" : 0.9971375738646984,
	"M" : 0.19422178670447465
}, {
	"A" : 1.2218595561019896E-4,
	"B" : -3.178718730456609E-7,
	"C" : -8.639839188528953E-7,
	"D" : 0.9697710884707362,
	"E" : 1.006589315011297E-5,
	"F" : 1.86669957887716,
	"H" : 1.1178558623037294E-5,
	"I" : -1.0588997338967232E-6,
	"J" : 6.197684408804083E-5,
	"K" : -0.002679254335959058,
	"L" : 0.9971378946429468,
	"M" : 0.19919755507271475
}, {
	"A" : 1.800011571773119E-5,
	"B" : 2.07233036997323E-6,
	"C" : -8.67952462124677E-7,
	"D" : 0.995767678406196,
	"E" : -2.9176193697821873E-4,
	"F" : 0.244680492200132,
	"H" : 1.1195482218118169E-5,
	"I" : -1.0590614569760959E-6,
	"J" : 6.197678950772834E-5,
	"K" : -0.0027281971077002254,
	"L" : 0.9971382297547109,
	"M" : 0.20489154090228112
}, {
	"A" : -8.856743871521466E-5,
	"B" : -1.1954358964949563E-6,
	"C" : -8.951494758768774E-7,
	"D" : 1.0226493822718794,
	"E" : 1.2129245180858561E-4,
	"F" : -1.4508344043570105,
	"H" : 1.1195083176485099E-5,
	"I" : -1.058911216933467E-6,
	"J" : 6.197673305785578E-5,
	"K" : -0.002772902223128426,
	"L" : 0.9971385257060987,
	"M" : 0.21041607754887082
}, {
	"A" : 1.5885487477440563E-4,
	"B" : -1.1371279806660084E-6,
	"C" : -1.0521139215402542E-6,
	"D" : 0.9586921699062145,
	"E" : 1.1673753192553704E-4,
	"F" : 2.6819219236240315,
	"H" : 1.1171906334594972E-5,
	"I" : -1.0590737316573673E-6,
	"J" : 6.197667369431392E-5,
	"K" : -0.002811657751053076,
	"L" : 0.9971388621943902,
	"M" : 0.21564175994444668
}, {
	"A" : 6.043650950982027E-5,
	"B" : 2.5654786230955295E-6,
	"C" : -1.065464981575559E-6,
	"D" : 0.9843993226678549,
	"E" : -3.708949416818541E-4,
	"F" : 1.0028885077408631,
	"H" : 1.1192155582928631E-5,
	"I" : -1.0593275859838158E-6,
	"J" : 6.197661890974815E-5,
	"K" : -0.0028616460101034136,
	"L" : 0.9971392108444235,
	"M" : 0.22168331597549695
}, {
	"A" : -5.3131015577800866E-5,
	"B" : 5.904834421421867E-7,
	"C" : -1.0302898607594813E-6,
	"D" : 1.0143931242903363,
	"E" : -1.1323443999344818E-4,
	"F" : -0.9777209906460484,
	"H" : 1.1196067342900129E-5,
	"I" : -1.059212751286509E-6,
	"J" : 6.197656438161614E-5,
	"K" : -0.0029074729936837684,
	"L" : 0.9971395109522234,
	"M" : 0.22754968075423676
}, {
	"A" : 1.7662369833404412E-4,
	"B" : 1.5235485031350748E-6,
	"C" : -1.0655644955281929E-6,
	"D" : 0.9522164381949096,
	"E" : -2.4223181247862158E-4,
	"F" : 3.22855293572502,
	"H" : 1.117714703025019E-5,
	"I" : -1.0593378667600462E-6,
	"J" : 6.197650842529323E-5,
	"K" : -0.002947095548933021,
	"L" : 0.99713984349561,
	"M" : 0.23308408526827407
} ], [

{
	"A" : 1.1334058185519247E-4,
	"B" : 1.6787120400429956E-6,
	"C" : -1.6575432737475637E-7,
	"D" : 0.9830127854971806,
	"E" : -1.332647740923676E-4,
	"F" : 0.6339312404525117,
	"H" : 1.119807729399458E-5,
	"I" : -1.086571464248287E-6,
	"J" : -1.6005055260831513E-4,
	"K" : -0.0016076347108935352,
	"L" : 1.0087391491902054,
	"M" : -0.05577396339867846
}, {
	"A" : 6.111387728213735E-6,
	"B" : 3.905015580452087E-6,
	"C" : -8.005541551892037E-8,
	"D" : 0.999474674613964,
	"E" : -3.1288833964993046E-4,
	"F" : 0.0018510724412408308,
	"H" : 1.1215010185361418E-5,
	"I" : -1.086637298475246E-6,
	"J" : -1.6004938922026257E-4,
	"K" : -0.001655032925100386,
	"L" : 1.0087394691430305,
	"M" : -0.052385633463018166
}, {
	"A" : -1.0284811480487654E-4,
	"B" : -1.9160684905372705E-7,
	"C" : -4.2618750750733625E-8,
	"D" : 1.0165268480931218,
	"E" : 5.048819019748407E-6,
	"F" : -0.6655683565386425,
	"H" : 1.1214078346366563E-5,
	"I" : -1.0864128673349072E-6,
	"J" : -1.600482281176041E-4,
	"K" : -0.001699770099932607,
	"L" : 1.0087397663285103,
	"M" : -0.04900655054007075
}, {
	"A" : 1.4899210999097523E-4,
	"B" : -5.5289396239111E-7,
	"C" : -1.6678654413126992E-7,
	"D" : 0.975615177205782,
	"E" : 3.5613558821978586E-5,
	"F" : 0.9956085444719065,
	"H" : 1.118952318701627E-5,
	"I" : -1.0865319125530348E-6,
	"J" : -1.6004707007655217E-4,
	"K" : -0.0017406009525728905,
	"L" : 1.0087400913302247,
	"M" : -0.045699142678131466
}, {
	"A" : 4.926003681560154E-5,
	"B" : 3.101964237028909E-6,
	"C" : -1.605041325403178E-7,
	"D" : 0.9920849758514692,
	"E" : -2.716623041862931E-4,
	"F" : 0.31533655264865956,
	"H" : 1.1209579191484575E-5,
	"I" : -1.0867456174401546E-6,
	"J" : -1.6004590831258936E-4,
	"K" : -0.0017886832889715265,
	"L" : 1.0087404242928173,
	"M" : -0.04200741872273284
}, {
	"A" : -6.521516943402972E-5,
	"B" : 4.697462068214975E-7,
	"C" : -1.2597915066692167E-7,
	"D" : 1.0113465057588655,
	"E" : -5.340737197911949E-5,
	"F" : -0.49512831404354074,
	"H" : 1.1213085735040096E-5,
	"I" : -1.0866096007422499E-6,
	"J" : -1.6004474709430117E-4,
	"K" : -0.0018341347013617337,
	"L" : 1.0087407279577505,
	"M" : -0.03833035047091471
}, {
	"A" : 1.7008780345384444E-4,
	"B" : 1.17137819488633E-6,
	"C" : -1.8643233345994048E-7,
	"D" : 0.9702640329654457,
	"E" : -1.1649375431943554E-4,
	"F" : 1.2977351096978964,
	"H" : 1.1193076937088264E-5,
	"I" : -1.0867404407477466E-6,
	"J" : -1.6004358754390102E-4,
	"K" : -0.0018754484684819772,
	"L" : 1.0087410548808933,
	"M" : -0.03474560503673274
}, {
	"A" : 4.741465286706159E-5,
	"B" : 5.179783733044729E-6,
	"C" : -7.891968811790662E-8,
	"D" : 0.9920048106699824,
	"E" : -4.8251178478153633E-4,
	"F" : 0.33423442144885485,
	"H" : 1.1216560266147368E-5,
	"I" : -1.0868950004461198E-6,
	"J" : -1.6004242346379094E-4,
	"K" : -0.0019243863279996276,
	"L" : 1.008741383859146,
	"M" : -0.030737105422304012
}, {
	"A" : -9.007336061905846E-5,
	"B" : 2.064260044454258E-6,
	"C" : 5.33787509748862E-8,
	"D" : 1.0168391944486075,
	"E" : -2.0966218426110572E-4,
	"F" : -0.7874092829606525,
	"H" : 1.1221549421791543E-5,
	"I" : -1.0866553877830754E-6,
	"J" : -1.6004126032753696E-4,
	"K" : -0.0019701702076986294,
	"L" : 1.0087416771340258,
	"M" : -0.02677308661850475
}, {
	"A" : 1.2879170666346695E-4,
	"B" : 1.5765337795237144E-6,
	"C" : 4.654703011919281E-8,
	"D" : 0.9760200260478484,
	"E" : -1.6919004625037815E-4,
	"F" : 1.1155407449441554,
	"H" : 1.1200957056756167E-5,
	"I" : -1.0866785769003684E-6,
	"J" : -1.6004009995229662E-4,
	"K" : -0.0020111646229850066,
	"L" : 1.0087419946178215,
	"M" : -0.02294354750029015
}, {
	"A" : 8.191707385751812E-7,
	"B" : 3.994045502553334E-6,
	"C" : 1.345152860210419E-7,
	"D" : 1.000278230339859,
	"E" : -4.070689560080609E-4,
	"F" : -0.03431700158944295,
	"H" : 1.1222363007379332E-5,
	"I" : -1.0867632045385989E-6,
	"J" : -1.600389368506816E-4,
	"K" : -0.00206001785423382,
	"L" : 1.0087423177361714,
	"M" : -0.01865668970231127
}, {
	"A" : -1.287940829137746E-4,
	"B" : -6.629121802603777E-7,
	"C" : 1.6444042461039032E-7,
	"D" : 1.0252726351773163,
	"E" : 3.944613689554899E-5,
	"F" : -1.23956798222207,
	"H" : 1.1225564684080869E-5,
	"I" : -1.0865276434124382E-6,
	"J" : -1.600377766827199E-4,
	"K" : -0.0021055326840553334,
	"L" : 1.0087426100315966,
	"M" : -0.014432919319006032
}, {
	"A" : 1.087209917702836E-4,
	"B" : -2.2163543715869594E-6,
	"C" : -1.3398216314186584E-8,
	"D" : 0.9781611593629691,
	"E" : 1.9747521014323866E-4,
	"F" : 1.0961954755985062,
	"H" : 1.1207197046281259E-5,
	"I" : -1.086646595815921E-6,
	"J" : -1.6003662082048065E-4,
	"K" : -0.0021467218030863933,
	"L" : 1.0087429375088561,
	"M" : -0.01033624522278842
}, {
	"A" : 6.097973950458524E-6,
	"B" : -6.970257704352889E-8,
	"C" : -1.318889775170362E-7,
	"D" : 0.9988418440683517,
	"E" : -1.653548420676998E-5,
	"F" : 0.05387990501549211,
	"H" : 1.1247395085456358E-5,
	"I" : -1.0869269641555768E-6,
	"J" : -1.6003546320841888E-4,
	"K" : -0.0021996155465160427,
	"L" : 1.0087432816462751,
	"M" : -0.0055650407884968445
}, {
	"A" : -9.820296541152018E-5,
	"B" : -4.075016741600379E-6,
	"C" : -2.9838499537859775E-7,
	"D" : 1.020162207134888,
	"E" : 4.0130679354888343E-4,
	"F" : -1.0360500689639593,
	"H" : 1.1537285677487574E-5,
	"I" : -1.0871358590569535E-6,
	"J" : -1.6003430900984883E-4,
	"K" : -0.0023044572808998964,
	"L" : 1.0087436194803274,
	"M" : 0.00199726061327965
}, {
	"A" : 1.5732763278331063E-4,
	"B" : -4.232246518132143E-6,
	"C" : -6.188214030089512E-7,
	"D" : 0.9663803805850648,
	"E" : 4.2969646747792467E-4,
	"F" : 1.7933299394280766,
	"H" : 1.1584180252155463E-5,
	"I" : -1.086466808408737E-6,
	"J" : -1.600331537182087E-4,
	"K" : -0.0023626376696199713,
	"L" : 1.0087438661891426,
	"M" : 0.007428262006214936
}, {
	"A" : 6.137391604665865E-5,
	"B" : -2.0820449764258342E-7,
	"C" : -7.939344397467352E-7,
	"D" : 0.9868196474821502,
	"E" : 4.972641136191669E-6,
	"F" : 0.7044385771077941,
	"H" : 1.1223591987352677E-5,
	"I" : -1.0870531170770192E-6,
	"J" : -1.600319933511285E-4,
	"K" : -0.0023305396253761046,
	"L" : 1.008744245758109,
	"M" : 0.00796109992734273
}, {
	"A" : -4.9699265216585076E-5,
	"B" : -2.3327436609044128E-6,
	"C" : -9.177498458967648E-7,
	"D" : 1.0108221657641252,
	"E" : 2.396186200712691E-4,
	"F" : -0.5926079601340462,
	"H" : 1.1203019042227425E-5,
	"I" : -1.087118913445373E-6,
	"J" : -1.6003083361554316E-4,
	"K" : -0.0023708133410593746,
	"L" : 1.008744570095189,
	"M" : 0.012434419259989227
}, {
	"A" : 1.8797915543178334E-4,
	"B" : -1.0572831503630198E-6,
	"C" : -1.1085611191230527E-6,
	"D" : 0.9579019069807373,
	"E" : 1.0303557934321361E-4,
	"F" : 2.352707253816334,
	"H" : 1.1175440493060851E-5,
	"I" : -1.087409629396685E-6,
	"J" : -1.6002967483735864E-4,
	"K" : -0.002409383319729841,
	"L" : 1.0087449200372731,
	"M" : 0.016894532711376087
}, {
	"A" : 6.722729495423074E-5,
	"B" : 3.6362209163698367E-6,
	"C" : -1.0989515004666828E-6,
	"D" : 0.9850800073766663,
	"E" : -4.313303887784059E-4,
	"F" : 0.8231262989902461,
	"H" : 1.1195955892773224E-5,
	"I" : -1.087697454660308E-6,
	"J" : -1.6002851121105222E-4,
	"K" : -0.002458676069153398,
	"L" : 1.0087452700785775,
	"M" : 0.02204176156556059
}, {
	"A" : -6.918104683295567E-5,
	"B" : 1.264471984008253E-6,
	"C" : -1.026973851070423E-6,
	"D" : 1.0162473247175967,
	"E" : -1.659540343439403E-4,
	"F" : -0.9574114941788139,
	"H" : 1.1199652409366045E-5,
	"I" : -1.087553038403577E-6,
	"J" : -1.6002734768755245E-4,
	"K" : -0.0025043034697205258,
	"L" : 1.008745570931552,
	"M" : 0.027079107931058388
}, {
	"A" : 1.4958065738035486E-4,
	"B" : 1.4901337583861363E-6,
	"C" : -1.0565160135644902E-6,
	"D" : 0.9649260959679395,
	"E" : -1.959968938081147E-4,
	"F" : 2.0522579400931136,
	"H" : 1.1178041929738036E-5,
	"I" : -1.087634689755923E-6,
	"J" : -1.600261859119323E-4,
	"K" : -0.0025439765879866627,
	"L" : 1.0087458982044666,
	"M" : 0.03185573182327062
}, {
	"A" : 2.0686480326492784E-5,
	"B" : 4.650167303665853E-6,
	"C" : -9.53725389329918E-7,
	"D" : 0.9955281877805646,
	"E" : -5.810507704495649E-4,
	"F" : 0.23560944366909098,
	"H" : 1.1198345726715075E-5,
	"I" : -1.0877475480342014E-6,
	"J" : -1.6002502078071856E-4,
	"K" : -0.002593505328803758,
	"L" : 1.0087462290749656,
	"M" : 0.03730120828913641
}, {
	"A" : -1.1076317594360674E-4,
	"B" : 6.841655859624041E-7,
	"C" : -8.712538424049399E-7,
	"D" : 1.0271714462193131,
	"E" : -1.0915742353745372E-4,
	"F" : -1.6689576720127661,
	"H" : 1.1199033237596634E-5,
	"I" : -1.0874955849171641E-6,
	"J" : -1.6002385746466397E-4,
	"K" : -0.0026384807855635017,
	"L" : 1.008746515984022,
	"M" : 0.042572214026222355
}, {
	"A" : 1.242712383817679E-4,
	"B" : -2.953137325789612E-7,
	"C" : -9.639643334669046E-7,
	"D" : 0.9692530263639583,
	"E" : 1.0995388038281817E-5,
	"F" : 1.8988459468491783,
	"H" : 1.1173706328027055E-5,
	"I" : -1.087553241796435E-6,
	"J" : -1.6002269768200517E-4,
	"K" : -0.0026769961684181,
	"L" : 1.008746840874899,
	"M" : 0.04753178062310326
}, {
	"A" : 1.830779550981987E-5,
	"B" : 2.3609374935062988E-6,
	"C" : -9.694064884158138E-7,
	"D" : 0.9956822603040791,
	"E" : -3.243195167783597E-4,
	"F" : 0.2505279192046146,
	"H" : 1.1191110239006097E-5,
	"I" : -1.0877208354576062E-6,
	"J" : -1.600215351297285E-4,
	"K" : -0.0027260403424946844,
	"L" : 1.0087471795196308,
	"M" : 0.05322942030397826
}, {
	"A" : -9.007878692823823E-5,
	"B" : -1.2714280743786333E-6,
	"C" : -9.995576799592953E-7,
	"D" : 1.0230378228013137,
	"E" : 1.3497490249392285E-4,
	"F" : -1.4758246458950453,
	"H" : 1.1190904676161573E-5,
	"I" : -1.0875765788509462E-6,
	"J" : -1.6002037441131822E-4,
	"K" : -0.0027707774776217775,
	"L" : 1.008747479034426,
	"M" : 0.058753386020725884
}, {
	"A" : 1.615651619135683E-4,
	"B" : -1.205683708871419E-6,
	"C" : -1.168328897627191E-6,
	"D" : 0.9579889671342698,
	"E" : 1.302184129485795E-4,
	"F" : 2.7274932772488683,
	"H" : 1.1166892137315365E-5,
	"I" : -1.087754515849415E-6,
	"J" : -1.600192162334313E-4,
	"K" : -0.0028092986036369894,
	"L" : 1.0087478203263842,
	"M" : 0.06396121913167008
}, {
	"A" : 6.146930757688907E-5,
	"B" : 2.9092475428704745E-6,
	"C" : -1.183818993499841E-6,
	"D" : 0.9841173693690735,
	"E" : -4.115872423540168E-4,
	"F" : 1.0220686868415214,
	"H" : 1.1187663259581981E-5,
	"I" : -1.0880142561897621E-6,
	"J" : -1.6001805380566614E-4,
	"K" : -0.002859404297623769,
	"L" : 1.008748172575821,
	"M" : 0.07000768635771237
}, {
	"A" : -5.4037761931580164E-5,
	"B" : 7.136629602833011E-7,
	"C" : -1.147388124067561E-6,
	"D" : 1.0146325119625317,
	"E" : -1.2512325372426858E-4,
	"F" : -0.9935580189485336,
	"H" : 1.1191852125447266E-5,
	"I" : -1.0878993758067779E-6,
	"J" : -1.6001689148409382E-4,
	"K" : -0.0029052876531778793,
	"L" : 1.008748475519198,
	"M" : 0.0758751292614761
}, {
	"A" : 1.7964018958549488E-4,
	"B" : 1.751779131087261E-6,
	"C" : -1.1862419118102707E-6,
	"D" : 0.9513897227940333,
	"E" : -2.6846688797377283E-4,
	"F" : 3.2851488387968857,
	"H" : 1.1172196809128287E-5,
	"I" : -1.0880287508729936E-6,
	"J" : -1.6001573019230886E-4,
	"K" : -0.002944693264495868,
	"L" : 1.00874881146607,
	"M" : 0.08139212343485269
} ], [

{
	"A" : 1.1545299694992739E-4,
	"B" : 1.912629315148351E-6,
	"C" : -1.9803760487047128E-7,
	"D" : 0.9826848264181365,
	"E" : -1.507208692146378E-4,
	"F" : 0.6466704200611275,
	"H" : 1.1189010082124362E-5,
	"I" : -1.0723667961953787E-6,
	"J" : -6.09348238893026E-5,
	"K" : -0.0016063515632680492,
	"L" : 1.0031319675078123,
	"M" : 0.023683143784182903
}, {
	"A" : 6.225668731985046E-6,
	"B" : 4.379286218547662E-6,
	"C" : -1.0660476201795888E-7,
	"D" : 0.9994431775215276,
	"E" : -3.498772008327933E-4,
	"F" : 0.0036332132567622466,
	"H" : 1.120643960489387E-5,
	"I" : -1.0724144480778186E-6,
	"J" : -6.093418282515639E-5,
	"K" : -0.0016537914321617109,
	"L" : 1.0031322825076998,
	"M" : 0.02707164123239636
}, {
	"A" : -1.0476332299225177E-4,
	"B" : -1.5911991635420009E-7,
	"C" : -6.754544967790821E-8,
	"D" : 1.0168319045571934,
	"E" : 2.3563342494981043E-6,
	"F" : -0.6776927427981718,
	"H" : 1.1205688215054632E-5,
	"I" : -1.0722057754986025E-6,
	"J" : -6.0933544202668166E-5,
	"K" : -0.0016985229020889392,
	"L" : 1.0031325773900832,
	"M" : 0.030449051993400644
}, {
	"A" : 1.517667589949756E-4,
	"B" : -5.596797307827472E-7,
	"C" : -2.0397904720859117E-7,
	"D" : 0.9751600234768034,
	"E" : 3.676282429410094E-5,
	"F" : 1.0142860423547972,
	"H" : 1.1180228100649003E-5,
	"I" : -1.0723327809047944E-6,
	"J" : -6.093290842024146E-5,
	"K" : -0.001739171564310027,
	"L" : 1.0031328994908932,
	"M" : 0.033747543606750696
}, {
	"A" : 5.017878550672705E-5,
	"B" : 3.4895425444769756E-6,
	"C" : -1.9878838386500064E-7,
	"D" : 0.9919194113454068,
	"E" : -3.0355863009390305E-4,
	"F" : 0.32277249592152657,
	"H" : 1.1200819802326123E-5,
	"I" : -1.0725273299483362E-6,
	"J" : -6.0932268932223366E-5,
	"K" : -0.0017873071422229714,
	"L" : 1.0031332273207099,
	"M" : 0.037439900799654424
}, {
	"A" : -6.642977784954152E-5,
	"B" : 5.73489841393382E-7,
	"C" : -1.6289412119174784E-7,
	"D" : 1.011552072796917,
	"E" : -6.175004759256808E-5,
	"F" : -0.5038107131258585,
	"H" : 1.1204592795299728E-5,
	"I" : -1.0724003378648206E-6,
	"J" : -6.093163017750758E-5,
	"K" : -0.0018327691850146266,
	"L" : 1.0031335282159262,
	"M" : 0.04111585200007539
}, {
	"A" : 1.7325719983252164E-4,
	"B" : 1.350684190049023E-6,
	"C" : -2.3015363181944082E-7,
	"D" : 0.969700914663008,
	"E" : -1.3131109443520472E-4,
	"F" : 1.3227520071486651,
	"H" : 1.1183785565083149E-5,
	"I" : -1.0725292559632393E-6,
	"J" : -6.0930992923591276E-5,
	"K" : -0.0018739084770800218,
	"L" : 1.0031338514304764,
	"M" : 0.044691365067592415
}, {
	"A" : 4.829965776309564E-5,
	"B" : 5.791618608697036E-6,
	"C" : -1.1504887442725931E-7,
	"D" : 0.9918280187059736,
	"E" : -5.370335127281578E-4,
	"F" : 0.3429899665170524,
	"H" : 1.1207901341181437E-5,
	"I" : -1.0726548675954461E-6,
	"J" : -6.09303511387993E-5,
	"K" : -0.001922923689605227,
	"L" : 1.0031341742777826,
	"M" : 0.04870164466956339
}, {
	"A" : -9.175192672472576E-5,
	"B" : 2.339950291974091E-6,
	"C" : 2.701226997636752E-8,
	"D" : 1.0171398728703593,
	"E" : -2.3503441653360824E-4,
	"F" : -0.8008428419998381,
	"H" : 1.121321552133292E-5,
	"I" : -1.0724181936372368E-6,
	"J" : -6.0929710416934846E-5,
	"K" : -0.001968732753880431,
	"L" : 1.0031344642538826,
	"M" : 0.05266516942720045
}, {
	"A" : 1.3119199482458654E-4,
	"B" : 1.7997039016837135E-6,
	"C" : 1.7982247246806082E-8,
	"D" : 0.9755622183257628,
	"E" : -1.9005472819344504E-4,
	"F" : 1.1373841443601123,
	"H" : 1.1191828111767332E-5,
	"I" : -1.0724389087335418E-6,
	"J" : -6.092907232330136E-5,
	"K" : -0.002009544452192813,
	"L" : 1.0031347779320399,
	"M" : 0.05648449625005014
}, {
	"A" : 8.347654372187208E-7,
	"B" : 4.477924513635045E-6,
	"C" : 1.1187798254486125E-7,
	"D" : 1.0002612943758606,
	"E" : -4.5373547845883877E-4,
	"F" : -0.032811135961310356,
	"H" : 1.1213811138832686E-5,
	"I" : -1.0724999279232428E-6,
	"J" : -6.092843154198446E-5,
	"K" : -0.0020584725514254387,
	"L" : 1.0031350952254527,
	"M" : 0.06077316448863712
}, {
	"A" : -1.311921056248444E-4,
	"B" : -6.815528434955809E-7,
	"C" : 1.4278589954841436E-7,
	"D" : 1.0257426766651179,
	"E" : 4.099507509636169E-5,
	"F" : -1.262575884891703,
	"H" : 1.121723707453448E-5,
	"I" : -1.0722768811755046E-6,
	"J" : -6.0927793731790914E-5,
	"K" : -0.002103996947951714,
	"L" : 1.0031353851524045,
	"M" : 0.06499565808007901
}, {
	"A" : 1.1074455452364518E-4,
	"B" : -2.4022658049460688E-6,
	"C" : -5.1913747523002485E-8,
	"D" : 0.9777613275482508,
	"E" : 2.1673013588952017E-4,
	"F" : 1.1159539617256087,
	"H" : 1.1197955334996124E-5,
	"I" : -1.072402297408459E-6,
	"J" : -6.0927160119128576E-5,
	"K" : -0.002144969812349018,
	"L" : 1.003135709704459,
	"M" : 0.06907978688377625
}, {
	"A" : 6.211805680056415E-6,
	"B" : -2.425630540869861E-8,
	"C" : -1.8219314545930843E-7,
	"D" : 0.9988169543867116,
	"E" : -1.9842756955767982E-5,
	"F" : 0.05523654723583604,
	"H" : 1.1238611238306717E-5,
	"I" : -1.0726577747699473E-6,
	"J" : -6.0926524697135775E-5,
	"K" : -0.0021979206415778663,
	"L" : 1.0031360477808349,
	"M" : 0.07385199103373452
}, {
	"A" : -1.0002925414331898E-4,
	"B" : -4.461611366579632E-6,
	"C" : -3.6454476859404394E-7,
	"D" : 1.0205524309104703,
	"E" : 4.437225830713487E-4,
	"F" : -1.0568896142285666,
	"H" : 1.1528431754004309E-5,
	"I" : -1.072808975655093E-6,
	"J" : -6.0925892517826874E-5,
	"K" : -0.0023027144318064074,
	"L" : 1.00313637612431,
	"M" : 0.08141000168325263
}, {
	"A" : 1.602537289278061E-4,
	"B" : -4.6355405605158495E-6,
	"C" : -7.140756416168514E-7,
	"D" : 0.9657710326483766,
	"E" : 4.762858186779795E-4,
	"F" : 1.82500936606084,
	"H" : 1.1574359658761413E-5,
	"I" : -1.0725544264955644E-6,
	"J" : -6.092525938417026E-5,
	"K" : -0.002360642800340429,
	"L" : 1.0031366628889558,
	"M" : 0.08682509954178386
}, {
	"A" : 6.251716473970603E-5,
	"B" : -1.7765029625138595E-7,
	"C" : -9.058689025565059E-7,
	"D" : 0.9865714863874473,
	"E" : 6.4539590880485775E-6,
	"F" : 0.7178586005575198,
	"H" : 1.1214620458943614E-5,
	"I" : -1.0730309085715817E-6,
	"J" : -6.092462158008294E-5,
	"K" : -0.0023286918534211054,
	"L" : 1.00313702729256,
	"M" : 0.08736385788870393
}, {
	"A" : -5.062400275024359E-5,
	"B" : -2.531374050374069E-6,
	"C" : -1.0418838356507365E-6,
	"D" : 1.0110307398722966,
	"E" : 2.669298536943643E-4,
	"F" : -0.6044171169705805,
	"H" : 1.1194345927001415E-5,
	"I" : -1.0730934466574027E-6,
	"J" : -6.092398414569988E-5,
	"K" : -0.0023689955241650296,
	"L" : 1.0031373478348513,
	"M" : 0.09183679864327132
}, {
	"A" : 1.914791851025388E-4,
	"B" : -1.1181487993283667E-6,
	"C" : -1.2506979185644695E-6,
	"D" : 0.9571193069440369,
	"E" : 1.1632484279289201E-4,
	"F" : 2.396383101979154,
	"H" : 1.1165992260364632E-5,
	"I" : -1.073378883220677E-6,
	"J" : -6.0923347910857295E-5,
	"K" : -0.0024073572857048475,
	"L" : 1.0031376937867122,
	"M" : 0.09628325001995108
}, {
	"A" : 6.848125500269475E-5,
	"B" : 4.081562956503859E-6,
	"C" : -1.2419495747373333E-6,
	"D" : 0.9847812772572979,
	"E" : -4.755722706022425E-4,
	"F" : 0.8408139696184662,
	"H" : 1.1187168046711271E-5,
	"I" : -1.0736372696440455E-6,
	"J" : -6.092270658369925E-5,
	"K" : -0.0024567634950187767,
	"L" : 1.0031380370837866,
	"M" : 0.10143476888879377
}, {
	"A" : -7.046990311110335E-5,
	"B" : 1.453809418183738E-6,
	"C" : -1.1653648548382023E-6,
	"D" : 1.0165406028971802,
	"E" : -1.8165116793511515E-4,
	"F" : -0.9741554610955063,
	"H" : 1.1191222850870375E-5,
	"I" : -1.0734947244461779E-6,
	"J" : -6.0922065500679246E-5,
	"K" : -0.0025024388914829387,
	"L" : 1.0031383347330944,
	"M" : 0.10647279853583314
}, {
	"A" : 1.523682456039399E-4,
	"B" : 1.7041534894346455E-6,
	"C" : -1.199060469136981E-6,
	"D" : 0.9642619203667664,
	"E" : -2.147524009501467E-4,
	"F" : 2.0917451162276848,
	"H" : 1.1168850695575383E-5,
	"I" : -1.0735719720988968E-6,
	"J" : -6.0921426254412214E-5,
	"K" : -0.0025418986391798626,
	"L" : 1.0031386580768498,
	"M" : 0.11123478475656157
}, {
	"A" : 2.107267195361473E-5,
	"B" : 5.204894307109242E-6,
	"C" : -1.0891088420006412E-6,
	"D" : 0.9954195884670298,
	"E" : -6.415156418029255E-4,
	"F" : 0.24301531715173041,
	"H" : 1.1189771542297056E-5,
	"I" : -1.073659795625126E-6,
	"J" : -6.092078344260843E-5,
	"K" : -0.002591539312774671,
	"L" : 1.0031389825306647,
	"M" : 0.11668474537327711
}, {
	"A" : -1.1282642352883343E-4,
	"B" : 8.107356248565623E-7,
	"C" : -1.0011055286973658E-6,
	"D" : 1.0276708719107432,
	"E" : -1.1881215226594577E-4,
	"F" : -1.6992377950809896,
	"H" : 1.1190725914267396E-5,
	"I" : -1.0734184471283825E-6,
	"J" : -6.092014267666812E-5,
	"K" : -0.0026365454376389152,
	"L" : 1.0031392672895976,
	"M" : 0.12195545599661273
}, {
	"A" : 1.2658573992663236E-4,
	"B" : -2.7383983169926296E-7,
	"C" : -1.1033692046691357E-6,
	"D" : 0.9686781025699247,
	"E" : 1.4652970151018962E-5,
	"F" : 1.934480245319719,
	"H" : 1.1164524876150494E-5,
	"I" : -1.0734832657233184E-6,
	"J" : -6.091950518888334E-5,
	"K" : -0.0026748106226932578,
	"L" : 1.0031395896229043,
	"M" : 0.1268973745936819
}, {
	"A" : 1.864931482153942E-5,
	"B" : 2.668653136694843E-6,
	"C" : -1.1109314341783971E-6,
	"D" : 0.9955871958883336,
	"E" : -3.566485873420788E-4,
	"F" : 0.25701447822211776,
	"H" : 1.118244139808322E-5,
	"I" : -1.0736369213670827E-6,
	"J" : -6.091886500247945E-5,
	"K" : -0.0027239475671763103,
	"L" : 1.0031399230948779,
	"M" : 0.13259850312351773
}, {
	"A" : -9.175622898727198E-5,
	"B" : -1.3558022182724727E-6,
	"C" : -1.1452155783686635E-6,
	"D" : 1.0234691582730875,
	"E" : 1.5244426219851448E-4,
	"F" : -1.5036243994254619,
	"H" : 1.11824362507007E-5,
	"I" : -1.073510933924382E-6,
	"J" : -6.091822671144831E-5,
	"K" : -0.0027687009549310915,
	"L" : 1.0031402215086018,
	"M" : 0.138121201962349
}, {
	"A" : 1.645733352360068E-4,
	"B" : -1.2822546417989855E-6,
	"C" : -1.3300812835570497E-6,
	"D" : 0.9572086763804464,
	"E" : 1.477438175925272E-4,
	"F" : 2.778006729859044,
	"H" : 1.1157538504891207E-5,
	"I" : -1.0736977609226983E-6,
	"J" : -6.091759075610437E-5,
	"K" : -0.002806957795371545,
	"L" : 1.0031405605352575,
	"M" : 0.14330957286438206
}, {
	"A" : 6.261568186882727E-5,
	"B" : 3.2762609070147164E-6,
	"C" : -1.3485871461771382E-6,
	"D" : 0.9838040889892454,
	"E" : -4.522869960510434E-4,
	"F" : 1.0433591407781933,
	"H" : 1.1178867876660004E-5,
	"I" : -1.0739387352742824E-6,
	"J" : -6.0916950652523116E-5,
	"K" : -0.0028571738554745707,
	"L" : 1.0031409069244717,
	"M" : 0.14936081874839147
}, {
	"A" : -5.50441787501299E-5,
	"B" : 8.434957496916695E-7,
	"C" : -1.3105966951698633E-6,
	"D" : 1.0148981687027572,
	"E" : -1.3486506924209607E-4,
	"F" : -1.0111709082266316,
	"H" : 1.1183347350840478E-5,
	"I" : -1.0738317799408037E-6,
	"J" : -6.091631071802883E-5,
	"K" : -0.0029030997715437934,
	"L" : 1.003141207518695,
	"M" : 0.15522868208881846
}, {
	"A" : 1.8298833799290648E-4,
	"B" : 1.9944127513937815E-6,
	"C" : -1.3544198433912413E-6,
	"D" : 0.9504719384097484,
	"E" : -2.9352957909623E-4,
	"F" : 3.34794867146411,
	"H" : 1.1162914669959889E-5,
	"I" : -1.0739570683315769E-6,
	"J" : -6.091567172927803E-5,
	"K" : -0.002942259974560102,
	"L" : 1.00314153950697,
	"M" : 0.1607266142991648
} ], [

{
	"A" : 1.1779201319539467E-4,
	"B" : 2.1650407684425943E-6,
	"C" : -2.3709668184324073E-7,
	"D" : 0.9823214009862227,
	"E" : -1.6907914560704285E-4,
	"F" : 0.6607902181513055,
	"H" : 1.1187428026915303E-5,
	"I" : -1.0582677968939969E-6,
	"J" : 5.453788267112403E-5,
	"K" : -0.0016062154581248933,
	"L" : 0.9964010122185769,
	"M" : 0.12189887182148595
}, {
	"A" : 6.35222325096052E-6,
	"B" : 4.8943756054686816E-6,
	"C" : -1.3869347359474204E-7,
	"D" : 0.9994075849550086,
	"E" : -3.8964269438679366E-4,
	"F" : 0.005655964809193392,
	"H" : 1.1205406974412746E-5,
	"I" : -1.058293735367588E-6,
	"J" : 5.453791205883851E-5,
	"K" : -0.0016537352780687797,
	"L" : 0.9964013271496057,
	"M" : 0.1252901282523453
}, {
	"A" : -1.0688390492652466E-4,
	"B" : -1.267986915465258E-7,
	"C" : -9.754286567353887E-8,
	"D" : 1.017169745590337,
	"E" : 4.91336322738789E-8,
	"F" : -0.6911289527815825,
	"H" : 1.120484120969989E-5,
	"I" : -1.0580999665332769E-6,
	"J" : 5.453793891729841E-5,
	"K" : -0.001698492017311537,
	"L" : 0.9964016248093586,
	"M" : 0.1286682365098386
}, {
	"A" : 1.5483895412060633E-4,
	"B" : -5.703129724032863E-7,
	"C" : -2.483762494565056E-7,
	"D" : 0.9746562034218584,
	"E" : 3.877495200299563E-5,
	"F" : 1.0349465719009459,
	"H" : 1.117839165176715E-5,
	"I" : -1.058239406548367E-6,
	"J" : 5.453796293208857E-5,
	"K" : -0.0017389746652867188,
	"L" : 0.9964019495359793,
	"M" : 0.13195963102771202
}, {
	"A" : 5.119611587867112E-5,
	"B" : 3.90988308396345E-6,
	"C" : -2.443199691448683E-7,
	"D" : 0.9917355223577715,
	"E" : -3.376523645499674E-4,
	"F" : 0.33104507429925434,
	"H" : 1.1199579299792095E-5,
	"I" : -1.0584140675007347E-6,
	"J" : 5.453799085269884E-5,
	"K" : -0.0017872034890444866,
	"L" : 0.9964022773286061,
	"M" : 0.1356554819012672
}, {
	"A" : -6.777464052887261E-5,
	"B" : 6.836783357222487E-7,
	"C" : -2.0663556266065086E-7,
	"D" : 1.011779630199669,
	"E" : -7.012346216583865E-5,
	"F" : -0.5134273176518036,
	"H" : 1.1203635859768912E-5,
	"I" : -1.0582952418847213E-6,
	"J" : 5.45380178553212E-5,
	"K" : -0.0018327091926977346,
	"L" : 0.9964025805369943,
	"M" : 0.13933295464539697
}, {
	"A" : 1.767665523373374E-4,
	"B" : 1.5433928490793392E-6,
	"C" : -2.818132216475533E-7,
	"D" : 0.9690772070689491,
	"E" : -1.4669130547417808E-4,
	"F" : 1.3504598253603035,
	"H" : 1.118195845883907E-5,
	"I" : -1.0584241182387544E-6,
	"J" : 5.4538043479213094E-5,
	"K" : -0.0018736914715731245,
	"L" : 0.9964029053659402,
	"M" : 0.14290125234401785
}, {
	"A" : 4.927965006595869E-5,
	"B" : 6.4570365627680815E-6,
	"C" : -1.575320035529515E-7,
	"D" : 0.9916312930363631,
	"E" : -5.958850630349843E-4,
	"F" : 0.3527641594137094,
	"H" : 1.1206777124850298E-5,
	"I" : -1.0585161002163446E-6,
	"J" : 5.4538073645915564E-5,
	"K" : -0.001922826753229856,
	"L" : 0.9964032268230909,
	"M" : 0.1469165103389969
}, {
	"A" : -9.361054641576771E-5,
	"B" : 2.6380424718031037E-6,
	"C" : -3.7150306164690505E-9,
	"D" : 1.0174724429969615,
	"E" : -2.621329924750171E-4,
	"F" : -0.8156894429848762,
	"H" : 1.1212437905916417E-5,
	"I" : -1.0582774441214582E-6,
	"J" : 5.4538102645773634E-5,
	"K" : -0.00196869525296961,
	"L" : 0.9964035182014612,
	"M" : 0.1508824337970509
}, {
	"A" : 1.338497588632137E-4,
	"B" : 2.040362227173631E-6,
	"C" : -1.5191732538610836E-8,
	"D" : 0.9750550356714598,
	"E" : -2.1220547179723326E-4,
	"F" : 1.161590147012248,
	"H" : 1.1190181662290577E-5,
	"I" : -1.0582954120263999E-6,
	"J" : 5.453812908146061E-5,
	"K" : -0.0020093405794909813,
	"L" : 0.9964038331959983,
	"M" : 0.1546936627546529
}, {
	"A" : 8.520438949943809E-7,
	"B" : 5.003515382018264E-6,
	"C" : 8.590468070224233E-8,
	"D" : 1.000241807924283,
	"E" : -5.041475434666154E-4,
	"F" : -0.031077648302016314,
	"H" : 1.1212804020666045E-5,
	"I" : -1.0583286027543437E-6,
	"J" : 5.453815823958097E-5,
	"K" : -0.002058385592405898,
	"L" : 0.9964041494042277,
	"M" : 0.15898752879547828
}, {
	"A" : -1.3384726246190581E-4,
	"B" : -7.050904027305904E-7,
	"C" : 1.181432903729629E-7,
	"D" : 1.0262632828125788,
	"E" : 4.325705717178607E-5,
	"F" : -1.2880707592557883,
	"H" : 1.1216464584185015E-5,
	"I" : -1.058116360252992E-6,
	"J" : 5.453818432077373E-5,
	"K" : -0.0021039517876886293,
	"L" : 0.9964044419380045,
	"M" : 0.1632117303679479
}, {
	"A" : 1.1298507163060023E-4,
	"B" : -2.6086360085386673E-6,
	"C" : -9.641231168977527E-8,
	"D" : 0.9773190904908802,
	"E" : 2.385086756646615E-4,
	"F" : 1.1377775484670565,
	"H" : 1.1196186135709052E-5,
	"I" : -1.0582530541314306E-6,
	"J" : 5.4538206339660444E-5,
	"K" : -0.002144721944617345,
	"L" : 0.996404769186455,
	"M" : 0.16728541892916837
}, {
	"A" : 6.337856620408644E-6,
	"B" : 2.2213427541828423E-8,
	"C" : -2.405257949478212E-7,
	"D" : 0.9987894427626429,
	"E" : -2.260807065113113E-5,
	"F" : 0.05672450554629904,
	"H" : 1.123736663427577E-5,
	"I" : -1.0584839583716033E-6,
	"J" : 5.453823017109727E-5,
	"K" : -0.002197773383045387,
	"L" : 0.9964051063926007,
	"M" : 0.17206229281691776
}, {
	"A" : -1.0205127547036064E-4,
	"B" : -4.887199799075148E-6,
	"C" : -4.415387375722446E-7,
	"D" : 1.020985295610842,
	"E" : 4.910690659016836E-4,
	"F" : -1.0800599637623236,
	"H" : 1.1527315585069253E-5,
	"I" : -1.0585688563491402E-6,
	"J" : 5.453825062889939E-5,
	"K" : -0.002302590934235127,
	"L" : 0.9964054295435858,
	"M" : 0.17962124737186969
}, {
	"A" : 1.634934540661881E-4,
	"B" : -5.079499014737365E-6,
	"C" : -8.25449979369175E-7,
	"D" : 0.9650972236751159,
	"E" : 5.284906652036625E-4,
	"F" : 1.8599763457750669,
	"H" : 1.1572240098234321E-5,
	"I" : -1.0588083923512848E-6,
	"J" : 5.453827237156261E-5,
	"K" : -0.002360287771949743,
	"L" : 0.9964057699021325,
	"M" : 0.18502295210601005
}, {
	"A" : 6.378302627263466E-5,
	"B" : -1.4749008281356168E-7,
	"C" : -1.0368862617404773E-6,
	"D" : 0.9862967871338242,
	"E" : 9.525711277547089E-6,
	"F" : 0.7326887064264156,
	"H" : 1.1213156903444599E-5,
	"I" : -1.0591635180023928E-6,
	"J" : 5.453829836088442E-5,
	"K" : -0.0023284734758277637,
	"L" : 0.996406123112699,
	"M" : 0.18556867612278438
}, {
	"A" : -5.164786732270166E-5,
	"B" : -2.7515810119282946E-6,
	"C" : -1.1872215437414013E-6,
	"D" : 1.0112621558494652,
	"E" : 2.9833649921329197E-4,
	"F" : -0.6175685113375948,
	"H" : 1.1193183480362467E-5,
	"I" : -1.059223763144601E-6,
	"J" : 5.453832383889301E-5,
	"K" : -0.002368837679668445,
	"L" : 0.9964064452003214,
	"M" : 0.19004449234307685
}, {
	"A" : 1.9535452116792307E-4,
	"B" : -1.1879944659121122E-6,
	"C" : -1.4172479407825733E-6,
	"D" : 0.9562530311329738,
	"E" : 1.3260418342042612E-4,
	"F" : 2.4446886493096827,
	"H" : 1.1163980103034987E-5,
	"I" : -1.0595089175446937E-6,
	"J" : 5.4538348380595014E-5,
	"K" : -0.002407004412873448,
	"L" : 0.9964067929341951,
	"M" : 0.19447961765945365
}, {
	"A" : 6.986977026879337E-5,
	"B" : 4.564986578969865E-6,
	"C" : -1.4093612810128775E-6,
	"D" : 0.9844498307307958,
	"E" : -5.221673401933913E-4,
	"F" : 0.8604484450988821,
	"H" : 1.1185887814846307E-5,
	"I" : -1.0597360030617509E-6,
	"J" : 5.453837795255101E-5,
	"K" : -0.0024565702251067023,
	"L" : 0.9964071345193446,
	"M" : 0.19963967967851204
}, {
	"A" : -7.189699237120095E-5,
	"B" : 1.6575730161783042E-6,
	"C" : -1.3271417091953452E-6,
	"D" : 1.0168651279225287,
	"E" : -1.9711352697981965E-4,
	"F" : -0.9926966351631563,
	"H" : 1.1190325163168424E-5,
	"I" : -1.059592262597775E-6,
	"J" : 5.453840719799041E-5,
	"K" : -0.0025023293686388115,
	"L" : 0.996407433848475,
	"M" : 0.2046821343310512
}, {
	"A" : 1.5545485017476324E-4,
	"B" : 1.9347181952067416E-6,
	"C" : -1.3656056279121032E-6,
	"D" : 0.9635262523688084,
	"E" : -2.334991347936466E-4,
	"F" : 2.1354710902887746,
	"H" : 1.1167120347987947E-5,
	"I" : -1.0596656562777973E-6,
	"J" : 5.453843480796028E-5,
	"K" : -0.002541589103429942,
	"L" : 0.9964077585454589,
	"M" : 0.20943197078759113
}, {
	"A" : 2.1500315787736923E-5,
	"B" : 5.8078949440876215E-6,
	"C" : -1.2469898611477959E-6,
	"D" : 0.9952984758848515,
	"E" : -7.059299049387846E-4,
	"F" : 0.25129429777007317,
	"H" : 1.1188723853194915E-5,
	"I" : -1.0597238083720484E-6,
	"J" : 5.4538465864562014E-5,
	"K" : -0.0025913874764000866,
	"L" : 0.9964080812665088,
	"M" : 0.21489088423095382
}, {
	"A" : -1.1511094786653686E-4,
	"B" : 9.459385261756381E-7,
	"C" : -1.15225331431823E-6,
	"D" : 1.0282237626532833,
	"E" : -1.2777077881764853E-4,
	"F" : -1.7327769277253537,
	"H" : 1.1189957967783215E-5,
	"I" : -1.0594903494531849E-6,
	"J" : 5.4538494921319014E-5,
	"K" : -0.0026364575544874924,
	"L" : 0.9964083687580256,
	"M" : 0.22016509346030944
}, {
	"A" : 1.2914845232625538E-4,
	"B" : -2.536649525985979E-7,
	"C" : -1.2656962571355734E-6,
	"D" : 0.9680416174467723,
	"E" : 2.0355237836611195E-5,
	"F" : 1.9738992247366696,
	"H" : 1.1162798877473179E-5,
	"I" : -1.059565595595835E-6,
	"J" : 5.453852070896881E-5,
	"K" : -0.002674481798663919,
	"L" : 0.9964086941624402,
	"M" : 0.22509172333684546
}, {
	"A" : 1.902748193183257E-5,
	"B" : 3.00171313094566E-6,
	"C" : -1.2756132528046749E-6,
	"D" : 0.9954815133351076,
	"E" : -3.9026493709570786E-4,
	"F" : 0.26422427289071493,
	"H" : 1.1181283050720747E-5,
	"I" : -1.0597050140170872E-6,
	"J" : 5.453854921327883E-5,
	"K" : -0.0027237552391738973,
	"L" : 0.9964090276504294,
	"M" : 0.23080089813265658
}, {
	"A" : -9.361352063530504E-5,
	"B" : -1.4511162271801936E-6,
	"C" : -1.3146399693297894E-6,
	"D" : 1.0239470193216675,
	"E" : 1.732720328391224E-4,
	"F" : -1.5344665074480872,
	"H" : 1.1181486209377312E-5,
	"I" : -1.0595987575690025E-6,
	"J" : 5.453857565407283E-5,
	"K" : -0.0027685568673376793,
	"L" : 0.9964093303835853,
	"M" : 0.23632621835804457
}, {
	"A" : 1.679040675388599E-4,
	"B" : -1.3692671323450867E-6,
	"C" : -1.5184516783950386E-6,
	"D" : 0.9563449871425291,
	"E" : 1.6881803549040342E-4,
	"F" : 2.8338724649656797,
	"H" : 1.1155621268132965E-5,
	"I" : -1.0598005227846485E-6,
	"J" : 5.453859993131971E-5,
	"K" : -0.0028065579854228417,
	"L" : 0.9964096731683298,
	"M" : 0.2414975487654374
}, {
	"A" : 6.388505504784092E-5,
	"B" : 3.6740789925993056E-6,
	"C" : -1.5403767585908668E-6,
	"D" : 0.983456673760088,
	"E" : -4.948253119891888E-4,
	"F" : 1.0669733283139067,
	"H" : 1.1177572015852455E-5,
	"I" : -1.0600227736135004E-6,
	"J" : 5.453862844317925E-5,
	"K" : -0.0028569308485231204,
	"L" : 0.9964100189425977,
	"M" : 0.24755852536873135
}, {
	"A" : -5.615852655616038E-5,
	"B" : 9.82231807000744E-7,
	"C" : -1.500370145235408E-6,
	"D" : 1.0151922133251219,
	"E" : -1.436060718447152E-4,
	"F" : -1.0306880178832216,
	"H" : 1.1182362238293386E-5,
	"I" : -1.059922944857128E-6,
	"J" : 5.453865670351776E-5,
	"K" : -0.0029029347244033943,
	"L" : 0.9964103223231433,
	"M" : 0.25343111402980867
}, {
	"A" : 1.8669564367601588E-4,
	"B" : 2.256189821192578E-6,
	"C" : -1.5499303041011103E-6,
	"D" : 0.949455404954108,
	"E" : -3.189366310607511E-4,
	"F" : 3.4174957418290433,
	"H" : 1.1161082727029203E-5,
	"I" : -1.0600454256604053E-6,
	"J" : 5.453868399035722E-5,
	"K" : -0.002941860677864838,
	"L" : 0.9964106557727916,
	"M" : 0.2589127085302607
} ], [

{
	"A" : 1.2037771548745191E-4,
	"B" : 2.4371073004125776E-6,
	"C" : -2.7662748536272375E-7,
	"D" : 0.981919345393095,
	"E" : -1.8877439751463498E-4,
	"F" : 0.6764196261920006,
	"H" : 1.118247349113366E-5,
	"I" : -1.0813884132598872E-6,
	"J" : -1.42238548303808E-4,
	"K" : -0.0016044131537995554,
	"L" : 1.0090590831328186,
	"M" : -0.08150123790028374
}, {
	"A" : 6.492142468061957E-6,
	"B" : 5.452369044922634E-6,
	"C" : -1.7101581795131438E-7,
	"D" : 0.9993674968844175,
	"E" : -4.326408063946019E-4,
	"F" : 0.007947801837872248,
	"H" : 1.1201041945740897E-5,
	"I" : -1.0814078678644812E-6,
	"J" : -1.422374492237033E-4,
	"K" : -0.0016520052495536675,
	"L" : 1.0090593870408,
	"M" : -0.07810929073320949
}, {
	"A" : -1.0922804701452016E-4,
	"B" : -9.423742808323254E-8,
	"C" : -1.2750370381731102E-7,
	"D" : 1.0175432671911437,
	"E" : -2.189698193433287E-6,
	"F" : -0.705988425634132,
	"H" : 1.1200668907473954E-5,
	"I" : -1.0812143340643843E-6,
	"J" : -1.422363527456838E-4,
	"K" : -0.0016967755078667324,
	"L" : 1.0090596741930327,
	"M" : -0.07473269652018644
}, {
	"A" : 1.5823504628864615E-4,
	"B" : -5.845515920199773E-7,
	"C" : -2.923935047416393E-7,
	"D" : 0.9740994029927492,
	"E" : 4.120655034967058E-5,
	"F" : 1.0577723740298097,
	"H" : 1.1173162805522274E-5,
	"I" : -1.0813681865506908E-6,
	"J" : -1.4223525848411356E-4,
	"K" : -0.0017370677469443763,
	"L" : 1.0090599895436227,
	"M" : -0.07145117336449403
}, {
	"A" : 5.2320772319536246E-5,
	"B" : 4.364736916784295E-6,
	"C" : -2.89197995440027E-7,
	"D" : 0.9915316530011182,
	"E" : -3.745335955045448E-4,
	"F" : 0.3402376507074223,
	"H" : 1.1194991305751856E-5,
	"I" : -1.081545770942327E-6,
	"J" : -1.4223416073694262E-4,
	"K" : -0.001785383102046012,
	"L" : 1.0090603070615032,
	"M" : -0.06775393472526048
}, {
	"A" : -6.926129394302372E-5,
	"B" : 8.009874243875004E-7,
	"C" : -2.4945300647338797E-7,
	"D" : 1.0120311137332862,
	"E" : -7.902248648861132E-5,
	"F" : -0.5240533436699479,
	"H" : 1.1199346726498138E-5,
	"I" : -1.0814290710148278E-6,
	"J" : -1.4223306400923397E-4,
	"K" : -0.0018309218796446203,
	"L" : 1.0090605999352746,
	"M" : -0.06407718922673666
}, {
	"A" : 1.8064598686962086E-4,
	"B" : 1.750453718418754E-6,
	"C" : -3.3223764217549245E-7,
	"D" : 0.9683875244413116,
	"E" : -1.6323544753049646E-4,
	"F" : 1.381106222546805,
	"H" : 1.117674139372582E-5,
	"I" : -1.0815676391717766E-6,
	"J" : -1.4223196845192243E-4,
	"K" : -0.0018717233416793988,
	"L" : 1.0090609150899112,
	"M" : -0.060518979787957505
}, {
	"A" : 5.036306168193505E-5,
	"B" : 7.1786485458247284E-6,
	"C" : -1.985545986515902E-7,
	"D" : 0.9914128187752453,
	"E" : -6.597457071393364E-4,
	"F" : 0.36365814661985496,
	"H" : 1.1202315310099298E-5,
	"I" : -1.081654438350732E-6,
	"J" : -1.4223086865677859E-4,
	"K" : -0.0019209737205727606,
	"L" : 1.0090612255668887,
	"M" : -0.056500839848922624
}, {
	"A" : -9.566517713111011E-5,
	"B" : 2.9598671944519594E-6,
	"C" : -3.2757872081567996E-8,
	"D" : 1.0178397079449724,
	"E" : -2.9142883587951474E-4,
	"F" : -0.8320669868662662,
	"H" : 1.1208341560098312E-5,
	"I" : -1.0814106551348956E-6,
	"J" : -1.4222977015204696E-4,
	"K" : -0.0019668918856439177,
	"L" : 1.0090615059428885,
	"M" : -0.05253480217743345
}, {
	"A" : 1.3678781953863073E-4,
	"B" : 2.2996313686629577E-6,
	"C" : -4.639455863930664E-8,
	"D" : 0.9744940822788237,
	"E" : -2.3612795143890253E-4,
	"F" : 1.188375673171322,
	"H" : 1.1185157076876173E-5,
	"I" : -1.0814367443767736E-6,
	"J" : -1.4222867392843508E-4,
	"K" : -0.0020073460589600245,
	"L" : 1.009061811138693,
	"M" : -0.048734701034845784
}, {
	"A" : 8.711581167553106E-7,
	"B" : 5.572940372289281E-6,
	"C" : 6.214066161636111E-8,
	"D" : 1.0002195072065092,
	"E" : -5.588337783706265E-4,
	"F" : -0.029087925899148104,
	"H" : 1.1208464527567852E-5,
	"I" : -1.0814723249152891E-6,
	"J" : -1.4222757514981144E-4,
	"K" : -0.0020565023448000375,
	"L" : 1.009062117013201,
	"M" : -0.04443782484577241
}, {
	"A" : -1.3678231979685762E-4,
	"B" : -7.333159615097173E-7,
	"C" : 9.598133465793524E-8,
	"D" : 1.0268389268935607,
	"E" : 4.588886838519102E-5,
	"F" : -1.3162676201136492,
	"H" : 1.121236834056294E-5,
	"I" : -1.0812745273591773E-6,
	"J" : -1.4222647935180355E-4,
	"K" : -0.0021020985705035855,
	"L" : 1.0090624003757966,
	"M" : -0.04021437717983645
}, {
	"A" : 1.1546174614829319E-4,
	"B" : -2.8358977599562962E-6,
	"C" : -1.3805963838819935E-7,
	"D" : 0.976830702542884,
	"E" : 2.623431257973152E-4,
	"F" : 1.1618559492017084,
	"H" : 1.119102201829758E-5,
	"I" : -1.0814532186431691E-6,
	"J" : -1.4222538703440035E-4,
	"K" : -0.0021426374915165525,
	"L" : 1.0090627212071865,
	"M" : -0.03615449382687075
}, {
	"A" : 6.47721244884103E-6,
	"B" : 7.015579472913203E-8,
	"C" : -2.956704572287805E-7,
	"D" : 0.998759068490358,
	"E" : -2.5521994189148245E-5,
	"F" : 0.058365994882478844,
	"H" : 1.1232758514223562E-5,
	"I" : -1.0817441407073858E-6,
	"J" : -1.4222429289811878E-4,
	"K" : -0.002195779717425239,
	"L" : 1.0090630539275196,
	"M" : -0.031375501299407915
}, {
	"A" : -1.0428633594949943E-4,
	"B" : -5.352962155757979E-6,
	"C" : -5.149735324838645E-7,
	"D" : 1.021464592397706,
	"E" : 5.426463645221702E-4,
	"F" : -1.1057569015174522,
	"H" : 1.152275531479674E-5,
	"I" : -1.0820397049471353E-6,
	"J" : -1.4222320208101547E-4,
	"K" : -0.002300582148450303,
	"L" : 1.0090633883087037,
	"M" : -0.02381999348199315
}, {
	"A" : 1.6707454596120996E-4,
	"B" : -5.565389317840896E-6,
	"C" : -9.328235668348839E-7,
	"D" : 0.9643532752736519,
	"E" : 5.853038396708143E-4,
	"F" : 1.8985365832013485,
	"H" : 1.1566588368094877E-5,
	"I" : -1.0814972932760014E-6,
	"J" : -1.4222210971670535E-4,
	"K" : -0.0023580545630608185,
	"L" : 1.0090636360696834,
	"M" : -0.01843120205194282
}, {
	"A" : 6.51823633166515E-5,
	"B" : -1.1733777238731591E-7,
	"C" : -1.1635477572546904E-6,
	"D" : 0.9859931919809242,
	"E" : 1.2819213907278026E-5,
	"F" : 0.7490747248193657,
	"H" : 1.1208320195299493E-5,
	"I" : -1.0820784849263632E-6,
	"J" : -1.4222101401772935E-4,
	"K" : -0.0023263863219540326,
	"L" : 1.0090640030273903,
	"M" : -0.017880562691971136
}, {
	"A" : -5.277962774519196E-5,
	"B" : -2.993831811348713E-6,
	"C" : -1.3278519910286946E-6,
	"D" : 1.0115184425058033,
	"E" : 3.3242410358980123E-4,
	"F" : -0.632159469590988,
	"H" : 1.1188672261852606E-5,
	"I" : -1.0822015512057526E-6,
	"J" : -1.422199188859663E-4,
	"K" : -0.002366800870646557,
	"L" : 1.009064321610893,
	"M" : -0.01340451084797678
}, {
	"A" : 1.996383950892966E-4,
	"B" : -1.2668024385042997E-6,
	"C" : -1.5787198655026202E-6,
	"D" : 0.9552956705509246,
	"E" : 1.5020570674550981E-4,
	"F" : 2.498059206416656,
	"H" : 1.115856588718156E-5,
	"I" : -1.0825300801875493E-6,
	"J" : -1.422188244558642E-4,
	"K" : -0.002404745846419587,
	"L" : 1.0090646638364262,
	"M" : -0.008984260916804487
}, {
	"A" : 7.140477758404984E-5,
	"B" : 5.08845848368189E-6,
	"C" : -1.5714378933662232E-6,
	"D" : 0.9840827312207807,
	"E" : -5.730218147164123E-4,
	"F" : 0.8822319695536862,
	"H" : 1.118126189958435E-5,
	"I" : -1.0827732843665672E-6,
	"J" : -1.4221772532613253E-4,
	"K" : -0.0024544690588896856,
	"L" : 1.0090649969416745,
	"M" : -0.0038178644635991077
}, {
	"A" : -7.347456113082629E-5,
	"B" : 1.8767739522473903E-6,
	"C" : -1.483324511664108E-6,
	"D" : 1.0172236502025953,
	"E" : -2.1410001164667847E-4,
	"F" : -1.0131671353519778,
	"H" : 1.118610492945038E-5,
	"I" : -1.0826354827631057E-6,
	"J" : -1.422166268377767E-4,
	"K" : -0.0025003037117272697,
	"L" : 1.0090652866622065,
	"M" : 0.0012265225341252517
}, {
	"A" : 1.588669734826631E-4,
	"B" : 2.1828994343220387E-6,
	"C" : -1.5262606289923042E-6,
	"D" : 0.9627127370171138,
	"E" : -2.5405756821328396E-4,
	"F" : 2.1838395748709445,
	"H" : 1.1162012024779067E-5,
	"I" : -1.0827190625728456E-6,
	"J" : -1.4221552970938856E-4,
	"K" : -0.00253933662705208,
	"L" : 1.0090656022475173,
	"M" : 0.005960591071925592
}, {
	"A" : 2.1973092892313417E-5,
	"B" : 6.461563186066499E-6,
	"C" : -1.3987601992226928E-6,
	"D" : 0.9951636972522806,
	"E" : -7.762058341995726E-4,
	"F" : 0.26055370665562805,
	"H" : 1.1184348751525075E-5,
	"I" : -1.0827741540042624E-6,
	"J" : -1.422144294362382E-4,
	"K" : -0.0025892905175908254,
	"L" : 1.009065914300038,
	"M" : 0.011426243829191662
}, {
	"A" : -1.1763634981210025E-4,
	"B" : 1.0905509308933858E-6,
	"C" : -1.2970317324612068E-6,
	"D" : 1.028834840625052,
	"E" : -1.3770306742344474E-4,
	"F" : -1.7698380285073654,
	"H" : 1.1185876358399405E-5,
	"I" : -1.0825393214064505E-6,
	"J" : -1.422133312557472E-4,
	"K" : -0.0026344149036390263,
	"L" : 1.009066191311831,
	"M" : 0.016701340696272382
}, {
	"A" : 1.3198136039105357E-4,
	"B" : -2.3444557117890952E-7,
	"C" : -1.4213227739201528E-6,
	"D" : 0.9673381125080596,
	"E" : 2.6374236711035337E-5,
	"F" : 2.017464560314693,
	"H" : 1.1157693748098385E-5,
	"I" : -1.0826270134822735E-6,
	"J" : -1.4221223585164644E-4,
	"K" : -0.002672168613798931,
	"L" : 1.0090665079180638,
	"M" : 0.02160879452185327
}, {
	"A" : 1.9445548690377734E-5,
	"B" : 3.3615663013186747E-6,
	"C" : -1.4333208022687671E-6,
	"D" : 0.9953642452736062,
	"E" : -4.270665347121394E-4,
	"F" : 0.27225085955433315,
	"H" : 1.1176787516331554E-5,
	"I" : -1.082771417415529E-6,
	"J" : -1.4221113780887862E-4,
	"K" : -0.0027215750136093675,
	"L" : 1.0090668317062352,
	"M" : 0.02732367885982967
}, {
	"A" : -9.566658071014089E-5,
	"B" : -1.5573970646443058E-6,
	"C" : -1.4767779592528285E-6,
	"D" : 1.0244755243055579,
	"E" : 1.956930983624261E-4,
	"F" : -1.5685932794585824,
	"H" : 1.1177208303569941E-5,
	"I" : -1.082673175667459E-6,
	"J" : -1.4221004187919828E-4,
	"K" : -0.0027664142574082007,
	"L" : 1.0090671251459327,
	"M" : 0.032848880133315106
}, {
	"A" : 1.7158591862109773E-4,
	"B" : -1.4667589289807381E-6,
	"C" : -1.6991710929392667E-6,
	"D" : 0.9553905161772036,
	"E" : 1.9149745753566094E-4,
	"F" : 2.8955940237647155,
	"H" : 1.1150311226337806E-5,
	"I" : -1.0828935212425783E-6,
	"J" : -1.422089476946775E-4,
	"K" : -0.002804129310902681,
	"L" : 1.0090674600208729,
	"M" : 0.03799909657573153
}, {
	"A" : 6.528833645980114E-5,
	"B" : 4.104370310731298E-6,
	"C" : -1.7242448815402156E-6,
	"D" : 0.9830720670715891,
	"E" : -5.41410105711293E-4,
	"F" : 1.0931515678021242,
	"H" : 1.1172930700908967E-5,
	"I" : -1.083120778011537E-6,
	"J" : -1.4220784968066447E-4,
	"K" : -0.0028546571825245337,
	"L" : 1.009067796174378,
	"M" : 0.04406751703209011
}, {
	"A" : -5.739036414764698E-5,
	"B" : 1.1306550826706285E-6,
	"C" : -1.6819462298478527E-6,
	"D" : 1.0155171460536394,
	"E" : -1.534311066961891E-4,
	"F" : -1.0522458604391431,
	"H" : 1.11780494906899E-5,
	"I" : -1.0830214141610561E-6,
	"J" : -1.4220675211290557E-4,
	"K" : -0.0029007306199417826,
	"L" : 1.0090680893480197,
	"M" : 0.049942157786063035
}, {
	"A" : 1.9079394174026376E-4,
	"B" : 2.5382848902744115E-6,
	"C" : -1.7369467057992694E-6,
	"D" : 0.9483313492934826,
	"E" : -3.468884572725983E-4,
	"F" : 3.494422069925349,
	"H" : 1.1155867452983248E-5,
	"I" : -1.0831484354989485E-6,
	"J" : -1.4220565529293738E-4,
	"K" : -0.0029393936295036838,
	"L" : 1.0090684131347558,
	"M" : 0.055403316056981566
} ], [

{
	"A" : 1.2323339677267064E-4,
	"B" : 2.731924832910515E-6,
	"C" : -3.306785412160451E-7,
	"D" : 0.9814749341607012,
	"E" : -2.090836206178892E-4,
	"F" : 0.6936907001327199,
	"H" : 1.1174301771221806E-5,
	"I" : -1.0659326112882894E-6,
	"J" : -2.199244138739731E-5,
	"K" : -0.0016033937770174589,
	"L" : 1.0008281392095455,
	"M" : 0.05951697061664163
}, {
	"A" : 6.646692758294215E-6,
	"B" : 6.059967991189907E-6,
	"C" : -2.1559572793705684E-7,
	"D" : 0.9993223133938045,
	"E" : -4.785758341085966E-4,
	"F" : 0.010533747234148905,
	"H" : 1.1193504319106928E-5,
	"I" : -1.0659315968220007E-6,
	"J" : -2.199198558916482E-5,
	"K" : -0.0016510527287039167,
	"L" : 1.0008284463950403,
	"M" : 0.06291028089617612
}, {
	"A" : -1.1181683842009793E-4,
	"B" : -6.134168062388312E-8,
	"C" : -1.690646660446049E-7,
	"D" : 1.0179558378726767,
	"E" : -3.578064053044727E-6,
	"F" : -0.7224191815839731,
	"H" : 1.1193332094761033E-5,
	"I" : -1.0657542250380736E-6,
	"J" : -2.1991532543452763E-5,
	"K" : -0.00169582457165518,
	"L" : 1.0008287396818645,
	"M" : 0.06628572169574909
}, {
	"A" : 1.6198559220326203E-4,
	"B" : -6.029034880228323E-7,
	"C" : -3.5277967258551257E-7,
	"D" : 0.9734846428541175,
	"E" : 4.523429177538674E-5,
	"F" : 1.0829468094943877,
	"H" : 1.1164694697085586E-5,
	"I" : -1.065918283971179E-6,
	"J" : -2.199108184719467E-5,
	"K" : -0.0017359015998010818,
	"L" : 1.0008290607415375,
	"M" : 0.06955720844052848
}, {
	"A" : 5.356289648295043E-5,
	"B" : 4.859503390797215E-6,
	"C" : -3.5084863991841075E-7,
	"D" : 0.991305775616695,
	"E" : -4.134769148151918E-4,
	"F" : 0.3504287890427804,
	"H" : 1.1187213851904243E-5,
	"I" : -1.0660757495672968E-6,
	"J" : -2.1990627290247033E-5,
	"K" : -0.001784299676657497,
	"L" : 1.0008293814526397,
	"M" : 0.07325652949748473
}, {
	"A" : -7.090311579349695E-5,
	"B" : 9.265758871279672E-7,
	"C" : -3.084850541679174E-7,
	"D" : 1.0123087548790295,
	"E" : -8.738976052313774E-5,
	"F" : -0.5358015180481743,
	"H" : 1.1191885505024146E-5,
	"I" : -1.0659683125080477E-6,
	"J" : -2.1990173991348616E-5,
	"K" : -0.0018298615186154166,
	"L" : 1.0008296799887617,
	"M" : 0.07693292489329906
}, {
	"A" : 1.8493043955380983E-4,
	"B" : 1.9741387882188377E-6,
	"C" : -4.0151296731849584E-7,
	"D" : 0.9676255829008369,
	"E" : -1.797882407004181E-4,
	"F" : 1.4149504553424777,
	"H" : 1.1168287559537582E-5,
	"I" : -1.0661055636074224E-6,
	"J" : -2.1989721747717184E-5,
	"K" : -0.001870458450184742,
	"L" : 1.000829999901157,
	"M" : 0.08048082649929711
}, {
	"A" : 5.155967324155242E-5,
	"B" : 7.96521423929164E-6,
	"C" : -2.554393825349166E-7,
	"D" : 0.9911703095873747,
	"E" : -7.282386560518717E-4,
	"F" : 0.3757786428377585,
	"H" : 1.1194675024084333E-5,
	"I" : -1.066160250806636E-6,
	"J" : -2.198926512958499E-5,
	"K" : -0.0019198223928356128,
	"L" : 1.0008303123712068,
	"M" : 0.08450260490462824
}, {
	"A" : -9.793432418980785E-5,
	"B" : 3.309156997310936E-6,
	"C" : -7.382601974192937E-8,
	"D" : 1.0182448482219115,
	"E" : -3.22348285692442E-4,
	"F" : -0.8501269207517907,
	"H" : 1.1201088184198404E-5,
	"I" : -1.0659173252935972E-6,
	"J" : -2.198881005799347E-5,
	"K" : -0.0019657812583488976,
	"L" : 1.0008305976720067,
	"M" : 0.08846911755335896
}, {
	"A" : 1.4003264183815034E-4,
	"B" : 2.5804464405254635E-6,
	"C" : -9.045857307654614E-8,
	"D" : 0.9738742076302458,
	"E" : -2.611069654676612E-4,
	"F" : 1.2179742972457461,
	"H" : 1.1176908998211665E-5,
	"I" : -1.0659401442625338E-6,
	"J" : -2.198835717859282E-5,
	"K" : -0.0020060195500946065,
	"L" : 1.0008309073991626,
	"M" : 0.09225771864203125
}, {
	"A" : 8.922852152704053E-7,
	"B" : 6.193045186009272E-6,
	"C" : 2.78538556663932E-8,
	"D" : 1.000193947176541,
	"E" : -6.176052906425866E-4,
	"F" : -0.02681503550047637,
	"H" : 1.1200952636847283E-5,
	"I" : -1.0659488733355538E-6,
	"J" : -2.1987901564712864E-5,
	"K" : -0.0020552850209583085,
	"L" : 1.0008312155366923,
	"M" : 0.09655829965413432
}, {
	"A" : -1.4002367746068778E-4,
	"B" : -7.668991917064716E-7,
	"C" : 6.370407668043754E-8,
	"D" : 1.0274748231503281,
	"E" : 4.979052334874723E-5,
	"F" : -1.3474378209575661,
	"H" : 1.1205109811118774E-5,
	"I" : -1.0657626773324935E-6,
	"J" : -2.198744911507955E-5,
	"K" : -0.002100900634488312,
	"L" : 1.0008315048468717,
	"M" : 0.10078122016784619
}, {
	"A" : 1.1819684370095729E-4,
	"B" : -3.0872338794285525E-6,
	"C" : -1.96386253703551E-7,
	"D" : 0.9762919032758646,
	"E" : 2.898554276953291E-4,
	"F" : 1.1883705349900993,
	"H" : 1.118261654464714E-5,
	"I" : -1.0659490501385704E-6,
	"J" : -2.1987000313250515E-5,
	"K" : -0.0021411809510993862,
	"L" : 1.0008318312966082,
	"M" : 0.10482671674253652
}, {
	"A" : 6.6311316473388615E-6,
	"B" : 1.198518062572873E-7,
	"C" : -3.7207642400449714E-7,
	"D" : 0.9987255584929926,
	"E" : -2.697720663036307E-5,
	"F" : 0.06014803361176746,
	"H" : 1.1224944864496322E-5,
	"I" : -1.0662118796744835E-6,
	"J" : -2.1986549438079983E-5,
	"K" : -0.0021944111980189973,
	"L" : 1.0008321660487667,
	"M" : 0.10960853660071734
}, {
	"A" : -1.0675450308106349E-4,
	"B" : -5.865061538212757E-6,
	"C" : -6.15841117990179E-7,
	"D" : 1.0219948659775469,
	"E" : 6.011739399127691E-4,
	"F" : -1.1342714009697374,
	"H" : 1.1514910812249202E-5,
	"I" : -1.0664341488775264E-6,
	"J" : -2.19861019352674E-5,
	"K" : -0.0022991786148338633,
	"L" : 1.0008324977623175,
	"M" : 0.11716073858224263
}, {
	"A" : 1.7102916413458402E-4,
	"B" : -6.099658952596343E-6,
	"C" : -1.0789735088723162E-6,
	"D" : 0.9635327584699667,
	"E" : 6.502864639514883E-4,
	"F" : 1.9409609799731697,
	"H" : 1.1557556551800019E-5,
	"I" : -1.066403297222962E-6,
	"J" : -2.1985652827294366E-5,
	"K" : -0.002356350505394289,
	"L" : 1.0008328042103045,
	"M" : 0.12253103504917817
}, {
	"A" : 6.672777170946276E-5,
	"B" : -8.714778410023882E-8,
	"C" : -1.3354774803797653E-6,
	"D" : 0.9856579780957873,
	"E" : 1.967079296605334E-5,
	"F" : 0.7671065714603174,
	"H" : 1.1200266463951003E-5,
	"I" : -1.0668535292412962E-6,
	"J" : -2.198520063800835E-5,
	"K" : -0.0023248617619202605,
	"L" : 1.0008331621921371,
	"M" : 0.12308965192096366
}, {
	"A" : -5.402945318255803E-5,
	"B" : -3.2614864751145944E-6,
	"C" : -1.518494585850405E-6,
	"D" : 1.0118020394561427,
	"E" : 3.7324765793300685E-4,
	"F" : -0.6483984524675179,
	"H" : 1.1180970433899429E-5,
	"I" : -1.066971484331436E-6,
	"J" : -2.198474920500626E-5,
	"K" : -0.002365321800965603,
	"L" : 1.0008334852572318,
	"M" : 0.12756645013996604
}, {
	"A" : 2.043693404187863E-4,
	"B" : -1.3559261069495676E-6,
	"C" : -1.7972134118693361E-6,
	"D" : 0.954238675738452,
	"E" : 1.7346608356660909E-4,
	"F" : 2.5568971393076936,
	"H" : 1.1149901211648938E-5,
	"I" : -1.0672956037294234E-6,
	"J" : -2.1984298234134503E-5,
	"K" : -0.0024030203971534547,
	"L" : 1.0008338320421473,
	"M" : 0.13197118321568269
}, {
	"A" : 7.310012120331777E-5,
	"B" : 5.65822651132919E-6,
	"C" : -1.790846783533695E-6,
	"D" : 0.9836764470943535,
	"E" : -6.246262777267475E-4,
	"F" : 0.9063148354362056,
	"H" : 1.1173448002388398E-5,
	"I" : -1.0675069766485912E-6,
	"J" : -2.198384245261087E-5,
	"K" : -0.002452903859250455,
	"L" : 1.0008341665985796,
	"M" : 0.13714479320879036
}, {
	"A" : -7.521681131672509E-5,
	"B" : 2.113857566321542E-6,
	"C" : -1.695018362335432E-6,
	"D" : 1.017619317816866,
	"E" : -2.2878125730585452E-4,
	"F" : -1.035811497065879,
	"H" : 1.1178722598537139E-5,
	"I" : -1.0673696107521558E-6,
	"J" : -2.1983387461399495E-5,
	"K" : -0.0024988074511753666,
	"L" : 1.0008344614177247,
	"M" : 0.14219136960218748
}, {
	"A" : 1.6263534863503182E-4,
	"B" : 2.451463517738617E-6,
	"C" : -1.7440261679269042E-6,
	"D" : 0.9618139556293954,
	"E" : -2.725144474879926E-4,
	"F" : 2.237225420805771,
	"H" : 1.1153679757625046E-5,
	"I" : -1.0674484572370524E-6,
	"J" : -2.198293379751526E-5,
	"K" : -0.0025375867912771355,
	"L" : 1.0008347814945466,
	"M" : 0.14690874142797838
}, {
	"A" : 2.2495272607114813E-5,
	"B" : 7.173796909842878E-6,
	"C" : -1.6048187301276329E-6,
	"D" : 0.9950137535902286,
	"E" : -8.492305604477224E-4,
	"F" : 0.2708424768061377,
	"H" : 1.117680571877111E-5,
	"I" : -1.0674753955774996E-6,
	"J" : -2.198247676249432E-5,
	"K" : -0.0025876976200436275,
	"L" : 1.0008350952147964,
	"M" : 0.1523818631139875
}, {
	"A" : -1.2042535976508617E-4,
	"B" : 1.2460866720687136E-6,
	"C" : -1.493916592432143E-6,
	"D" : 1.0295095611463694,
	"E" : -1.4486634449895064E-4,
	"F" : -1.8108154259462026,
	"H" : 1.1178642583931087E-5,
	"I" : -1.0672504067721356E-6,
	"J" : -2.1982022037514426E-5,
	"K" : -0.0026328671031023987,
	"L" : 1.0008353784378983,
	"M" : 0.15765785848270752
}, {
	"A" : 1.3510995739074438E-4,
	"B" : -2.1628908530857416E-7,
	"C" : -1.63276543396762E-6,
	"D" : 0.9665612725061692,
	"E" : 3.692314163572519E-5,
	"F" : 2.0654955495156173,
	"H" : 1.1149363366880216E-5,
	"I" : -1.0673466205868287E-6,
	"J" : -2.198157008159729E-5,
	"K" : -0.0026703196588044875,
	"L" : 1.000835701121943,
	"M" : 0.16254482938893489
}, {
	"A" : 1.9907286396891877E-5,
	"B" : 3.752410466351108E-6,
	"C" : -1.6476477648907917E-6,
	"D" : 0.9952341893745142,
	"E" : -4.633113338741168E-4,
	"F" : 0.2811128679859394,
	"H" : 1.1169113327547109E-5,
	"I" : -1.0674764944207382E-6,
	"J" : -2.198111539386538E-5,
	"K" : -0.002719858515675355,
	"L" : 1.0008360281239845,
	"M" : 0.1682659873731609
}, {
	"A" : -9.793386888334865E-5,
	"B" : -1.6762877796949738E-6,
	"C" : -1.6971291234568753E-6,
	"D" : 1.025059497983193,
	"E" : 2.24315900993588E-4,
	"F" : -1.6063949847812182,
	"H" : 1.116976238246803E-5,
	"I" : -1.0673982157594075E-6,
	"J" : -2.198066287983913E-5,
	"K" : -0.002764724967391885,
	"L" : 1.0008363291395312,
	"M" : 0.17379093058480066
}, {
	"A" : 1.7565200472891007E-4,
	"B" : -1.5763178451422277E-6,
	"C" : -1.9443683711983795E-6,
	"D" : 0.95433674928438,
	"E" : 2.20835203833758E-4,
	"F" : 2.9636356750124833,
	"H" : 1.114176067323891E-5,
	"I" : -1.0676302576451135E-6,
	"J" : -2.1980212204564253E-5,
	"K" : -0.0028021226384709053,
	"L" : 1.0008366705952056,
	"M" : 0.1789185540364997
}, {
	"A" : 6.683817783126322E-5,
	"B" : 4.5722076047471916E-6,
	"C" : -1.9737426921739853E-6,
	"D" : 0.9826466242867582,
	"E" : -5.877695946310268E-4,
	"F" : 1.122070004043053,
	"H" : 1.1165101299170921E-5,
	"I" : -1.067838431123569E-6,
	"J" : -2.1979757369949837E-5,
	"K" : -0.0028528072097344648,
	"L" : 1.0008370093083414,
	"M" : 0.18499509460525587
}, {
	"A" : -5.875077732087064E-5,
	"B" : 1.2903176584977416E-6,
	"C" : -1.928521476068923E-6,
	"D" : 1.015875844875893,
	"E" : -1.5963327859935816E-4,
	"F" : -1.0761150246544275,
	"H" : 1.1170568828600125E-5,
	"I" : -1.0677473110676239E-6,
	"J" : -2.197930331881981E-5,
	"K" : -0.0028989425868530816,
	"L" : 1.000837308657097,
	"M" : 0.19087177291658008
}, {
	"A" : 1.9532015044543272E-4,
	"B" : 2.843878145863954E-6,
	"C" : -1.9908797848078308E-6,
	"D" : 0.9470895389716247,
	"E" : -3.7275432123351493E-4,
	"F" : 3.5793498861894477,
	"H" : 1.1147421934754043E-5,
	"I" : -1.0678705690825296E-6,
	"J" : -2.1978849783388377E-5,
	"K" : -0.0029373133158685505,
	"L" : 1.000837636999961,
	"M" : 0.19631102377388743
} ], [

{
	"A" : 1.263861401545885E-4,
	"B" : 3.056468245166144E-6,
	"C" : -3.9573386190205895E-7,
	"D" : 0.9809837085829258,
	"E" : -2.3068762439493185E-4,
	"F" : 0.7127866515202186,
	"H" : 1.11744089307253E-5,
	"I" : -1.0520655654433497E-6,
	"J" : 1.0573976317429512E-4,
	"K" : -0.0016035919101256013,
	"L" : 0.9918315829682314,
	"M" : 0.21807541805810615
}, {
	"A" : 6.81734777807641E-6,
	"B" : 6.732236645934364E-6,
	"C" : -2.692497887979428E-7,
	"D" : 0.9992710633536035,
	"E" : -5.287660955843876E-4,
	"F" : 0.013481579222570872,
	"H" : 1.1194315773233043E-5,
	"I" : -1.052039731386234E-6,
	"J" : 1.0573953420212057E-4,
	"K" : -0.0016513619596310036,
	"L" : 0.9918318994907054,
	"M" : 0.22147294726528344
}, {
	"A" : -1.1467479815507886E-4,
	"B" : -2.7893546805657365E-8,
	"C" : -2.189831813659282E-7,
	"D" : 1.0184113696628287,
	"E" : -4.2861337874455785E-6,
	"F" : -0.7405759767771087,
	"H" : 1.119435355789733E-5,
	"I" : -1.0518772235457163E-6,
	"J" : 1.0573930233853668E-4,
	"K" : -0.0016961702673086165,
	"L" : 0.9918322051985484,
	"M" : 0.2248497986838629
}, {
	"A" : 1.6612611726962712E-4,
	"B" : -6.264866325711438E-7,
	"C" : -4.2493228957773965E-7,
	"D" : 0.9728061535922734,
	"E" : 5.0733991656670696E-5,
	"F" : 1.1107057934641489,
	"H" : 1.1164470588020947E-5,
	"I" : -1.0520579381001482E-6,
	"J" : 1.0573906813726719E-4,
	"K" : -0.0017360465440390271,
	"L" : 0.9918325388748173,
	"M" : 0.22811303499929636
}, {
	"A" : 5.4934281863650014E-5,
	"B" : 5.406327786561249E-6,
	"C" : -4.243633920930634E-7,
	"D" : 0.9910553117570942,
	"E" : -4.5573734971071644E-4,
	"F" : 0.3617538475918991,
	"H" : 1.118775996311605E-5,
	"I" : -1.0521950080111253E-6,
	"J" : 1.0573883791720196E-4,
	"K" : -0.0017845737176429566,
	"L" : 0.9918328691642699,
	"M" : 0.2318176045664586
}, {
	"A" : -7.271565986055606E-5,
	"B" : 1.0630562847779856E-6,
	"C" : -3.7874074476640374E-7,
	"D" : 1.012615100244176,
	"E" : -9.569506670459305E-5,
	"F" : -0.5487735460992553,
	"H" : 1.119277241301564E-5,
	"I" : -1.0520956533199843E-6,
	"J" : 1.0573860639395694E-4,
	"K" : -0.0018301961642350761,
	"L" : 0.9918331796561972,
	"M" : 0.23549652878409688
}, {
	"A" : 1.8966053080848866E-4,
	"B" : 2.2195786129053374E-6,
	"C" : -4.838016931518752E-7,
	"D" : 0.966783982462573,
	"E" : -1.9708799104023456E-4,
	"F" : 1.4523317706880334,
	"H" : 1.1168084449120208E-5,
	"I" : -1.0522348651842428E-6,
	"J" : 1.0573837375610351E-4,
	"K" : -0.0018706047042655882,
	"L" : 0.9918335110202747,
	"M" : 0.23903612845242606
}, {
	"A" : 5.288085958032873E-5,
	"B" : 8.83642190485645E-6,
	"C" : -3.2285761797368195E-7,
	"D" : 0.9909007493356796,
	"E" : -8.034077806087225E-4,
	"F" : 0.38930775855078537,
	"H" : 1.1195378373574094E-5,
	"I" : -1.0522517764344208E-6,
	"J" : 1.0573814574615925E-4,
	"K" : -0.0019201321835140561,
	"L" : 0.9918338313767663,
	"M" : 0.24306512167277106
}, {
	"A" : -1.0043950406957158E-4,
	"B" : 3.6943039818382317E-6,
	"C" : -1.2229588297607563E-7,
	"D" : 1.0186914093494295,
	"E" : -3.5591295841186366E-4,
	"F" : -0.8700103300434421,
	"H" : 1.1202209245109174E-5,
	"I" : -1.0520034179895E-6,
	"J" : 1.0573791605372751E-4,
	"K" : -0.0019661710121283704,
	"L" : 0.9918341274084668,
	"M" : 0.24703529288035497
}, {
	"A" : 1.436149974978207E-4,
	"B" : 2.8894186359096352E-6,
	"C" : -1.423456286175906E-7,
	"D" : 0.9731893027465333,
	"E" : -2.8803737760085824E-4,
	"F" : 1.2506916476850165,
	"H" : 1.1176935636791896E-5,
	"I" : -1.0520235048661064E-6,
	"J" : 1.0573768420452101E-4,
	"K" : -0.0020062081391785114,
	"L" : 0.9918344480935701,
	"M" : 0.25081449214121676
}, {
	"A" : 9.156322082759516E-7,
	"B" : 6.879217558930506E-6,
	"C" : -1.2267575399960151E-8,
	"D" : 1.000164330841642,
	"E" : -6.822045823469125E-4,
	"F" : -0.024180883381632157,
	"H" : 1.1201797843085615E-5,
	"I" : -1.052000513479534E-6,
	"J" : 1.0573745516556654E-4,
	"K" : -0.0020556319144873214,
	"L" : 0.9918347644113084,
	"M" : 0.25512256654292287
}, {
	"A" : -1.4360202826524393E-4,
	"B" : -8.073364305971609E-7,
	"C" : 2.6117261797686808E-8,
	"D" : 1.0281770605247402,
	"E" : 5.4831518355058506E-5,
	"F" : -1.381879509834107,
	"H" : 1.1206224348525584E-5,
	"I" : -1.051824583153671E-6,
	"J" : 1.0573722269857644E-4,
	"K" : -0.002101303513171615,
	"L" : 0.9918350659203554,
	"M" : 0.25934822471208463
}, {
	"A" : 1.2121624872252212E-4,
	"B" : -3.369777588080325E-6,
	"C" : -2.6479422488012716E-7,
	"D" : 0.9756978685056197,
	"E" : 3.2140058033292007E-4,
	"F" : 1.217549140466872,
	"H" : 1.1182471884751966E-5,
	"I" : -1.0520268609037764E-6,
	"J" : 1.0573698660520936E-4,
	"K" : -0.0021413359596778037,
	"L" : 0.9918354051808507,
	"M" : 0.26338136309550464
}, {
	"A" : 6.8010772826809784E-6,
	"B" : 1.7195094903499353E-7,
	"C" : -4.6183361790408384E-7,
	"D" : 0.9986885829021048,
	"E" : -2.745917015545274E-5,
	"F" : 0.06209372749799513,
	"H" : 1.122547709109245E-5,
	"I" : -1.0522659401601686E-6,
	"J" : 1.0573675278646721E-4,
	"K" : -0.002194704484352883,
	"L" : 0.9918357487971292,
	"M" : 0.2681700848024775
}, {
	"A" : -1.0947910578584796E-4,
	"B" : -6.4373419665919585E-6,
	"C" : -7.345293309146683E-7,
	"D" : 1.0225816503814826,
	"E" : 6.675946613086126E-4,
	"F" : -1.1659214931132738,
	"H" : 1.1515634830316923E-5,
	"I" : -1.0524172954218258E-6,
	"J" : 1.0573651522127747E-4,
	"K" : -0.0022995165461452416,
	"L" : 0.9918360845209406,
	"M" : 0.2757246878409205
}, {
	"A" : 1.7539469118244E-4,
	"B" : -6.696760223690035E-6,
	"C" : -1.251345221886524E-6,
	"D" : 0.962628461419115,
	"E" : 7.243446943334675E-4,
	"F" : 1.9875997595954686,
	"H" : 1.1557031943110196E-5,
	"I" : -1.0529458811525672E-6,
	"J" : 1.0573627956844689E-4,
	"K" : -0.0023564069925043896,
	"L" : 0.99183646112661,
	"M" : 0.2810790314761107
}, {
	"A" : 6.843389514532561E-5,
	"B" : -5.678399550568258E-8,
	"C" : -1.5383559164305893E-6,
	"D" : 0.9852879767023524,
	"E" : 2.9360534654188086E-5,
	"F" : 0.786961941026675,
	"H" : 1.1200519283105503E-5,
	"I" : -1.0532654731720825E-6,
	"J" : 1.0573604656566316E-4,
	"K" : -0.002325088565811484,
	"L" : 0.9918368166519542,
	"M" : 0.2816468034825448
}, {
	"A" : -5.540916671309404E-5,
	"B" : -3.5620795637569813E-6,
	"C" : -1.7434703170060573E-6,
	"D" : 1.0121159191216975,
	"E" : 4.208674033634452E-4,
	"F" : -0.6664626557248994,
	"H" : 1.1181584195107952E-5,
	"I" : -1.053383369420402E-6,
	"J" : 1.057358129564756E-4,
	"K" : -0.0023656291226927806,
	"L" : 0.9918371512229243,
	"M" : 0.2861279205799292
}, {
	"A" : 2.0959215530425013E-4,
	"B" : -1.4583429068792952E-6,
	"C" : -2.0551547184055607E-6,
	"D" : 0.9530721600159495,
	"E" : 2.0186508430697359E-4,
	"F" : 2.621754999330733,
	"H" : 1.1149451934755472E-5,
	"I" : -1.0537119617959334E-6,
	"J" : 1.057355789303438E-4,
	"K" : -0.0024030918485777875,
	"L" : 0.9918375100571808,
	"M" : 0.29051939880628197
}, {
	"A" : 7.497189909777546E-5,
	"B" : 6.288364412743164E-6,
	"C" : -2.0497407633435216E-6,
	"D" : 0.98322661578527,
	"E" : -6.794561392666765E-4,
	"F" : 0.9329926244172384,
	"H" : 1.1173944267639513E-5,
	"I" : -1.0538907926904706E-6,
	"J" : 1.0573534990687694E-4,
	"K" : -0.002453190094925617,
	"L" : 0.9918378524909457,
	"M" : 0.29570503524701053
}, {
	"A" : -7.714025645411127E-5,
	"B" : 2.374330611232267E-6,
	"C" : -1.9445923835625933E-6,
	"D" : 1.018055690994288,
	"E" : -2.4266501935699125E-4,
	"F" : -1.0608127823797986,
	"H" : 1.1179685154627528E-5,
	"I" : -1.0537505281682513E-6,
	"J" : 1.0573512007017172E-4,
	"K" : -0.0024992040269466997,
	"L" : 0.9918381585202809,
	"M" : 0.30075796504388563
}, {
	"A" : 1.6679570902944363E-4,
	"B" : 2.7466799994435576E-6,
	"C" : -2.00067446676222E-6,
	"D" : 0.9608211676295468,
	"E" : -2.905099103145403E-4,
	"F" : 2.296170491237717,
	"H" : 1.1153596362389884E-5,
	"I" : -1.0538259361814184E-6,
	"J" : 1.057348888038323E-4,
	"K" : -0.0025377404754181043,
	"L" : 0.9918384897433157,
	"M" : 0.30546106529800454
}, {
	"A" : 2.3071819458486686E-5,
	"B" : 7.96236271627393E-6,
	"C" : -1.8474118415046092E-6,
	"D" : 0.9948465790496357,
	"E" : -9.280228875923058E-4,
	"F" : 0.2823452281372738,
	"H" : 1.1177598765454988E-5,
	"I" : -1.0538195295839436E-6,
	"J" : 1.0573466111379881E-4,
	"K" : -0.0025880623891509913,
	"L" : 0.9918388110147589,
	"M" : 0.3109467249159934
}, {
	"A" : -1.2350440682062924E-4,
	"B" : 1.4159541885661042E-6,
	"C" : -1.7254537407751513E-6,
	"D" : 1.0302542050347938,
	"E" : -1.505579616605246E-4,
	"F" : -1.8560735481114534,
	"H" : 1.1179764502100564E-5,
	"I" : -1.0536006692651867E-6,
	"J" : 1.0573443094158419E-4,
	"K" : -0.00263331520960719,
	"L" : 0.9918391064888397,
	"M" : 0.3162278217096173
}, {
	"A" : 1.3856388135002895E-4,
	"B" : -1.9938887341197642E-7,
	"C" : -1.881462645680898E-6,
	"D" : 0.9657037579354437,
	"E" : 5.1091678074044466E-5,
	"F" : 2.118455426665605,
	"H" : 1.1149275814137383E-5,
	"I" : -1.053710121934337E-6,
	"J" : 1.0573419796877648E-4,
	"K" : -0.0026704718713261855,
	"L" : 0.9918394423249879,
	"M" : 0.32109652450162685
}, {
	"A" : 2.041707966204953E-5,
	"B" : 4.183706321825298E-6,
	"C" : -1.8996342272536992E-6,
	"D" : 0.9950897754728771,
	"E" : -5.011484154238133E-4,
	"F" : 0.29094767778587993,
	"H" : 1.116975502046813E-5,
	"I" : -1.0538258848891147E-6,
	"J" : 1.057339679252367E-4,
	"K" : -0.002720194570287049,
	"L" : 0.9918397790840174,
	"M" : 0.32682909938193916
}, {
	"A" : -1.0043684796423591E-4,
	"B" : -1.8114694864124203E-6,
	"C" : -1.956127048119427E-6,
	"D" : 1.0257046162638517,
	"E" : 2.586223200751192E-4,
	"F" : -1.6482369770601508,
	"H" : 1.117064498923348E-5,
	"I" : -1.0537695599444064E-6,
	"J" : 1.0573373543021347E-4,
	"K" : -0.0027651246234796645,
	"L" : 0.9918400944399934,
	"M" : 0.33235806473931007
}, {
	"A" : 1.8014082521089492E-4,
	"B" : -1.7014492321720809E-6,
	"C" : -2.2327576079117506E-6,
	"D" : 0.9531738506219654,
	"E" : 2.562196386861615E-4,
	"F" : 3.038635417142359,
	"H" : 1.1141427809169269E-5,
	"I" : -1.0540220119481525E-6,
	"J" : 1.0573350122067282E-4,
	"K" : -0.002802209081693263,
	"L" : 0.9918404501063947,
	"M" : 0.3374653380269592
}, {
	"A" : 6.854928963617724E-5,
	"B" : 5.089029334381934E-6,
	"C" : -2.267108022868669E-6,
	"D" : 0.9821758993535923,
	"E" : -6.365067648061995E-4,
	"F" : 1.1540694613286178,
	"H" : 1.1165572888272024E-5,
	"I" : -1.0542120147949419E-6,
	"J" : 1.0573327138374555E-4,
	"K" : -0.0028531052043945238,
	"L" : 0.9918407980215846,
	"M" : 0.34355561572920124
}, {
	"A" : -6.025265640663413E-5,
	"B" : 1.4647259531930246E-6,
	"C" : -2.218264380404733E-6,
	"D" : 1.0162715920531582,
	"E" : -1.6378536815864209E-4,
	"F" : -1.1024933233711636,
	"H" : 1.1171417566790964E-5,
	"I" : -1.0541279707454443E-6,
	"J" : 1.057330406528667E-4,
	"K" : -0.0028993433788855327,
	"L" : 0.9918411098979476,
	"M" : 0.34943912211929273
}, {
	"A" : 2.0031719440605222E-4,
	"B" : 3.180180207618122E-6,
	"C" : -2.2892273932040297E-6,
	"D" : 0.9457179447407498,
	"E" : -3.986520916328118E-4,
	"F" : 3.6731321012048284,
	"H" : 1.1147211507078758E-5,
	"I" : -1.0542493986687163E-6,
	"J" : 1.0573280919079497E-4,
	"K" : -0.0029374294164199455,
	"L" : 0.9918414495971888,
	"M" : 0.35485907082511403
} ], [

{
	"A" : 1.2986754252497512E-4,
	"B" : 3.4129446484509884E-6,
	"C" : -4.6306877776736144E-7,
	"D" : 0.9804406637317129,
	"E" : -2.5432482513565446E-4,
	"F" : 0.7339142608234397,
	"H" : 1.1171479763927294E-5,
	"I" : -1.0734588653527055E-6,
	"J" : -9.079914614673612E-5,
	"K" : -0.0016020247371955065,
	"L" : 1.0068373240489308,
	"M" : -0.06817009879796387
}, {
	"A" : 7.0058261412153655E-6,
	"B" : 7.473595389217991E-6,
	"C" : -3.2464029775525205E-7,
	"D" : 0.9992130524800586,
	"E" : -5.840382655151188E-4,
	"F" : 0.0168425989249954,
	"H" : 1.119214802597357E-5,
	"I" : -1.073423703590315E-6,
	"J" : -9.079831791553028E-5,
	"K" : -0.0016499021160854,
	"L" : 1.0068376181908718,
	"M" : -0.064770143617352
}, {
	"A" : -1.1783052749825274E-4,
	"B" : 6.4958212142585126E-9,
	"C" : -2.702776215057767E-7,
	"D" : 1.0189144197135818,
	"E" : -4.80586194839816E-6,
	"F" : -0.7606329869213369,
	"H" : 1.119240697616819E-5,
	"I" : -1.0732614977859711E-6,
	"J" : -9.079749267176807E-5,
	"K" : -0.0016947372865274701,
	"L" : 1.0068379022574874,
	"M" : -0.061393874570967455
}, {
	"A" : 1.7069806434832913E-4,
	"B" : -6.552976377083297E-7,
	"C" : -4.987767823205758E-7,
	"D" : 0.9720571594080525,
	"E" : 5.703976646032061E-5,
	"F" : 1.1413368055764295,
	"H" : 1.1161182013330606E-5,
	"I" : -1.07346090860716E-6,
	"J" : -9.079666925559948E-5,
	"K" : -0.0017343850078077594,
	"L" : 1.0068382157701592,
	"M" : -0.05814167195785558
}, {
	"A" : 5.644868781984336E-5,
	"B" : 6.008830489623307E-6,
	"C" : -4.993605093872588E-7,
	"D" : 0.9907776045681658,
	"E" : -5.023067345746313E-4,
	"F" : 0.3743498358398938,
	"H" : 1.1185305380023713E-5,
	"I" : -1.0736007969303074E-6,
	"J" : -9.079584205096136E-5,
	"K" : -0.0017830388932935648,
	"L" : 1.0068385246343894,
	"M" : -0.05443365485916729
}, {
	"A" : -7.471706998907202E-5,
	"B" : 1.211466385875326E-6,
	"C" : -4.5013225302703574E-7,
	"D" : 1.0129531861371674,
	"E" : -1.046983742867269E-4,
	"F" : -0.5630856301086169,
	"H" : 1.1190681448058903E-5,
	"I" : -1.073503745785409E-6,
	"J" : -9.079501640102405E-5,
	"K" : -0.0018287140739801089,
	"L" : 1.0068388136775042,
	"M" : -0.05075420047978696
}, {
	"A" : 1.948836495548889E-4,
	"B" : 2.4884721394613507E-6,
	"C" : -5.672828096159321E-7,
	"D" : 0.9658542319418757,
	"E" : -2.1607057252026607E-4,
	"F" : 1.4936429447407136,
	"H" : 1.1164819986642094E-5,
	"I" : -1.073654661176704E-6,
	"J" : -9.079419146579282E-5,
	"K" : -0.0018689072425104314,
	"L" : 1.0068391243980415,
	"M" : -0.04722578149085166
}, {
	"A" : 5.433989178449394E-5,
	"B" : 9.797951502577007E-6,
	"C" : -3.9083994340938233E-7,
	"D" : 0.9906011961596448,
	"E" : -8.864313475385188E-4,
	"F" : 0.4044135237309092,
	"H" : 1.1193095116102114E-5,
	"I" : -1.0736627436003232E-6,
	"J" : -9.079336236977875E-5,
	"K" : -0.0019185984422449565,
	"L" : 1.0068394223207946,
	"M" : -0.043191313323404756
}, {
	"A" : -1.0320581903422443E-4,
	"B" : 4.117917500545687E-6,
	"C" : -1.7057807499831767E-7,
	"D" : 1.019183766408787,
	"E" : -3.9287635948426214E-4,
	"F" : -0.8918987928336719,
	"H" : 1.120037177637645E-5,
	"I" : -1.0734060247319377E-6,
	"J" : -9.079253508270657E-5,
	"K" : -0.0019647105750948413,
	"L" : 1.006839695921471,
	"M" : -0.03921948653260188
}, {
	"A" : 1.47570786017015E-4,
	"B" : 3.228659542831025E-6,
	"C" : -1.938768998677176E-7,
	"D" : 0.9724324263965514,
	"E" : -3.1767189136644447E-4,
	"F" : 1.2868721149061457,
	"H" : 1.1173918353146739E-5,
	"I" : -1.073434461429379E-6,
	"J" : -9.079170966619365E-5,
	"K" : -0.0020045182480430412,
	"L" : 1.0068399956876846,
	"M" : -0.035452746700684656
}, {
	"A" : 9.414399473328672E-7,
	"B" : 7.635966550623152E-6,
	"C" : -5.1478995510834125E-8,
	"D" : 1.0001301768045892,
	"E" : -7.535268594551781E-4,
	"F" : -0.021133701415237738,
	"H" : 1.1199664989747227E-5,
	"I" : -1.0734109638921296E-6,
	"J" : -9.079088146646264E-5,
	"K" : -0.0020540996805777922,
	"L" : 1.0068402902442557,
	"M" : -0.031138999211179907
}, {
	"A" : -1.475531751471415E-4,
	"B" : -8.547076166820489E-7,
	"C" : -1.0232978797652947E-8,
	"D" : 1.0289526842027499,
	"E" : 6.0568076094114076E-5,
	"F" : -1.4199315873847809,
	"H" : 1.1204374774975712E-5,
	"I" : -1.0732497250920403E-6,
	"J" : -9.079005683920727E-5,
	"K" : -0.0020998178868154582,
	"L" : 1.0068405714676771,
	"M" : -0.026912807316875842
}, {
	"A" : 1.2455015599632802E-4,
	"B" : -3.685150235854806E-6,
	"C" : -3.325000066389805E-7,
	"D" : 0.975042744859195,
	"E" : 3.5640934200387164E-4,
	"F" : 1.2496871693292633,
	"H" : 1.1179262212723806E-5,
	"I" : -1.0735000379735737E-6,
	"J" : -9.078923512173542E-5,
	"K" : -0.0021395691822334584,
	"L" : 1.006840893758394,
	"M" : -0.022895496851560893
}, {
	"A" : 6.988757587755856E-6,
	"B" : 2.2694921031352067E-7,
	"C" : -5.511886497222562E-7,
	"D" : 0.9986477637631879,
	"E" : -2.7946446778059908E-5,
	"F" : 0.06423895055922912,
	"H" : 1.1222992914006191E-5,
	"I" : -1.0738031630541656E-6,
	"J" : -9.078841121223924E-5,
	"K" : -0.002193070382475071,
	"L" : 1.0068412221621656,
	"M" : -0.01810210061739781
}, {
	"A" : -1.1248735015190192E-4,
	"B" : -7.073221064635149E-6,
	"C" : -8.532897710633591E-7,
	"D" : 1.0232309717362682,
	"E" : 7.410719689744383E-4,
	"F" : -1.201020408050681,
	"H" : 1.1513274182473054E-5,
	"I" : -1.0741717295648101E-6,
	"J" : -9.07875909966771E-5,
	"K" : -0.0022978900652219636,
	"L" : 1.0068415586677588,
	"M" : -0.010549350186920492
}, {
	"A" : 1.8021473200313665E-4,
	"B" : -7.360315712912069E-6,
	"C" : -1.424908362190891E-6,
	"D" : 0.9616315272453448,
	"E" : 8.061913313213154E-4,
	"F" : 2.038928423622565,
	"H" : 1.1553307287248682E-5,
	"I" : -1.073936230278072E-6,
	"J" : -9.078676838203403E-5,
	"K" : -0.0023545111615987935,
	"L" : 1.0068418334312526,
	"M" : -0.00520957878416084
}, {
	"A" : 7.031781865052267E-5,
	"B" : -2.590100756094671E-8,
	"C" : -1.7429778809141538E-6,
	"D" : 0.9848794827652227,
	"E" : 3.990457088320909E-5,
	"F" : 0.808872592242551,
	"H" : 1.1197738895019071E-5,
	"I" : -1.0744852723121312E-6,
	"J" : -9.078594412642582E-5,
	"K" : -0.0023233729279894533,
	"L" : 1.0068421919835373,
	"M" : -0.004634666288438893
}, {
	"A" : -5.693255529082286E-5,
	"B" : -3.897319390322451E-6,
	"C" : -1.9704875660053744E-6,
	"D" : 1.0124633092065096,
	"E" : 4.733202151498972E-4,
	"F" : -0.6865061835633242,
	"H" : 1.1179196409694114E-5,
	"I" : -1.0746711420761557E-6,
	"J" : -9.078512070348488E-5,
	"K" : -0.0023639862478859186,
	"L" : 1.006842512553476,
	"M" : -1.5161482588155195E-4
}, {
	"A" : 2.1535910008307901E-4,
	"B" : -1.5745887389506663E-6,
	"C" : -2.315738721669902E-6,
	"D" : 0.9517844899004899,
	"E" : 2.3301397402519797E-4,
	"F" : 2.693318896992423,
	"H" : 1.1145922740873893E-5,
	"I" : -1.0750494089384333E-6,
	"J" : -9.078429730252635E-5,
	"K" : -0.0024011818367171145,
	"L" : 1.0068428555147477,
	"M" : 0.004222937568556517
}, {
	"A" : 7.703889457566504E-5,
	"B" : 6.983007193817059E-6,
	"C" : -2.311085068207319E-6,
	"D" : 0.9827285566714181,
	"E" : -7.404483641266779E-4,
	"F" : 0.9625938457065786,
	"H" : 1.117144025503114E-5,
	"I" : -1.0752442706207788E-6,
	"J" : -9.07834692649434E-5,
	"K" : -0.0024514989186457115,
	"L" : 1.0068431784099658,
	"M" : 0.009418877360076294
}, {
	"A" : -7.926415920311847E-5,
	"B" : 2.660032377699295E-6,
	"C" : -2.1961019842642315E-6,
	"D" : 1.0185370742848363,
	"E" : -2.58361153498754E-4,
	"F" : -1.0883730875211768,
	"H" : 1.1177680911744758E-5,
	"I" : -1.0751087586857722E-6,
	"J" : -9.078264255474311E-5,
	"K" : -0.002497618681275071,
	"L" : 1.0068434636642252,
	"M" : 0.014476032198217581
}, {
	"A" : 1.7138974421238018E-4,
	"B" : 3.070537592630984E-6,
	"C" : -2.259187244613159E-6,
	"D" : 0.9597243522874805,
	"E" : -3.1074758931026736E-4,
	"F" : 2.3613159265660215,
	"H" : 1.1150466107778811E-5,
	"I" : -1.0751952557175315E-6,
	"J" : -9.078181674088137E-5,
	"K" : -0.0025358809314468544,
	"L" : 1.0068437748268195,
	"M" : 0.019161129246640485
}, {
	"A" : 2.370852708000193E-5,
	"B" : 8.832417209614363E-6,
	"C" : -2.0912758305069445E-6,
	"D" : 0.9946602827039897,
	"E" : -0.0010155575492376556,
	"F" : 0.2952429498836864,
	"H" : 1.1175416742226219E-5,
	"I" : -1.075182428977861E-6,
	"J" : -9.078098766790443E-5,
	"K" : -0.0025864180117878277,
	"L" : 1.0068440739783853,
	"M" : 0.024657631629452226
}, {
	"A" : -1.2690431988904294E-4,
	"B" : 1.601429851616487E-6,
	"C" : -1.9576925340825113E-6,
	"D" : 1.031076187353392,
	"E" : -1.5720600316626587E-4,
	"F" : -1.9060218820741284,
	"H" : 1.1177932084105446E-5,
	"I" : -1.0749607659565896E-6,
	"J" : -9.078016130786848E-5,
	"K" : -0.0026317476666122275,
	"L" : 1.0068443477547788,
	"M" : 0.029941571217932506
}, {
	"A" : 1.4237770934966143E-4,
	"B" : -1.835040963626966E-7,
	"C" : -2.13104139334952E-6,
	"D" : 0.9647569890771592,
	"E" : 6.64167303625618E-5,
	"F" : 2.1769152232591296,
	"H" : 1.1146139677675748E-5,
	"I" : -1.0750856632713024E-6,
	"J" : -9.077933706391761E-5,
	"K" : -0.002668573129426477,
	"L" : 1.006844664097514,
	"M" : 0.03478792609530501
}, {
	"A" : 2.09800454500364E-5,
	"B" : 4.658345154950894E-6,
	"C" : -2.152352832407445E-6,
	"D" : 0.9949294422908679,
	"E" : -5.434135790096661E-4,
	"F" : 0.3019102059333818,
	"H" : 1.1167407846679467E-5,
	"I" : -1.075206790046579E-6,
	"J" : -9.077851007205373E-5,
	"K" : -0.0027184818122805154,
	"L" : 1.0068449801522945,
	"M" : 0.040530086582293734
}, {
	"A" : -1.0320054991419525E-4,
	"B" : -1.9635934664918864E-6,
	"C" : -2.2157543044798444E-6,
	"D" : 1.0264173752274246,
	"E" : 2.961503863048165E-4,
	"F" : -1.694499995886872,
	"H" : 1.116855292082608E-5,
	"I" : -1.075160956931498E-6,
	"J" : -9.077768566734257E-5,
	"K" : -0.00276346753736334,
	"L" : 1.0068452754865405,
	"M" : 0.04606067257009272
}, {
	"A" : 1.8509729293780808E-4,
	"B" : -1.8428263226510921E-6,
	"C" : -2.522277502414738E-6,
	"D" : 0.9518902298231069,
	"E" : 2.9492591511370847E-4,
	"F" : 3.1213857441034634,
	"H" : 1.1138026751011942E-5,
	"I" : -1.0754376471577842E-6,
	"J" : -9.077686251313111E-5,
	"K" : -0.0028002023731801273,
	"L" : 1.0068456129295384,
	"M" : 0.05114329114803695
}, {
	"A" : 7.043883676183249E-5,
	"B" : 5.658253051876727E-6,
	"C" : -2.5615133385503697E-6,
	"D" : 0.9816550352135209,
	"E" : -6.909370922585367E-4,
	"F" : 1.1895376186585054,
	"H" : 1.116304329640272E-5,
	"I" : -1.0756334037909099E-6,
	"J" : -9.077603539936474E-5,
	"K" : -0.002851314604356503,
	"L" : 1.0068459402912708,
	"M" : 0.05724558605106722
}, {
	"A" : -6.191103600405867E-5,
	"B" : 1.655173272441246E-6,
	"C" : -2.5086792023731874E-6,
	"D" : 1.0167083077707844,
	"E" : -1.689056377358611E-4,
	"F" : -1.1315906933014048,
	"H" : 1.1169291446622154E-5,
	"I" : -1.0755499593173568E-6,
	"J" : -9.077520936062733E-5,
	"K" : -0.002897650841248378,
	"L" : 1.0068462309506714,
	"M" : 0.06313366188078362
}, {
	"A" : 2.0583515434813293E-4,
	"B" : 3.5494246248823913E-6,
	"C" : -2.5882224294893064E-6,
	"D" : 0.9442027372970188,
	"E" : -4.278158336319393E-4,
	"F" : 3.7767699501346215,
	"H" : 1.114394570200794E-5,
	"I" : -1.0756772516051782E-6,
	"J" : -9.077438358290335E-5,
	"K" : -0.002935418102310905,
	"L" : 1.0068465501180413,
	"M" : 0.0685300086861389
} ], [

{
	"A" : 1.337146164164249E-4,
	"B" : 3.8065799372599685E-6,
	"C" : -5.533167221072333E-7,
	"D" : 0.9798398356965379,
	"E" : -2.78724576901368E-4,
	"F" : 0.7572789442656358,
	"H" : 1.1165107680177755E-5,
	"I" : -1.061018748194087E-6,
	"J" : 1.7104117563060406E-5,
	"K" : -0.0016012508694558392,
	"L" : 0.9981531456320454,
	"M" : 0.10673114935434569
}, {
	"A" : 7.214142343059393E-6,
	"B" : 8.295350893972042E-6,
	"C" : -3.993451969108719E-7,
	"D" : 0.9991472341553731,
	"E" : -6.438556060857081E-4,
	"F" : 0.02065730208050809,
	"H" : 1.1186600723633866E-5,
	"I" : -1.060960797660826E-6,
	"J" : 1.710436150281769E-5,
	"K" : -0.0016492322389467517,
	"L" : 0.99815345040642,
	"M" : 0.11013405796438747
}, {
	"A" : -1.2131752691790787E-4,
	"B" : 4.2000635191996594E-8,
	"C" : -3.397275961658508E-7,
	"D" : 1.0194703350379655,
	"E" : -3.799653256919555E-6,
	"F" : -0.7828309999604244,
	"H" : 1.1187093636899625E-5,
	"I" : -1.0608142888557381E-6,
	"J" : 1.7104602090145526E-5,
	"K" : -0.0016940821899424918,
	"L" : 0.9981537481202452,
	"M" : 0.11350986983961775
}, {
	"A" : 1.7574997447822316E-4,
	"B" : -6.901845903684034E-7,
	"C" : -5.978946918672179E-7,
	"D" : 0.9712297548967399,
	"E" : 6.612009696027599E-5,
	"F" : 1.1751230483860127,
	"H" : 1.1154419472192423E-5,
	"I" : -1.0610279561618086E-6,
	"J" : 1.7104840928483522E-5,
	"K" : -0.0017334704589870853,
	"L" : 0.9981540752092997,
	"M" : 0.11675039839337842
}, {
	"A" : 5.8122233652424526E-5,
	"B" : 6.676121638404808E-6,
	"C" : -6.000998934441171E-7,
	"D" : 0.990469356097833,
	"E" : -5.519986524973319E-4,
	"F" : 0.3883403614472627,
	"H" : 1.1179447360010197E-5,
	"I" : -1.0611484158040696E-6,
	"J" : 1.7105083803425902E-5,
	"K" : -0.0017822498896578054,
	"L" : 0.9981543948715483,
	"M" : 0.12046244004523032
}, {
	"A" : -7.692859840302546E-5,
	"B" : 1.3737735662378014E-6,
	"C" : -5.462597312266837E-7,
	"D" : 1.01332653920457,
	"E" : -1.1267304711282122E-4,
	"F" : -0.5789223455194588,
	"H" : 1.1185212684783341E-5,
	"I" : -1.0610606148153678E-6,
	"J" : 1.7105324846777847E-5,
	"K" : -0.001827968324533913,
	"L" : 0.9981546971302464,
	"M" : 0.12414259300385311
}, {
	"A" : 2.006553059250571E-4,
	"B" : 2.7846547911991593E-6,
	"C" : -6.793677895799988E-7,
	"D" : 0.9648263139368964,
	"E" : -2.348719153815182E-4,
	"F" : 1.539290919134146,
	"H" : 1.1158085015061658E-5,
	"I" : -1.061212547837087E-6,
	"J" : 1.7105565297548253E-5,
	"K" : -0.0018679167044979295,
	"L" : 0.9981550203654308,
	"M" : 0.12765913241491944
}, {
	"A" : 5.595231948873902E-5,
	"B" : 1.0864579017777487E-5,
	"C" : -4.827229749260198E-7,
	"D" : 0.9902678947137815,
	"E" : -9.767690469573154E-4,
	"F" : 0.4212701052401826,
	"H" : 1.1187423863801005E-5,
	"I" : -1.0611861367415543E-6,
	"J" : 1.7105810278361666E-5,
	"K" : -0.001917773639064535,
	"L" : 0.9981553276020492,
	"M" : 0.13169976125755056
}, {
	"A" : -1.0626267338631479E-4,
	"B" : 4.586301851183805E-6,
	"C" : -2.3675563365355146E-7,
	"D" : 1.0197269201047732,
	"E" : -4.3237550409003234E-4,
	"F" : -0.9160325068023667,
	"H" : 1.1195177842038273E-5,
	"I" : -1.0609271750006144E-6,
	"J" : 1.7106053049609216E-5,
	"K" : -0.001963951104073658,
	"L" : 0.9981556133867855,
	"M" : 0.13567341672751354
}, {
	"A" : 1.5194206023494417E-4,
	"B" : 3.603124635098709E-6,
	"C" : -2.6442571476881227E-7,
	"D" : 0.9715953525104055,
	"E" : -3.4893142807845834E-4,
	"F" : 1.3268862971435738,
	"H" : 1.1167449837978793E-5,
	"I" : -1.060953017772981E-6,
	"J" : 1.7106293941915318E-5,
	"K" : -0.002003498502176626,
	"L" : 0.9981559252915986,
	"M" : 0.13942681027401704
}, {
	"A" : 9.699915941574488E-7,
	"B" : 8.4748422448655E-6,
	"C" : -1.0599331168315018E-7,
	"D" : 1.0000906825449647,
	"E" : -8.313936725414806E-4,
	"F" : -0.0176247844901809,
	"H" : 1.1194153493432335E-5,
	"I" : -1.060900853278035E-6,
	"J" : 1.7106537952782386E-5,
	"K" : -0.0020532388591902873,
	"L" : 0.9981562294664741,
	"M" : 0.14374685575512558
}, {
	"A" : -1.5191905248124193E-4,
	"B" : -9.101259936805661E-7,
	"C" : -6.11097401570504E-8,
	"D" : 1.0298099831476861,
	"E" : 6.835758046008777E-5,
	"F" : -1.4620284789780271,
	"H" : 1.1199162757602465E-5,
	"I" : -1.060751813497518E-6,
	"J" : 1.7106778044118087E-5,
	"K" : -0.0020989934109394426,
	"L" : 0.9981565242350996,
	"M" : 0.14797359293334011
}, {
	"A" : 1.2823392888883234E-4,
	"B" : -4.038703691477963E-6,
	"C" : -4.245854932083404E-7,
	"D" : 0.9743198062217289,
	"E" : 3.974159427571067E-4,
	"F" : 1.2850633571797516,
	"H" : 1.1172577961904295E-5,
	"I" : -1.0610165754876277E-6,
	"J" : 1.710701501766998E-5,
	"K" : -0.002138428946722115,
	"L" : 0.9981568603660378,
	"M" : 0.15197390660341625
}, {
	"A" : 7.196173766210734E-6,
	"B" : 2.8533363094496167E-7,
	"C" : -6.717595785188379E-7,
	"D" : 0.9986026605073448,
	"E" : -2.5963567793496622E-5,
	"F" : 0.06655683073040564,
	"H" : 1.121708741064209E-5,
	"I" : -1.0612985743563286E-6,
	"J" : 1.710725461367968E-5,
	"K" : -0.0021920630737213287,
	"L" : 0.9981571990469007,
	"M" : 0.1567726196753938
}, {
	"A" : -1.1581109812985879E-4,
	"B" : -7.78306121862471E-6,
	"C" : -1.0125155285312104E-6,
	"D" : 1.0239501264319415,
	"E" : 8.259153289031929E-4,
	"F" : -1.2400477890696493,
	"H" : 1.1507411823874492E-5,
	"I" : -1.0616118761852533E-6,
	"J" : 1.7107490129397718E-5,
	"K" : -0.002296870504864046,
	"L" : 0.9981575423258562,
	"M" : 0.1643234837365526
}, {
	"A" : 1.8554035034923366E-4,
	"B" : -8.101182989328493E-6,
	"C" : -1.656074907652183E-6,
	"D" : 0.9605318329785177,
	"E" : 9.015014216231521E-4,
	"F" : 2.0953542994247982,
	"H" : 1.1545951345670602E-5,
	"I" : -1.0618523563765692E-6,
	"J" : 1.710772834501162E-5,
	"K" : -0.0023531324600156722,
	"L" : 0.9981578796203365,
	"M" : 0.169641840398981
}, {
	"A" : 7.239955354809702E-5,
	"B" : 5.5872797499745275E-9,
	"C" : -2.014958278895307E-6,
	"D" : 0.9844281675436832,
	"E" : 5.6559574431958026E-5,
	"F" : 0.8329654808694613,
	"H" : 1.1191518766606734E-5,
	"I" : -1.0622874093701995E-6,
	"J" : 1.710796773474188E-5,
	"K" : -0.0023222146179193714,
	"L" : 0.9981582386303103,
	"M" : 0.1702271568865399
}, {
	"A" : -5.8615767476677405E-5,
	"B" : -4.272846352071369E-6,
	"C" : -2.27193602242437E-6,
	"D" : 1.012848126283643,
	"E" : 5.370375684492501E-4,
	"F" : -0.7088827430234232,
	"H" : 1.1173404730557834E-5,
	"I" : -1.0624758490784814E-6,
	"J" : 1.710820636302568E-5,
	"K" : -0.0023628973405322995,
	"L" : 0.9981585721298387,
	"M" : 0.1747125093061186
}, {
	"A" : 2.217313838683843E-4,
	"B" : -1.7069477360465157E-6,
	"C" : -2.661291655492448E-6,
	"D" : 0.9503621014691248,
	"E" : 2.7378051674986636E-4,
	"F" : 2.7722054853948066,
	"H" : 1.1138902661023131E-5,
	"I" : -1.0628572028048566E-6,
	"J" : 1.7108445013847007E-5,
	"K" : -0.002399794449672754,
	"L" : 0.9981589281176753,
	"M" : 0.17906888985817204
}, {
	"A" : 7.932311285863136E-5,
	"B" : 7.75269285968605E-6,
	"C" : -2.6577372507219366E-6,
	"D" : 0.9821765697657838,
	"E" : -8.021512931009056E-4,
	"F" : 0.9953468245221302,
	"H" : 1.116553338420534E-5,
	"I" : -1.0630221858320965E-6,
	"J" : 1.71086886156524E-5,
	"K" : -0.002450338283324527,
	"L" : 0.9981592603082277,
	"M" : 0.18427606355180615
}, {
	"A" : -8.16110835271111E-5,
	"B" : 2.975105370062181E-6,
	"C" : -2.5299820682889163E-6,
	"D" : 1.0190684334486377,
	"E" : -2.6989557409251574E-4,
	"F" : -1.11889616577173,
	"H" : 1.1172311361939968E-5,
	"I" : -1.0628864686168527E-6,
	"J" : 1.7108930818465762E-5,
	"K" : -0.0024965591728118852,
	"L" : 0.9981595582049749,
	"M" : 0.18933756789010658
}, {
	"A" : 1.7646628870293668E-4,
	"B" : 3.427698347824304E-6,
	"C" : -2.602358142533845E-6,
	"D" : 0.958511682088897,
	"E" : -3.2713465321876356E-4,
	"F" : 2.433242213970516,
	"H" : 1.1143881506581188E-5,
	"I" : -1.0629693650843208E-6,
	"J" : 1.7109171926876776E-5,
	"K" : -0.0025345133233827255,
	"L" : 0.9981598816282542,
	"M" : 0.1940030735149776
}, {
	"A" : 2.4412183736277626E-5,
	"B" : 9.797284954871088E-6,
	"C" : -2.415354153795235E-6,
	"D" : 0.9944523723120255,
	"E" : -0.0011071037860688193,
	"F" : 0.30960826036243816,
	"H" : 1.1169860019255573E-5,
	"I" : -1.0629264574069097E-6,
	"J" : 1.7109416737604022E-5,
	"K" : -0.002585271825239488,
	"L" : 0.998160189831836,
	"M" : 0.19951119670440676
}, {
	"A" : -1.3066121092375482E-4,
	"B" : 1.805090070305937E-6,
	"C" : -2.266654557825376E-6,
	"D" : 1.0319841515139387,
	"E" : -1.5903394381666658E-4,
	"F" : -1.9613011476685642,
	"H" : 1.1172748331400584E-5,
	"I" : -1.0627128631535143E-6,
	"J" : 1.7109658492664437E-5,
	"K" : -0.002630670080264963,
	"L" : 0.9981604772275006,
	"M" : 0.20479780326058972
}, {
	"A" : 1.4659194050814506E-4,
	"B" : -1.6881272779656342E-7,
	"C" : -2.4628439281304537E-6,
	"D" : 0.9637109328074871,
	"E" : 8.943883943857145E-5,
	"F" : 2.241363855689997,
	"H" : 1.1139547574035014E-5,
	"I" : -1.0628490445530048E-6,
	"J" : 1.710989803865859E-5,
	"K" : -0.0026671251479513103,
	"L" : 0.9981608076173245,
	"M" : 0.20961972981967847
}, {
	"A" : 2.1602178510882197E-5,
	"B" : 5.183414784948326E-6,
	"C" : -2.4883774676354165E-6,
	"D" : 0.994751219619161,
	"E" : -5.84383948876166E-4,
	"F" : 0.3140191173442872,
	"H" : 1.1161670801396184E-5,
	"I" : -1.062956806130444E-6,
	"J" : 1.7110140571041654E-5,
	"K" : -0.0027172233766350473,
	"L" : 0.9981611346528894,
	"M" : 0.21537205026652373
}, {
	"A" : -1.0625429453758883E-4,
	"B" : -2.135403070813169E-6,
	"C" : -2.560953219932216E-6,
	"D" : 1.0272054573256355,
	"E" : 3.4405595778252973E-4,
	"F" : -1.7458252284122864,
	"H" : 1.1163087136500938E-5,
	"I" : -1.0629327193978355E-6,
	"J" : 1.7110380349960597E-5,
	"K" : -0.002762254883748483,
	"L" : 0.9981614454236052,
	"M" : 0.22090390071389265
}, {
	"A" : 1.9057401106370442E-4,
	"B" : -2.003126627903029E-6,
	"C" : -2.906767103905139E-6,
	"D" : 0.9504723822519168,
	"E" : 3.4482358114473755E-4,
	"F" : 3.2126003399316687,
	"H" : 1.113114802298032E-5,
	"I" : -1.0632263780507856E-6,
	"J" : 1.711061884146492E-5,
	"K" : -0.0027985998379165267,
	"L" : 0.9981617977643111,
	"M" : 0.22595955929682532
}, {
	"A" : 7.25269269872264E-5,
	"B" : 6.2884368268179E-6,
	"C" : -2.95250907966782E-6,
	"D" : 0.9810781685939673,
	"E" : -7.445323630008716E-4,
	"F" : 1.228742396524467,
	"H" : 1.1157110149762062E-5,
	"I" : -1.0634047185043016E-6,
	"J" : 1.7110861623648166E-5,
	"K" : -0.0028499347389185914,
	"L" : 0.9981621355415342,
	"M" : 0.23207462167556514
}, {
	"A" : -6.374352739291211E-5,
	"B" : 1.8642975843086163E-6,
	"C" : -2.8945623355980388E-6,
	"D" : 1.0171905400439982,
	"E" : -1.677531931250087E-4,
	"F" : -1.1638546536050853,
	"H" : 1.1163791233559373E-5,
	"I" : -1.0633297043982637E-6,
	"J" : 1.7111103159606067E-5,
	"K" : -0.0028963630109331007,
	"L" : 0.9981624400330418,
	"M" : 0.23796710415990674
}, {
	"A" : 2.1193269380082036E-4,
	"B" : 3.956965223927966E-6,
	"C" : -2.98546161170421E-6,
	"D" : 0.9425276124975426,
	"E" : -4.531551745685647E-4,
	"F" : 3.8912368717064965,
	"H" : 1.1137216187451227E-5,
	"I" : -1.0634544046483896E-6,
	"J" : 1.7111344414233454E-5,
	"K" : -0.0029337739583183975,
	"L" : 0.9981627715632442,
	"M" : 0.24333757494969177
} ], [

{
	"A" : 1.37970925556119E-4,
	"B" : 4.248246284754842E-6,
	"C" : -6.62404823770224E-7,
	"D" : 0.9791739978438159,
	"E" : -3.0489087762930467E-4,
	"F" : 0.7831783742440166,
	"H" : 1.116628330927183E-5,
	"I" : -1.0509410846015754E-6,
	"J" : 1.2350764645208123E-4,
	"K" : -0.0016015367683479553,
	"L" : 0.9894162957208295,
	"M" : 0.28620928415875824
}, {
	"A" : 7.444669595901843E-6,
	"B" : 9.220894974015792E-6,
	"C" : -4.897121672620131E-7,
	"D" : 0.999071933678664,
	"E" : -7.102116007899895E-4,
	"F" : 0.025042405282874824,
	"H" : 1.118869473204498E-5,
	"I" : -1.0508547214627129E-6,
	"J" : 1.235073123121433E-4,
	"K" : -0.0016496671903922788,
	"L" : 0.9894166156944522,
	"M" : 0.28961787238131365
}, {
	"A" : -1.2517522157318162E-4,
	"B" : 7.905613719216831E-8,
	"C" : -4.236776648403051E-7,
	"D" : 1.0200853982695435,
	"E" : -1.4805756904934242E-6,
	"F" : -0.8074193494940118,
	"H" : 1.1189436653458174E-5,
	"I" : -1.0507222724109866E-6,
	"J" : 1.2350697452367942E-4,
	"K" : -0.001694564939342058,
	"L" : 0.9894169319149597,
	"M" : 0.2929955536610578
}, {
	"A" : 1.813389723441805E-4,
	"B" : -7.327931625944473E-7,
	"C" : -7.172293536861218E-7,
	"D" : 0.9703146653178862,
	"E" : 7.786651602259553E-5,
	"F" : 1.2124420043583086,
	"H" : 1.1155158542885957E-5,
	"I" : -1.050959528514639E-6,
	"J" : 1.23506634840731E-4,
	"K" : -0.0017336985904137237,
	"L" : 0.9894172783497766,
	"M" : 0.2962256266919212
}, {
	"A" : 5.997389463741065E-5,
	"B" : 7.427074637744724E-6,
	"C" : -7.212595143357703E-7,
	"D" : 0.9901263265643365,
	"E" : -6.066604732382075E-4,
	"F" : 0.40394905490029487,
	"H" : 1.1181196279075323E-5,
	"I" : -1.0510606152092095E-6,
	"J" : 1.2350629969182236E-4,
	"K" : -0.0017826512961391927,
	"L" : 0.9894176138176789,
	"M" : 0.2999447397478434
}, {
	"A" : -7.937525606482865E-5,
	"B" : 1.5541147666553456E-6,
	"C" : -6.617730966551605E-7,
	"D" : 1.0137392299816668,
	"E" : -1.2024701592849851E-4,
	"F" : -0.5964469859954988,
	"H" : 1.118738582994716E-5,
	"I" : -1.0509806753766782E-6,
	"J" : 1.2350596246779588E-4,
	"K" : -0.001828449468433746,
	"L" : 0.9894179341717262,
	"M" : 0.30362825135307503
}, {
	"A" : 2.0704083244238447E-4,
	"B" : 3.1161409488333902E-6,
	"C" : -8.13858994641592E-7,
	"D" : 0.9636882850544453,
	"E" : -2.5451204891169255E-4,
	"F" : 1.589822762478434,
	"H" : 1.1158859193449722E-5,
	"I" : -1.0511384134215263E-6,
	"J" : 1.2350562457047465E-4,
	"K" : -0.0018681600545136234,
	"L" : 0.989418275357707,
	"M" : 0.30713433639903087
}, {
	"A" : 5.773644937967504E-5,
	"B" : 1.2066848431135924E-5,
	"C" : -5.929199754506342E-7,
	"D" : 0.9898958468610317,
	"E" : -0.0010774678176517227,
	"F" : 0.44018151412274165,
	"H" : 1.118938510241696E-5,
	"I" : -1.0510701992094695E-6,
	"J" : 1.2350529160759516E-4,
	"K" : -0.001918235310114369,
	"L" : 0.989418596269573,
	"M" : 0.3111846405072356
}, {
	"A" : -1.096446746755575E-4,
	"B" : 5.112532723838825E-6,
	"C" : -3.1606005790330016E-7,
	"D" : 1.020326507899881,
	"E" : -4.758874554227077E-4,
	"F" : -0.9426341611033422,
	"H" : 1.1197660105821683E-5,
	"I" : -1.0508006276221948E-6,
	"J" : 1.2350495622498459E-4,
	"K" : -0.0019645170189335204,
	"L" : 0.9894188984566341,
	"M" : 0.31516311625273374
}, {
	"A" : 1.5677831575944268E-4,
	"B" : 4.023125331098498E-6,
	"C" : -3.488394418882379E-7,
	"D" : 0.9706682026026101,
	"E" : -3.830834770326419E-4,
	"F" : 1.3712287534508505,
	"H" : 1.1168521766913297E-5,
	"I" : -1.05082488344177E-6,
	"J" : 1.2350461893195774E-4,
	"K" : -0.0020038092979461908,
	"L" : 0.9894192275709912,
	"M" : 0.31890462890169147
}, {
	"A" : 1.0016226972275888E-6,
	"B" : 9.419737299953823E-6,
	"C" : -1.7109678518423266E-7,
	"D" : 1.0000444511538262,
	"E" : -9.183874211942111E-4,
	"F" : -0.013519331921997946,
	"H" : 1.1196292103610173E-5,
	"I" : -1.0507383119140457E-6,
	"J" : 1.2350428494894983E-4,
	"K" : -0.002053760053485121,
	"L" : 0.9894195457996773,
	"M" : 0.32323468662798405
}, {
	"A" : -1.5674900963680294E-4,
	"B" : -9.7580828306576E-7,
	"C" : -1.217332845637742E-7,
	"D" : 1.0307587518714172,
	"E" : 7.811668976387409E-5,
	"F" : -1.508651888652821,
	"H" : 1.1201624170231739E-5,
	"I" : -1.0506003227384042E-6,
	"J" : 1.23503946660386E-4,
	"K" : -0.0020995861611510236,
	"L" : 0.9894198589813357,
	"M" : 0.3274649766053699
}, {
	"A" : 1.3230918052942187E-4,
	"B" : -4.441379806596757E-6,
	"C" : -5.344043623178862E-7,
	"D" : 0.973521341909759,
	"E" : 4.4512987062717E-4,
	"F" : 1.3240368830010993,
	"H" : 1.1173413158371837E-5,
	"I" : -1.0508929052521765E-6,
	"J" : 1.235036052034122E-4,
	"K" : -0.00213870524748927,
	"L" : 0.9894202152554357,
	"M" : 0.3314495464965148
}, {
	"A" : 7.425680892181319E-6,
	"B" : 3.4819976679756337E-7,
	"C" : -8.155518300689835E-7,
	"D" : 0.9985527318401637,
	"E" : -2.2069530956514427E-5,
	"F" : 0.06908244923397433,
	"H" : 1.1218807372148643E-5,
	"I" : -1.0511631832743618E-6,
	"J" : 1.2350326651222598E-4,
	"K" : -0.0021925236308675267,
	"L" : 0.9894205701883863,
	"M" : 0.3362574906932423
}, {
	"A" : -1.1948784032078663E-4,
	"B" : -8.588162271117028E-6,
	"C" : -1.202439418368506E-6,
	"D" : 1.0247480998300489,
	"E" : 9.238117829681869E-4,
	"F" : -1.283528121188283,
	"H" : 1.1509383699814801E-5,
	"I" : -1.0514359252145056E-6,
	"J" : 1.2350292339236013E-4,
	"K" : -0.002297392130159892,
	"L" : 0.9894209268002498,
	"M" : 0.34381161535930005
}, {
	"A" : 1.9143162690204996E-4,
	"B" : -8.94163187137309E-6,
	"C" : -1.9319732409428525E-6,
	"D" : 0.9593178853170912,
	"E" : 0.001011973429228874,
	"F" : 2.1574249051191146,
	"H" : 1.1546323077538112E-5,
	"I" : -1.0521707120014767E-6,
	"J" : 1.2350258349680399E-4,
	"K" : -0.002353302532156931,
	"L" : 0.9894213336147857,
	"M" : 0.3491103369051416
}, {
	"A" : 7.470264966413787E-5,
	"B" : 3.797312908560002E-8,
	"C" : -2.3395945076831737E-6,
	"D" : 0.9839289286252324,
	"E" : 7.855046084159767E-5,
	"F" : 0.859521290542034,
	"H" : 1.1192876921639616E-5,
	"I" : -1.0525056010068923E-6,
	"J" : 1.235022442376832E-4,
	"K" : -0.002322603234432563,
	"L" : 0.9894216996695491,
	"M" : 0.3497073786074907
}, {
	"A" : -6.047780698281713E-5,
	"B" : -4.700208969143915E-6,
	"C" : -2.63170922676359E-6,
	"D" : 1.013275195362553,
	"E" : 6.124804587273047E-4,
	"F" : -0.7338886449651909,
	"H" : 1.1175213150638186E-5,
	"I" : -1.052706762649791E-6,
	"J" : 1.235019041249119E-4,
	"K" : -0.0023633900280515263,
	"L" : 0.9894220523476349,
	"M" : 0.35419835686843726
}, {
	"A" : 2.2878103644985437E-4,
	"B" : -1.8599692310772298E-6,
	"C" : -3.0737329932417623E-6,
	"D" : 0.9487891150025689,
	"E" : 3.237770573321086E-4,
	"F" : 2.859294219455478,
	"H" : 1.11393488206879E-5,
	"I" : -1.053105497694773E-6,
	"J" : 1.2350156421947478E-4,
	"K" : -0.002399988463025693,
	"L" : 0.9894224281044046,
	"M" : 0.3585379984269821
}, {
	"A" : 8.185045583131156E-5,
	"B" : 8.619266604448228E-6,
	"C" : -3.0713943937055177E-6,
	"D" : 0.9815635314587894,
	"E" : -8.67968440218192E-4,
	"F" : 1.0317317869485123,
	"H" : 1.1167219410634921E-5,
	"I" : -1.0532406590213483E-6,
	"J" : 1.2350122965654187E-4,
	"K" : -0.0024508178319422314,
	"L" : 0.9894227747563491,
	"M" : 0.363761235768834
}, {
	"A" : -8.420758652394333E-5,
	"B" : 3.3281706317556115E-6,
	"C" : -2.9282196121194204E-6,
	"D" : 1.0196554487118306,
	"E" : -2.791791264371568E-4,
	"F" : -1.152678325153829,
	"H" : 1.117458409477523E-5,
	"I" : -1.0531008025616018E-6,
	"J" : 1.235008935426829E-4,
	"K" : -0.0024971818453138894,
	"L" : 0.9894230900073921,
	"M" : 0.36883106910863717
}, {
	"A" : 1.8208281778431257E-4,
	"B" : 3.827920107557503E-6,
	"C" : -3.011594549295893E-6,
	"D" : 0.9571690496267138,
	"E" : -3.4176518084905183E-4,
	"F" : 2.512819237228541,
	"H" : 1.1144809373975217E-5,
	"I" : -1.0531826124537957E-6,
	"J" : 1.2350055630827583E-4,
	"K" : -0.002534827716061727,
	"L" : 0.9894234311330194,
	"M" : 0.3734785456217651
}, {
	"A" : 2.5190780229777943E-5,
	"B" : 1.088453474551443E-5,
	"C" : -2.8016318016632624E-6,
	"D" : 0.9942193925921856,
	"E" : -0.0012068967668596997,
	"F" : 0.325746670634544,
	"H" : 1.1171932231379689E-5,
	"I" : -1.0531028733495873E-6,
	"J" : 1.2350022306961694E-4,
	"K" : -0.0025858659677737705,
	"L" : 0.9894237527404499,
	"M" : 0.3790033858585957
}, {
	"A" : -1.3481758078359718E-4,
	"B" : 2.0323171017189168E-6,
	"C" : -2.6347009116634013E-6,
	"D" : 1.0329881669731549,
	"E" : -1.576199643977816E-4,
	"F" : -2.0225007640983677,
	"H" : 1.1175223101012044E-5,
	"I" : -1.0528924955233165E-6,
	"J" : 1.2349988641019438E-4,
	"K" : -0.002631370752709472,
	"L" : 0.9894240583134319,
	"M" : 0.38429662018825184
}, {
	"A" : 1.5125423469442012E-4,
	"B" : -1.5554481658242025E-7,
	"C" : -2.8581006039640755E-6,
	"D" : 0.9625537832635587,
	"E" : 1.1921054260710662E-4,
	"F" : 2.3125390691311623,
	"H" : 1.1140461588288186E-5,
	"I" : -1.053046842391936E-6,
	"J" : 1.2349954750418002E-4,
	"K" : -0.0026674479400981,
	"L" : 0.9894244087424369,
	"M" : 0.38909531069111836
}, {
	"A" : 2.229053420799154E-5,
	"B" : 5.773634312200571E-6,
	"C" : -2.888577395054881E-6,
	"D" : 0.9945525087370015,
	"E" : -6.269123714446323E-4,
	"F" : 0.3274967592296889,
	"H" : 1.1163537273761737E-5,
	"I" : -1.0531422363069254E-6,
	"J" : 1.23499211833078E-4,
	"K" : -0.002717790272754428,
	"L" : 0.9894247520329742,
	"M" : 0.39486289294472954
}, {
	"A" : -1.0963258631413453E-4,
	"B" : -2.3324803071211875E-6,
	"C" : -2.9719945164874417E-6,
	"D" : 1.0280780067016053,
	"E" : 4.0202142974976596E-4,
	"F" : -1.8028105460543884,
	"H" : 1.116524454358725E-5,
	"I" : -1.053143103169063E-6,
	"J" : 1.2349887312240737E-4,
	"K" : -0.0027629028537035083,
	"L" : 0.9894250838125771,
	"M" : 0.40039997690473683
}, {
	"A" : 1.966328804077211E-4,
	"B" : -2.187713078249942E-6,
	"C" : -3.36471056994192E-6,
	"D" : 0.9489045138312804,
	"E" : 4.054971114442196E-4,
	"F" : 3.313293617189629,
	"H" : 1.1131742127190591E-5,
	"I" : -1.0534661162298065E-6,
	"J" : 1.2349853307180858E-4,
	"K" : -0.002798848773466034,
	"L" : 0.9894254578310466,
	"M" : 0.4054298017108522
}, {
	"A" : 7.483722791956637E-5,
	"B" : 6.9973487009100666E-6,
	"C" : -3.4181383221643102E-6,
	"D" : 0.9804380606074119,
	"E" : -8.007755733387967E-4,
	"F" : 1.2722344925423386,
	"H" : 1.1158760288787484E-5,
	"I" : -1.0536290320217745E-6,
	"J" : 1.2349819788393113E-4,
	"K" : -0.002850465326048379,
	"L" : 0.9894258114611318,
	"M" : 0.4115632663579163
}, {
	"A" : -6.577085886472211E-5,
	"B" : 2.0976240810988145E-6,
	"C" : -3.3539393216042157E-6,
	"D" : 1.0177235359425367,
	"E" : -1.622160477268153E-4,
	"F" : -1.1996081224788213,
	"H" : 1.116591444838555E-5,
	"I" : -1.0535606570494238E-6,
	"J" : 1.2349786099702387E-4,
	"K" : -0.0028970268036800917,
	"L" : 0.9894261347434679,
	"M" : 0.4174647228956019
}, {
	"A" : 2.1867885774806695E-4,
	"B" : 4.414005696506962E-6,
	"C" : -3.4583130930077033E-6,
	"D" : 0.9406731662264747,
	"E" : -4.773761716023728E-4,
	"F" : 4.01790296852414,
	"H" : 1.1137981513420492E-5,
	"I" : -1.0536859237353369E-6,
	"J" : 1.2349752403473246E-4,
	"K" : -0.002934076811357045,
	"L" : 0.9894264842468772,
	"M" : 0.4228108416991745
} ], [

{
	"A" : 1.4268802374817202E-4,
	"B" : 4.742656987355431E-6,
	"C" : -7.79253718885542E-7,
	"D" : 0.9784349155532652,
	"E" : -3.339997186913024E-4,
	"F" : 0.8119547911337577,
	"H" : 1.1163426411053834E-5,
	"I" : -1.0725760271057538E-6,
	"J" : -9.774432261316912E-5,
	"K" : -0.0015998422408074475,
	"L" : 1.0089548402351198,
	"M" : -0.14497537717943487
}, {
	"A" : 7.700215974182356E-6,
	"B" : 1.0260148693985727E-5,
	"C" : -5.86426222359826E-7,
	"D" : 0.9989858621268581,
	"E" : -7.845697085713255E-4,
	"F" : 0.030093425970335375,
	"H" : 1.1186837818200068E-5,
	"I" : -1.0724764328839953E-6,
	"J" : -9.774347793950477E-5,
	"K" : -0.0016481176962628297,
	"L" : 1.0089551214106933,
	"M" : -0.14156278960763302
}, {
	"A" : -1.2945026028488016E-4,
	"B" : 1.1808905675536607E-7,
	"C" : -5.133216631758586E-7,
	"D" : 1.0207670451908086,
	"E" : 1.4625036612869735E-6,
	"F" : -0.8346827750374359,
	"H" : 1.1187845901816651E-5,
	"I" : -1.0723439894944065E-6,
	"J" : -9.774263715245368E-5,
	"K" : -0.0016930507693189156,
	"L" : 1.008955399858337,
	"M" : -0.138185218772378
}, {
	"A" : 1.8753265354598536E-4,
	"B" : -7.835979130010884E-7,
	"C" : -8.442894696703007E-7,
	"D" : 0.9693008570616257,
	"E" : 9.138855730839168E-5,
	"F" : 1.2537602194333886,
	"H" : 1.1151825213828737E-5,
	"I" : -1.0726067984911936E-6,
	"J" : -9.774179760124735E-5,
	"K" : -0.0017318912077541881,
	"L" : 1.0089557105653597,
	"M" : -0.1349687045239989
}, {
	"A" : 6.202612757810755E-5,
	"B" : 8.269727977516794E-6,
	"C" : -8.500533652533449E-7,
	"D" : 0.9897440558317783,
	"E" : -6.679206115336456E-4,
	"F" : 0.4214088886146783,
	"H" : 1.1178963477354031E-5,
	"I" : -1.072711480532007E-6,
	"J" : -9.774095375325587E-5,
	"K" : -0.0017810151535542218,
	"L" : 1.008956008563871,
	"M" : -0.13124420053463837
}, {
	"A" : -8.208663777409253E-5,
	"B" : 1.75444511718581E-6,
	"C" : -7.843195821699567E-7,
	"D" : 1.0141961885288993,
	"E" : -1.2851220932930119E-4,
	"F" : -0.6158482799000922,
	"H" : 1.1185610927277878E-5,
	"I" : -1.072634080889756E-6,
	"J" : -9.774011232988045E-5,
	"K" : -0.001826883141916369,
	"L" : 1.008956291392721,
	"M" : -0.1275593041391403
}, {
	"A" : 2.1411754309408337E-4,
	"B" : 3.4864478672957944E-6,
	"C" : -9.563724745476065E-7,
	"D" : 0.9624262435765445,
	"E" : -2.763766483724339E-4,
	"F" : 1.6458821173546312,
	"H" : 1.1155565212139784E-5,
	"I" : -1.0728073630561497E-6,
	"J" : -9.773927115186432E-5,
	"K" : -0.0018663185721834452,
	"L" : 1.0089565961687583,
	"M" : -0.12406690293119027
}, {
	"A" : 5.9713948649564585E-5,
	"B" : 1.3417644728619393E-5,
	"C" : -7.09378089269741E-7,
	"D" : 0.9894800451381514,
	"E" : -0.0011905932770162053,
	"F" : 0.4614390861661377,
	"H" : 1.1187384403865686E-5,
	"I" : -1.0727259653897647E-6,
	"J" : -9.773842525861998E-5,
	"K" : -0.001916613815922119,
	"L" : 1.0089568781400686,
	"M" : -0.12000850350887049
}, {
	"A" : -1.1339277803967818E-4,
	"B" : 5.702265975404686E-6,
	"C" : -3.994090774783743E-7,
	"D" : 1.0209895835927796,
	"E" : -5.246217158116906E-4,
	"F" : -0.9719935018620163,
	"H" : 1.1196221713305476E-5,
	"I" : -1.0724432454312094E-6,
	"J" : -9.773758235476215E-5,
	"K" : -0.001962991663418734,
	"L" : 1.00895714137188,
	"M" : -0.11602717564164777
}, {
	"A" : 1.6213812585297305E-4,
	"B" : 4.49314688899527E-6,
	"C" : -4.373957627201719E-7,
	"D" : 0.9696395868340346,
	"E" : -4.212885134222688E-4,
	"F" : 1.4204660245231935,
	"H" : 1.1165550543479341E-5,
	"I" : -1.072477078811751E-6,
	"J" : -9.773674072866001E-5,
	"K" : -0.0020019896236931345,
	"L" : 1.0089574335531637,
	"M" : -0.11230101742876286
}, {
	"A" : 1.0367291463087014E-6,
	"B" : 1.0480781285515661E-5,
	"C" : -2.38889147907706E-7,
	"D" : 0.9999905375964317,
	"E" : -0.0010160869864819233,
	"F" : -0.008719009201740846,
	"H" : 1.1194481372878151E-5,
	"I" : -1.0723870402795654E-6,
	"J" : -9.773589594758159E-5,
	"K" : -0.002052151333771235,
	"L" : 1.008957713617633,
	"M" : -0.10796262939402368
}, {
	"A" : -1.621014378889729E-4,
	"B" : -1.0524284610458068E-6,
	"C" : -1.8452040384531188E-7,
	"D" : 1.0318105018380948,
	"E" : 8.932574030495744E-5,
	"F" : -1.5603581384384597,
	"H" : 1.1200157838509028E-5,
	"I" : -1.0722655070516396E-6,
	"J" : -9.773505563770435E-5,
	"K" : -0.002098037177574952,
	"L" : 1.008957990562493,
	"M" : -0.10373102352968999
}, {
	"A" : 1.3682514829227443E-4,
	"B" : -4.897483021348847E-6,
	"C" : -6.492953854575489E-7,
	"D" : 0.9726378892221987,
	"E" : 4.990181908510749E-4,
	"F" : 1.3670791581425874,
	"H" : 1.1170176155705924E-5,
	"I" : -1.0726185621923179E-6,
	"J" : -9.773421779346592E-5,
	"K" : -0.002136793715294516,
	"L" : 1.0089583149787842,
	"M" : -0.09976623044349253
}, {
	"A" : 7.680068212945201E-6,
	"B" : 4.1623000024415546E-7,
	"C" : -9.663698868900283E-7,
	"D" : 0.9984973594311555,
	"E" : -1.7560591714982365E-5,
	"F" : 0.07187195689039072,
	"H" : 1.1216525034773994E-5,
	"I" : -1.0729655242069924E-6,
	"J" : -9.773337714913399E-5,
	"K" : -0.0021907904656472965,
	"L" : 1.0089586398631383,
	"M" : -0.09495124976092484
}, {
	"A" : -1.2356192463292004E-4,
	"B" : -9.497061283614272E-6,
	"C" : -1.4020803693615136E-6,
	"D" : 1.0256348680173915,
	"E" : 0.00103406616088364,
	"F" : -1.3319909503261442,
	"H" : 1.1507264398913364E-5,
	"I" : -1.0734896687125683E-6,
	"J" : -9.773254084155525E-5,
	"K" : -0.0022956728510052926,
	"L" : 1.0089589846844405,
	"M" : -0.08739867056647199
}, {
	"A" : 1.9795964353575002E-4,
	"B" : -9.89067915080355E-6,
	"C" : -2.2228404570334703E-6,
	"D" : 0.9579754076353311,
	"E" : 0.0011363288129473403,
	"F" : 2.225894363640691,
	"H" : 1.1542439890099843E-5,
	"I" : -1.07338321198025E-6,
	"J" : -9.773170086335714E-5,
	"K" : -0.0023512381096963964,
	"L" : 1.0089592654833837,
	"M" : -0.08211799043783685
}, {
	"A" : 7.725497685173721E-5,
	"B" : 7.158378800831144E-8,
	"C" : -2.6821273768629084E-6,
	"D" : 0.9833757270602064,
	"E" : 1.032366562299103E-4,
	"F" : 0.8889130390598439,
	"H" : 1.119020802375914E-5,
	"I" : -1.0739805872406194E-6,
	"J" : -9.773086139641673E-5,
	"K" : -0.0023207738640564912,
	"L" : 1.0089596220796153,
	"M" : -0.08151095004723174
}, {
	"A" : -6.254115291648432E-5,
	"B" : -5.183921370388589E-6,
	"C" : -3.0113680142829224E-6,
	"D" : 1.0137498646563472,
	"E" : 6.972655973243036E-4,
	"F" : -0.7617895142975613,
	"H" : 1.1173040052492311E-5,
	"I" : -1.0742636821214901E-6,
	"J" : -9.773002284074739E-5,
	"K" : -0.002361655569956156,
	"L" : 1.0089599462670833,
	"M" : -0.07701677109616867
}, {
	"A" : 2.3659329007674756E-4,
	"B" : -2.0353982415066696E-6,
	"C" : -3.509212567420761E-6,
	"D" : 0.9470465968662438,
	"E" : 3.7991726259178904E-4,
	"F" : 2.9556940983457025,
	"H" : 1.1135700283548822E-5,
	"I" : -1.074725104244223E-6,
	"J" : -9.772918378120332E-5,
	"K" : -0.0023979120356329986,
	"L" : 1.0089602916078206,
	"M" : -0.07269816872212687
}, {
	"A" : 8.465158149695284E-5,
	"B" : 9.591976116496426E-6,
	"C" : -3.508011391817334E-6,
	"D" : 0.9808816582379336,
	"E" : -9.422517002235509E-4,
	"F" : 1.0722955384590023,
	"H" : 1.1164923777950975E-5,
	"I" : -1.0748790377768103E-6,
	"J" : -9.772833973820116E-5,
	"K" : -0.002449034248627413,
	"L" : 1.0089606030566785,
	"M" : -0.06746037318589515
}, {
	"A" : -8.708509210686444E-5,
	"B" : 3.723065645999668E-6,
	"C" : -3.3481686052549975E-6,
	"D" : 1.0203050883941955,
	"E" : -2.898540822684481E-4,
	"F" : -1.1900487505772617,
	"H" : 1.1172924013314045E-5,
	"I" : -1.0747431907764948E-6,
	"J" : -9.7727497813338E-5,
	"K" : -0.002495536428654077,
	"L" : 1.008960881481471,
	"M" : -0.062384314311202615
}, {
	"A" : 1.883073504678201E-4,
	"B" : 4.275400045106181E-6,
	"C" : -3.4430219602032963E-6,
	"D" : 0.955680045693839,
	"E" : -3.5842465115365485E-4,
	"F" : 2.601094104047661,
	"H" : 1.1141689249982711E-5,
	"I" : -1.0748382643921417E-6,
	"J" : -9.77266564338164E-5,
	"K" : -0.0025328304897698217,
	"L" : 1.0089611868249762,
	"M" : -0.057759273466217564
}, {
	"A" : 2.6053776287948693E-5,
	"B" : 1.210581619526252E-5,
	"C" : -3.2084504200113884E-6,
	"D" : 0.9939580724129655,
	"E" : -0.0013194627450729968,
	"F" : 0.3439697290814365,
	"H" : 1.117005866568821E-5,
	"I" : -1.0747483804030011E-6,
	"J" : -9.772581143330239E-5,
	"K" : -0.002584155734950855,
	"L" : 1.0089614698973577,
	"M" : -0.052219191969925305
}, {
	"A" : -1.394237193825809E-4,
	"B" : 2.2856232106960306E-6,
	"C" : -3.0218414024396623E-6,
	"D" : 1.0341002977934295,
	"E" : -1.5627869129275496E-4,
	"F" : -2.090290745109087,
	"H" : 1.1173782928253218E-5,
	"I" : -1.0745329412920057E-6,
	"J" : -9.772497008558867E-5,
	"K" : -0.0026297591483341876,
	"L" : 1.008961737524345,
	"M" : -0.046921626686526
}, {
	"A" : 1.564209914284298E-4,
	"B" : -1.4362118183619543E-7,
	"C" : -3.2739501654166503E-6,
	"D" : 0.9612715548270785,
	"E" : 1.5249923626470263E-4,
	"F" : 2.3913648809320875,
	"H" : 1.113732546187407E-5,
	"I" : -1.0747076261141686E-6,
	"J" : -9.772413029351945E-5,
	"K" : -0.0026654091436171257,
	"L" : 1.0089620530787329,
	"M" : -0.04215108068274276
}, {
	"A" : 2.3053464984323924E-5,
	"B" : 6.435322258191434E-6,
	"C" : -3.3094979574599392E-6,
	"D" : 0.9943306662079863,
	"E" : -6.750634774448372E-4,
	"F" : 0.34260145136067877,
	"H" : 1.1161438644213817E-5,
	"I" : -1.074810140666571E-6,
	"J" : -9.772328740870195E-5,
	"K" : -0.0027159999692401016,
	"L" : 1.008962359905638,
	"M" : -0.036369904832099564
}, {
	"A" : -1.1337624675156199E-4,
	"B" : -2.5568520740648637E-6,
	"C" : -3.4041698731002157E-6,
	"D" : 1.0290456612506205,
	"E" : 4.6694209277120535E-4,
	"F" : -1.8660891778490623,
	"H" : 1.1163458327634324E-5,
	"I" : -1.0748251522141317E-6,
	"J" : -9.772244775541061E-5,
	"K" : -0.00276118367997924,
	"L" : 1.008962656159781,
	"M" : -0.030830085763227544
}, {
	"A" : 2.0334714887981775E-4,
	"B" : -2.3986584609669848E-6,
	"C" : -3.846557003805984E-6,
	"D" : 0.947167767113001,
	"E" : 4.7349167408583526E-4,
	"F" : 3.424744930336601,
	"H" : 1.1128258151082981E-5,
	"I" : -1.0751812142828499E-6,
	"J" : -9.77216088658972E-5,
	"K" : -0.0027966796099008207,
	"L" : 1.0089629971211167,
	"M" : -0.0258313181984704
}, {
	"A" : 7.739775249726577E-5,
	"B" : 7.792545783535942E-6,
	"C" : -3.908002685903966E-6,
	"D" : 0.979726668884723,
	"E" : -8.644527012506842E-4,
	"F" : 1.320654344468494,
	"H" : 1.1156427468517194E-5,
	"I" : -1.0753522360351653E-6,
	"J" : -9.772076541558761E-5,
	"K" : -0.002848585626196609,
	"L" : 1.008963314539585,
	"M" : -0.01968095048687246
}, {
	"A" : -6.801755424801215E-5,
	"B" : 2.357705382927122E-6,
	"C" : -3.836888248454073E-6,
	"D" : 1.0183136573889442,
	"E" : -1.563923173080184E-4,
	"F" : -1.2391967634102912,
	"H" : 1.116409314860789E-5,
	"I" : -1.0752846282269246E-6,
	"J" : -9.771992401541585E-5,
	"K" : -0.0028952748997710387,
	"L" : 1.0089636006802323,
	"M" : -0.013772805803455412
}, {
	"A" : 2.2615535776893125E-4,
	"B" : 4.925316000825575E-6,
	"C" : -3.9553884532139705E-6,
	"D" : 0.9386167654386668,
	"E" : -5.04994111565793E-4,
	"F" : 4.1584034006955335,
	"H" : 1.113468628255454E-5,
	"I" : -1.0754175772120789E-6,
	"J" : -9.771908240852056E-5,
	"K" : -0.0029319163431580364,
	"L" : 1.0089639139610114,
	"M" : -0.00845624659814348
} ], [

{
	"A" : 1.479272995605907E-4,
	"B" : 5.299487555676663E-6,
	"C" : -9.34816162034835E-7,
	"D" : 0.9776126002252283,
	"E" : -3.638780639221295E-4,
	"F" : 0.8439438370151038,
	"H" : 1.115611757096513E-5,
	"I" : -1.0630833268132633E-6,
	"J" : -1.1783047857316653E-5,
	"K" : -0.0015988651981899693,
	"L" : 1.0009919040826958,
	"M" : 0.03959656291590363
}, {
	"A" : 7.984128018168057E-6,
	"B" : 1.1434056238490697E-5,
	"C" : -7.157768184828939E-7,
	"D" : 0.9988870741370874,
	"E" : -8.660960180293387E-4,
	"F" : 0.03588339853740763,
	"H" : 1.1180620848261213E-5,
	"I" : -1.0629570347253647E-6,
	"J" : -1.1782678062621788E-5,
	"K" : -0.0016472828680207385,
	"L" : 1.0009921985487011,
	"M" : 0.043013323852392205
}, {
	"A" : -1.3419818301940722E-4,
	"B" : 1.594330183429804E-7,
	"C" : -6.335394946432871E-7,
	"D" : 1.0215241353724025,
	"E" : 7.33496978000403E-6,
	"F" : -0.8650296081650595,
	"H" : 1.1181914990610053E-5,
	"I" : -1.0628406358348386E-6,
	"J" : -1.1782312688501939E-5,
	"K" : -0.0016922362774778321,
	"L" : 1.0009924936459385,
	"M" : 0.0463904119505969
}, {
	"A" : 1.9441149613874664E-4,
	"B" : -8.441721086605014E-7,
	"C" : -1.0135347068285228E-6,
	"D" : 0.9681752377655926,
	"E" : 1.1004597237729286E-4,
	"F" : 1.299533725648871,
	"H" : 1.1143995225171288E-5,
	"I" : -1.0631238896996464E-6,
	"J" : -1.1781948484446136E-5,
	"K" : -0.0017307406621398513,
	"L" : 1.0009928214102501,
	"M" : 0.049591858607527683
}, {
	"A" : 6.430567699211576E-5,
	"B" : 9.220954987565477E-6,
	"C" : -1.0216763542958418E-6,
	"D" : 0.9893169041401393,
	"E" : -7.338984840430385E-4,
	"F" : 0.4409269465977559,
	"H" : 1.117233609737589E-5,
	"I" : -1.0632093624396433E-6,
	"J" : -1.1781579514591467E-5,
	"K" : -0.0017800360566440077,
	"L" : 1.0009931331883593,
	"M" : 0.05332200341126736
}, {
	"A" : -8.509797962563681E-5,
	"B" : 1.9784181721771432E-6,
	"C" : -9.478860796274802E-7,
	"D" : 1.0147032240199678,
	"E" : -1.3460126604059042E-4,
	"F" : -0.6374402950368676,
	"H" : 1.1179479679546134E-5,
	"I" : -1.0631420072071407E-6,
	"J" : -1.1781213385797518E-5,
	"K" : -0.0018259625045402572,
	"L" : 1.0009934322802252,
	"M" : 0.05700797961799253
}, {
	"A" : 2.2197749644448095E-4,
	"B" : 3.902670686173337E-6,
	"C" : -1.1461544420221514E-6,
	"D" : 0.9610235053231406,
	"E" : -2.9741612488010105E-4,
	"F" : 1.7081374942972616,
	"H" : 1.1147778994691215E-5,
	"I" : -1.0633194630349507E-6,
	"J" : -1.1780847324782684E-5,
	"K" : -0.0018650819432792787,
	"L" : 1.000993752821259,
	"M" : 0.06048510844811972
}, {
	"A" : 6.191062533944525E-5,
	"B" : 1.4944337326294743E-5,
	"C" : -8.652085394800224E-7,
	"D" : 0.9890139855712619,
	"E" : -0.0013155137440037379,
	"F" : 0.48534618866688106,
	"H" : 1.1181011113969852E-5,
	"I" : -1.0631989386666874E-6,
	"J" : -1.1780476131262319E-5,
	"K" : -0.0019156019672266211,
	"L" : 1.0009940466589313,
	"M" : 0.06455201754306472
}, {
	"A" : -1.1755575034144705E-4,
	"B" : 6.367185133582254E-6,
	"C" : -5.12065489788327E-7,
	"D" : 1.0217243235362048,
	"E" : -5.772993298478468E-4,
	"F" : -1.0045051874894853,
	"H" : 1.1190457822163324E-5,
	"I" : -1.062910174320919E-6,
	"J" : -1.1780108276071566E-5,
	"K" : -0.0019620668290372123,
	"L" : 1.0009943246830773,
	"M" : 0.06853591385151958
}, {
	"A" : 1.680912368842158E-4,
	"B" : 5.022364850226779E-6,
	"C" : -5.569713742437088E-7,
	"D" : 0.968495769860283,
	"E" : -4.619058567527645E-4,
	"F" : 1.4752142259349057,
	"H" : 1.1158115359455323E-5,
	"I" : -1.0629424466168658E-6,
	"J" : -1.1779741796003051E-5,
	"K" : -0.0020007276283138253,
	"L" : 1.0009946320567025,
	"M" : 0.07224486792620155
}, {
	"A" : 1.0757853368126291E-6,
	"B" : 1.167936968915484E-5,
	"C" : -3.3143093292054004E-7,
	"D" : 0.9999273967999898,
	"E" : -0.0011244983436426992,
	"F" : -0.0031276781955966726,
	"H" : 1.1188312434295966E-5,
	"I" : -1.0628206257301542E-6,
	"J" : -1.17793718674708E-5,
	"K" : -0.002051104057613884,
	"L" : 1.0009949243978156,
	"M" : 0.07659192464780062
}, {
	"A" : -1.6804585460894472E-4,
	"B" : -1.1420359882219344E-6,
	"C" : -2.7062776497555063E-7,
	"D" : 1.0329789926603326,
	"E" : 1.041456068833213E-4,
	"F" : -1.617873641960614,
	"H" : 1.1194358374710944E-5,
	"I" : -1.0627134544582972E-6,
	"J" : -1.177900687898692E-5,
	"K" : -0.002097037178884875,
	"L" : 1.0009952180637356,
	"M" : 0.08082433886556828
}, {
	"A" : 1.4184044731102574E-4,
	"B" : -5.416919623524308E-6,
	"C" : -8.036316367920904E-7,
	"D" : 0.9716583963497101,
	"E" : 5.632721916128958E-4,
	"F" : 1.4146340717743442,
	"H" : 1.1162442919099291E-5,
	"I" : -1.0630922255838726E-6,
	"J" : -1.1778644450677334E-5,
	"K" : -0.002135382729164803,
	"L" : 1.0009955604010798,
	"M" : 0.08476709156457218
}, {
	"A" : 7.962657492921466E-6,
	"B" : 4.903329355876451E-7,
	"C" : -1.1677858184899748E-6,
	"D" : 0.9984358013794576,
	"E" : -8.46558293687849E-6,
	"F" : 0.07487083433807129,
	"H" : 1.1209824978930527E-5,
	"I" : -1.0634292444411386E-6,
	"J" : -1.1778278889595928E-5,
	"K" : -0.0021895597338925654,
	"L" : 1.0009958996772497,
	"M" : 0.0895894323111861
}, {
	"A" : -1.2808614032611132E-4,
	"B" : -1.0528918843455415E-5,
	"C" : -1.667435409746787E-6,
	"D" : 1.0266227077404437,
	"E" : 0.0011639008442045906,
	"F" : -1.386265389224718,
	"H" : 1.1500626888372167E-5,
	"I" : -1.0639299338199848E-6,
	"J" : -1.1777918314304081E-5,
	"K" : -0.0022944296191269586,
	"L" : 1.0009962575838642,
	"M" : 0.09713975262275198
}, {
	"A" : 2.052090089466052E-4,
	"B" : -1.0968432893943003E-5,
	"C" : -2.607572147095283E-6,
	"D" : 0.9564878255519034,
	"E" : 0.0012840802382925176,
	"F" : 2.301394374706433,
	"H" : 1.1533853005785133E-5,
	"I" : -1.0642310119823861E-6,
	"J" : -1.1777553230618576E-5,
	"K" : -0.0023495363359131716,
	"L" : 1.000996596736016,
	"M" : 0.10239346353591827
}, {
	"A" : 8.008971697015532E-5,
	"B" : 1.0657799287550063E-7,
	"C" : -3.134512685853963E-6,
	"D" : 0.9827613821604473,
	"E" : 1.3920898558694716E-4,
	"F" : 0.9213255317517905,
	"H" : 1.1183093645339426E-5,
	"I" : -1.0647431427646126E-6,
	"J" : -1.177718938416561E-5,
	"K" : -0.002319359640210905,
	"L" : 1.0009969599254163,
	"M" : 0.1030140948605549
}, {
	"A" : -6.483256648470714E-5,
	"B" : -5.734404824098149E-6,
	"C" : -3.5124018831211856E-6,
	"D" : 1.014278725998679,
	"E" : 8.020413531255599E-4,
	"F" : -0.7932115245639579,
	"H" : 1.1166473132484533E-5,
	"I" : -1.065042074754885E-6,
	"J" : -1.177682648600964E-5,
	"K" : -0.002360332752203931,
	"L" : 1.0009973015765041,
	"M" : 0.1075114122213563
}, {
	"A" : 2.4526961678894565E-4,
	"B" : -2.237492549905795E-6,
	"C" : -4.083334110394077E-6,
	"D" : 0.9451121028961893,
	"E" : 4.5350553335765653E-4,
	"F" : 3.0623895672906656,
	"H" : 1.1127529922716484E-5,
	"I" : -1.0655180886498528E-6,
	"J" : -1.1776462930823683E-5,
	"K" : -0.00239620309812949,
	"L" : 1.0009976643161025,
	"M" : 0.11180658903140284
}, {
	"A" : 8.77630007498631E-5,
	"B" : 1.0690332089779986E-5,
	"C" : -4.083726866888071E-6,
	"D" : 0.9801212990192312,
	"E" : -0.0010163490192098834,
	"F" : 1.117406263230805,
	"H" : 1.1158233441443954E-5,
	"I" : -1.0656442366308028E-6,
	"J" : -1.1776093861104453E-5,
	"K" : -0.002447631166745623,
	"L" : 1.000997988377577,
	"M" : 0.11705972629715689
}, {
	"A" : -9.028101650576659E-5,
	"B" : 4.167485758266309E-6,
	"C" : -3.902206377359718E-6,
	"D" : 1.0210255083354696,
	"E" : -2.922934758089468E-4,
	"F" : -1.2316990005638218,
	"H" : 1.1166924832162195E-5,
	"I" : -1.0655079969446035E-6,
	"J" : -1.1775727239871081E-5,
	"K" : -0.0024942670387986254,
	"L" : 1.0009982825278598,
	"M" : 0.12214169759317883
}, {
	"A" : 1.9522087872347882E-4,
	"B" : 4.77874800575151E-6,
	"C" : -4.012177369006054E-6,
	"D" : 0.9540249689790699,
	"E" : -3.673145488392038E-4,
	"F" : 2.699007892093505,
	"H" : 1.1134099554443999E-5,
	"I" : -1.065601158756202E-6,
	"J" : -1.1775361151933339E-5,
	"K" : -0.002531161830631845,
	"L" : 1.0009986034161784,
	"M" : 0.12674147301004268
}, {
	"A" : 2.7012439082430006E-5,
	"B" : 1.3485811799274217E-5,
	"C" : -3.7455427353005888E-6,
	"D" : 0.9936640304565572,
	"E" : -0.0014374970078279148,
	"F" : 0.36439809851071914,
	"H" : 1.1163831000970958E-5,
	"I" : -1.065477359230016E-6,
	"J" : -1.1774990997470702E-5,
	"K" : -0.0025827850010955444,
	"L" : 1.0009988981618392,
	"M" : 0.13229740206588758
}, {
	"A" : -1.4453950477699706E-4,
	"B" : 2.5698102605886675E-6,
	"C" : -3.533321355053687E-6,
	"D" : 1.0353348255404171,
	"E" : -1.457545577068231E-4,
	"F" : -2.1657548378934735,
	"H" : 1.1168023995811183E-5,
	"I" : -1.0652685841217036E-6,
	"J" : -1.1774624920968257E-5,
	"K" : -0.0026284777234195644,
	"L" : 1.0009991823193332,
	"M" : 0.13759859213678283
}, {
	"A" : 1.6215935876839893E-4,
	"B" : -1.3338627313785878E-7,
	"C" : -3.8230745409428835E-6,
	"D" : 0.9598476151660975,
	"E" : 1.9988600598708217E-4,
	"F" : 2.478622035436274,
	"H" : 1.112971785843797E-5,
	"I" : -1.065458864468738E-6,
	"J" : -1.177426060966491E-5,
	"K" : -0.0026636455718289653,
	"L" : 1.000999515547548,
	"M" : 0.14233747929392848
}, {
	"A" : 2.3900917399011234E-5,
	"B" : 7.181609232631558E-6,
	"C" : -3.865360744814694E-6,
	"D" : 0.9940822918752019,
	"E" : -7.198104486860757E-4,
	"F" : 0.3593511754224892,
	"H" : 1.1154964346449248E-5,
	"I" : -1.0655491745614754E-6,
	"J" : -1.1773892680866371E-5,
	"K" : -0.0027144920226760405,
	"L" : 1.0009998365716086,
	"M" : 0.1481325804725202
}, {
	"A" : -1.1753387554502837E-4,
	"B" : -2.8135660001815666E-6,
	"C" : -3.974859819066978E-6,
	"D" : 1.0301212023206858,
	"E" : 5.504394305830829E-4,
	"F" : -1.9367603172868257,
	"H" : 1.1157320936150406E-5,
	"I" : -1.0655897361155908E-6,
	"J" : -1.1773528598324479E-5,
	"K" : -0.002759735088545767,
	"L" : 1.0010001518638916,
	"M" : 0.1536741823583725
}, {
	"A" : 2.1080401935247295E-4,
	"B" : -2.640945806486883E-6,
	"C" : -4.482295514751655E-6,
	"D" : 0.945239803974232,
	"E" : 5.616141268092179E-4,
	"F" : 3.548096910788445,
	"H" : 1.1120271031783702E-5,
	"I" : -1.0659707193605428E-6,
	"J" : -1.1773165116468753E-5,
	"K" : -0.0027947244326469445,
	"L" : 1.0010005118604255,
	"M" : 0.1586380560784164
}, {
	"A" : 8.024186025767932E-5,
	"B" : 8.689872018852185E-6,
	"C" : -4.554330656159067E-6,
	"D" : 0.9789341085593151,
	"E" : -9.252870473801522E-4,
	"F" : 1.3744329648761777,
	"H" : 1.1149698742940473E-5,
	"I" : -1.0661261065081362E-6,
	"J" : -1.1772796591591472E-5,
	"K" : -0.0028469312595120755,
	"L" : 1.0010008430308233,
	"M" : 0.16480591299477965
}, {
	"A" : -7.05128146720746E-5,
	"B" : 2.6494494691498005E-6,
	"C" : -4.474288560096795E-6,
	"D" : 1.0189683945931165,
	"E" : -1.3870129680526588E-4,
	"F" : -1.283389287229511,
	"H" : 1.1157919700410801E-5,
	"I" : -1.0660674806262094E-6,
	"J" : -1.1772430414003221E-5,
	"K" : -0.002893742127525911,
	"L" : 1.001001146194298,
	"M" : 0.17072008137984085
}, {
	"A" : 2.3445949202716143E-4,
	"B" : 5.500777130684753E-6,
	"C" : -4.611367078855011E-6,
	"D" : 0.9363312709521097,
	"E" : -5.247591736861068E-4,
	"F" : 4.314331671084801,
	"H" : 1.1126907663028263E-5,
	"I" : -1.0661992542182475E-6,
	"J" : -1.1772064045900699E-5,
	"K" : -0.00292992226206934,
	"L" : 1.0010014751490104,
	"M" : 0.17600329432389117
} ], [

{
	"A" : 1.5376236211128713E-4,
	"B" : 5.937244435871847E-6,
	"C" : -1.1264343542372046E-6,
	"D" : 0.9766947258790424,
	"E" : -3.9590409033962715E-4,
	"F" : 0.8796492077126459,
	"H" : 1.1155599554557583E-5,
	"I" : -1.054878805306636E-6,
	"J" : 8.142780640058023E-5,
	"K" : -0.0015988658207675144,
	"L" : 0.9922414726690363,
	"M" : 0.24507425018964568
}, {
	"A" : 8.300421906026756E-6,
	"B" : 1.2782423716162228E-5,
	"C" : -8.752950924062475E-7,
	"D" : 0.9987724928848252,
	"E" : -9.578943326005174E-4,
	"F" : 0.04262184446270112,
	"H" : 1.1181326408982173E-5,
	"I" : -1.0547165758545418E-6,
	"J" : 8.142766074514807E-5,
	"K" : -0.0016474738891361085,
	"L" : 0.9922417857030581,
	"M" : 0.2484979402852332
}, {
	"A" : -1.394855751826185E-4,
	"B" : 2.0388346100297383E-7,
	"C" : -7.817933700415836E-7,
	"D" : 1.022367270984745,
	"E" : 1.6051417446760752E-5,
	"F" : -0.8988868996802921,
	"H" : 1.1182930522046775E-5,
	"I" : -1.0546150206458549E-6,
	"J" : 8.142751001860571E-5,
	"K" : -0.0016924791904955327,
	"L" : 0.9922421033464985,
	"M" : 0.25187671532694367
}, {
	"A" : 2.0207198347144129E-4,
	"B" : -9.172901638265785E-7,
	"C" : -1.2215545708293973E-6,
	"D" : 0.9669221572111439,
	"E" : 1.3404773386582747E-4,
	"F" : 1.350389629133133,
	"H" : 1.1142891600979254E-5,
	"I" : -1.0549326108222346E-6,
	"J" : 8.142735798966072E-5,
	"K" : -0.0017306385282438441,
	"L" : 0.9922424553167559,
	"M" : 0.25506363580734615
}, {
	"A" : 6.684461634853811E-5,
	"B" : 1.0312871646878108E-5,
	"C" : -1.2325141951485818E-6,
	"D" : 0.9888375069526489,
	"E" : -8.073246428921266E-4,
	"F" : 0.46288830237790535,
	"H" : 1.1172582412122267E-5,
	"I" : -1.0549977773610664E-6,
	"J" : 8.142721146348064E-5,
	"K" : -0.0017801570928668298,
	"L" : 0.9922427867924455,
	"M" : 0.25880252552451566
}, {
	"A" : -8.845152669922918E-5,
	"B" : 2.2331171063427746E-6,
	"C" : -1.1487761687467568E-6,
	"D" : 1.0152671649804006,
	"E" : -1.3917811259034352E-4,
	"F" : -0.6615041445911629,
	"H" : 1.1180273551292252E-5,
	"I" : -1.0549392066572238E-6,
	"J" : 8.142706163233315E-5,
	"K" : -0.0018261784098285716,
	"L" : 0.9922431080511274,
	"M" : 0.2624921280539638
}, {
	"A" : 2.3073107270032978E-4,
	"B" : 4.378446872621566E-6,
	"C" : -1.3789595405544475E-6,
	"D" : 0.9594598066207709,
	"E" : -3.188911344409462E-4,
	"F" : 1.777509851330251,
	"H" : 1.1146728525757155E-5,
	"I" : -1.055127646809595E-6,
	"J" : 8.142691177182027E-5,
	"K" : -0.0018649758715696407,
	"L" : 0.9922434509820164,
	"M" : 0.26595472348708427
}, {
	"A" : 6.435743528587778E-5,
	"B" : 1.669889017064108E-5,
	"C" : -1.0564696591996992E-6,
	"D" : 0.9884888983872884,
	"E" : -0.0014569961271320153,
	"F" : 0.5124361909947766,
	"H" : 1.1181546245575547E-5,
	"I" : -1.0549559277261977E-6,
	"J" : 8.142676768407853E-5,
	"K" : -0.0019157793196313833,
	"L" : 0.9922437616147874,
	"M" : 0.27003382023758604
}, {
	"A" : -1.221920640595009E-4,
	"B" : 7.129566901076245E-6,
	"C" : -6.504953262709279E-7,
	"D" : 1.0225401132186676,
	"E" : -6.360969176171238E-4,
	"F" : -1.0405399969640712,
	"H" : 1.1191666215548679E-5,
	"I" : -1.054649262033358E-6,
	"J" : 8.142661981702659E-5,
	"K" : -0.001962371148380271,
	"L" : 0.9922440593421697,
	"M" : 0.2740232189225935
}, {
	"A" : 1.747212790712549E-4,
	"B" : 5.62833488437775E-6,
	"C" : -7.037496174699953E-7,
	"D" : 0.9672199509021766,
	"E" : -5.067273804115757E-4,
	"F" : 1.5363114115025382,
	"H" : 1.1157459231414535E-5,
	"I" : -1.0546811515244059E-6,
	"J" : 8.142647041969875E-5,
	"K" : -0.002000686307326305,
	"L" : 0.9922443880063554,
	"M" : 0.277715676880689
}, {
	"A" : 1.1193629929628912E-6,
	"B" : 1.3056160772295655E-5,
	"C" : -4.4510402663622273E-7,
	"D" : 0.9998524161186424,
	"E" : -0.001247694019411938,
	"F" : 0.0034998749870283064,
	"H" : 1.1189076091211447E-5,
	"I" : -1.0545177715481913E-6,
	"J" : 8.142632502838865E-5,
	"K" : -0.0020513345436654618,
	"L" : 0.9922446976452477,
	"M" : 0.28207526970800245
}, {
	"A" : -1.7466560132817222E-4,
	"B" : -1.2483442208832685E-6,
	"C" : -3.763337681483847E-7,
	"D" : 1.0342807843716173,
	"E" : 1.2274929272848567E-4,
	"F" : -1.6820203384158958,
	"H" : 1.1195526324558891E-5,
	"I" : -1.0544241493271045E-6,
	"J" : 8.142617389111928E-5,
	"K" : -0.0020973495254565933,
	"L" : 0.992245013928823,
	"M" : 0.28631134560055216
}, {
	"A" : 1.474253414797122E-4,
	"B" : -6.018249292472078E-6,
	"C" : -9.925458434034695E-7,
	"D" : 0.9705699545273774,
	"E" : 6.395676674344486E-4,
	"F" : 1.4672868918569293,
	"H" : 1.1161456186181695E-5,
	"I" : -1.0548479337790795E-6,
	"J" : 8.142601991723009E-5,
	"K" : -0.0021352668134682062,
	"L" : 0.9922453821124009,
	"M" : 0.2902323383423209
}, {
	"A" : 8.27743177511664E-6,
	"B" : 5.724116294292259E-7,
	"C" : -1.4140962021347292E-6,
	"D" : 0.9983671276102086,
	"E" : 4.844925683755719E-6,
	"F" : 0.07812724550603889,
	"H" : 1.1210012144546866E-5,
	"I" : -1.055186105380912E-6,
	"J" : 8.142586958692632E-5,
	"K" : -0.0021896792177074076,
	"L" : 0.9922457429298248,
	"M" : 0.2950660005226382
}, {
	"A" : -1.3312376103202794E-4,
	"B" : -1.1719853164837701E-5,
	"C" : -1.9916994962176915E-6,
	"D" : 1.0277270010273014,
	"E" : 0.001316902739034731,
	"F" : -1.4472751908833743,
	"H" : 1.1501073480690849E-5,
	"I" : -1.0556780221104844E-6,
	"J" : 8.14257137122798E-5,
	"K" : -0.0022946043671936422,
	"L" : 0.9922461214885203,
	"M" : 0.3026187751438556
}, {
	"A" : 2.1328113101759527E-4,
	"B" : -1.221272734630574E-5,
	"C" : -3.0774962999080557E-6,
	"D" : 0.9548359706560632,
	"E" : 0.001459100836370908,
	"F" : 2.384802555436181,
	"H" : 1.1532173810779867E-5,
	"I" : -1.0564523692524475E-6,
	"J" : 8.142556300511083E-5,
	"K" : -0.002349240073982628,
	"L" : 0.9922465320234863,
	"M" : 0.3078459718672093
}, {
	"A" : 8.32466516469399E-5,
	"B" : 1.4347229448929966E-7,
	"C" : -3.6869782442661148E-6,
	"D" : 0.9820772693957451,
	"E" : 1.8628919184493498E-4,
	"F" : 0.957207854189619,
	"H" : 1.1182805914389249E-5,
	"I" : -1.0568889178275143E-6,
	"J" : 8.142541053679508E-5,
	"K" : -0.0023193606337486017,
	"L" : 0.9922469090085286,
	"M" : 0.3084819786963635
}, {
	"A" : -6.73841285094845E-5,
	"B" : -6.371217452727507E-6,
	"C" : -4.124150661644066E-6,
	"D" : 1.0148700402156123,
	"E" : 9.28837597484744E-4,
	"F" : -0.8286958138414775,
	"H" : 1.1166774088078313E-5,
	"I" : -1.0572174981016147E-6,
	"J" : 8.142525686827273E-5,
	"K" : -0.002360460822785626,
	"L" : 0.9922472758483423,
	"M" : 0.3129856500781898
}, {
	"A" : 2.5493166277357204E-4,
	"B" : -2.4740237294373912E-6,
	"C" : -4.784241025790337E-6,
	"D" : 0.9429588630900412,
	"E" : 5.45305593050216E-4,
	"F" : 3.180828467640822,
	"H" : 1.1126039189068848E-5,
	"I" : -1.0577277693712972E-6,
	"J" : 8.142510417341597E-5,
	"K" : -0.0023959293884274757,
	"L" : 0.9922476644090921,
	"M" : 0.317257794955367
}, {
	"A" : 9.122849833786972E-5,
	"B" : 1.1951479339078475E-5,
	"C" : -4.786532110445663E-6,
	"D" : 0.9792701845786951,
	"E" : -0.001094612439658249,
	"F" : 1.167869343131315,
	"H" : 1.11584013988697E-5,
	"I" : -1.057824369210536E-6,
	"J" : 8.142495766078062E-5,
	"K" : -0.0024477308728592106,
	"L" : 0.9922480071271877,
	"M" : 0.3225314422197698
}, {
	"A" : -9.384022316272222E-5,
	"B" : 4.676153802618543E-6,
	"C" : -4.57841480616672E-6,
	"D" : 1.0218262098602509,
	"E" : -2.88351927167696E-4,
	"F" : -1.2781500888595474,
	"H" : 1.1167856570737378E-5,
	"I" : -1.0576822080388126E-6,
	"J" : 8.142480824224752E-5,
	"K" : -0.0024945449812605602,
	"L" : 0.9922483226178826,
	"M" : 0.32762330193509115
}, {
	"A" : 2.029205144682411E-4,
	"B" : 5.3545251161857266E-6,
	"C" : -4.7067489965524345E-6,
	"D" : 0.9521798820290996,
	"E" : -3.7054640984024445E-4,
	"F" : 2.8080099702929147,
	"H" : 1.1133256598849783E-5,
	"I" : -1.0577766736963312E-6,
	"J" : 8.142465837723822E-5,
	"K" : -0.0025310245901550843,
	"L" : 0.9922486656670344,
	"M" : 0.3321982864908932
}, {
	"A" : 2.808028292200504E-5,
	"B" : 1.5071421932244533E-5,
	"C" : -4.4008947281959365E-6,
	"D" : 0.9933311363851658,
	"E" : -0.0015668120701093358,
	"F" : 0.38755191391101107,
	"H" : 1.1164513991523961E-5,
	"I" : -1.0576078104396203E-6,
	"J" : 8.142451300130471E-5,
	"K" : -0.002583012608710078,
	"L" : 0.9922489769954268,
	"M" : 0.33777551776802284
}, {
	"A" : -1.5023672922387377E-4,
	"B" : 2.8941106724467147E-6,
	"C" : -4.1572577553772305E-6,
	"D" : 1.0367086981182183,
	"E" : -1.2739088219859696E-4,
	"F" : -2.249911014958343,
	"H" : 1.1169220518025824E-5,
	"I" : -1.057399424464478E-6,
	"J" : 8.14243630027911E-5,
	"K" : -0.0026288335071456004,
	"L" : 0.9922492831544503,
	"M" : 0.3430841934896307
}, {
	"A" : 1.6854983894143416E-4,
	"B" : -1.2524099668453914E-7,
	"C" : -4.492869178696068E-6,
	"D" : 0.9582620248154399,
	"E" : 2.6120121395933893E-4,
	"F" : 2.5755245805194136,
	"H" : 1.1128849698671672E-5,
	"I" : -1.0576156010966287E-6,
	"J" : 8.142421117507403E-5,
	"K" : -0.0026634929185718192,
	"L" : 0.9922496415463087,
	"M" : 0.3477912747312075
}, {
	"A" : 2.4844819178859723E-5,
	"B" : 8.03754636491405E-6,
	"C" : -4.543312025040436E-6,
	"D" : 0.9938028377181354,
	"E" : -7.645403142646501E-4,
	"F" : 0.37810891204571817,
	"H" : 1.1155366397397337E-5,
	"I" : -1.0576945247420255E-6,
	"J" : 8.142406339534114E-5,
	"K" : -0.002714656434079643,
	"L" : 0.992249983110213,
	"M" : 0.3536056557768461
}, {
	"A" : -1.2216373587170537E-4,
	"B" : -3.112025563911658E-6,
	"C" : -4.670778028348366E-6,
	"D" : 1.0313201232043525,
	"E" : 6.534713293717687E-4,
	"F" : -2.0158735300792614,
	"H" : 1.1158090424734368E-5,
	"I" : -1.0577666236244454E-6,
	"J" : 8.142391130261384E-5,
	"K" : -0.0027599938672722146,
	"L" : 0.9922503244357301,
	"M" : 0.3591528067317995
}, {
	"A" : 2.1910803029046022E-4,
	"B" : -2.9237238388102327E-6,
	"C" : -5.257543786107988E-6,
	"D" : 0.9430940075063745,
	"E" : 6.708182029342424E-4,
	"F" : 3.685018682081136,
	"H" : 1.1118977051527423E-5,
	"I" : -1.0581906462192592E-6,
	"J" : 8.14237585371469E-5,
	"K" : -0.002794447774761011,
	"L" : 0.9922507120875821,
	"M" : 0.3640814352038433
}, {
	"A" : 8.340955367547309E-5,
	"B" : 9.719539300512281E-6,
	"C" : -5.342459470591976E-6,
	"D" : 0.9780479590768891,
	"E" : -9.875095344114015E-4,
	"F" : 1.4344881748693297,
	"H" : 1.1149817433553366E-5,
	"I" : -1.0583320509960359E-6,
	"J" : 8.142361149221511E-5,
	"K" : -0.002847022876721894,
	"L" : 0.9922510635084052,
	"M" : 0.37027278149616905
}, {
	"A" : -7.329165138747484E-5,
	"B" : 2.9823146803220624E-6,
	"C" : -5.251389472826773E-6,
	"D" : 1.0196965479070172,
	"E" : -1.106772112393628E-4,
	"F" : -1.3327599455806194,
	"H" : 1.1158652504894562E-5,
	"I" : -1.0582808707138014E-6,
	"J" : 8.142346160461278E-5,
	"K" : -0.0028939985217562025,
	"L" : 0.9922513897923011,
	"M" : 0.3761974906665273
}, {
	"A" : 2.4370792499595062E-4,
	"B" : 6.159383010739816E-6,
	"C" : -5.411067311777984E-6,
	"D" : 0.9337837809916891,
	"E" : -5.395292931780205E-4,
	"F" : 4.487980174912082,
	"H" : 1.1125851666848874E-5,
	"I" : -1.0584156726611837E-6,
	"J" : 8.14233121608221E-5,
	"K" : -0.0029296948452497418,
	"L" : 0.9922517412681486,
	"M" : 0.3814474756909476
} ], [

{
	"A" : 1.6028216415175933E-4,
	"B" : 6.667257451686837E-6,
	"C" : -1.3418886457561285E-6,
	"D" : 0.9756668830548278,
	"E" : -4.3186326078625825E-4,
	"F" : 0.9196672377238428,
	"H" : 1.11507709656955E-5,
	"I" : -1.073655861882905E-6,
	"J" : -1.4105706010569818E-4,
	"K" : -0.001596885617885846,
	"L" : 1.0145537752146652,
	"M" : -0.31417295479332097
}, {
	"A" : 8.65395226945509E-6,
	"B" : 1.4329562575188248E-5,
	"C" : -1.054703756664388E-6,
	"D" : 0.9986394482872925,
	"E" : -0.00106264054468852,
	"F" : 0.05050029662743327,
	"H" : 1.1177845997023539E-5,
	"I" : -1.0734719411154003E-6,
	"J" : -1.410560318835241E-4,
	"K" : -0.0016456856357933702,
	"L" : 1.0145540343438597,
	"M" : -0.31074341923977045
}, {
	"A" : -1.4539288628978575E-4,
	"B" : 2.5207715870223524E-7,
	"C" : -9.483881213689926E-7,
	"D" : 1.0233092748782724,
	"E" : 2.6821362837381457E-5,
	"F" : -0.9367532528085576,
	"H" : 1.1179787129833585E-5,
	"I" : -1.073372452697896E-6,
	"J" : -1.410550091847096E-4,
	"K" : -0.0016907310156284439,
	"L" : 1.0145542999398316,
	"M" : -0.30736452278415527
}, {
	"A" : 2.1063069285265357E-4,
	"B" : -1.0045557130577976E-6,
	"C" : -1.4547239803874845E-6,
	"D" : 0.965522627884809,
	"E" : 1.6248391753492797E-4,
	"F" : 1.407118298993737,
	"H" : 1.1137416739970263E-5,
	"I" : -1.0737263664850616E-6,
	"J" : -1.41053987053108E-4,
	"K" : -0.0017284936913597448,
	"L" : 1.0145546026117387,
	"M" : -0.30419537954094267
}, {
	"A" : 6.968170954646524E-5,
	"B" : 1.1565096998511493E-5,
	"C" : -1.46867083850033E-6,
	"D" : 0.9882978092813914,
	"E" : -8.909113829531634E-4,
	"F" : 0.48771378443416324,
	"H" : 1.1168595850485907E-5,
	"I" : -1.0737929896365017E-6,
	"J" : -1.410529593300902E-4,
	"K" : -0.0017782401336887688,
	"L" : 1.0145548819788672,
	"M" : -0.30044877059117425
}, {
	"A" : -9.219832161544428E-5,
	"B" : 2.5229904376811163E-6,
	"C" : -1.3735954149662888E-6,
	"D" : 1.015896442047847,
	"E" : -1.436554376255117E-4,
	"F" : -0.6883699960781087,
	"H" : 1.1176886731023572E-5,
	"I" : -1.0737385488512885E-6,
	"J" : -1.4105193560259854E-4,
	"K" : -0.0018243485563402828,
	"L" : 1.0145551514247302,
	"M" : -0.29675704094188404
}, {
	"A" : 2.4051165541938424E-4,
	"B" : 4.922123838957404E-6,
	"C" : -1.6392473293214138E-6,
	"D" : 0.9577110188115512,
	"E" : -3.42732443755267E-4,
	"F" : 1.8551096668234095,
	"H" : 1.1141313077223103E-5,
	"I" : -1.07394705051167E-6,
	"J" : -1.4105091144245296E-4,
	"K" : -0.0018627744356365383,
	"L" : 1.0145554439095434,
	"M" : -0.29331236500183877
}, {
	"A" : 6.70917952176886E-5,
	"B" : 1.871300293299072E-5,
	"C" : -1.270177432344255E-6,
	"D" : 0.9878955546342638,
	"E" : -0.0016188976847217873,
	"F" : 0.5432537174147001,
	"H" : 1.1177878685320053E-5,
	"I" : -1.073750827584874E-6,
	"J" : -1.4104988146379505E-4,
	"K" : -0.0019138718222109219,
	"L" : 1.0145557001392405,
	"M" : -0.2892218949418748
}, {
	"A" : -1.2737237970439352E-4,
	"B" : 8.003087187180569E-6,
	"C" : -8.049466948545358E-7,
	"D" : 1.0234488774362944,
	"E" : -7.030354969117525E-4,
	"F" : -1.0805835380815552,
	"H" : 1.1188736042555547E-5,
	"I" : -1.0734243842680513E-6,
	"J" : -1.410488560628087E-4,
	"K" : -0.001960585732007303,
	"L" : 1.0145559438637974,
	"M" : -0.28522843380415
}, {
	"A" : 1.821293141377467E-4,
	"B" : 6.3218157759781235E-6,
	"C" : -8.673284574989282E-7,
	"D" : 0.9657922877012197,
	"E" : -5.5757998285344E-4,
	"F" : 1.6047440933907637,
	"H" : 1.11524768948712E-5,
	"I" : -1.0734665114586761E-6,
	"J" : -1.4104783163937373E-4,
	"K" : -0.0019985029072699945,
	"L" : 1.0145562212033212,
	"M" : -0.2815561814550165
}, {
	"A" : 1.1681534992646903E-6,
	"B" : 1.4635985841504606E-5,
	"C" : -5.715102127101801E-7,
	"D" : 0.9997635089871437,
	"E" : -0.0013887239551877428,
	"F" : 0.011369630316039547,
	"H" : 1.1185657289636275E-5,
	"I" : -1.0732908546362552E-6,
	"J" : -1.4104680309739992E-4,
	"K" : -0.002049431865060569,
	"L" : 1.0145564773585818,
	"M" : -0.2771849680430023
}, {
	"A" : -1.8206136864407085E-4,
	"B" : -1.3734568096168687E-6,
	"C" : -4.936165889368738E-7,
	"D" : 1.0357357782206122,
	"E" : 1.4470127263166432E-4,
	"F" : -1.7537696698054788,
	"H" : 1.1192546387817082E-5,
	"I" : -1.0732168820304366E-6,
	"J" : -1.4104578086915343E-4,
	"K" : -0.0020955184211288724,
	"L" : 1.0145567432667661,
	"M" : -0.2729470166596002
}, {
	"A" : 1.536647197293295E-4,
	"B" : -6.7126294314157064E-6,
	"C" : -1.202584435477938E-6,
	"D" : 0.969356470476896,
	"E" : 7.279624171872001E-4,
	"F" : 1.5258166736966814,
	"H" : 1.115610179280857E-5,
	"I" : -1.0737174611641365E-6,
	"J" : -1.4104476062315463E-4,
	"K" : -0.002132945231210215,
	"L" : 1.014557066752701,
	"M" : -0.26905225082191464
}, {
	"A" : 8.629208067212346E-6,
	"B" : 6.637449150304064E-7,
	"C" : -1.6880846984701492E-6,
	"D" : 0.9982902576144852,
	"E" : 2.0894015136718735E-5,
	"F" : 0.08172466667019762,
	"H" : 1.1205942267888958E-5,
	"I" : -1.0741420233273402E-6,
	"J" : -1.4104373645562607E-4,
	"K" : -0.002187593877067684,
	"L" : 1.0145573840480182,
	"M" : -0.26420877332566306
}, {
	"A" : -1.3875120889972337E-4,
	"B" : -1.3091578964230521E-5,
	"C" : -2.3525311403371774E-6,
	"D" : 1.0289653588466763,
	"E" : 0.001493589820483976,
	"F" : -1.515995405126887,
	"H" : 1.149717534543182E-5,
	"I" : -1.0749078572791504E-6,
	"J" : -1.4104271842629856E-4,
	"K" : -0.0022925249760703537,
	"L" : 1.01455773877845,
	"M" : -0.2566581600403879
}, {
	"A" : 2.2229850822785835E-4,
	"B" : -1.3646469051220578E-5,
	"C" : -3.6008488086824997E-6,
	"D" : 0.9529956820514371,
	"E" : 0.0016613589039309318,
	"F" : 2.477345119230449,
	"H" : 1.1525910623477742E-5,
	"I" : -1.0748707290897386E-6,
	"J" : -1.4104169383821752E-4,
	"K" : -0.002346684575911695,
	"L" : 1.014558012021709,
	"M" : -0.2514558336879418
}, {
	"A" : 8.677385320199349E-5,
	"B" : 1.8265848678034047E-7,
	"C" : -4.3024353855170006E-6,
	"D" : 0.9813129763738289,
	"E" : 2.4156913178785544E-4,
	"F" : 0.9971719859531731,
	"H" : 1.117822030671789E-5,
	"I" : -1.0755801735928827E-6,
	"J" : -1.410406725068647E-4,
	"K" : -0.002317128647291611,
	"L" : 1.01455836635202,
	"M" : -0.2508053774417931
}, {
	"A" : -7.023458751165279E-5,
	"B" : -7.106045622595758E-6,
	"C" : -4.8055914643185815E-6,
	"D" : 1.0155332574263412,
	"E" : 0.001075770811496568,
	"F" : -0.8687598160613561,
	"H" : 1.1162843170042791E-5,
	"I" : -1.0760058337666578E-6,
	"J" : -1.4103965274059327E-4,
	"K" : -0.002358349821122374,
	"L" : 1.0145586921004082,
	"M" : -0.24629726481362013
}, {
	"A" : 2.6572640595023955E-4,
	"B" : -2.749764740350713E-6,
	"C" : -5.565129013618275E-6,
	"D" : 0.9405543291067602,
	"E" : 6.522411532046135E-4,
	"F" : 3.312872881790099,
	"H" : 1.1120141711229437E-5,
	"I" : -1.0765939228996046E-6,
	"J" : -1.4103863152692409E-4,
	"K" : -0.002393358260292189,
	"L" : 1.0145590376784241,
	"M" : -0.24205293680097384
}, {
	"A" : 9.510099666387717E-5,
	"B" : 1.3398047338242236E-5,
	"C" : -5.569481113187891E-6,
	"D" : 0.9783144666330372,
	"E" : -0.0011832439369072745,
	"F" : 1.2246362863952527,
	"H" : 1.1154334237151176E-5,
	"I" : -1.07670709059704E-6,
	"J" : -1.4103760422395917E-4,
	"K" : -0.002445552412325469,
	"L" : 1.0145593306930039,
	"M" : -0.23675926191754115
}, {
	"A" : -9.781691868004927E-5,
	"B" : 5.258206785763164E-6,
	"C" : -5.3313792303111285E-6,
	"D" : 1.0227190532212944,
	"E" : -2.825998282673936E-4,
	"F" : -1.3299894071387826,
	"H" : 1.116462819128472E-5,
	"I" : -1.0765674886004106E-6,
	"J" : -1.4103658063258084E-4,
	"K" : -0.0024925448133501504,
	"L" : 1.0145595949673663,
	"M" : -0.23165896604587033
}, {
	"A" : 2.1152361315079915E-4,
	"B" : 6.012769765639803E-6,
	"C" : -5.480040945915476E-6,
	"D" : 0.950116297218301,
	"E" : -3.729156986764792E-4,
	"F" : 2.929888490056328,
	"H" : 1.1128076528699182E-5,
	"I" : -1.0766766622705148E-6,
	"J" : -1.4103555697397852E-4,
	"K" : -0.0025285501667724475,
	"L" : 1.0145598881771036,
	"M" : -0.2271137285097211
}, {
	"A" : 2.9273644929217468E-5,
	"B" : 1.6891261221063658E-5,
	"C" : -5.1302541355102704E-6,
	"D" : 0.9929532171477717,
	"E" : -0.0017142685800308755,
	"F" : 0.4139944729904528,
	"H" : 1.1161016037597449E-5,
	"I" : -1.0764881053226816E-6,
	"J" : -1.4103452883584833E-4,
	"K" : -0.002580921967592076,
	"L" : 1.0145601455695328,
	"M" : -0.22151561801729258
}, {
	"A" : -1.5660213647006316E-4,
	"B" : 3.2643577201341145E-6,
	"C" : -4.8512112325038714E-6,
	"D" : 1.038242626051101,
	"E" : -1.0519387558360904E-4,
	"F" : -2.3439389692939585,
	"H" : 1.1166283979235914E-5,
	"I" : -1.076272916455956E-6,
	"J" : -1.4103350587757468E-4,
	"K" : -0.002626866366711056,
	"L" : 1.0145603993307475,
	"M" : -0.21620119004364824
}, {
	"A" : 1.7568970502690462E-4,
	"B" : -1.1941474920007522E-7,
	"C" : -5.2378374784112225E-6,
	"D" : 0.9564906784619325,
	"E" : 3.3294275738171564E-4,
	"F" : 2.6836256645983667,
	"H" : 1.1123641214139113E-5,
	"I" : -1.0765169233817318E-6,
	"J" : -1.4103248421915016E-4,
	"K" : -0.0026609492898046483,
	"L" : 1.0145607095403193,
	"M" : -0.21153161871734483
}, {
	"A" : 2.5899588822486663E-5,
	"B" : 9.018459163456782E-6,
	"C" : -5.297271772564116E-6,
	"D" : 0.9934874649775338,
	"E" : -8.147607137516388E-4,
	"F" : 0.39931604388402775,
	"H" : 1.1151557911537324E-5,
	"I" : -1.076602862415399E-6,
	"J" : -1.4103145825972163E-4,
	"K" : -0.0027124443084858285,
	"L" : 1.0145610003672516,
	"M" : -0.20569864564822637
}, {
	"A" : -1.273362120062238E-4,
	"B" : -3.4577150873627005E-6,
	"C" : -5.44451196371476E-6,
	"D" : 1.032660879777211,
	"E" : 7.730566755981272E-4,
	"F" : -2.104575444929651,
	"H" : 1.11546828516218E-5,
	"I" : -1.0766969418263272E-6,
	"J" : -1.41030437215528E-4,
	"K" : -0.0027578682186231163,
	"L" : 1.0145612929545393,
	"M" : -0.2001479509199271
}, {
	"A" : 2.283854892799475E-4,
	"B" : -3.2525874267275157E-6,
	"C" : -6.119714281993538E-6,
	"D" : 0.9406979773401076,
	"E" : 7.977517578865445E-4,
	"F" : 3.8376566707811435,
	"H" : 1.1113299829168533E-5,
	"I" : -1.0771676668408503E-6,
	"J" : -1.4102941605570463E-4,
	"K" : -0.0027917161193045104,
	"L" : 1.0145616350922069,
	"M" : -0.1952607072362298
}, {
	"A" : 8.694918286700215E-5,
	"B" : 1.0899960588339752E-5,
	"C" : -6.2189571294890555E-6,
	"D" : 0.977054006135404,
	"E" : -0.0010576949994174356,
	"F" : 1.5019238724926254,
	"H" : 1.1145698129100268E-5,
	"I" : -1.0773173964029326E-6,
	"J" : -1.4102838936019824E-4,
	"K" : -0.0028446792087208905,
	"L" : 1.0145619361207707,
	"M" : -0.18904624740935105
}, {
	"A" : -7.639636387146709E-5,
	"B" : 3.362232945836041E-6,
	"C" : -6.115296222519717E-6,
	"D" : 1.0205089905048226,
	"E" : -7.72230862366996E-5,
	"F" : -1.3879365383836557,
	"H" : 1.1155206528501438E-5,
	"I" : -1.0772685878901456E-6,
	"J" : -1.410273659768202E-4,
	"K" : -0.0028918188029081193,
	"L" : 1.0145622112847263,
	"M" : -0.18311262223869562
}, {
	"A" : 2.540416437311066E-4,
	"B" : 6.912598279118498E-6,
	"C" : -6.300061967223769E-6,
	"D" : 0.9309350411411401,
	"E" : -5.550908061309201E-4,
	"F" : 4.6821514420516905,
	"H" : 1.1120438884293371E-5,
	"I" : -1.0774125864809747E-6,
	"J" : -1.4102634180179763E-4,
	"K" : -0.0029269658647024244,
	"L" : 1.0145625125453535,
	"M" : -0.1779019236601016
} ], [

{
	"A" : 1.6759514216635463E-4,
	"B" : 7.509677505290746E-6,
	"C" : -1.6301199614598971E-6,
	"D" : 0.9745111704465614,
	"E" : -4.680083429207116E-4,
	"F" : 0.9645888465274766,
	"H" : 1.1141761233846026E-5,
	"I" : -1.0637358952569897E-6,
	"J" : -4.4427346886921626E-5,
	"K" : -0.0015957294583301973,
	"L" : 1.0044471107480462,
	"M" : -0.04975105373432598
}, {
	"A" : 9.050642422403499E-6,
	"B" : 1.6119091842181632E-5,
	"C" : -1.295484587271467E-6,
	"D" : 0.9984839451066705,
	"E" : -0.0011792662117784403,
	"F" : 0.05967319512637914,
	"H" : 1.1170329639154097E-5,
	"I" : -1.0635157644545146E-6,
	"J" : -4.44268585108043E-5,
	"K" : -0.0016447281356590793,
	"L" : 1.0044473907809959,
	"M" : -0.04631544836502144
}, {
	"A" : -1.520181668843712E-4,
	"B" : 3.047569330227873E-7,
	"C" : -1.17235583196873E-6,
	"D" : 1.024365775781746,
	"E" : 4.3787909106640654E-5,
	"F" : -0.9793651453765051,
	"H" : 1.1172639689971398E-5,
	"I" : -1.0634363385442214E-6,
	"J" : -4.4426376578088345E-5,
	"K" : -0.0016898016286859274,
	"L" : 1.0044476817298431,
	"M" : -0.04293700874586648
}, {
	"A" : 2.2022970795787522E-4,
	"B" : -1.109227404594293E-6,
	"C" : -1.7666214163769567E-6,
	"D" : 0.9639535758586817,
	"E" : 2.0139328958634906E-4,
	"F" : 1.470499957787979,
	"H" : 1.112769041156092E-5,
	"I" : -1.0638203882251673E-6,
	"J" : -4.44258953508081E-5,
	"K" : -0.0017271113176775543,
	"L" : 1.0044480106602975,
	"M" : -0.03978801699486212
}, {
	"A" : 7.286421904173501E-5,
	"B" : 1.3012770494258419E-5,
	"C" : -1.7846161693979568E-6,
	"D" : 0.9876873968109408,
	"E" : -9.817441996915477E-4,
	"F" : 0.5157857288631931,
	"H" : 1.1160518834651967E-5,
	"I" : -1.0638637932824935E-6,
	"J" : -4.442540758797797E-5,
	"K" : -0.0017770969604384845,
	"L" : 1.0044483118441292,
	"M" : -0.03603329170073266
}, {
	"A" : -9.640057676896241E-5,
	"B" : 2.8556860549588947E-6,
	"C" : -1.6746776664300356E-6,
	"D" : 1.016601211946579,
	"E" : -1.4305873881426123E-4,
	"F" : -0.7186036832208629,
	"H" : 1.1169470330196773E-5,
	"I" : -1.0638223565395677E-6,
	"J" : -4.4424924463215554E-5,
	"K" : -0.0018232861406204393,
	"L" : 1.0044486062023168,
	"M" : -0.03233984799771861
}, {
	"A" : 2.51481835022771E-4,
	"B" : 5.548470644045622E-6,
	"C" : -1.9872242427165787E-6,
	"D" : 0.9557474863496793,
	"E" : -3.63759292810073E-4,
	"F" : 1.9421119208363962,
	"H" : 1.1131653470441982E-5,
	"I" : -1.0640385409432795E-6,
	"J" : -4.442444086949493E-5,
	"K" : -0.0018612871613186144,
	"L" : 1.0044489231741096,
	"M" : -0.02891553582958295
}, {
	"A" : 7.015933455734036E-5,
	"B" : 2.104366581434647E-5,
	"C" : -1.5568104057006593E-6,
	"D" : 0.9872217308547704,
	"E" : -0.0018009197461879012,
	"F" : 0.5783824326645117,
	"H" : 1.1170155671869075E-5,
	"I" : -1.0637903099519619E-6,
	"J" : -4.4423950347094454E-5,
	"K" : -0.001912696936045677,
	"L" : 1.0044491984574364,
	"M" : -0.024812975230815937
}, {
	"A" : -1.3318283191354752E-4,
	"B" : 9.012101584993104E-6,
	"C" : -1.0134973186248786E-6,
	"D" : 1.0244647453711195,
	"E" : -7.762712216958789E-4,
	"F" : -1.1253167541726725,
	"H" : 1.1181825431916259E-5,
	"I" : -1.0634529017394811E-6,
	"J" : -4.442346527533392E-5,
	"K" : -0.001959530108877061,
	"L" : 1.0044494649026632,
	"M" : -0.02081576360433246
}, {
	"A" : 1.9043853832445556E-4,
	"B" : 7.121919457286907E-6,
	"C" : -1.088020294304215E-6,
	"D" : 0.9641882744517716,
	"E" : -6.119368580925766E-4,
	"F" : 1.6816106500773458,
	"H" : 1.114329565765626E-5,
	"I" : -1.063493373143487E-6,
	"J" : -4.442298131457356E-5,
	"K" : -0.0019969928987677577,
	"L" : 1.004449765800885,
	"M" : -0.017166504607303068
}, {
	"A" : 1.2230046873007439E-6,
	"B" : 1.6463404087119216E-5,
	"C" : -7.432647562977124E-7,
	"D" : 0.9996573751959659,
	"E" : -0.001548376162901377,
	"F" : 0.020696798092103563,
	"H" : 1.1178207013462504E-5,
	"I" : -1.0632756737294358E-6,
	"J" : -4.4422492510576284E-5,
	"K" : -0.002048219496487036,
	"L" : 1.0044500415755522,
	"M" : -0.01278300611738814
}, {
	"A" : -1.9035587322724368E-4,
	"B" : -1.521588854691558E-6,
	"C" : -6.534262311230776E-7,
	"D" : 1.0373683146475514,
	"E" : 1.7372073219235062E-4,
	"F" : -1.8344170724158175,
	"H" : 1.1185576001548903E-5,
	"I" : -1.063220562147471E-6,
	"J" : -4.442201107379695E-5,
	"K" : -0.0020943695575397214,
	"L" : 1.004450333019932,
	"M" : -0.008543782721972093
}, {
	"A" : 1.6066203035070004E-4,
	"B" : -7.520641291947072E-6,
	"C" : -1.4848607143846948E-6,
	"D" : 0.9679987000564552,
	"E" : 8.35996317732679E-4,
	"F" : 1.5909654198403587,
	"H" : 1.1146501441405832E-5,
	"I" : -1.0637610753372329E-6,
	"J" : -4.442153200900911E-5,
	"K" : -0.0021312406207130152,
	"L" : 1.0044506842623377,
	"M" : -0.0046786368438915815
}, {
	"A" : 9.023859881107654E-6,
	"B" : 7.662596626101248E-7,
	"C" : -2.0548314312307525E-6,
	"D" : 0.9982038531547914,
	"E" : 4.647397679491405E-5,
	"F" : 0.08554956866282737,
	"H" : 1.1197756505265666E-5,
	"I" : -1.0641810413991593E-6,
	"J" : -4.4421048403520125E-5,
	"K" : -0.0021861396421059,
	"L" : 1.004451024907553,
	"M" : 1.7532082711113617E-4
}, {
	"A" : -1.4506159866201074E-4,
	"B" : -1.4683876874865831E-5,
	"C" : -2.8339347202255283E-6,
	"D" : 1.0303599409540993,
	"E" : 0.0017071291936758826,
	"F" : -1.5939679169168812,
	"H" : 1.1489078079462978E-5,
	"I" : -1.0649365959070067E-6,
	"J" : -4.442057191378357E-5,
	"K" : -0.0022910572312753175,
	"L" : 1.0044514025679376,
	"M" : 0.007723218863247894
}, {
	"A" : 2.3241039402721597E-4,
	"B" : -1.5311485224156485E-5,
	"C" : -4.296758122745992E-6,
	"D" : 0.9509382559541564,
	"E" : 0.0019081104306906127,
	"F" : 2.5800398884348397,
	"H" : 1.1515173968246195E-5,
	"I" : -1.0653820419204152E-6,
	"J" : -4.442008759042437E-5,
	"K" : -0.0023445998856175265,
	"L" : 1.0044517505312314,
	"M" : 0.01288947260036366
}, {
	"A" : 9.072991430780775E-5,
	"B" : 2.244839549803146E-7,
	"C" : -5.1199678539060045E-6,
	"D" : 0.9804558178722118,
	"E" : 3.199884153559651E-4,
	"F" : 1.0414980721106986,
	"H" : 1.1169470074623433E-5,
	"I" : -1.0660013476382346E-6,
	"J" : -4.4419607325485444E-5,
	"K" : -0.0023154346745002385,
	"L" : 1.0044521194791685,
	"M" : 0.013558595735958079
}, {
	"A" : -7.343116251190551E-5,
	"B" : -7.960498911163683E-6,
	"C" : -5.7102638735262445E-6,
	"D" : 1.0162802811122447,
	"E" : 0.0012617538704375875,
	"F" : -0.9145903535718389,
	"H" : 1.1154823230663524E-5,
	"I" : -1.0664557905659677E-6,
	"J" : -4.4419128834571886E-5,
	"K" : -0.0023567801909223363,
	"L" : 1.0044524726881434,
	"M" : 0.018071183329084306
}, {
	"A" : 2.7783297289296627E-4,
	"B" : -3.073622873328574E-6,
	"C" : -6.601104343806341E-6,
	"D" : 0.9378589961521584,
	"E" : 7.941737567307428E-4,
	"F" : 3.460188129931339,
	"H" : 1.1109950638577004E-5,
	"I" : -1.067070328431008E-6,
	"J" : -4.4418648619704015E-5,
	"K" : -0.002391268873111585,
	"L" : 1.00445284558063,
	"M" : 0.0222841617778613
}, {
	"A" : 9.944502098147012E-5,
	"B" : 1.5070644903358854E-5,
	"C" : -6.608296750476583E-6,
	"D" : 0.977236572742072,
	"E" : -0.0012679432591653494,
	"F" : 1.288357800738595,
	"H" : 1.1146172931741916E-5,
	"I" : -1.0671510234372406E-6,
	"J" : -4.441816128331055E-5,
	"K" : -0.0024438865067395454,
	"L" : 1.0044531592304793,
	"M" : 0.027599369430390652
}, {
	"A" : -1.0227717758448662E-4,
	"B" : 5.929730157561153E-6,
	"C" : -6.330725376590962E-6,
	"D" : 1.0237182325496406,
	"E" : -2.586356089295805E-4,
	"F" : -1.3884701767019578,
	"H" : 1.1157393103644608E-5,
	"I" : -1.0670106702637128E-6,
	"J" : -4.4417678242480996E-5,
	"K" : -0.0024910612772828244,
	"L" : 1.0044534477706009,
	"M" : 0.03270798405537789
}, {
	"A" : 2.211732302486169E-4,
	"B" : 6.771363552982024E-6,
	"C" : -6.5063059806469425E-6,
	"D" : 0.9477991898433515,
	"E" : -3.577674769985606E-4,
	"F" : 3.0662750982883153,
	"H" : 1.111868329384258E-5,
	"I" : -1.0671181231991511E-6,
	"J" : -4.441719518877285E-5,
	"K" : -0.002526528458588473,
	"L" : 1.0044537651349117,
	"M" : 0.0372193916427932
}, {
	"A" : 3.0612448438382955E-5,
	"B" : 1.89967285895154E-5,
	"C" : -6.098674012910976E-6,
	"D" : 0.9925218726083358,
	"E" : -0.001868264927452401,
	"F" : 0.44396474806126207,
	"H" : 1.1153486718651351E-5,
	"I" : -1.0668848426931277E-6,
	"J" : -4.441670678934084E-5,
	"K" : -0.0025793121724859702,
	"L" : 1.0044540414454275,
	"M" : 0.04283972399025515
}, {
	"A" : -1.6374145760944536E-4,
	"B" : 3.690633243902397E-6,
	"C" : -5.773002604847477E-6,
	"D" : 1.039961694587987,
	"E" : -6.340938779203498E-5,
	"F" : -2.449786004581256,
	"H" : 1.115937220530494E-5,
	"I" : -1.0666764237443616E-6,
	"J" : -4.441622457029837E-5,
	"K" : -0.0026253769494246626,
	"L" : 1.0044543203353555,
	"M" : 0.04815927399249631
}, {
	"A" : 1.8369751453883865E-4,
	"B" : -1.1664105770137212E-7,
	"C" : -6.227026808192093E-6,
	"D" : 0.9545042198524243,
	"E" : 4.333958791562509E-4,
	"F" : 2.8042489520448726,
	"H" : 1.1114216068808247E-5,
	"I" : -1.0669425258846843E-6,
	"J" : -4.441574375513291E-5,
	"K" : -0.002658807859006629,
	"L" : 1.0044546575985862,
	"M" : 0.052786267164265155
}, {
	"A" : 2.7082806136835558E-5,
	"B" : 1.0151702055427592E-5,
	"C" : -6.298434771734307E-6,
	"D" : 0.9931298152026216,
	"E" : -8.554936018185799E-4,
	"F" : 0.4229948476422578,
	"H" : 1.1143683891101652E-5,
	"I" : -1.0670149169778043E-6,
	"J" : -4.4415257986818446E-5,
	"K" : -0.00271065665202741,
	"L" : 1.0044549710235913,
	"M" : 0.05863882381163421
}, {
	"A" : -1.3313708195972218E-4,
	"B" : -3.861045426045706E-6,
	"C" : -6.471844489652767E-6,
	"D" : 1.0341661594439984,
	"E" : 9.294446871876971E-4,
	"F" : -2.2048777243180666,
	"H" : 1.1147248824228129E-5,
	"I" : -1.067143969746276E-6,
	"J" : -4.441477781458314E-5,
	"K" : -0.0027561600898025063,
	"L" : 1.0044552924362904,
	"M" : 0.06419211624051968
}, {
	"A" : 2.3879032934015498E-4,
	"B" : -3.637946568879613E-6,
	"C" : -7.263818351477269E-6,
	"D" : 0.9380124158697072,
	"E" : 9.647598284345804E-4,
	"F" : 4.007948481361382,
	"H" : 1.1103355917807534E-5,
	"I" : -1.0676513907403873E-6,
	"J" : -4.441429773149874E-5,
	"K" : -0.002789323848190861,
	"L" : 1.0044556637738822,
	"M" : 0.06903246219735593
}, {
	"A" : 9.091969396513022E-5,
	"B" : 1.2264112626780843E-5,
	"C" : -7.382083040408105E-6,
	"D" : 0.9759343634588049,
	"E" : -0.00111885468214723,
	"F" : 1.5774948618854978,
	"H" : 1.113748092840261E-5,
	"I" : -1.067784055397425E-6,
	"J" : -4.4413810939336607E-5,
	"K" : -0.0028427037109395314,
	"L" : 1.0044559869496936,
	"M" : 0.07527148110966664
}, {
	"A" : -7.98785107916089E-5,
	"B" : 3.7994897961191043E-6,
	"C" : -7.26189951061329E-6,
	"D" : 1.0214188128435353,
	"E" : -1.8634794741956284E-5,
	"F" : -1.4503193104465026,
	"H" : 1.114773206678521E-5,
	"I" : -1.0677470274611522E-6,
	"J" : -4.441332814153487E-5,
	"K" : -0.002890008992494586,
	"L" : 1.004456288136737,
	"M" : 0.08121359398501227
}, {
	"A" : 2.6563251352618167E-4,
	"B" : 7.780922147482272E-6,
	"C" : -7.479868661341982E-6,
	"D" : 0.9277368550144729,
	"E" : -5.525433750790398E-4,
	"F" : 4.8996329233341385,
	"H" : 1.1110789903900908E-5,
	"I" : -1.0678903243910298E-6,
	"J" : -4.441284443812421E-5,
	"K" : -0.002924534668920842,
	"L" : 1.004456613752609,
	"M" : 0.08637962480861461
} ] ];
HGIS.Converter.minLon=75;
HGIS.Converter.minLat=18;
HGIS.Converter.maxLon=135;
HGIS.Converter.maxLat=54;
HGIS.Converter.per=2;
// 18中国范围内最小维度 75中国范围内最小经度
/*
 * APIFunction: getFactor
 * 根据经纬度获取脱密因子
 * 
 * 示例:
 * (begin code)
 * var lonlat=new HGIS.LonLat(120,30);
 * var factor=HGIS.Converter.getFactor(lonlat);
 * // => equivalent to ...
 * new HGIS.Bounds(5, 42, 10, 45);
 * (end)
 */
HGIS.Converter.getFactor = function(lonlat) {
	var lon, lat;
	if (typeof (lonlat.lon) == "undefined") {
		lon = lonlat.x;
		lat = lonlat.y;
	} else {
		lon = lonlat.lon;
		lat = lonlat.lat;
	}
	var row = Math.floor((lat - HGIS.Converter.minLat) / HGIS.Converter.per);
	var col = Math.floor((lon - HGIS.Converter.minLon) / HGIS.Converter.per);
	//超出最小行数，以最小行数为准
	if(row<0)
		row=0;
	//超出最大行数，以最大行数为准
	if(row>HGIS.Converter.Factor.length-1)
		row=HGIS.Converter.Factor.length-1;
	if(col<0){
		col=0;
	}
	//超出最大列数，以最大列数为准
	if(col>HGIS.Converter.Factor[0].length-1){
		col=HGIS.Converter.Factor[0].length-1
	}
	return HGIS.Converter.Factor[row][col];
};HGIS.Converter=HGIS.Converter||{};
HGIS.Converter.decrylon=function(x,y){
	var ret=300.0+x+2.0*y+0.1*x*x+0.1*x*y+ 0.2 * Math.sqrt(Math.abs(x));
	ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;  
    ret += (20.0 * Math.sin(y * Math.PI) + 40.0 * Math.sin(y / 3.0 * Math.PI)) * 2.0 / 3.0;  
    ret += (160.0 * Math.sin(y / 12.0 * Math.PI) + 320 * Math.sin(y * Math.PI / 30.0)) * 2.0 / 3.0;  
    return ret;
}
HGIS.Converter.decrylat=function(x,y){
	var ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));  
    ret += (20.0 * Math.sin(6.0 * x * Math.PI) + 20.0 * Math.sin(2.0 * x * Math.PI)) * 2.0 / 3.0;  
    ret += (20.0 * Math.sin(x * Math.PI) + 40.0 * Math.sin(x / 3.0 * Math.PI)) * 2.0 / 3.0;  
    ret += (150.0 * Math.sin(x / 12.0 * Math.PI) + 300.0 * Math.sin(x / 30.0 * Math.PI)) * 2.0 / 3.0;  
    return ret;  
}
HGIS.Converter.decry=function(point){
     var ee=0.00669342162296594323;
     var a = 6378245.0;  
	 var dLat = HGIS.Converter.decrylat(point.x - 105.0, point.y - 35.0);  
     var dLon = HGIS.Converter.decrylon(point.x - 105.0, point.x - 35.0);  
     var radLat = point.y / 180.0 * Math.PI;  
     var magic = Math.sin(radLat);  
     magic = 1 - ee * magic * magic;  
     var sqrtMagic =Math.sqrt(magic);  
     dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * Math.PI);  
     dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * Math.PI);  
     point.x = point.x + dLat;  
     point.y = point.y + dLon;    
}
HGIS.Converter.encry=function(point){
    var ee=0.00669342162296594323;
    var a = 6378245.0;  
	var dLat = HGIS.Converter.decrylat(point.x - 105.0, point.y - 35.0);  
    var dLon = HGIS.Converter.decrylon(point.x - 105.0, point.x - 35.0);  
    var radLat = point.y / 180.0 * Math.PI;  
    var magic = Math.sin(radLat);  
    magic = 1 - ee * magic * magic;  
    var sqrtMagic = Math.sqrt(magic);  
    dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * Math.PI);  
    dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * Math.PI);  
    point.x = point.x - dLat;  
    point.y = point.y - dLon;    
}/**
 * Class: HGIS.Data.FeatureType
 * HGIS对外提供的地础地理信息类型.
 * 基础地理信息指的是地球表层系统的实体，包括自然形成的实体如高山河流等，以及人工形成的地理实体，如道路房屋等。在计算机内以一定的数据结构表征出来，即基础地理信息。HGIS对这些地类信息进行了两级分类，父类与子类，详见XXXX.html
 */
HGIS.Data = HGIS.Data || {};
HGIS.Data.FeatureType = function(){
	var thisObj = this;
	thisObj.superType=["poi","district","road","railway","resArea","area"];
	thisObj.poi=["airport_pt","association_pt","border_port_pt","bridge_a_pt",
	                      "bridge_b_pt","building_pt","car_maintenance_pt","car_rental_pt",
	                      "car_seconde_pt","carpark_pt","carservice_pt","carstation_pt","commodity_pt",
	                      "entrance_pt","exhcenter_pt","farmers_pt","high_speed_pt","hotel_a_pt",
	                      "hotel_b_pt","industrial_pt","logistics_a_pt","logistics_b_pt","logistics_b_pt",
	                      "logistics_c_pt","mall_a_pt","mall_b_pt","motorway_service_pt","oil_pt",
	                      "park_a_pt","place_a_pt","post_pt","resarea_pt","school_university_a_pt",
	                      "sight_a_pt","sight_b_pt","stores_a_pt","stores_b_pt","supermarket_pt",
	                      "toll_pt","town_a_pt","town_b_pt","town_c_pt","town_d_pt","trastation_a_pt",
	                      "trastation_b_pt","vehicle_detection_pt","business_pt","antique_pt","atm_pt",
	                      "baby_pt","bank_pt","barber_pt","bicycle_pt","bread_pt","buspark_pt","clothing_pt",
	                      "coffee_pt_pt","community_hospital_pt","company_pt","computer_pt","convenience_pt",
	                      "cosmetics_pt","county_pt","cultural_pt","dental_pt","epidemic_pt","flowers_pt","food_bar_pt",
	                      "food_china_pt","food_fast_pt","food_west_pt","garden_pt","government_pt","handicraft_pt",
	                      "home_improvement_pt","hospital_a_pt","hospital_b_pt","hotel_c_pt","insurance_pt",
	                      "ktv_pt","laundry_pt","library_pt","light_pt","lotterystation_pt","mobile_pt","mountain_pt",
	                      "museum_a_pt","museum_b_pt","other_pt","other_rental_pt","paper_pt","park_b_pt","pet_hospital_pt",
	                      "pet_pt","pill_pt","police_pt","retail_pt","school_pt","scientific_pt","securities_pt","sports_pt",
	                      "square_pt","stadium_a_pt","stadium_b_pt","tea_pt","ticket_pt","training_pt","travel_pt","tv_station_pt",
	                      "video_pt","village_committee_pt","wc_pt","wharf_pt","zoo_pt"];
	thisObj.road=["oneroad_ln","tworoad_ln","threeroad_a_ln","threeroad_ln","ringroad_one_ln","ringroad_two_ln","ferry_ln",
	           "Ic_Oneroad_Ln","IC_TwoRoad_ln"];
	thisObj.railway=["Railway_A_ln","Railway_B_ln"];
	thisObj.district=["town_pg"];
	thisObj.resArea=["Vegetation_A_pg","Vegetation_B_pg","School_University_pg","Hospital_pg","Sight_pg","Traffic_Hub_pg","House_pg"];
	thisObj.area=["resarea_pg"];

	/**
	 * APIMethod: getAllSuperType
	 * 获取所有的父类型
	 * 
	 * Parameters:
	 * 
	 * 		无
	 * 
	 * Returns:
	 * 
	 * 		{Array<{String}>} 包含所有地理要素父类型的字符串数组
	 * 
	 */
	this.getAllSuperType = function(){
		return thisObj.superType;
	}

	/**
	 * APIMethod: getSuperTypeBySubType
	 * 根据子类型获取父类型
	 * 
	 * Parameters:
	 * 
	 * subType - {String} 子类型
	 * 
	 * Returns:
	 * 
	 * {String|null} -  子类型所属的父类型.如果没有找到父类型则返回null
	 * 
	 */
	this.getSuperTypeBySubType = function(subType){
		if(this.contains(thisObj.poi,subType))
			return "poi";
		else if(this.contains(thisObj.district,subType))
			return "district";
		else if(this.contains(thisObj.road,subType))
			return "road";
		else if(this.contains(thisObj.resArea,subType))
			return "resArea";
		else if(this.contains(thisObj.area,subType))
			return "area";
		else if(this.contains(thisObj.railway,subType))
			return "railway";
		else
			return null;
	}


	/**
	 * APIMethod: getSubTypeBySuperType
	 * 获取父类型下属的子类型
	 * 
	 * Parameters:
	 * superType - {String} 父类型
	 * 
	 * Returns:
	 * {Array<{String}>|null} - 子类型数组，如果没有找到则返回null
	 * 
	 * 
	 */
	this.getSubTypeBySuperType = function(superType){
		if(superType=="poi")
			return thisObj.poi;
		else if(superType=="district")
			return thisObj.district;
		else if(superType=="road")
			return thisObj.road;
		else if(superType=="resArea")
			return thisObj.resArea;
		else if(superType=="railway")
			return thisObj.railway;
		else if(superType=="area")
			return thisObj.area;
		else
			return null;
	}
	/**
	 * APIMethod: buildQueryFeatureType
	 * 构建查询条件
	 * 
	 * Parameters:
	 * filter - {String} 过滤条件,取值如下：
	 * * "all"      构建查询所有类型的条件
	 * * "poi"      构建查询所有poi的条件
	 * * "road"     构建查询所有road的条件
	 * * "railway"  构建查询所有railway的条件
	 * * "district" 构建查询所有district的条件
	 * * "resArea"  构建查询所有resArea的条件
	 * * "area"     构建查询所有area的条件
	 * 
	 * Returns:
	 * {Array<{Object}>} - 包含superType的查询条件数组
	 */
	this.buildQueryFeatureType=function(filter){
		var arr=[]
		if(filter=="all"){
			arr=[
			  {"superType": "poi"},
			  {"superType": "road"},
			  {"superType": "railway"},
			  {"superType": "district"},
			  {"superType": "resArea"},
			  {"superType": "area"}
			];
		}else if(filter=="poi"){
			arr=[
				  {"superType": "poi"}
				];
		}else if(filter=="road"){
			arr=[
				  {"superType": "road"}
				];
		}else if(filter=="railway"){
			arr=[
				  {"superType": "railway"}
				];
		}
		else if(filter=="district"){
			arr= [
				  {"superType": "district"}
				];
		}
		else if(filter=="resArea"){
			arr=[
			  {"superType": "resArea"}
			];
		}else if(filter=="area"){
			arr=[
				  {"superType": "area"}
				];
		}else{
			arr=[];
		}
		return arr;
		
	}
	
	this.contains=function (arr, obj) {  
	    var i = arr.length;  
	    while (i--) {  
	        if (arr[i] === obj) {  
	            return true;  
	        }  
	    }  
	    return false;  
	}  
	
};
/**
 * HGIS.Feature.Graphic
 * 矢量图形对象
 * 
 * Examples:
 * 
 * (code)
 * var g=new HGIS.Feature.Graphic(geometry,symbol,attributes,infoTemplate);
 * layer.add(g);
 * (end)
 */
HGIS.Feature = HGIS.Feature || {};
HGIS.Feature.Graphic = HGIS
		.Class({
			/**
			 * Property: id
			 * 对象id
			 */
			id : null,
			/**
			 * Property: layer
			 * 对象图层
			 */
			layer : null,
			/**
			 * Property: attributes
			 * 对象属性
			 */
			attributes : null,
			/**
			 * Property: geometry
			 * 对象集合图形
			 */
			geometry : null,
			/**
			 * Property: infoTemplate
			 * 对象info模板
			 */
			infoTemplate : null,
			/**
			 * Property: symbol
			 * 显示的样式
			 */
			symbol : null,
			/**
			 * Property: visible
			 * 可见性
			 */
			visible : true,
			events : null,
			_olObject : null,
			mouseOverStats : false,
			initialize : function(geometry, symbol, attributes, infoTemplate) {
				this.attributes = attributes;
				this.geometry = geometry;
				this.infoTemplate = infoTemplate;
				this.symbol = symbol;
				this.events = {
					click : [],
					mouseOver : [],
					mouseOut : [],
					doubleClick : []
				};
			},
			getLayer : function() {

			},
			
			/**
			 * Method: destroyOlObject
			 */
			destroyOlObject : function() {
				if (this._olObject !== null) {
					this._olObject.destroy();
					this._olObject = null;
				}

			},
			hide : function() {

			},
			/**
			 * Method: refresh
			 * 更新graphic
			 */
			refresh : function() {
				if (this.layer === null || this.layer.map === null) {
					return;
				}
				thisMovie(this.layer.map.id).updateGraphic(this.toJson(),
						this.layer.toJson());
			},
			/**
			 * Method: updateLevel
			 * 更新graphic的显示顺序.
			 * level 表示顺序 0表示最下面， -1 表示最上面
			 */
			updateLevel : function(level) {
				if (this.layer === null || this.layer.map === null) {
					return;
				}
				if (level == null || level == undefined) {
					level = -1;
				}
				thisMovie(this.layer.map.id).updateLevel(this.toJson(),
						this.layer.toJson(), level);
			},
			/**
			 * Method: setAttributes
			 * 设置graphic的属性参数
			 */
			setAttributes : function(attributes) {
				this.attributes = attributes;
			},
			/**
			 * Method: setGeometry
			 * 设置graphic的坐标
			 */
			setGeometry : function(geometry) {
				this.geometry = geometry;
			},

			setInfoTemplate : function(infoTemplate) {

			},
			/**
			 * Method: setSymbol
			 * 设置样式
			 */
			setSymbol : function(symbol) {
				this.symbol = symbol;
			},

			/**
			 * Method: show
			 * 设置可见性为true
			 */
			show : function() {
				this.visible = true;
			},
			/**
			 * Method: addEventListener
			 * 添加监听程序
			 * 
			 * Parameters:
			 * eventType: - {String} 时间类型 （'click'点击事件、'mouseOver'鼠标移动到上面事件、'mouseOut'鼠标移除事件、"doubleClick"鼠标双击时间）
			 * functionName - {Object} 响应函数
			 */
			addEventListener : function(eventType, functionName) {
				if (this.events[eventType] === null) {
					return 0;
				}
				for (var i = 0; i < this.events[eventType].length; i++) {
					if (this.events[eventType][i] === functionName) {
						// alert("函数已注册" + this.id);
						return 0;
					}
				}
				this.events[eventType].push(functionName);
				if (this.layer == null || this.layer.map == null) {
					return;
				}
				var eventObj = {
					type : "graphic",
					id : this.id,
					layerId : this.layer.id,
					eventType : eventType
				};

				thisMovie(this.layer.map.id).addJSEventListener(eventObj);
			},

			/**
			 * Method: toJson
			 * 对象序列化为json
			 */
			toJson : function() {
				var json = {
					id : this.id,
					visible : this.visible
				};
				if (this.geometry) {
					json.geometry = this.geometry.toJson();
				}
				if (this.attributes) {
					json.attributes = HGIS.Util.extend({}, this.attributes);
				}
				// if(this.layer){
				// json.layer=this.layer.toJson();
				// }
				if (this.symbol) {
					json.symbol = this.symbol.toJson();
				}
				if (this.infoTemplate) {
					json.infoTemplate = this.infoTemplate.toJson();
				}
				var eventsLi = [];
				for ( var name in this.events) {
					if (this.events[name].length > 0) {
						eventsLi.push(name);
					}
				}
				json.events = eventsLi;
				return json;
			},
			getOlObject : function() { // 获取可叠加到地图上的features对象
				if (this._olObject == null) {
					this._olObject = new HGIS.Feature.Vector(this.geometry,
							this.attributes);

					this._olObject.style = this._getStyleBySymbol();

					this._olObject.events = this.events;
				}
				return this._olObject;
			},
			_getStyleBySymbol : function(symbol) { // 获取图层样式
				symbol = symbol ? symbol : this.symbol;
				var style = new Object();
				if (symbol.type == "simplelinesymbol") {
					style["stroke"] = true;
					style["strokeColor"] = this._getColor(symbol.color)
							|| "#0000ff";
					style["strokeOpacity"] = symbol.color.a;
					style["strokeWidth"] = symbol.width || 1;
					style["strokeDashstyle"] = symbol.style || 'solid';
					style["cursor"] = symbol.cursor || '';
					if (symbol.endArrow) {
						style["endArrow"] = true;
					}
				} else if (symbol.type == "picturemarkersymbol") {
					style["externalGraphic"] = symbol.url;
					style["graphicWidth"] = symbol.width || 28;
					// style["graphicWidth"] = 28;
					style["graphicHeight"] = symbol.height || 30;
					// style["graphicHeight"] = 34;
					style["rotation"] = symbol.angle || 0;
					style["graphicXOffset"] = symbol.xoffset || 0;
					// style["graphicXOffset"] = 0;
					style["graphicYOffset"] = symbol.yoffset || 0;
					// style["graphicYOffset"] = 0;

					style["stroke"] = false;
					if (typeof (symbol.outline) === "object") {
						style["stroke"] = true;
						style["strokeColor"] = this
								._getColor(symbol.outline.color)
								|| "#000000";
						style["strokeOpacity"] = symbol.outline.color.a
						style["strokeWidth"] = symbol.outline.width;
						style["strokeDashstyle"] = symbol.outline.style
								|| 'solid';
					}
				} else if (symbol.type == "compositesymbol") {
					for ( var i in symbol.symbols) {
						HGIS.Util.extend(style, this
								._getStyleBySymbol(symbol.symbols[i]));
					}
				} else if (symbol.type == "textsymbol") {
					style["fill"] = false;
					style["label"] = symbol.text || '';
					style["rotation"] = symbol.angle || 0;
					style["labelXOffset"] = symbol.xoffset || 0;
					style["labelYOffset"] = symbol.yoffset || 0;
					style["labelAlign"] = {
						'middle' : 'cm',
						'start' : 'lm',
						'above' : 'ct',
						'below' : 'cb',
						'end' : 'rm'
					}[symbol.placement] || 'cm';
					if (symbol.borderLineColor) {
						style["labelOutlineColor"] = this
								._getColor(symbol.borderLineColor);
					}
					if (symbol.color) {
						style["fontColor"] = this._getColor(symbol.color)
								|| "#000000";
					}
					if (symbol.font) {
						style["fontSize"] = symbol.font.size;
						style["fontWeight"] = symbol.font.weight;
						style["fontStyle"] = symbol.font.style;
						style["fontFamily"] = symbol.font.family;
					}
					if (symbol.backgroundColor) {
						style["backgroundColor"] = this
								._getColor(symbol.backgroundColor)
								|| "#FFFFFF";
					}
				} else if (symbol.type == "simplemarkersymbol"
						|| symbol.type == "simplefillsymbol") {// 
					style["fillColor"] = this._getColor(symbol.color);
					style["fillOpacity"] = symbol.color.a;
					style["rotation"] = symbol.angle || 0;
					style["pointRadius"] = symbol.size || 12;
					style["labelXOffset"] = symbol.xoffset || 0;
					style["labelYOffset"] = symbol.yoffset || 0;
					style["graphicName"] = symbol.style;
					style["stroke"] = false;
					style["cursor"] = symbol.cursor || '';
					if (typeof (symbol.outline) === "object"
							&& symbol.outline != null) {
						style["stroke"] = true;
						style["strokeColor"] = this
								._getColor(symbol.outline.color)
								|| "#000000";
						style["strokeOpacity"] = symbol.outline.color.a;
						style["strokeWidth"] = symbol.outline.width;
						style["strokeDashstyle"] = symbol.outline.style
								|| 'solid';
					}
				}
				return style;
			},
			_getColor : function(color) {
				return "#" + this.toString16(color.r)
						+ this.toString16(color.g) + this.toString16(color.b);
			},
			toString16 : function(num) { // 转换为16进制字符串
				var str = num.toString(16);
				while (str.length < 2) {
					str = "0" + str;
				}
				return str;
			},
			CLASS_NAME : 'HGIS.Feature.Graphic'
		});/* Copyright (c) 2006-2012 by HGIS Contributors (see authors.txt for 
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS.Format.OSM
 */
//
// HGIS patches to support XMLHttpRequest 2 'arraybuffer' responseType
//
 
var xhrSendOrig = HGIS.Request.XMLHttpRequest.prototype.send;
HGIS.Request.XMLHttpRequest.prototype.send = function(vData) {
   this._object.responseType = 'arraybuffer';
   xhrSendOrig.apply(this, arguments);
};

var httpParseFeaturesOrig = HGIS.Protocol.HTTP.prototype.parseFeatures;
HGIS.Protocol.HTTP.prototype.parseFeatures = function(request) {
    if (!request._object.response) {
        return httpParseFeaturesOrig.apply(this, arguments);
    } else {
        return this.format.read(request._object.response);
    }
};

var httpHandleResponseOrig = HGIS.Protocol.HTTP.prototype.handleResponse;
HGIS.Protocol.HTTP.prototype.handleResponse = function(resp, options) {
  // local files (file:/// URL) may return response status 0
  if (resp.priv.status === 0) {
      resp.priv.status = 200;
      resp.priv._object.status = 200;
  }
  httpHandleResponseOrig.apply(this, arguments);
};

//
// HGIS patches for performance optimization (no string parsing, already got number)
//

// replacing initialize seems not to work?
//HGIS.Geometry.Point.prototype.initialize = function(x, y) {
HGIS.Geometry.PbfPoint = HGIS.Class(HGIS.Geometry.Point, {
    initialize: function(x, y) {
        // replaces HGIS.Geometry.Point initialize > skip

        // optimize HGIS.Geometry initialize > skip
        HGIS.Util.lastSeqID += 1; 
        this.id = "HGIS_Geometry_Point_" + HGIS.Util.lastSeqID;        
    
        // assume both of same type for better performance
        if (typeof x === 'number') {
            this.x = x;
            this.y = y;
        } else {
            this.x = parseFloat(x);
            this.y = parseFloat(y);
        }
    }
});

//HGIS.Geometry.OsmPoint = HGIS.Class(HGIS.Geometry.Point, {
//osm_id: null
//});



/**
 * Class: HGIS.Format.PBF
 *
 * Simple support to read the binary OSM PBF format.
 *
 * NOTE: EXPERIMENTAL!
 *
 * Inherits from:
 *  - <HGIS.Format>
 */
HGIS.Format.PBF = HGIS.Class(HGIS.Format.OSM, { //HGIS.Format, {
    //checkTags: false,
    initialize: function(options) {
        options = options || {};
        // OSM coordinates are always in longlat WGS84
        //this.externalProjection = new HGIS.Projection("EPSG:4326");
        //HGIS.Format.prototype.initialize.apply(this, arguments);
        HGIS.Format.OSM.prototype.initialize.apply(this, arguments);
    }, 
    
    read: function(buffer) {
    	//var startTime=new Date().getTime();
        var pbf = new Pbf(buffer); //解析pbf
        var tile = Tile.read(pbf);
//        var w=new Worker("../../../../gisapi/extension/HGIS/Format/worker.js");
//        w.postMessage(tile);
//        w.onmessage = function (event) {
//        	return event.data;
//        };
        //return;
        //构建featureList
        var feat_list = [];
        if (tile != null && tile.layers != null) {
            var len = tile.layers.length;
            for (var i = 0; i < len; i++) {
                var f = tile.layers[i].features;             
                for (var j = 0; j < f.length; j++) {               		    
                	this.d(f[j],tile.layers[i]);
                    feat_list.push(f[j]);
                }
            }
        }
        //var endTime=new Date().getTime();
        //console.log("解码耗时:"+(endTime-startTime)/1000+"秒");
        return feat_list;
    },
    d:function(feature,info){
      var tags = feature.tags;
      var attributes = {};
      for (var k = 0; k < tags.length / 2; k++) {
          var key = info.keys[tags[2 * k]];
          var value = info.values[tags[2 * k + 1]].string_value;
          attributes[key] = value;
      }
      feature["attributes"] = attributes;
      feature["origin"]=info.geolt;
      //this.formatFeatureId(feature);
      feature.destroy=function(){};
      this.decode(feature);
    },
    formatFeatureId:function(feature){
        var c=feature["origin"].split("-")[0];
        var r=feature["origin"].split("-")[1];
        var cl=c.length;
		var rl=r.length;
		if(cl<6){
			for(var i=0;i<6-cl;i++){
				c="0"+c;
			}
		}else if(cl>6){
			c=c.substring(cl-6);
		}
		if(rl<6){
			for(var j=0;j<6-rl;j++){
				r="0"+r;
			}
		}else if(rl>6){
			r=r.substring(rl-6);
		}
		feature["id"]="1"+c+r+feature["id"];
    },
  //解码执行指令
	decodeCommandType : function(commandInteger) {
		return commandInteger & 0x7;
	},
	//解码执行次数
	decodeCount : function(commandInteger) {
		return commandInteger >> 3;
	},
	//解码参数指令
	decodeParameterInteger : function(coord) {
		return ((coord >> 1) ^ (-(coord & 1)));
	},
    decode:function(feature){
		if (feature.type == 3) {//绘制面
			this.decodePolygon(feature);
		}else if (feature.type == 2) {
            this.decodePolyLine(feature);
		} else if (feature.type == 1) {
            this.decodePoint(feature);
		} else {//不被支持的几何体
			return;
		}
    },
    clone:function(obj) {
        var out = [],i = 0,len = obj.length;
        for (; i < len; i++) {
            if (obj[i] instanceof Array){
                out[i] = deepcopy(obj[i]);
            }
            else out[i] = obj[i];
        }
        return out;
    },
    decodePoint:function(feature){
    	var i = 0, commandType = 0, count = 1, coordX = 0, coordY = 0;
    	var geoArr=[];
    	var geometry=feature.geometry;
    	var geomLen = geometry.length;
    	HGIS.Matrix.init();
        while (i < geomLen) {//遍历画点
            //执行指令解析
            var cmdInteger = geometry[i];
            var cmdType = this.decodeCommandType(cmdInteger);
            var count = this.decodeCount(cmdInteger);
            //参数指令解析
            for (var j = i + 1; j < i + 1 + count * 2; j = j + 2) {
                coordX = this.decodeParameterInteger(geometry[j]);
                coordY = this.decodeParameterInteger(geometry[j + 1]);
                geoArr.push(coordX);
                geoArr.push(coordY);
//                if(geoStr!="")
//                	geoStr=geoStr+",";
//                geoStr=geoStr+coordX+","+coordY+",";
            	HGIS.Matrix.move(coordX,coordY);
            }
            i = i + 1 + 2 * count;
        }
        feature["attributes"]["hashcode"]=HGIS.Matrix.m;
        //feature.geoStr=geoArr;
        feature.geometry = geoArr;
    },
    decodePolyLine : function(feature){
    	var lineGeom=feature.geometry;
        //计数器，执行指令类型，执行次数，地理坐标
        var i = 0, commandType = 0, count = 1, coordX = 0, coordY = 0;
        var prePointX = 0;
        var prePointY = 0;
        var geomLen = lineGeom.length;
        var geoArr=[];
        HGIS.Matrix.init();
        while (i < geomLen) {
            var cmdInteger = lineGeom[i];
            var cmdType = this.decodeCommandType(cmdInteger);
            var count = this.decodeCount(cmdInteger);
            if (cmdType == 1) {
            	if(geoArr.lentgh>0){
            		geoArr.push("|");
            		geoArr.push("|");
            	}
                for ( j = 0; j < count; j = j + 2) {
                    var index = j + i + 1;
                    var pixelX = this.decodeParameterInteger(lineGeom[index]) + prePointX;
                    var pixelY = this.decodeParameterInteger(lineGeom[index + 1]) + prePointY;
                    prePointX = pixelX;
                    prePointY = pixelY;
                    geoArr.push(pixelX);
                    geoArr.push(pixelY);
                    //geoStr=geoStr+pixelX+","+pixelY+",";
                }
                //索引后移count*2位
                i = i + count * 2 + 1;
            } else if (cmdType == 2) {
                //坐标的最大索引、最小索引
                var maxIndex = count * 2 + i, minIndex = i + 1;
                for (var k = minIndex; k < maxIndex; k = k + 2) {
                    var pixelX = this.decodeParameterInteger(lineGeom[k]) + prePointX;
                    var pixelY = this.decodeParameterInteger(lineGeom[k + 1]) + prePointY;
                    HGIS.Matrix.line(prePointX,prePointY,pixelX,pixelY);
                    prePointX = pixelX;
                    prePointY = pixelY;
                    geoArr.push(pixelX);
                    geoArr.push(pixelY);
                    //geoStr=geoStr+pixelX+","+pixelY+",";
                }
                i = i + count * 2 + 1;
            }
        }
        feature["attributes"]["hashcode"]=HGIS.Matrix.m;
        //feature.geoStr=geoArr;
        feature.geometry = geoArr;
    },
    decodePolygon: function(feature){
    	var lineGeom=feature.geometry;
        //计数器，执行指令类型，执行次数，地理坐标
        var i = 0, commandType = 0, count = 1, coordX = 0, coordY = 0;
        var prePointX = 0;
        var prePointY = 0;
        var geomLen = lineGeom.length;
        var geoArr=[];
        HGIS.Matrix.init();
        while (i < geomLen) {
            var cmdInteger = lineGeom[i];
            var cmdType = this.decodeCommandType(cmdInteger);
            var count = this.decodeCount(cmdInteger);
            if (cmdType == 1) {
            	if(geoArr.lentgh>0){
            		geoArr.push("|");
            		geoArr.push("|");
            	}
                for ( j = 0; j < count; j = j + 2) {
                    var index = j + i + 1;
                    var pixelX = this.decodeParameterInteger(lineGeom[index]) + prePointX;
                    var pixelY = this.decodeParameterInteger(lineGeom[index + 1]) + prePointY;
                    prePointX = pixelX;
                    prePointY = pixelY;
                    geoArr.push(pixelX);
                    geoArr.push(pixelY);
                    //geoStr=geoStr+pixelX+","+pixelY+",";
                }
                //索引后移count*2位
                i = i + count * 2 + 1;
            } else if (cmdType == 2) {
                //坐标的最大索引、最小索引
                var maxIndex = count * 2 + i, minIndex = i + 1;
                for (var k = minIndex; k < maxIndex; k = k + 2) {
                    var pixelX = this.decodeParameterInteger(lineGeom[k]) + prePointX;
                    var pixelY = this.decodeParameterInteger(lineGeom[k + 1]) + prePointY;
                    HGIS.Matrix.line(prePointX,prePointY,pixelX,pixelY);
                    prePointX = pixelX;
                    prePointY = pixelY;
                    geoArr.push(pixelX);
                    geoArr.push(pixelY);
                    //geoStr=geoStr+pixelX+","+pixelY+",";
                }
                i = i + count * 2 + 1;
            }else if (cmdType == 7) {//闭合
				count = 0;
				HGIS.Matrix.fill();
				i = i + count * 2 + 1;
			}
        }
        feature["attributes"]["hashcode"]=HGIS.Matrix.m;
        //feature.geoStr=geoArr;
        feature.geometry = geoArr;
    },

    //isWayArea: HGIS.Format.OSM.prototype.isWayArea,
    
    CLASS_NAME: "HGIS.Format.PBF" 
});    
    /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var Pbf=__webpack_require__(1);
var Tile=__webpack_require__(3);
window.Pbf=Pbf;
window.Tile=Tile.Tile;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Pbf;

var ieee754 = __webpack_require__(2);

function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            this.type = val & 0x7;
            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function(isSigned) {
        var buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;
        b = buf[this.pos];   val |= (b & 0x0f) << 28;

        return readVarintRemainder(val, isSigned, this);
    },

    readVarint64: function() { // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = readUtf8(this.buf, this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function(arr, isSigned) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readVarint(isSigned));
        return arr;
    },
    readPackedSVarint: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(l, s, p) {
    var buf = p.buf,
        h, b;

    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ?
    pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return ((high >>> 0) * 0x100000000) + (low >>> 0);
}

function writeBigVarint(val, pbf) {
    var low, high;

    if (val >= 0) {
        low  = (val % 0x100000000) | 0;
        high = (val / 0x100000000) | 0;
    } else {
        low  = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = (low + 1) | 0;
        } else {
            low = 0;
            high = (high + 1) | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos]   = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen =
        len <= 0x3fff ? 1 :
            len <= 0x1fffff ? 2 :
                len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
}

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] * 0x1000000);
}

function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = (val >>> 8);
    buf[pos + 2] = (val >>> 16);
    buf[pos + 3] = (val >>> 24);
}

function readInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
    var str = '';
    var i = pos;

    while (i < end) {
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence =
            b0 > 0xEF ? 4 :
                b0 > 0xDF ? 3 :
                    b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) break;

        var b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;

        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || (i + 1 === str.length)) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}


/***/ }),
/* 2 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

var Tile = exports.Tile = {};
Tile.read = function (pbf, end) {
    return pbf.readFields(Tile._readField, {layers: []}, end);
};
Tile._readField = function (tag, obj, pbf) {
    if (tag === 3) obj.layers.push(Tile.Layer.read(pbf, pbf.readVarint() + pbf.pos));
};
Tile.write = function (obj, pbf) {
    if (obj.layers) for (var i = 0; i < obj.layers.length; i++) pbf.writeMessage(3, Tile.Layer.write, obj.layers[i]);
};

Tile.GeomType = {
    "UNKNOWN": 0,
    "POINT": 1,
    "LINESTRING": 2,
    "POLYGON": 3
};

// Tile.Value ========================================

Tile.Value = {};

Tile.Value.read = function (pbf, end) {
    return pbf.readFields(Tile.Value._readField, {string_value: "", float_value: 0, double_value: 0, int_value: 0, uint_value: 0, sint_value: 0, bool_value: false}, end);
};
Tile.Value._readField = function (tag, obj, pbf) {
    if (tag === 1) obj.string_value = pbf.readString();
    else if (tag === 2) obj.float_value = pbf.readFloat();
    else if (tag === 3) obj.double_value = pbf.readDouble();
    else if (tag === 4) obj.int_value = pbf.readVarint(true);
    else if (tag === 5) obj.uint_value = pbf.readVarint();
    else if (tag === 6) obj.sint_value = pbf.readSVarint();
    else if (tag === 7) obj.bool_value = pbf.readBoolean();
};
Tile.Value.write = function (obj, pbf) {
    if (obj.string_value) pbf.writeStringField(1, obj.string_value);
    if (obj.float_value) pbf.writeFloatField(2, obj.float_value);
    if (obj.double_value) pbf.writeDoubleField(3, obj.double_value);
    if (obj.int_value) pbf.writeVarintField(4, obj.int_value);
    if (obj.uint_value) pbf.writeVarintField(5, obj.uint_value);
    if (obj.sint_value) pbf.writeSVarintField(6, obj.sint_value);
    if (obj.bool_value) pbf.writeBooleanField(7, obj.bool_value);
};

// Tile.Feature ========================================

Tile.Feature = {};

Tile.Feature.read = function (pbf, end) {
    return pbf.readFields(Tile.Feature._readField, {id: 0, tags: [], type: 0, geometry: []}, end);
};
Tile.Feature._readField = function (tag, obj, pbf) {
    if (tag === 1) obj.id = pbf.readVarint();
    else if (tag === 2) pbf.readPackedVarint(obj.tags);
    else if (tag === 3) obj.type = pbf.readVarint();
    else if (tag === 4) pbf.readPackedVarint(obj.geometry);
};
Tile.Feature.write = function (obj, pbf) {
    if (obj.id) pbf.writeVarintField(1, obj.id);
    if (obj.tags) pbf.writePackedVarint(2, obj.tags);
    if (obj.type) pbf.writeVarintField(3, obj.type);
    if (obj.geometry) pbf.writePackedVarint(4, obj.geometry);
};

// Tile.Layer ========================================

Tile.Layer = {};

Tile.Layer.read = function (pbf, end) {
    return pbf.readFields(Tile.Layer._readField, {version: 1, name: "", features: [], keys: [], values: [], extent: 4096}, end);
};
Tile.Layer._readField = function (tag, obj, pbf) {
    if (tag === 15) obj.version = pbf.readVarint();
    else if (tag === 1) obj.name = pbf.readString();
    else if (tag === 2) obj.features.push(Tile.Feature.read(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 3) obj.keys.push(pbf.readString());
    else if (tag === 4) obj.values.push(Tile.Value.read(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 5) obj.extent = pbf.readVarint();
    else if (tag === 8) obj.geolt =pbf.readString();
};
Tile.Layer.write = function (obj, pbf) {
    if (obj.version != undefined && obj.version !== 1) pbf.writeVarintField(15, obj.version);
    if (obj.name) pbf.writeStringField(1, obj.name);
    if (obj.features) for (var i = 0; i < obj.features.length; i++) pbf.writeMessage(2, Tile.Feature.write, obj.features[i]);
    if (obj.keys) for (i = 0; i < obj.keys.length; i++) pbf.writeStringField(3, obj.keys[i]);
    if (obj.values) for (i = 0; i < obj.values.length; i++) pbf.writeMessage(4, Tile.Value.write, obj.values[i]);
    if (obj.extent != undefined && obj.extent !== 4096) pbf.writeVarintField(5, obj.extent);
    if (obj.geolt) pbf.writeStringField(8, obj.geolt);
};

/***/ })
/******/ ]);/**
 *  未使用webworker
 */
//onmessage =function(event) {
//	var tile=event.data;
//	var feat_list = [];
//    if (tile != null && tile.layers != null) {
//        var len = tile.layers.length;
//        for (var i = 0; i < len; i++) {
//            var f = tile.layers[i].features;             
//            for (var j = 0; j < f.length; j++) {               		    
//                var tags = f[j].tags;
//                var attributes = {};
//                for (var k = 0; k < tags.length / 2; k++) {
//                    var key = tile.layers[i].keys[tags[2 * k]];
//                    var value = tile.layers[i].values[tags[2 * k + 1]].string_value;
//                    attributes[key] = value;
//                }
//                f[j]["attributes"] = attributes;
//                f[j]["origin"]=tile.layers[i].geolt;
//                decode(f[j]);
//                feat_list.push(f[j]);
//            }
//        }
//    }
//    //此方法存在问题
//    postMessage(feat_list);
//};
//解码执行指令
function decodeCommandType(commandInteger) {
	return commandInteger & 0x7;
};
//解码执行次数
function decodeCount(commandInteger) {
	return commandInteger >> 3;
};
//解码参数指令
function decodeParameterInteger(coord) {
	return ((coord >> 1) ^ (-(coord & 1)));
};
function decode(feature){
	if (feature.type == 3) {//绘制面
		decodePolygon(feature);
	}else if (feature.type == 2) {
        decodePolyLine(feature);
	} else if (feature.type == 1) {
        decodePoint(feature);
	} else {//不被支持的几何体
		return;
	}
};
function decodePoint(feature){
	var i = 0, commandType = 0, count = 1, coordX = 0, coordY = 0;
	var geoArr=[];
	var geometry=feature.geometry;
	var geomLen = geometry.length;
	//HGIS.Matrix.init();
    while (i < geomLen) {//遍历画点
        //执行指令解析
        var cmdInteger = geometry[i];
        var cmdType = decodeCommandType(cmdInteger);
        var count = decodeCount(cmdInteger);
        //参数指令解析
        for (var j = i + 1; j < i + 1 + count * 2; j = j + 2) {
            coordX = decodeParameterInteger(geometry[j]);
            coordY = decodeParameterInteger(geometry[j + 1]);
            geoArr.push(coordX);
            geoArr.push(coordY);
        	//HGIS.Matrix.move(coordX,coordY);
        }
        i = i + 1 + 2 * count;
    }
    //feature["attributes"]["hashcode"]=HGIS.Matrix.m;
    feature.geoStr=geoArr;
};
function decodePolyLine(feature){
	var lineGeom=feature.geometry;
    //计数器，执行指令类型，执行次数，地理坐标
    var i = 0, commandType = 0, count = 1, coordX = 0, coordY = 0;
    var prePointX = 0;
    var prePointY = 0;
    var geomLen = lineGeom.length;
    var geoArr=[];
    //HGIS.Matrix.init();
    while (i < geomLen) {
        var cmdInteger = lineGeom[i];
        var cmdType = decodeCommandType(cmdInteger);
        var count = decodeCount(cmdInteger);
        if (cmdType == 1) {
        	if(geoArr.lentgh>0){
        		geoArr.push("|");
        		geoArr.push("|");
        	}
            for ( j = 0; j < count; j = j + 2) {
                var index = j + i + 1;
                var pixelX = decodeParameterInteger(lineGeom[index]) + prePointX;
                var pixelY = decodeParameterInteger(lineGeom[index + 1]) + prePointY;
                prePointX = pixelX;
                prePointY = pixelY;
                geoArr.push(pixelX);
                geoArr.push(pixelY);
            }
            //索引后移count*2位
            i = i + count * 2 + 1;
        } else if (cmdType == 2) {
            //坐标的最大索引、最小索引
            var maxIndex = count * 2 + i, minIndex = i + 1;
            for (var k = minIndex; k < maxIndex; k = k + 2) {
                var pixelX = decodeParameterInteger(lineGeom[k]) + prePointX;
                var pixelY =decodeParameterInteger(lineGeom[k + 1]) + prePointY;
                //HGIS.Matrix.line(prePointX,prePointY,pixelX,pixelY);
                prePointX = pixelX;
                prePointY = pixelY;
                geoArr.push(pixelX);
                geoArr.push(pixelY);
            }
            i = i + count * 2 + 1;
        }
    }
    //feature["attributes"]["hashcode"]=HGIS.Matrix.m;
    feature.geoStr=geoArr;
};
function decodePolygon(feature){
	var lineGeom=feature.geometry;
    //计数器，执行指令类型，执行次数，地理坐标
    var i = 0, commandType = 0, count = 1, coordX = 0, coordY = 0;
    var prePointX = 0;
    var prePointY = 0;
    var geomLen = lineGeom.length;
    var geoArr=[];
   // HGIS.Matrix.init();
    while (i < geomLen) {
        var cmdInteger = lineGeom[i];
        var cmdType = decodeCommandType(cmdInteger);
        var count = decodeCount(cmdInteger);
        if (cmdType == 1) {
        	if(geoArr.lentgh>0){
        		geoArr.push("|");
        		geoArr.push("|");
        	}
            for ( j = 0; j < count; j = j + 2) {
                var index = j + i + 1;
                var pixelX = decodeParameterInteger(lineGeom[index]) + prePointX;
                var pixelY = decodeParameterInteger(lineGeom[index + 1]) + prePointY;
                prePointX = pixelX;
                prePointY = pixelY;
                geoArr.push(pixelX);
                geoArr.push(pixelY);
                //geoStr=geoStr+pixelX+","+pixelY+",";
            }
            //索引后移count*2位
            i = i + count * 2 + 1;
        } else if (cmdType == 2) {
            //坐标的最大索引、最小索引
            var maxIndex = count * 2 + i, minIndex = i + 1;
            for (var k = minIndex; k < maxIndex; k = k + 2) {
                var pixelX = decodeParameterInteger(lineGeom[k]) + prePointX;
                var pixelY = decodeParameterInteger(lineGeom[k + 1]) + prePointY;
                //HGIS.Matrix.line(prePointX,prePointY,pixelX,pixelY);
                prePointX = pixelX;
                prePointY = pixelY;
                geoArr.push(pixelX);
                geoArr.push(pixelY);
                //geoStr=geoStr+pixelX+","+pixelY+",";
            }
            i = i + count * 2 + 1;
        }else if (cmdType == 7) {//闭合
			count = 0;
			//HGIS.Matrix.fill();
			i = i + count * 2 + 1;
		}
    }
    //feature["attributes"]["hashcode"]=HGIS.Matrix.m;
    feature.geoStr=geoArr;
}/**
 * Class: HGIS.Geometry.GeomRelation
 * 地理几何体之间的拓扑运算 
 * Constructor: HGIS.Geometry.GeomRelation
 * 构造函数.
 * 
 * 示例：
 * (code)
 *     var geomRelation=new  HGIS.Geometry.GeomRelation();
 * (end)
 *
 */
HGIS.Geometry=HGIS.Geometry||{};
HGIS.Geometry.GeomRelation = function() {
	var thisObj = this;
	thisObj.wkt= new HGIS.Format.WKT();
	/**
	 * APIMethod: intersect
	 * 求交集.至少提供两个几何体才能取交集.
	 * 
	 * Parameter:
	 * geom - {Array(Geometry)}  几何体数组.超过两个几何体时，HGIS从第一个几何体开始进行交集运算，相交结果再与第二个几何体进行相交运算，依次类推，直到最后一个几何体与上一个几何体相交运算结束。
	 * callback - {function} 回调函数. 回调函数的参数就是取交集的结果，该结果是一个{<HGIS.Feature.Vector>}对象，也是取交集后的结果。 
	 */
	this.intersect = function(geoms,callback) {
		if (geoms.length < 2) {
			alert( HGIS.language[HGIS.InitParam.language]["need_twoSet_AND"] );	//"用来求交集几何体最少有两个" 
			return;
		}
		
		//组装restful查询参数
		var wktStrArr = new Array();
		for (var i = 0; i < geoms.length; i = i + 1) {
			var wktStr = thisObj.wkt.extractGeometry(geoms[i]);
			wktStrArr.push(wktStr);
		}
		var params = {
			"wktStr" : wktStrArr.join("-")
		};
		var successHandler=function(result){
			var vector=thisObj.wkt.read(result);
			callback(vector);
		};
		var errorHandler=function(status){
			callback(status);
		};
		//执行查询
		 HGIS.Utils.send(geomTopologyURL.intersect,params,"POST","text",successHandler,errorHandler);
		};
 
	/**
	 * APIMethod: union
	 * 求并集.用来求并集几何体最少有两个.
	 * 
	 * Parameters:
	 * geoms - {Array(Geometry)} 几何体数组. 
	 * callback - {function} 回调函数。回调函数的参数是一个{<HGIS.Feature.Vector>}对象，也是取并集后的结果.
	 */
	this.union = function(geoms, callback) {
		//判断几何体是否满足条件，如果不满足则退出执行
		if (geoms.length < 2) {
			alert( HGIS.language[HGIS.InitParam.language]["need_twoSet_Udlte"] );	//"至少要两个几何体才能取并集" 
			return;
		}
	   //组装restful查询参数
		var wktStrArr = new Array();
		for (var i = 0; i < geoms.length; i = i + 1) {
			var wktStr = thisObj.wkt.extractGeometry(geoms[i]);
			wktStrArr.push(wktStr);
		}
		var params = {
			"wktStr" : wktStrArr.join("-")
		};
		
		var successHandler=function(result){
			var vector=thisObj.wkt.read(result);
			callback(vector);
		};
		var errorHandler=function(status){
			callback(status);
		};
		//执行rest查询
		
		HGIS.Utils.send(geomTopologyURL.union,params,"POST","text",successHandler,errorHandler);
	};
 
	/**
	 * APIMethod: difference
	 * 求差集.至少需要两个几何体才能取差集.
	 * 
	 * Parameter:
	 * geoms - {Array(Geometry)} 几何体数组.超过两个几何体时，HGIS从第一个几何体开始进行求差运算，求差结果再与第二个几何体进行求差运算，依次类推。直到最后一个几何体与上一个几何体求差运算结束。
	 * callback - {function} 回调函数. 回调函数的参数就是取交集的结果，该结果是一个{<HGIS.Feature.Vector>}对象。 
	 */
	
	this.difference = function(geoms, callback) {
		if (geoms.length < 2) {
			alert( HGIS.language[HGIS.InitParam.language]["need_twoSet_SU"] );	//"用来求差集几何体最少有两个" 
			return;
		}
		 //组装restful查询参数
		var wktStrArr = new Array();
		for (var i = 0; i < geoms.length; i = i + 1) {
			var wktStr = thisObj.wkt.extractGeometry(geoms[i]);
			wktStrArr.push(wktStr);
		}
		var params = {
			"wktStr" : wktStrArr.join("-")
		};
		
		var successHandler=function(result){
			var vector=thisObj.wkt.read(result);
			callback(vector);
		};
		var errorHandler=function(status){
			callback(status);
		};
		//执行rest查询
		HGIS.Utils.send(geomTopologyURL.difference,params,"POST","text",successHandler,errorHandler);
	};
	/**
	 * APIMethod: convexHull
	 * 求凸包.
	 * 凸包（Convex Hull）是一个计算几何（图形学）中不严谨的概念，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边型，它能包含点集中所有的点。
	 * X的凸包可以用X内所有点(X1，...Xn)的线性组合来构造. 在二维欧几里得空间中，凸包可想象为一条刚好包着所有点的橡皮圈。
	 * 
	 * Parameter:
	 * geom - {Geometry} 一个几何体。
	 * callback - {function} 回调函数. 回调函数的参数是一个{<HGIS.Feature.Vector>}对象,其中包含了该几何体的取凸包。
	 */
	this.convexHull = function(geom, callback) {
		var params = {
			"wktStr" : thisObj.wkt.extractGeometry(geom)
		};
		
		var successHandler=function(result){
			var vector=thisObj.wkt.read(result);
			callback(vector);
		};
		var errorHandler=function(status){
			callback(status);
		};
		//执行rest查询
		HGIS.Utils.send(geomTopologyURL.convexHull,params,"POST","text",successHandler,errorHandler);

	};
	/**
	 * APIMethod: buffer
	 * 取一个几何体的缓冲区.
	 * 一个几何体的缓冲区有正向缓冲与负向缓冲之分，几何体扩张后形成正向缓冲区，被侵蚀后形成负向缓冲区。以某湖中岛摊地部分举例，雨季水涨，面积减小，正向缓冲；旱季水落，面积增大，负向缓冲。
	 * 
	 * Parameter:
	 * geom - {Geometry} 一个几何体. 
	 * distance - {Number} 缓冲距离，单位米.
	 * quadrantSegments - {Number} 拐角点平滑度样式,拐角点位置用多少个点进行拐角位置的平滑处理；-1表示不传，不传就给默认值 50
	 * endCapStyle - {Number} 端点样式.端点样式分为4类，分别用数字1、2、3、4表示，对应的端点类型分别为round、butt、square、flat；其他值将默认为round
	 * 
	 */
	this.buffer = function(geom, distance, quadrantSegments, endCapStyle,
			callback) {
		if(HGIS.InitParam.mapUnit=="degrees"){
			var distSpan = HGIS.MapEx.prototype.degreeSpanToMeter.apply(this, [geom.getBounds().top, "degrees" ]);
			distance = distance / distSpan;
		}
		var params = {
			"wktStr" : thisObj.wkt.extractGeometry(geom),
			"distance" : distance,
			"quadrantSegments" : quadrantSegments,
			"endCapStyle" : endCapStyle
		};
		
		var successHandler=function(result){
			var vector=thisObj.wkt.read(result);
			callback(vector);
		};
		var errorHandler=function(status){
			callback(status);
		};
		//执行rest查询
		HGIS.Utils.send(geomTopologyURL.buffer,params,"POST","text",successHandler,errorHandler);

	};
	/**
	 * Method: is8poly
	 * 判断一个几何体是否是面八字.是则返回true,否则返回其数据类型
	 * 
	 * Parameter:
	 * geom - {Geometry} 一个几何体
	 * callback - {function} 
	 * 
	 */
	this.is8poly=function(geom,callback){
		var params={"wktStr":thisObj.wkt.extractGeometry(geom)};
		HGIS.Utils.send(geomTopologyURL.is8poly,params,"POST","text",function(res) {
			callback(res);
		}, function(status) {
			callback(status);
		});
	};
	/**
	 * APIMethod: getArea
	 * 求面积.
	 * 返回几何体的面积.前提是几何体有一个非0区域，也就说几何体至少是面状的，其它类型的几何体返回结果为0。比如一条线或一个点的面积为0.
	 * 
	 * Parameter:
	 * geom - {Geometry} 一个几何体
	 * callback - {function} 回调函数。回调函数中参数即是几体的面积。
	 * 
	 */
	this.getArea = function(geom, callback) {
		var params = {
			"wktStr" : thisObj.wkt.extractGeometry(geom)
		};
		
		var successHandler=function(result){
			callback(result);
		};
		var errorHandler=function(status){
			callback(status);
		};
		HGIS.Utils.send(geomTopologyURL.getArea,params,"POST","text",successHandler,errorHandler);
	};

	/**
	 * APIMethod: isContain
	 * 包含判断.
	 * 判断数组中的第一个元素是否包含了第二个元素。
	 * 
	 * Parameter:
	 * geomArr - {Array(Geometry)} 几何体数组。注意：这个数组只能有两个几何体元素。
	 * callback - {function} 回调函数。如果数组中的第一个元素包含了第二个元素，则回调函数中的参数为true,否则为false。
	 */
	this.isContain=function(geomArr,callback){
			if(geomArr.length>2){
				alert( HGIS.language[HGIS.InitParam.language]["only_twoElement_inArr"] );	//"数组长度过大，只能包含两个元素" 
				return;
			}
			if(geomArr.length<2){
				alert( HGIS.language[HGIS.InitParam.language]["need_twoElement_inArr"] );	//"数组长度不满足要求，应包含两个元素"
				return;
			}
			var sourceWkt = thisObj.wkt.extractGeometry(geomArr[0]);
			var targetWkt=thisObj.wkt.extractGeometry(geomArr[1]);
			var params={"sourceWkt":sourceWkt,"targetWkt":targetWkt};
			var successHandler=function(result){
				callback(result);
			};
			var errorHandler=function(status){
				callback(status);
			};
			
			HGIS.Utils.send(geomTopologyURL.isContain,params,"POST","text",successHandler,errorHandler);

	};
	/**
	 * APIMethod: reverseGeometry
	 * 计算所有坐标序列的相反顺序，构建一个新的几何体
	 * 
	 * Parameter:
	 * geom - {Geometry} 任意几何体
	 * callback - {function} 回调函数。回调结果中包含了一个新的几何体，其坐标序列与参数几何体相反
	 */
	this.reverseGeometry=function(geom,callback){
			var wktStr = thisObj.wkt.extractGeometry(geom);
			var params={"wktStr":wktStr};
		    var successHandler=function(result){
		    	var vector=thisObj.wkt.read(result);
				callback(vector);
			};
			var errorHandler=function(status){
				callback(status);
			};
		HGIS.Utils.send(geomTopologyURL.reverseGeometry,params,"POST","text",successHandler,errorHandler);
	};
	// 返回运算结果
	this.getRes = function(geoms, url,callback) {
		var wktStrArr = new Array();
		for (var i = 0; i < geoms.length; i = i + 1) {
			var wktStr = thisObj.wkt.extractGeometry(geoms[i]);
			wktStrArr.push(wktStr);
		}
		var params = {
			"wktStr" : wktStrArr.join("-")
		};
		var successHandler=function(result){
			callback(result);
		};
		var errorHandler=function(status){
			callback(status);
		};
	HGIS.Utils.send(url,params,"POST","text",successHandler,errorHandler);
	};
	
};
/**
 * Class: HGIS.InitParam HGIS引擎初始化时产生的与地图相关的一些参数.
 * 
 * Examples: (code) //绘制tip框的回调事件是否已经注册的标志. HGIS.InitParam.isShowTipRegister;
 * 
 *  // 地图初始化范围. HGIS.InitParam.extent;
 *  // HGIS平台路径. HGIS.InitParam.basePath;
 *  // 地图初始化比例级别. HGIS.InitParam.initLevel;
 *  // 地图类型. HGIS.InitParam.mapType;
 *  // 地图根目录. HGIS.InitParam.tileRootPath;
 *  // 初始化地图中心点. HGIS.InitParam.center;
 * 
 * //图层分辨率 切片原点 切片格式 切片大小等信息 HGIS.InitParam.extra;
 * 
 * //是否在浏览器中启用缓存数据库.注意，如果你的浏览器不支持html5，则有不要启用此项。默认为false。
 * 支持IndexDB的浏览器,IE10、Firefox10、Chrome23、Oper15及其以上版本.
 * 
 * HGIS.InitParam.map; (end)
 */
HGIS.INCHES_PER_UNIT["千米"] = HGIS.INCHES_PER_UNIT["km"];
HGIS.INCHES_PER_UNIT["米"] = HGIS.INCHES_PER_UNIT["m"];
HGIS.INCHES_PER_UNIT["英里"] = HGIS.INCHES_PER_UNIT["mi"];
HGIS.INCHES_PER_UNIT["英尺"] = HGIS.INCHES_PER_UNIT["ft"];
HGIS.InitParam = {
	version : 1.4,

	/**
	 * APIProperty: isFrontConfig 地图接入方式是否采用前端配置，默认采用后端配置。当需要采用前端配置时，将此值设置为true。
	 */
	isFrontConfig : false,
	/**
	 * APIProperty: reloadFactor
	 * 是否从后台获取脱密因子，默认false;false情况下按照前端的纠偏因子，设为true从后台获取，弥补部分地区纠偏因子精度低的问题.
	 */
	reloadFactor : false,
	/**
	 * APIProperty: isShowTipRegister 布尔类型,绘制tip框的回调事件是否已经注册的标志.
	 */
	isShowTipRegister : false,// 绘制tip框的回调事件是否已经注册的标志

	/**
	 * APIProperty: basePath HGIS平台路径.
	 */
	basePath : APIAdress,// HGIS平台路径

	/**
	 * APIProperty: center 值为经纬度,地图初始化中心点.
	 * 
	 * Example: (code) center:new HGIS.LonLat(120,30) //或者 HGIS.InitParam.center =
	 * new HGIS.LonLat(120,30)
	 */
	center : new HGIS.LonLat(120, 30),

	/**
	 * APIProperty: extent 地图初始化范围.
	 * 
	 * Example: (code) extent:null //或者 HGIS.InitParam.extent = new
	 * HGIS.HGIS.Bounds("8349254.0313363","2037355.1155927", "15029177.082954",
	 * "7170603.8142116");
	 */
	extent : null,

	/**
	 * APIProperty: language 地图初始化语言.主要涉及接口的提示；
	 * 
	 * 示例： (code) HGIS.InitParam.language="zh_CN";//将平台语言设置为中文
	 * HGIS.InitParam.language="en_US";//将平台语言设置为英文 (end)
	 */
	language : "zh_CN",
	/**
	 * APIProperty: maxLevel {Number} 地图初始化最大层级.
	 */
	maxLevel : 20,
	/**
	 * APIProperty: minLevel {Number} 地图初始化最小层级.
	 */
	minLevel : 0,
	/**
	 * APIProperty: initLevel {Number} 地图初始化最小层级.
	 */
	initLevel : 12,
	/**
	 * APIProperty: mapType {String} 地图初始化类型.
	 */
	mapType : "HikMap",// 地图类型
	/**
	 * APIProperty: tileOrigin 切片加载坐标.
	 * 
	 * Example: (code) tileOrigin:new HGIS.LonLat(-180,90)
	 */
	tileOrigin : new HGIS.LonLat(-180, 90),
	/**
	 * APIProperty: userProxy
	 * {true/false} 是否使用代理，默认为false.
	 */	 	
 	userProxy:false,
	/**
	 * APIProperty: resolutions 初始化分辨率.
	 * 
	 * Example: (code) resolution:[156543.03392804062,
	 * 78271.51696402031,39135.758482010155, 19567.879241005077,
	 * 9783.939620502539,4891.969810251269, 2445.9849051256347,
	 * 1222.9924525628173,611.4962262814087, 305.74811314070433,
	 * 152.87405657035217,76.43702828517608, 38.21851414258804,
	 * 19.10925707129402,9.55462853564701, 4.777314267823505,
	 * 2.3886571339117526,1.1943285669558763, 0.5971642834779382,
	 * 0.2985821417389691,0.14929107086948454]
	 */
	resolutions : [],
	/**
	 * APIProperty: tileSize 切片大小.
	 */
	tileSize : 256,
	/**
	 * APIProperty: srid 地图坐标类型.
	 */
	srid : 4326,
	// wmts专用的三个参数
	layer : "", // wmts 图层
	matrixSet : "", // wmts 矩阵及
	style : "default",
	// ezmap 专用
	levelSequence : "", // PGIS地图正反序列
	zoomOffset : "", // pgis地图级别偏移

	/**
	 * APIProperty: vecUrl 矢量地址.
	 */
	vecUrl : "",// 矢量地址
	/**
	 * APIProperty: imgUrl 地图影像地址.
	 */
	imgUrl : "",// 影像地址
	/**
	 * 矢量切片地址
	 */
	hvtUrl : "",

	/**
	 * APIProperty: enableVtMap 是否启用矢量瓦片:true表示启用矢量切片
	 * false表示不启用矢量切片;不启用情况下为默认的常规图片切片地图
	 */
	enableVtMap : "",
	tfwUrl : "",// 2.5维
	mixedUrl : "",// 混合
	vecUrl_w : "",// 二网域地图根目录
	imgUrl_w : "",// 二网域影像地址
	map : null,
	mapUnit : "m",
	// 网域
	netDomain : "n",
	/**
	 * APIProperty: factor 是否纠偏."1"为纠偏,"0"为不纠偏.默认为不纠偏.
	 */
	factor : "",
	geodesic : false, // false为平面坐标系，true为地理坐标系
	

	// 初始化相关的参数
	init : function(url, callback) {
		// 获取地图初始化
		url = HGIS.Utils.getUrlByExpolreType(url);
		if (url.indexOf("jsonp") != -1) {
			HgisAjax({   
			  url: url,    // 请求地址
			  jsonp: 'jsonp',  // 采用jsonp请求，且回调函数名为"jsonpCallbak"，可以设置为合法的字符串
			  data: {},   // 传输数据
			  success: function(params){ HGIS.InitParam.successCallback(params,callback) },
			  error: function(error) {}   // 请求失败的回调函数
			});
		} else {
			HGIS.Utils.send(url,"","get","json",function(params){ HGIS.InitParam.successCallback(params , callback) }, function(err) {} );
		}
	},
	// 请求成功回调函数
	successCallback : function(params,callback){
		params = params.data;
		var center = params.center.split(',');
		HGIS.InitParam.center = new HGIS.LonLat(
				center[0], center[1]);
		var bounds = params.extent.split(',');
		HGIS.InitParam.extent = new HGIS.Bounds(
				bounds[0], bounds[1], bounds[2],
				bounds[3]);
		HGIS.InitParam.maxLevel = params.maxLevel;
		HGIS.InitParam.minLevel = params.minLevel;
		HGIS.InitParam.initLevel = params.initLevel;
		HGIS.InitParam.mapType = params.mapType;
		HGIS.InitParam.enableVtMap = params.enableVtMap;// 是否启用矢量切片
		HGIS.InitParam.imageFormat = params.imageFormat;
		if (HGIS.InitParam.mapType.toLowerCase() == "wmtsmap") {
			var tileOrigin = params.tileOrigin
					.split(',');
			HGIS.InitParam.tileOrigin = new HGIS.LonLat(
					tileOrigin[0], tileOrigin[1]);
			HGIS.InitParam.layer = params.layer;
			HGIS.InitParam.matrixSet = params.matrixSet;
			HGIS.InitParam.style = params.style;
		} 
		if (HGIS.InitParam.mapType.toLowerCase() == "ezmap") {
			HGIS.InitParam.levelSequence = params.levelSequence;
			HGIS.InitParam.zoomOffset = params.zoomOffset;
		}
		HGIS.InitParam.resolutions = params.resolutions;
		HGIS.InitParam.tileSize = params.tileSize ? params.tileSize : 256  ;
		HGIS.InitParam.srid = params.srid;

		if (HGIS.InitParam.netDomain.toLowerCase() == "w") {
			HGIS.InitParam.vecUrl = params.vecUrl_w;
			HGIS.InitParam.imgUrl = params.imgUrl_w;
		} else if (HGIS.InitParam.netDomain
				.toLowerCase() == "ww") {
			HGIS.InitParam.vecUrl = params.vecUrl_ww;
			HGIS.InitParam.imgUrl = params.imgUrl_ww;
		} else {
			HGIS.InitParam.vecUrl = HGIS.InitParam.netDomainUrl(HGIS.InitParam.mapType,params.vecUrl);
			HGIS.InitParam.imgUrl = HGIS.InitParam.netDomainUrl(HGIS.InitParam.mapType,params.imgUrl);
			if (params.tfwUrl) {
				HGIS.InitParam.tfwUrl = HGIS.InitParam.netDomainUrl(HGIS.InitParam.mapType,params.tfwUrl);
			}
			if (params.mixedUrl) {
				HGIS.InitParam.mixedUrl = HGIS.InitParam.netDomainUrl(HGIS.InitParam.mapType,params.mixedUrl);
			}
		}
		// hvt 待定
		HGIS.InitParam.hvtUrl = params.hvtUrl;
		HGIS.InitParam.isInit = true;
		HGIS.InitParam.factor = params.factor;
		if (HGIS.InitParam.srid == "900913") {
			HGIS.InitParam.extent.transform(
					"EPSG:4326", "EPSG:900913");
			HGIS.InitParam.center.transform(
					"EPSG:4326", "EPSG:900913");
			HGIS.InitParam.geodesic = false;
		} else if (HGIS.InitParam.srid == "4326") {
			HGIS.InitParam.geodesic = true;
		}
		// 获取客户端地址，设置跨域代理地址
		var curWwwPath = window.document.location.href;
		var pathName = window.document.location.pathname;
		var pos = curWwwPath.indexOf(pathName);
		var localhostPath = curWwwPath
				.substring(0, pos);
		var projectName = pathName.substring(0,
				pathName.substr(1).indexOf('/') + 1);
		var contextPath = localhostPath + projectName;// 项目路径,例:http://localhost:8080/dypgis
		if (callback) {
			callback();
		}
	},
	// v1.4.3 新增内容 ； 用于离线地图的多网域使用； 多网域情况下ip和端口号取url的ip 和端口号
	netDomainUrl : function(mapType, url) {
		if (mapType.toLowerCase() === "googlemap" || mapType.toLowerCase() === "gaodemap"
				|| mapType.toLowerCase() === "hikmap" || mapType.toLowerCase() === "spiritmap"
				|| mapType.toLowerCase() === "arcgismap") {
			var reg = RegExp("http")
			if( reg.test(url) ){
				return url ;
			}else{
				var urlsArray = url.split("|");
				for (var i = 0; i < urlsArray.length; i++) {
					urlsArray[i] = window.location.protocol +  "//" + window.location.host + urlsArray[i];
				}
				for (var i = 0; i < urlsArray.length; i++) {
					url = urlsArray[i] + "|"
				}
				url = url.substring(0, url.length - 1);
				
				return url;
			}	
		} else {
			return url;
		}
	},

};
HGIS.language = HGIS.language || {};
HGIS.language.en_US={
	"m":"m",
	"km":"km",
	"m2":"m²",
	"km2":"km²",
	//MapOperate.js
	"clear":"clear",
	"close":"close",
	"length":"Length",
	"area":"area",
	"start":"start",
	//退出测量
	"escmeasure":"Single click to determine position.<br>double click to end drawing.<br>press Esc to exit.",	
	"track_data_noEmpty": "Race data cannot be empty.", //轨迹数据不能为空
	"point_noTrack": "A point cannot be a Track", //一个点不能成为轨迹
	"replay_track_point_err": "Replay the track point error",//重新播放轨迹点错误
	"vectorLayer_noExist": "Vector layer does not exist",//矢量图层不存在
	"buff_radius_err": "Buffer radius error, please enter positive integer",//缓冲半径错误，请输入正整数
	"open_camera_needParam": "To open the nearest N camera, enter a positive integer",//要打开最近的N个摄像头，请输入正整数
	"vectorLayer_noExist.": "The vector layer does not exist",//矢量图层不存在
	"this": "This",//这 
	"camera_preview.": "Camera will be previewed",//个摄像头将被预览
	"query_err": "Query error",//查询出错
	"track_data_noProducted": "Track data is not producted", //轨迹数据尚未生成
	"center_data_err": "Center point data type error", //中心点数据类型错误
	"center_noExist": "Center doesn't exist", //中心点不存在
	"Encirclement_noFound": "No encirclement was found.", //没有发现包围圈
	"need_twoSet_AND": "At least two geometry to AND set", //用来求交集几何体最少有两个
	"need_twoSet_Udlte": "At least two geometry to Udlte set", //至少要两个几何体才能取并集
	"need_twoSet_SU": "At least two set geometry to SU set", //用来求差集几何体最少有两个
	"only_twoElement_inArr": "array is too large to contain ,only two elements", //数组长度过大，只能包含两个元素
	"need_twoElement_inArr": "array length does not meet the requirements, should contain two elements", //数组长度不满足要求，应包含两个元素
	"HGIS_noKnow": "HGIS It's not clear what you're looking for", //HGIS不清楚你想找啥？
	"err_msg": "error message", //错误信息：
	"nonsupport_idxDB": "nonsupport IndexedDB", //不支持IndexedDB
	"DB_fail": "Database creation/connection failed", //数据库创建/连接失败
	"del_DB_success": "[delete database success]", //【删除数据库成功】
	"del_DB_err": "[delete database error]",//【删除数据库失败】
	"no_instant": "Database not instantiate", //database未实例化
	"insert_err": "Insert failed, and the tag may already exist in the database", //插入失败，该标签在数据库中可能已经存在
	"brows_noSupport_AJAX": "Your browser does not support AJAX.", //您的浏览器不支持AJAX！
	"no_supportType": "The type of operation that is not supported", //不被支持的操作类型
	"only_supportType": "Only text、json and XML are supported, please check resultType parameter is correct", //只支持 text json 和 xml三种格式，请检查resultType参数是否正确	
	"Tolerance_val_noReasonable": "Tolerance value is not reasonable",	//提供的容差值不合理
	"least_twoPoint": "At least give a starting point and end point", //至少要给出一个起点及终点
	"can_noFind": "Can't find",	//查找不到
	"map_noInit": "The map is not initialized.", //地图未初始化完成
}/**
 * Class: HGIS.language
 * HGIS For JavaScript 语言包
 * 
 * 示例：
 * (code)
 *     //使用中文的话在地图初始化之前调用
 *     HGIS.InitParam.language="zh_CN";
 *     //如果使用英文的话则在地图初始化之前调用
 *     HGIS.InitParam.language="en_US";
 * (end)
 *
 */
HGIS.language = HGIS.language || {};
HGIS.language.zh_CN={ 
	"m":"米",
	"km":"千米",
	"m2":"平方米",
	"km2":"平方千米",
	//MapOperate.js
	"clear":"清除",
	"close":"关闭",
	"length":"总长",
	"area":"面积",
	"start":"起点",
	//退出测量
	"escmeasure":"单击确定位置.<br>双击结束绘制.<br>按ESC退出配置.",
	"track_data_noEmpty": "轨迹数据不能为空",  //轨迹数据不能为空
	"point_noTrack": "一个点不能成为轨迹",  //一个点不能成为轨迹
	"replay_track_point_err": "重新播放轨迹点错误",//重新播放轨迹点错误
	"vectorLayer_noExist": "矢量图层不存在",//矢量图层不存在
	"buff_radius_err": "缓冲半径错误，请输入正整数",//缓冲半径错误，请输入正整数
	"open_camera_needParam": "要打开最近的N个摄像头，请输入正整数", //要打开最近的N个摄像头，请输入正整数
	"vectorLayer_noExist.": "矢量图层不存在", //矢量图层不存在
	"this": "这 ", //这 
	"camera_preview.": "个摄像头将被预览",//个摄像头将被预览
	"query_err": "查询出错",//查询出错
	"track_data_noProducted": "轨迹数据尚未生成", //轨迹数据尚未生成
	"center_data_err": "中心点数据类型错误", //中心点数据类型错误
	"center_noExist": "中心点不存在", //中心点不存在
	"Encirclement_noFound": "没有发现包围圈", //没有发现包围圈
	"need_twoSet_AND": "用来求交集几何体最少有两个", //用来求交集几何体最少有两个
	"need_twoSet_Udlte": "至少要两个几何体才能取并集", //至少要两个几何体才能取并集
	"need_twoSet_SU": "用来求差集几何体最少有两个", //用来求差集几何体最少有两个
	"only_twoElement_inArr": "数组长度过大，只能包含两个元素", //数组长度过大，只能包含两个元素
	"need_twoElement_inArr": "数组长度不满足要求，应包含两个元素", //数组长度不满足要求，应包含两个元素
	"HGIS_noKnow": "HGIS不清楚你想找啥？", //HGIS不清楚你想找啥？
	"err_msg": "错误信息：", //错误信息：
	"noSupport_idxDB": "不支持IndexedDB", //不支持IndexedDB
	"DB_fail": "数据库创建/连接失败", //数据库创建/连接失败
	"del_DB_success": "【删除数据库成功】", //【删除数据库成功】
	"del_DB_err": "【删除数据库失败】",//【删除数据库失败】
	"no_instant": "database未实例化", //database未实例化
	"insert_err": "插入失败，该标签在数据库中可能已经存在", //插入失败，该标签在数据库中可能已经存在
	"brows_noSupport_AJAX": "您的浏览器不支持AJAX！", //您的浏览器不支持AJAX！
	"no_supportType": "不被支持的操作类型", //不被支持的操作类型
	"only_supportType": "只支持 text json 和 xml三种格式，请检查resultType参数是否正确", //只支持 text json 和 xml三种格式，请检查resultType参数是否正确	
	"Tolerance_val_noReasonable": "提供的容差值不合理",	//提供的容差值不合理
	"least_twoPoint": "至少要给出一个起点及终点", //至少要给出一个起点及终点
	"can_noFind": "查找不到",	//查找不到
	"map_noInit": "地图未初始化完成", //地图未初始化完成
}

HGIS.language = HGIS.language || {};
HGIS.language.uk_UA={
	"m":"m",
	"km":"km",
	"m2":"m²",
	"km2":"km²",
	//MapOperate.js
	"clear":"clear",
	"close":"close",
	"length":"Length",
	"area":"area",
	"start":"start",
	//退出测量
	"escmeasure":"Single click to determine position.<br>double click to end drawing.<br>press Esc to exit.",	
	"track_data_noEmpty": "Race data cannot be empty.", //轨迹数据不能为空
	"point_noTrack": "A point cannot be a Track", //一个点不能成为轨迹
	"replay_track_point_err": "Replay the track point error",//重新播放轨迹点错误
	"vectorLayer_noExist": "Vector layer does not exist",//矢量图层不存在
	"buff_radius_err": "Buffer radius error, please enter positive integer",//缓冲半径错误，请输入正整数
	"open_camera_needParam": "To open the nearest N camera, enter a positive integer",//要打开最近的N个摄像头，请输入正整数
	"vectorLayer_noExist.": "The vector layer does not exist",//矢量图层不存在
	"this": "This",//这 
	"camera_preview.": "Camera will be previewed",//个摄像头将被预览
	"query_err": "Query error",//查询出错
	"track_data_noProducted": "Track data is not producted", //轨迹数据尚未生成
	"center_data_err": "Center point data type error", //中心点数据类型错误
	"center_noExist": "Center doesn't exist", //中心点不存在
	"Encirclement_noFound": "No encirclement was found.", //没有发现包围圈
	"need_twoSet_AND": "At least two geometry to AND set", //用来求交集几何体最少有两个
	"need_twoSet_Udlte": "At least two geometry to Udlte set", //至少要两个几何体才能取并集
	"need_twoSet_SU": "At least two set geometry to SU set", //用来求差集几何体最少有两个
	"only_twoElement_inArr": "array is too large to contain ,only two elements", //数组长度过大，只能包含两个元素
	"need_twoElement_inArr": "array length does not meet the requirements, should contain two elements", //数组长度不满足要求，应包含两个元素
	"HGIS_noKnow": "HGIS It's not clear what you're looking for", //HGIS不清楚你想找啥？
	"err_msg": "error message", //错误信息：
	"nonsupport_idxDB": "nonsupport IndexedDB", //不支持IndexedDB
	"DB_fail": "Database creation/connection failed", //数据库创建/连接失败
	"del_DB_success": "[delete database success]", //【删除数据库成功】
	"del_DB_err": "[delete database error]",//【删除数据库失败】
	"no_instant": "Database not instantiate", //database未实例化
	"insert_err": "Insert failed, and the tag may already exist in the database", //插入失败，该标签在数据库中可能已经存在
	"brows_noSupport_AJAX": "Your browser does not support AJAX.", //您的浏览器不支持AJAX！
	"no_supportType": "The type of operation that is not supported", //不被支持的操作类型
	"only_supportType": "Only text、json and XML are supported, please check resultType parameter is correct", //只支持 text json 和 xml三种格式，请检查resultType参数是否正确	
	"Tolerance_val_noReasonable": "Tolerance value is not reasonable",	//提供的容差值不合理
	"least_twoPoint": "At least give a starting point and end point", //至少要给出一个起点及终点
	"can_noFind": "Can't find",	//查找不到
	"map_noInit": "The map is not initialized.", //地图未初始化完成
}



/**
 * Class: HGIS.Layer.AgsOffLayer
 * AgsOffLayer地图，在部署方案中将地图类型配置为ArcGISOff则可以接这类服务
 */

/**
 * Constructor: HGIS.Layer.AgsOffLayer
 * 构造方法
 * 
 * Parameters:
 * tileRootPath - {String} 图层服务地址 eg http://localhost:4444/g/{z}/{y}/{x}.png.
 * mapBounds - {String} 地图边界.
 * minZoom - {Int} 最小级别
 * maxZoom - {Int} 最大级别
 * resInfo - {Array} 分辨率数组
 * tileOrigin - {Lonlat} 切片原点的坐标
 * name - {String} 图层名称
 * 
 * Examples:
 * (code)
 * var url="http://localhost:1578/tiles";
 * //如果params参数为空 则切片原点默认为(-180,90)
 * var layer=new HGIS.Layer.AgsOffLayer(url,bounds,8,20,{},new HGIS.LonLat(-180, 90),"vec");
 * map.addLayer(layer);
 * (end)
 */

HGIS.Layer = HGIS.Layer || {};
HGIS.Layer.AgsOffLayer = function(tileRootPath, mapBounds, minZoom, maxZoom,resInfo,tileOrigin,name) {
	var thisObj=this;
	thisObj.resolutions = resInfo;
	thisObj.name=name;
	thisObj.tileOrigin = tileOrigin;
	var options = {
		projection : new HGIS.Projection("EPSG:4326"),
		maxExtent : new HGIS.Bounds(-180, -90, 180, 90)
	};

	function isBoundIntersect(bounds1, bounds2) {
		if (bounds1.bottom > bounds2.top || bounds1.top < bounds2.bottom || bounds1.right < bounds2.left
				|| bounds1.left > bounds2.right) {
			return false;
		} else {
			return true;
		}
	};

	// 加载瓦片地址
	this.getTileUrl = function(bounds,tileType,obj) {
		bounds = obj.adjustBounds(bounds);
		var res = obj.map.getResolution();
		var center = bounds.getCenterLonLat();
		var col = Math.floor((center.lon - obj.tileOrigin.lon) / (res * obj.tileSize.w));
		var row = Math.floor((obj.tileOrigin.lat - center.lat) / (res * obj.tileSize.h));
		var level = obj.map.getZoom();
		var type = (obj.url.split("^")[1]  != undefined ) ? obj.url.split("^")[1]: "png" ;
		if (isBoundIntersect(mapBounds, bounds) && level >= minZoom && level <= maxZoom) {
			col = 'C' + HGIS.Number.zeroPad(col, 8, 16);
			row = 'R' + HGIS.Number.zeroPad(row, 8, 16);
			level = 'L' + HGIS.Number.zeroPad(level, 2, 10);
			var tileProxyUrl = "";
			if (HGIS.InitParam.useProxy == "true")
				tileProxyUrl = tileCacheProxyURL + "?mapType="
						+ HGIS.InitParam.mapType +"&tileType="+tileType+ "&tileURL=" + obj.url
						+ "&level=" + level + "&col=" + col + "&row=" + row
						+ "&type=" + type;
			else
				tileProxyUrl = obj.url.split("^")[0] + "/" + level + "/" + row + "/" + col
						+ "." + type;
		 		
			return HGIS.Utils.getSafeAddress(tileProxyUrl);		 
		}else{
			return HGIS.Utils.getSafeAddress(APIAdress+ "/gisapi/theme/image/none.png");
		}
	};
	// 矢量地图
	var vecLayer = new HGIS.Layer.TMS(thisObj.name, tileRootPath, {
		serviceVersion : '.',
		layername : '.',
		alpha : true,
		tileOrigin : thisObj.tileOrigin,//new HGIS.LonLat(-180, 90),
		tileOriginCorner : "tl",
		tileSize: new HGIS.Size(HGIS.InitParam.tileSize,HGIS.InitParam.tileSize), //設定切片大小
		createBackBuffer:function() {	
			return null;
		},
		getURL :function(bounds){
			var url=thisObj.getTileUrl(bounds,thisObj.name,this);
			return url;
		},
		isBaseLayer : true,
		displayInLayerSwitcher : true,		 
		resolutions:thisObj.resolutions,
		serverResolutions:thisObj.resolutions,
		tileOptions : {
			blankImageUrl : HGIS.Utils.getSafeAddress(APIAdress+"/gisapi/theme/image/none.png"), // 空白图片
			onImageError : function() { // 切片数据加载失败使用空白图片代替
				var img = this.imgDiv;
				this.createBackBuffer=function() {	
					return null;
				};
				if (img.src != null) {
					this.imageReloadAttempts++;
					if (this.imageReloadAttempts <= HGIS.IMAGE_RELOAD_ATTEMPTS) {
						this.setImgSrc(this.layer.getURL(this.bounds));
					} else {
						//HGIS.Element.addClass(img, "olImageLoadError");
						this.events.triggerEvent("loaderror");
						img.src = HGIS.Utils.getSafeAddress(APIAdress+ "/gisapi/theme/image/none.png");
						this.onImageLoad();
					}
				}
			}
		}
	});
	return vecLayer;
};/**
 * Class: HGIS.Layer.AgsOnLayer
 * Arcgis再线瓦片地图图层，在部署方案中将地图类型配置为ArcGISOn则可以接这类服务
 */

/**
 * Constructor: HGIS.Layer.AgsOnLayer
 * 构造方法
 * 
 * Parameters:
 * tileRootPath - {String} 图层服务地址 eg http://localhost:4444/g/{z}/{y}/{x}.png.
 * mapBounds - {String} 地图边界.
 * minZoom - {Int} 最小级别.
 * maxZoom - {Int} 最大级别.
 * resolutions -{Array} 分辨率数组.
 * tileOrigin -{Lonlat} 切片原点的坐标
 * name - {String} 图层名称.
 * 
 * Examples:
 * (code)
 * var url="http://localhost:1578/tiles";
 * //如果params参数为空 则切片原点默认为(-180,90)
 * var layer=new HGIS.Layer.AgsOnLayer(url,bounds,8,20,{},new HGIS.LonLat(-180, 90),"矢量地图");
 * map.addLayer(layer);
 * (end)
 */
HGIS.Layer.AgsOnLayer=function(tileRootPath, mapBounds, minZoom, maxZoom,resolutions,tileOrigin,name) { 
	var thisObj=this; 
	thisObj.resolutions = resolutions;
	thisObj.name=name;
	thisObj.tileOrigin = tileOrigin;
	var options = {
		projection : new HGIS.Projection("EPSG:900913"),
		maxExtent : new HGIS.Bounds(-180, -90, 180, 90)
	};

	function isBoundIntersect(bounds1, bounds2) {
		if (bounds1.bottom > bounds2.top || bounds1.top < bounds2.bottom || bounds1.right < bounds2.left
				|| bounds1.left > bounds2.right) {
			return false;
		} else {
			return true;
		}
	};

	// 加载瓦片地址
	this.getTileUrl = function(bounds,tileType,obj) {
		bounds = obj.adjustBounds(bounds);
		var res = obj.map.getResolution();
		var center = bounds.getCenterLonLat();
		var col = Math.floor((center.lon - obj.tileOrigin.lon) / (res * obj.tileSize.w));
		var row = Math.floor((obj.tileOrigin.lat - center.lat) / (res * obj.tileSize.h));
		var level = obj.map.getZoom();
		if (isBoundIntersect(mapBounds, bounds) && level >= minZoom && level <= maxZoom) {
			var tileProxyUrl = "";
			if (HGIS.InitParam.useProxy == "true")
				tileProxyUrl = tileCacheProxyURL + "?mapType="
						+ HGIS.InitParam.mapType+"&tileType="+tileType + "&tileURL=" + obj.url.split("^")[0]
						+ "&level=" + level + "&col=" + col + "&row=" + row
						+ "&type=" + obj.type;
			else
				tileProxyUrl=obj.url.split("^")[0] + "/tile/" + level + "/" + row + "/" + col; 
			
			tileProxyUrl = HGIS.Utils.getSafeAddress(tileProxyUrl);
			
			return tileProxyUrl;
		}else{
			return HGIS.Utils.getSafeAddress(APIAdress+ "/gisapi/theme/image/none.png");
		}
	};
	
	// 矢量地图
	var vecLayer = new HGIS.Layer.TMS(thisObj.name, tileRootPath, {
		serviceVersion : '.',
		layername : '.',
		alpha : true,
		type : thisObj.url !=undefined ? ( thisObj.url.split("^")[1] != undefined ? thisObj.url.split("^")[1]: "png" ) :"png",
		tileOrigin : thisObj.tileOrigin,// new HGIS.LonLat(-180, 90),
		tileOriginCorner : "tl",
		tileSize: new HGIS.Size(HGIS.InitParam.tileSize,HGIS.InitParam.tileSize), //設定切片大小
		getURL :function(bounds){
			var url=thisObj.getTileUrl(bounds,thisObj.name,this);
			return url;
		},
		createBackBuffer:function() {	
			return null;
		},
		isBaseLayer : true,
		displayInLayerSwitcher : true,
		resolutions:thisObj.resolutions,
		serverResolutions:thisObj.resolutions,
		tileOptions : {
			blankImageUrl : HGIS.Utils.getSafeAddress(APIAdress+"/gisapi/theme/image/none.png"), // 空白图片
			onImageError : function() { // 切片数据加载失败使用空白图片代替
				var img = this.imgDiv;
				this.createBackBuffer=function() {	
					return null;
				};
				if (img.src != null) {
					this.imageReloadAttempts++;
					if (this.imageReloadAttempts <= HGIS.IMAGE_RELOAD_ATTEMPTS) {
						this.setImgSrc(this.layer.getURL(this.bounds));
					} else {
						//HGIS.Element.addClass(img, "olImageLoadError");
						this.events.triggerEvent("loaderror");
						img.src = HGIS.Utils.getSafeAddress(APIAdress+ "/gisapi/theme/image/none.png");
						this.onImageLoad();
					}
				}
			}
		}
	});
	return vecLayer;
};
/**
 * Class: HGIS.Layer.EzLayer
 * 接EzLayer,pgis常用的地图服务类型
 * 
 * 继承自: 
 * {<HGIS.Layer.TMS>}
 * 
 * Examples:
 * (code)
 *  var url="http://localhost/Dataserver";
 *  var layer=new HGIS.Layer.EzLayer("PGIS",url,null);
 *  map.addLayer(layer);
 * (end)
 */
HGIS.Layer=HGIS.Layer||{};
HGIS.Layer.EzLayer = HGIS.Class(HGIS.Layer.TMS, {
	type : "EzLayer",
	options : null,
	/**
	 * APIProperty: url
	 * 服务地址，提供前端地址
	 */
	url : null,
	cacheTileUrl : null,
	isBaseLayer : true,
	levelSequence : 1,		//用于判断是否对缩放层级进行反转的标识，1是正常的，0需要反转
	levelMax : 22,		    // 对缩放层级进行反转时，会用 ：levelMax - 当前等级
	ezZoomOffset : 0,	    //表示是否对缩放等级设置偏移量，该请求参数会添加至请求瓦片的url中
	minLevel:0,	            
	maxLevel:22,
	mapBounds:null,
	tileOptions : {
		blankImageUrl : "/gisapi/theme/image/none.png", // 空白图片
		onImageError : function() { // 切片数据加载失败使用空白图片代替
			var img = this.imgDiv;
			this.createBackBuffer=function() {	
				return null;
			};
			if (img.src != null) {
				this.imageReloadAttempts++;
				if (this.imageReloadAttempts <= HGIS.IMAGE_RELOAD_ATTEMPTS) {
					this.setImgSrc(this.layer.getURL(this.bounds));
				} else {
					//HGIS.Element.addClass(img, "olImageLoadError");
					this.events.triggerEvent("loaderror");
					img.src = "jsapi/theme/img/none.png";
					this.onImageLoad();
				}
			}
		}
	},
	/**
	 * Constructor: HGIS.Layer.EzLayer
	 * 构造函数
	 * 
	 * Parameters:
	 * name - {String} 服务名称
	 * url - {String} 服务地址
	 * options - {Object} 图层参数
	 */
	initialize : function(name, url, options) {
		HGIS.Layer.TMS.prototype.initialize.apply(this, arguments);
		this.tileOrigin = options.tileOrigin?options.tileOrigin:new HGIS.LonLat(0,0);    
	},
	/**
	 * APIMethod: getURL
	 * 获取访问路径
	 * 
	 * Parameters:
	 * bounds - {Object} 请求范围
	 * 
	 * Returns:
	 * {String} 切片地址
	 */
	getURL: function (bounds) {
		bounds = this.adjustBounds(bounds);
        var res = this.getServerResolution();
        var x = Math.round((bounds.left - this.tileOrigin.lon) / (res * this.tileSize.w));
        var y = Math.round((this.tileOrigin.lat - bounds.bottom ) / (res * this.tileSize.h));
        var z = this.serverResolutions != null ?
            HGIS.Util.indexOf(this.serverResolutions, res) :
            this.getServerZoom();
        if (this.levelSequence === 0) {//比例尺层级升序
			z = this.levelMax - z;
		}
        var path = "?Service=getImage&Type=RGB&Col=" + x + "&Row=" + y
				+ "&Zoom=" + z;//去掉了+ "&V=0.3" 
		if (this.ezZoomOffset != 0) {
			path = path + "&ZoomOffset=" + this.ezZoomOffset;
		}
        var url = this.url.split("^")[0];
        if (HGIS.Util.isArray(url)) {
            url = this.selectUrl(path, url);
        }
        return url + path;
    },
	createBackBuffer:function() {	
		return null;
	},
    clone : function(obj) {
		if (obj == null) {
			obj = new HGIS.Layer.EzLayer(this.name, this.url, this
							.getOptions());
		}
		obj = HGIS.Layer.Grid.prototype.clone.apply(this, [obj]);
		return obj;
	},    
	/**
	 * APIMethod: hide
	 * 隐藏图层
	 */
	hide : function() {
		this.setVisibility(false);
	},
	/**
	 * APIMethod: refresh
	 * 图层刷新
	 */
	refresh : function() {
		this.redraw();
	},
	/**
	 * APIMethod: show
	 * 显示图层
	 */
	show : function() {
		this.setVisibility(true);
	},
	CLASS_NAME : 'HGIS.Layer.EzLayer'
});/**
 * HGIS.Layer.GraphicLayer
 * HGIS虚拟矢量图层,根据要加的要素的类型，选择map对象上合适的矢量图层作为容器， 
 * 如果是{<HGIS.Marker>}要素则添加到map.markerLayer上
 * 如果是{<HGIS.Feature.Vector>} 则添加到Layer.Vector上
 */
HGIS.Layer = HGIS.Layer || {};
HGIS.Layer.GraphicLayer = HGIS.Class({
	graphicLayer : null,
	markerLayer : null,
	markers : null,
	features : null,
	id : null,
	/**
	 ***Constructor: HGIS.Layer.GraphicLayer
	 * 构造方法
	 * 
	 * Parameters: 
	 * id - {String} 图层id 如果为空则自动生成一个hgis_layer_guid 的随机id
	 */
	initialize : function(id) {
		if (!id) {
			this.id = 'hgis_layer_' + HGIS.Util.createUniqueID();
		}
		this.markers = {};
		this.features = {};
	},
	/**
	 * Method: getFeatureFromEvent
	 * 获取事件的宿主要素
	 * 
	 * Parameters:
	 * evt - {Object} 事件
	 */
	getFeatureFromEvent : function(evt) {
		return this.graphicLayer.getFeatureFromEvent(evt);
	},
	/**
	 * Method: add
	 * 添加要素，如果是mark则添加到markLayer 如果是vector 则添加到vectorLayer
	 * 
	 * Parameters:
	 * graphic {<HGIS.Marker>}或者{<HGIS.MarkerEx>}或者{<HGIS.Feature.Vector>}
	 */
	add : function(graphic) {
		var thisObj = this;
		// 如果没有id，添加一个id
		if (!graphic.id) {
			graphic.id = 'hgis_graphic_' + HGIS.Util.createUniqueID();
		}
		if (graphic.CLASS_NAME == 'HGIS.Marker'
				|| graphic.CLASS_NAME == 'HGIS.Marker.MarkerEx') {
			thisObj.markerLayer.addMarker(graphic);
			graphic.layer = thisObj.markerLayer;
			thisObj.markers[graphic.id] = graphic;
		} else if (graphic.CLASS_NAME == 'HGIS.Feature.Vector') {
			thisObj.graphicLayer.addFeatures([ graphic ]);
			thisObj.features[graphic.id] = graphic;
		}
	},
	/**
	 * Method: addMarker
	 * 添加Mark 或MarkEx要素
	 * 
	 * Parameters:
	 * graphic {<HGIS.Marker>}或者{<HGIS.Marker.MarkerEx>}
	 */
	addMarker : function(graphic) {
		if (!graphic.id) {
			graphic.id = 'hgis_graphic_' + HGIS.Util.createUniqueID();
		}
		if (graphic.CLASS_NAME == 'HGIS.Marker'
				|| graphic.CLASS_NAME == 'HGIS.Marker.MarkerEx') {
			this.markerLayer.addMarker(graphic);
			graphic.layer = this.markerLayer;
			this.markers[graphic.id] = graphic;
		}
	},
	/**
	 * Method: removeMarker
	 * 删除Mark 或MarkEx要素
	 * 
	 * Parameters:
	 * graphic {<HGIS.Marker>}或者{<HGIS.MarkerEx>}
	 */
	removeMarker : function(graphic) {
		if (graphic.CLASS_NAME == 'HGIS.Marker'
				|| graphic.CLASS_NAME == 'HGIS.Marker.MarkerEx') {
			this.markerLayer.removeMarker(graphic);
			delete this.markers[graphic.id];
		}
	},
	/**
	 * Method: clearMarkers
	 * 删除Marklayer图层上所有的要素
	 */
	clearMarkers : function() {
		for ( var key in this.markers) {
			this.markerLayer.removeMarker(this.markers[key]);
			delete this.markers[key];
		}
	},
	/**
	 * Method: remove
	 * 删除要素
	 * 
	 * Parameters:
	 * graphic - {<HGIS.Marker>} 或者 {<HGIS.MarkerEx>} 或者 {<HGIS.Feature.Vector>}根据类型不同在相应的图层上删除
	 */
	remove : function(graphic) {
		if (graphic.CLASS_NAME == 'HGIS.Marker'
				|| graphic.CLASS_NAME == 'HGIS.Marker.MarkerEx') {
			this.markerLayer.removeMarker(graphic);
			delete this.markers[graphic.id];
		} else if (graphic.CLASS_NAME == 'HGIS.Feature.Vector') {
			this.graphicLayer.removeFeatures([ graphic ]);
			delete this.features[graphic.id];
		}
	},
	
	/**
	 * Method: clear
	 * 删除markerlayer和vectorlayer上的所有要素
	 */
	clear : function() {
		for ( var key in this.markers) {
			this.markerLayer.removeMarker(this.markers[key]);
			delete this.markers[key];
		}
		for ( var key in this.features) {
			this.graphicLayer.removeFeatures(this.features[key]);
			delete this.features[key];
		}
	},
	
	/**
	 * Method: setMap
	 * 为该类中的图层绑定指定的layer
	 * 
	 * 示例:
	 * (code)
	 *  //方法的实现如下:
	 *  setMap : function(map) {
	 *		this.graphicLayer = map.graphicLayer;
	 *		this.markerLayer = map.markerLayer;
	 *		this.map = map;
	 *	}
	 * (end)
	 */
	setMap : function(map) {
		this.graphicLayer = map.graphicLayer;
		this.markerLayer = map.markerLayer;
		this.map = map;
	},
	/**
	 * Method: addFeatures
	 * 添加多个矢量图形
	 * 
	 * Parameters:
	 * fts - {Array} 一个矢量要素的集合
	 */
	addFeatures : function(fts) {
		for (var i = 0; i < fts.length; i++) {
			var ft = fts[i];
			if (!ft.id) {
				ft.id = 'hgis_graphic_' + HGIS.Util.createUniqueID();
			}
			this.features[ft.id] = ft;
		}
		this.graphicLayer.addFeatures(fts);
	},
	/**
	 * Method:removeFeatures
	 * 移除指定的矢量图形
	 * 
	 * Parameters:
	 * fts - {Array} 一个矢量要素的集合
	 */
	removeFeatures : function(fts) {
		for (var i = 0; i < fts.length; i++) {
			var ft = fts[i];
			this.graphicLayer.removeFeatures([ ft ]);
			delete this.features[ft.id];
		}
	},
	/**
	 * Method: removeAllFeatures
	 * 移除所有矢量图形
	 */
	removeAllFeatures : function() {
		for ( var key in this.features) {
			this.graphicLayer.removeFeatures(this.features[key]);
			delete this.features[key];
		}
	},
	/**
	 * Method: getFeatureBy
	 * 根据属性值获取要素
	 * 
	 * Parameters:
	 * property - {String} 属性名
	 * value - {String} 属性值
	 */
	getFeatureBy : function(property, value) {
		return this.graphicLayer.getFeatureBy(property, value);
	},
	/**
	 * Method: getFeatureById
	 * 根据id获取要素
	 * 
	 * Parameters:
	 * id - {String} 要素id
	 */
	getFeatureById : function(id) {
		return this.graphicLayer.getFeatureById(id);
	},
	/**
	 * Method: getFeatureByFid
	 * 根据fid获取要素
	 * 
	 * Parameters:
	 * fid - {String} 要素fid
	 */
	getFeatureByFid : function(fid) {
		return this.graphicLayer.getFeatureByFid(fid);
	},
	
	/**
	 * Method: getFeaturesByAttribute
	 * 根据属性值获取要素
	 * 
	 * Parameters:
	 * attrName - {String} 属性名
	 * attrValue - {String} 属性值
	 */
	getFeaturesByAttribute : function(attrName, attrValue) {
		return this.graphicLayer.getFeaturesByAttribute(attrName, attrValue);
	},
	/**
	 * Method: clearFeaturesByAttribute
	 * 根据属性名和属性值来删除指定的矢量要素
	 * 
	 * Parameters:
	 * attrName - {String} 属性名
	 * attrValue - {String} 属性值
	 */
	clearFeaturesByAttribute : function(attrName, attrValue) {
		var features=this.graphicLayer.getFeaturesByAttribute(attrName, attrValue);
		for ( var i in features) {
			var feature = features[i];
			this.graphicLayer.removeFeatures(feature);
			delete this.features[feature.id];
		}
	},
	/**
	 * Method: setVisibility
	 * 设置图层可见或者隐藏
	 * 
	 * Parameters:
	 * visible - {Boolean} 可见性
	 */
	setVisibility : function(visible) {
		this.visible = visible ? true : false;
		for ( var i in this.features) {
			var feature = this.features[i];
			var style = feature.style;
			if (!this.visible) {
				style["display"] = "none";
			} else {
				if (style.hasOwnProperty("display")) {
					delete style["display"];
				}
			}
			this.features[i].style = style;
			this.features[i].layer.drawFeature(feature, style);
		}
		// 移除图片标注
		for ( var i in this.markers) {
			this.markers[i].icon.display(this.visible);
		}
	},

	/**
	 * Method: getMarkers
	 * 获取所有的marker
	 * 
	 * Returns:
	 * {Array}
	 */
	getMarkers : function() {
		var mks = [];
		for ( var key in this.markers) {
			mks.push(this.markers[key]);
		}
		return mks;
	},
	/**
	 * Method: getMarkersByAttribute
	 * 根据属性值获取marker
	 * 
	 * Parameters:
	 * attrName - {String} 属性名
	 * attrValue - {String} 属性值
	 */
	getMarkersByAttribute : function(attrName, attrValue) {
		var mks = [];
		for ( var key in this.markers) {
			if(this.markers[key].attributes[attrName]==attrValue){
				mks.push(this.markers[key]);
			}
		}
		return mks;
	},
	/**
	 * Method: redraw
	 * 重绘所有矢量要素
	 */
	redraw : function() {
		for ( var key in this.features) {
			this.graphicLayer.drawFeature(this.features[key]);
		}
	},
	/**
	 * Method: getFeatures
	 * 获取所有的feature
	 * 
	 * Returns:
	 * {Array}
	 */
	getFeatures : function() {
		var fts = [];
		for ( var key in this.features) {
			fts.push(this.features[key]);
		}
		return fts;
	},
	
	/**
	 * Method: hide
	 * 隐藏图层
	 */
	hide : function() {
		this.setVisibility(false);
	},
	
	/**
	 * Method: show
	 * 显示图层
	 */
	show : function() {
		this.setVisibility(true);
	},
	CLASS_NAME : "HGIS.Layer.GraphicLayer"
});




/**
 * Class: HGIS.Layer.HeatMapLayer
 * 热力图。热力图是一种复杂的专题图，基于空间数据量化分析某种现象的发展趋势。考虑到浏览器兼容性怀性能影响，需后台接口配合完成。
 */
HGIS.Layer=HGIS.Layer||{};
HGIS.Layer.HeatLayer = function(option) {
	// WMS参数
	var config = {};
	if (option) {
		config.FORMAT = option.FORMAT ? option.FORMAT : 'image/png';
		config.SERVICE=option.SERVICE?option.SERVICE:"WMS";
		config.VERSION=option.VERSION?option.VERSION:'1.1.1';
		config.REQUEST=option.REQUEST?option.REQUEST:'GetMap';
		//config.SRS=option.SRS?option.SRS:'EPSG:4326';
	} else {
		config = {
			FORMAT : 'image/png',
			SERVICE : 'WMS',
			VERSION : '1.1.1',
			REQUEST : 'GetMap'
//			SRS : 'EPSG:4326'
		};
	}
	config.LAYERS=HGIS.InitParam.map.size.h + '~' + HGIS.InitParam.map.size.w;// 不对外暴露
	config.BBOX=HGIS.InitParam.map.getExtent();

	/**
	 * APIMethod: getLayer
	 * 获取返回的热力图层
	 * 
	 * Parameters:
	 * layerName - {String} 图层名称
	 * layerURL - {String} 图层地址
	 */
	this.getLayer = function(layerName, layerURL) {
		var heatLayer = new HGIS.Layer.WMS(layerName, layerURL, config, {
			opacity : 1,
			singleTile : false,// 注意效率与精度问题
			//ratio:1,
			isBaseLayer : false,
			noMagic : false,
			transitionEffect:"map-resize",
			TRANSPARENT : true
		});
		return heatLayer;
	};
	/**
	 * APIMethod: getConfig
	 * 获取请求配置
	 */
	this.getConfig=function(){
		return config;
	};
};/**
 * Class: HGIS.Layer.Heatmap
 * 热力图。热力图作为独立的图层，基于HGIS.LonLat点位信息，仅限于支持Canvas的浏览器可用。
 * 
 */ 
HGIS.Layer.Heatmap = HGIS.Class(HGIS.Layer, {
	// the heatmap isn't a basic layer by default - you usually want to display the heatmap over another map ;)
	isBaseLayer: false,
	heatmap: null,
	mapLayer: null,
	handler : null,
	// we store the lon lat data, because we have to redraw with new positions on zoomend|moveend
	tmpData: {},
	/**
	 * Constructor: HGIS.Layer.Heatmap
	 * 构造Heatmap新实例
	 * 
	 * Parameters:
	 * style   - {Object} 传入的style参数
	 * name - {String} 图层名字,
	 * map - {Object} map对象 
	 * heatmapOptions - {Object} 热力图配置.例如:
	 *               - - gradient (object)　梯度： 设置热点图的光圈颜色，数值为[0,1]，数值大的在光圈内侧，数值相等则靠下的生效，数值设置不分大小顺序，并可以同时设置很多颜色 ;
	 *                - -     radius (number)  设置光圈的半径大小，值>=0,=0取得是默认值 ;
	 *                - -     visible 显示隐藏;
	 *                - -     element div容器;
	 *                - -     max最大值;
	 *                - -     legend:图例;
	 *              
     * layerOptions - {Object} 图层配置
	 */
    initialize: function(name, map, mLayer, heatmapOptions, layerOptions){
        var heatdiv = document.createElement("div");
        HGIS.Layer.prototype.initialize.apply(this, [name, layerOptions]);
	    heatdiv.style.cssText = "position:absolute;width:"+map.size.w+"px;height:"+map.size.h+"px;";
	    this.div.appendChild(heatdiv); // this will be the heatmaps element
	    heatmapOptions.element = heatdiv;// add to our heatmap.js config
	    this.mapLayer = mLayer;
	    this.map = map;
	    this.heatmap = h337.create(heatmapOptions);//将参数传给h337  create the heatmap with passed heatmap-options
        this.handler = function(){ 
                if(this.tmpData.max){
                    this.updateLayer(); 
                }
        };
	    // on zoomend and moveend we have to move the canvas element and redraw the datapoints with new positions
	    map.events.register("zoomend", this, this.handler);//监听缩放事件，缩放完成后重绘
	    map.events.register("moveend", this, this.handler);//监听移动事件，移动完成后重绘
    },
    
    /** 
    * APIMethod: updateLayer
    * 更新图层,重绘热力图
    */
	updateLayer: function(){
                var pixelOffset = this.getPixelOffset(),
                    el = this.heatmap.get('element');
                // if the pixeloffset e.g. for x was positive move the canvas element to the left by setting left:-offset.y px 
                // otherwise move it the right by setting it a positive value. same for top
                el.style.top = ((pixelOffset.y > 0)?('-'+pixelOffset.y):(Math.abs(pixelOffset.y)))+'px';
                el.style.left = ((pixelOffset.x > 0)?('-'+pixelOffset.x):(Math.abs(pixelOffset.x)))+'px';
                this.setDataSet(this.tmpData);//调用setDataSet方法将我们的数据进行格式化，序列化，以便h337能够正确加载
	},
        getPixelOffset: function () {
            var o = this.mapLayer.map.layerContainerOrigin,
                o_lonlat = new HGIS.LonLat(o.lon, o.lat),
                o_pixel = this.mapLayer.getViewPortPxFromLonLat(o_lonlat),
                c = this.mapLayer.map.center,
                c_lonlat = new HGIS.LonLat(c.lon, c.lat),
                c_pixel = this.mapLayer.getViewPortPxFromLonLat(c_lonlat);
            return { 
                x: o_pixel.x - c_pixel.x,
                y: o_pixel.y - c_pixel.y 
            };

        },
    /**
     * APIMethod: setDataSet
     * setDataSet方法将我们的数据进行格式化，序列化，以便热力图能够正确加载
     * 
     * Parameters:
     * obj - {obj} 数据
     */
	setDataSet: function(obj){
	    var set = {},
		dataset = obj.data,
		dlen = dataset.length, entry, lonlat, pixel;
		set.max = obj.max;
		set.data = [];
		// get the pixels for all the lonlat entries
            while(dlen--){
                entry = dataset[dlen];
//                if(this.projection!=this.map.getProjectionObject()){
//                	 lonlat = entry.lonlat.clone().transform(this.projection, this.map.getProjectionObject());
//                }else{
//                	 lonlat = entry.lonlat;
//                }
                //默认传入数值为对应坐标系的数据,如数据坐标系不符合，请在调用该方法之前进行转换
                lonlat = entry.lonlat;
                pixel = this.roundPixels(this.getViewPortPxFromLonLat(lonlat));
                if(pixel){//如果有值,push
                    set.data.push({x: pixel.x, y: pixel.y, count: entry.count});
                }
            }
	    this.tmpData = obj;
	    this.heatmap.store.setDataSet(set);
	},
	// we don't want to have decimal numbers such as xxx.9813212 since they slow canvas performance down + don't look nice
	roundPixels: function(p){
	    if(p.x < 0 || p.y < 0){  return false;  }
        p.x = (p.x >> 0);
	    p.y = (p.y >> 0);
        return p;
	},
	
	/**
     * APIMethod: addDataPoint
     * 添加单个点
     * 
     * Parameters:
     * lonlat - {obj} 经纬度
     */
	addDataPoint: function(lonlat){// same procedure as setDataSet
	    var pixel = this.roundPixels(this.mapLayer.getViewPortPxFromLonLat(lonlat)), entry = {lonlat: lonlat},   args;
        if(arguments.length == 2){
            entry.count = arguments[1];
        }
        this.tmpData.data.push(entry);
       if(pixel){
            args = [pixel.x, pixel.y];
            if(arguments.length == 2){
                args.push(arguments[1]);
            }
            this.heatmap.store.addDataPoint.apply(this.heatmap.store, args);
       }
	},
	/**
	 * APIProperty: toggle
	 * 显示或隐藏
	 */
	toggle: function(){
		this.heatmap.toggleDisplay();
	},
	/**
	 * APIMethod: destroy
	 * 
	 * 销毁 
	 */
	destroy: function() {
		map.events.unregister("zoomend", this, this.handler);
		map.events.unregister("moveend", this, this.handler);
        HGIS.Layer.prototype.destroy.apply(this, arguments); 
    },
	CLASS_NAME: "HGIS.Layer.Heatmap"
});

/*
 * heatmap.js 1.0 -    JavaScript Heatmap Library
 *
 * Copyright (c) 2011, Patrick Wied (http://www.patrick-wied.at)
 * Dual-licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and the Beerware (http://en.wikipedia.org/wiki/Beerware) license.
 */

(function(w){
    // the heatmapFactory creates heatmap instances
    var heatmapFactory = (function(){

    // store object constructor
    // a heatmap contains a store
    // the store has to know about the heatmap in order to trigger heatmap updates when datapoints get added
    var store = function store(hmap){

        var _ = {
            // data is a two dimensional array
            // a datapoint gets saved as data[point-x-value][point-y-value]
            // the value at [point-x-value][point-y-value] is the occurrence of the datapoint
            data: [],
            // tight coupling of the heatmap object
            heatmap: hmap
        };
        // the max occurrence - the heatmaps radial gradient alpha transition is based on it
        this.max = 1;

        this.get = function(key){
            return _[key];
        };
        this.set = function(key, value){
            _[key] = value;
        };
    }

    store.prototype = {
        // function for adding datapoints to the store
        // datapoints are usually defined by x and y but could also contain a third parameter which represents the occurrence
        addDataPoint: function(x, y){
            if(x < 0 || y < 0)
                return;

            var me = this,
                heatmap = me.get("heatmap"),
                data = me.get("data");

            if(!data[x])
                data[x] = [];

            if(!data[x][y])
                data[x][y] = 0;

            // if count parameter is set increment by count otherwise by 1
            data[x][y]+=(arguments.length<3)?1:arguments[2];
            
            me.set("data", data);
            // do we have a new maximum?
            if(me.max < data[x][y]){
                // max changed, we need to redraw all existing(lower) datapoints
                heatmap.get("actx").clearRect(0,0,heatmap.get("width"),heatmap.get("height"));
                me.setDataSet({ max: data[x][y], data: data }, true);
                return;
            }
            heatmap.drawAlpha(x, y, data[x][y], true);
        },
        setDataSet: function(obj, internal){
            var me = this,
                heatmap = me.get("heatmap"),
                data = [],
                d = obj.data,
                dlen = d.length;
            // clear the heatmap before the data set gets drawn
            heatmap.clear();
            this.max = obj.max;
            // if a legend is set, update it
            heatmap.get("legend") && heatmap.get("legend").update(obj.max);
            
            if(internal != null && internal){
                for(var one in d){
                    // jump over undefined indexes
                    if(one === undefined)
                        continue;
                    for(var two in d[one]){
                        if(two === undefined)
                            continue;
                        // if both indexes are defined, push the values into the array
                        heatmap.drawAlpha(one, two, d[one][two], false);   
                    }
                }
            }else{
                while(dlen--){
                    var point = d[dlen];
                    heatmap.drawAlpha(point.x, point.y, point.count, false);
                    if(!data[point.x])
                        data[point.x] = [];

                    if(!data[point.x][point.y])
                        data[point.x][point.y] = 0;

                    data[point.x][point.y] = point.count;
                }
            }
            heatmap.colorize();
            this.set("data", d);
        },
        exportDataSet: function(){
            var me = this,
                data = me.get("data"),
                exportData = [];

            for(var one in data){
                // jump over undefined indexes
                if(one === undefined)
                    continue;
                for(var two in data[one]){
                    if(two === undefined)
                        continue;
                    // if both indexes are defined, push the values into the array
                    exportData.push({x: parseInt(one, 10), y: parseInt(two, 10), count: data[one][two]});
                }
            }

            return { max: me.max, data: exportData };
        },
        generateRandomDataSet: function(points){
            var heatmap = this.get("heatmap"),
            w = heatmap.get("width"),
            h = heatmap.get("height");
            var randomset = {},
            max = Math.floor(Math.random()*1000+1);
            randomset.max = max;
            var data = [];
            while(points--){
                data.push({x: Math.floor(Math.random()*w+1), y: Math.floor(Math.random()*h+1), count: Math.floor(Math.random()*max+1)});
            }
            randomset.data = data;
            this.setDataSet(randomset);
        }
    };

    var legend = function legend(config){
        this.config = config;

        var _ = {
            element: null,
            labelsEl: null,
            gradientCfg: null,
            ctx: null
        };
        this.get = function(key){
            return _[key];
        };
        this.set = function(key, value){
            _[key] = value;
        };
        this.init();
    };
    legend.prototype = {
        init: function(){
            var me = this,
                config = me.config,
                title = config.title || "Legend",
                position = config.position,
                offset = config.offset || 10,
                gconfig = config.gradient,
                labelsEl = document.createElement("ul"),
                labelsHtml = "",
                grad, element, gradient, positionCss = "";
 
            me.processGradientObject();
            
            // Positioning

            // top or bottom
            if(position.indexOf('t') > -1){
                positionCss += 'top:'+offset+'px;';
            }else{
                positionCss += 'bottom:'+offset+'px;';
            }

            // left or right
            if(position.indexOf('l') > -1){
                positionCss += 'left:'+offset+'px;';
            }else{
                positionCss += 'right:'+offset+'px;';
            }

            element = document.createElement("div");
            element.style.cssText = "border-radius:5px;position:absolute;"+positionCss+"font-family:Helvetica; width:256px;z-index:10000000000; background:rgba(255,255,255,1);padding:10px;border:1px solid black;margin:0;";
            element.innerHTML = "<h3 style='padding:0;margin:0;text-align:center;font-size:16px;'>"+title+"</h3>";
            // create gradient in canvas
            labelsEl.style.cssText = "position:relative;font-size:12px;display:block;list-style:none;list-style-type:none;margin:0;height:15px;";
            

            // create gradient element
            gradient = document.createElement("div");
            gradient.style.cssText = ["position:relative;display:block;width:256px;height:15px;border-bottom:1px solid black; background-image:url(",me.createGradientImage(),");"].join("");

            element.appendChild(labelsEl);
            element.appendChild(gradient);
            
            me.set("element", element);
            me.set("labelsEl", labelsEl);

            me.update(1);
        },
        processGradientObject: function(){
            // create array and sort it
            var me = this,
                gradientConfig = this.config.gradient,
                gradientArr = [];

            for(var key in gradientConfig){
                if(gradientConfig.hasOwnProperty(key)){
                    gradientArr.push({ stop: key, value: gradientConfig[key] });
                }
            }
            gradientArr.sort(function(a, b){
                return (a.stop - b.stop);
            });
            gradientArr.unshift({ stop: 0, value: 'rgba(0,0,0,0)' });

            me.set("gradientArr", gradientArr);
        },
        createGradientImage: function(){
            var me = this,
                gradArr = me.get("gradientArr"),
                length = gradArr.length,
                canvas = document.createElement("canvas"),
                ctx = canvas.getContext("2d"),
                grad;
            // the gradient in the legend including the ticks will be 256x15px
            canvas.width = "256";
            canvas.height = "15";

            grad = ctx.createLinearGradient(0,5,256,10);

            for(var i = 0; i < length; i++){
                grad.addColorStop(1/(length-1) * i, gradArr[i].value);
            }

            ctx.fillStyle = grad;
            ctx.fillRect(0,5,256,10);
            ctx.strokeStyle = "black";
            ctx.beginPath();
 
            for(var i = 0; i < length; i++){
                ctx.moveTo(((1/(length-1)*i*256) >> 0)+.5, 0);
                ctx.lineTo(((1/(length-1)*i*256) >> 0)+.5, (i==0)?15:5);
            }
            ctx.moveTo(255.5, 0);
            ctx.lineTo(255.5, 15);
            ctx.moveTo(255.5, 4.5);
            ctx.lineTo(0, 4.5);
            
            ctx.stroke();

            // we re-use the context for measuring the legends label widths
            me.set("ctx", ctx);

            return canvas.toDataURL();
        },
        getElement: function(){
            return this.get("element");
        },
        update: function(max){
            var me = this,
                gradient = me.get("gradientArr"),
                ctx = me.get("ctx"),
                labels = me.get("labelsEl"),
                labelText, labelsHtml = "", offset;

            for(var i = 0; i < gradient.length; i++){

                labelText = max*gradient[i].stop >> 0;
                offset = (ctx.measureText(labelText).width/2) >> 0;

                if(i == 0){
                    offset = 0;
                }
                if(i == gradient.length-1){
                    offset *= 2;
                }
                labelsHtml += '<li style="position:absolute;left:'+(((((1/(gradient.length-1)*i*256) || 0)) >> 0)-offset+.5)+'px">'+labelText+'</li>';
            }       
            labels.innerHTML = labelsHtml;
        }
    };

    // heatmap object constructor
    var heatmap = function heatmap(config){
        // private variables
        var _ = {
            radius : 40,
            element : {},
            canvas : {},
            acanvas: {},
            ctx : {},
            actx : {},
            legend: null,
            visible : true,
            width : 0,
            height : 0,
            max : false,
            gradient : false,
            opacity: 180,
            premultiplyAlpha: false,
            bounds: {
                l: 1000,
                r: 0,
                t: 1000,
                b: 0
            },
            debug: false
        };
        // heatmap store containing the datapoints and information about the maximum
        // accessible via instance.store
        this.store = new store(this);

        this.get = function(key){
            return _[key];
        };
        this.set = function(key, value){
            _[key] = value;
        };
        // configure the heatmap when an instance gets created
        this.configure(config);
        // and initialize it
        this.init();
    };

    // public functions
    heatmap.prototype = {
        configure: function(config){
                var me = this,
                    rout, rin;

                me.set("radius", config["radius"] || 40);
                me.set("element", (config.element instanceof Object)?config.element:document.getElementById(config.element));
                me.set("visible", (config.visible != null)?config.visible:true);
                me.set("max", config.max || false);
                me.set("gradient", config.gradient || {"0.45": "rgb(0,0,255)", "0.55": "rgb(0,255,255)", "0.65": "rgb(0,255,0)", "0.95": "yellow", "1.0": "rgb(255,0,0)"});    // default is the common blue to red gradient
                me.set("opacity", parseInt(255/(100/config.opacity), 10) || 180);
                me.set("width", config.width || 0);
                me.set("height", config.height || 0);
                me.set("debug", config.debug);
                if(config.legend){
                    var legendCfg = config.legend;
                    legendCfg.gradient = me.get("gradient");
                    me.set("legend", new legend(legendCfg));
                }
                
        },
        resize: function () {
                var me = this,
                    element = me.get("element"),
                    canvas = me.get("canvas"),
                    acanvas = me.get("acanvas");
                canvas.width = acanvas.width = me.get("width") || element.style.width.replace(/px/, "") || me.getWidth(element);
                this.set("width", canvas.width);
                canvas.height = acanvas.height = me.get("height") || element.style.height.replace(/px/, "") || me.getHeight(element);
                this.set("height", canvas.height);
        },

        init: function(){
                var me = this,
                canvas = document.createElement("canvas"),
                acanvas = document.createElement("canvas"),
                ctx = canvas.getContext("2d"),
                actx = acanvas.getContext("2d"),
                element = me.get("element");
                me.initColorPalette();
                me.set("canvas", canvas);
                me.set("ctx", ctx);
                me.set("acanvas", acanvas);
                me.set("actx", actx);
                me.resize();
                canvas.style.cssText = acanvas.style.cssText = "position:absolute;top:0;left:0;z-index:10000000;";
                if(!me.get("visible"))
                    canvas.style.display = "none";

                element.appendChild(canvas);
                if(me.get("legend")){
                    element.appendChild(me.get("legend").getElement());
                }
                
                // debugging purposes only
                if(me.get("debug"))
                    document.body.appendChild(acanvas);
                
                actx.shadowOffsetX = 15000; 
                actx.shadowOffsetY = 15000; 
                actx.shadowBlur = 15; 
        },
        initColorPalette: function(){

            var me = this,
                canvas = document.createElement("canvas"),
                gradient = me.get("gradient"),
                ctx, grad, testData;

            canvas.width = "1";
            canvas.height = "256";
            ctx = canvas.getContext("2d");
            grad = ctx.createLinearGradient(0,0,1,256);

            // Test how the browser renders alpha by setting a partially transparent pixel
            // and reading the result.  A good browser will return a value reasonably close
            // to what was set.  Some browsers (e.g. on Android) will return a ridiculously wrong value.
            testData = ctx.getImageData(0,0,1,1);
            testData.data[0] = testData.data[3] = 64; // 25% red & alpha
            testData.data[1] = testData.data[2] = 0; // 0% blue & green
            ctx.putImageData(testData, 0, 0);
            testData = ctx.getImageData(0,0,1,1);
            me.set("premultiplyAlpha", (testData.data[0] < 60 || testData.data[0] > 70));
            
            for(var x in gradient){
                grad.addColorStop(x, gradient[x]);
            }

            ctx.fillStyle = grad;
            ctx.fillRect(0,0,1,256);

            me.set("gradient", ctx.getImageData(0,0,1,256).data);
        },
        getWidth: function(element){
            var width = element.offsetWidth;
            if(element.style.paddingLeft){
                width+=element.style.paddingLeft;
            }
            if(element.style.paddingRight){
                width+=element.style.paddingRight;
            }

            return width;
        },
        getHeight: function(element){
            var height = element.offsetHeight;
            if(element.style.paddingTop){
                height+=element.style.paddingTop;
            }
            if(element.style.paddingBottom){
                height+=element.style.paddingBottom;
            }

            return height;
        },
        colorize: function(x, y){
                // get the private variables
                var me = this,
                    width = me.get("width"),
                    radius = me.get("radius"),
                    height = me.get("height"),
                    actx = me.get("actx"),
                    ctx = me.get("ctx"),
                    x2 = radius * 3,
                    premultiplyAlpha = me.get("premultiplyAlpha"),
                    palette = me.get("gradient"),
                    opacity = me.get("opacity"),
                    bounds = me.get("bounds"),
                    left, top, bottom, right, 
                    image, imageData, length, alpha, offset, finalAlpha;
                
                if(x != null && y != null){
                    if(x+x2>width){
                        x=width-x2;
                    }
                    if(x<0){
                        x=0;
                    }
                    if(y<0){
                        y=0;
                    }
                    if(y+x2>height){
                        y=height-x2;
                    }
                    left = x;
                    top = y;
                    right = x + x2;
                    bottom = y + x2;

                }else{
                    if(bounds['l'] < 0){
                        left = 0;
                    }else{
                        left = bounds['l'];
                    }
                    if(bounds['r'] > width){
                        right = width;
                    }else{
                        right = bounds['r'];
                    }
                    if(bounds['t'] < 0){
                        top = 0;
                    }else{
                        top = bounds['t'];
                    }
                    if(bounds['b'] > height){
                        bottom = height;
                    }else{
                        bottom = bounds['b'];
                    }    
                }

                image = actx.getImageData(left, top, right-left, bottom-top);
                imageData = image.data;
                length = imageData.length;
                // loop thru the area
                for(var i=3; i < length; i+=4){

                    // [0] -> r, [1] -> g, [2] -> b, [3] -> alpha
                    alpha = imageData[i],
                    offset = alpha*4;

                    if(!offset)
                        continue;

                    // we ve started with i=3
                    // set the new r, g and b values
                    finalAlpha = (alpha < opacity)?alpha:opacity;
                    imageData[i-3]=palette[offset];
                    imageData[i-2]=palette[offset+1];
                    imageData[i-1]=palette[offset+2];
                    
                    if (premultiplyAlpha) {
                    	// To fix browsers that premultiply incorrectly, we'll pass in a value scaled
                    	// appropriately so when the multiplication happens the correct value will result.
                    	imageData[i-3] /= 255/finalAlpha;
                    	imageData[i-2] /= 255/finalAlpha;
                    	imageData[i-1] /= 255/finalAlpha;
                    }
                    
                    // we want the heatmap to have a gradient from transparent to the colors
                    // as long as alpha is lower than the defined opacity (maximum), we'll use the alpha value
                    imageData[i] = finalAlpha;
                }
                // the rgb data manipulation didn't affect the ImageData object(defined on the top)
                // after the manipulation process we have to set the manipulated data to the ImageData object
                image.data = imageData;
                ctx.putImageData(image, left, top);
        },
        drawAlpha: function(x, y, count, colorize){
                // storing the variables because they will be often used
                var me = this,
                    radius = me.get("radius"),
                    ctx = me.get("actx"),
                    max = me.get("max"),
                    bounds = me.get("bounds"),
                    xb = x - (1.5 * radius) >> 0, yb = y - (1.5 * radius) >> 0,
                    xc = x + (1.5 * radius) >> 0, yc = y + (1.5 * radius) >> 0;

                ctx.shadowColor = ('rgba(0,0,0,'+((count)?(count/me.store.max):'0.1')+')');

                ctx.shadowOffsetX = 15000; 
                ctx.shadowOffsetY = 15000; 
                ctx.shadowBlur = 15; 

                ctx.beginPath();
                ctx.arc(x - 15000, y - 15000, radius, 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.fill();
                if(colorize){
                    // finally colorize the area
                    me.colorize(xb,yb);
                }else{
                    // or update the boundaries for the area that then should be colorized
                    if(xb < bounds["l"]){
                        bounds["l"] = xb;
                    }
                    if(yb < bounds["t"]){
                        bounds["t"] = yb;
                    }
                    if(xc > bounds['r']){
                        bounds['r'] = xc;
                    }
                    if(yc > bounds['b']){
                        bounds['b'] = yc;
                    }
                }
        },
        /**
         * 切换显示或隐藏
         */
        toggleDisplay: function(){
                var me = this,
                    visible = me.get("visible"),
                canvas = me.get("canvas");

                if(!visible)
                    canvas.style.display = "block";
                else
                    canvas.style.display = "none";

                me.set("visible", !visible);
        },
        // dataURL export
        getImageData: function(){
                return this.get("canvas").toDataURL();
        },
        clear: function(){
            var me = this,
                w = me.get("width"),
                h = me.get("height");

            me.store.set("data",[]);
            // @TODO: reset stores max to 1
            //me.store.max = 1;
            me.get("ctx").clearRect(0,0,w,h);
            me.get("actx").clearRect(0,0,w,h);
        },
        cleanup: function(){
            var me = this;
            me.get("element").removeChild(me.get("canvas"));
        }
    };

    return {
            create: function(config){
                return new heatmap(config);
            }, 
            util: {
                mousePosition: function(ev){
                    // this doesn't work right
                    // rather use
                    /*
                        // this = element to observe
                        var x = ev.pageX - this.offsetLeft;
                        var y = ev.pageY - this.offsetTop;

                    */
                    var x, y;

                    if (ev.layerX) { // Firefox
                        x = ev.layerX;
                        y = ev.layerY;
                    } else if (ev.offsetX) { // Opera
                        x = ev.offsetX;
                        y = ev.offsetY;
                    }
                    if(typeof(x)=='undefined')
                        return;

                    return [x,y];
                }
            }
        };
    })();
    w.h337 = w.heatmapFactory = heatmapFactory;
})(window);/**
 * Class: HGIS.Layer.MsTile
 * 用于解决大规模点状地物快速渲染的一种特殊图层。一般地，需要服务端配合完成。
 * 
 * 继承自:
 * {<HGIS.Layer.TMS>}
 */
HGIS.Layer = HGIS.Layer || {};
HGIS.Layer.MsTile = HGIS.Class(HGIS.Layer.TMS, {
	/**
	 * Constructor: HGIS.Layer.MsTile
	 * 构造方法
	 * 
	 * Parameters:
	 * name - {String} 图层名称
	 * url - {String} 图层的服务地址:eg http://localhost:1578/ms/
	 * params - {<HGIS.InitParam} 可以为null
	 * 
	 * 示例:
	 * (code)
	 * var url="http://localhost:1578/ms/";
	 * //如果params参数为空 则切片原点默认为(-180,90)
	 * var layer=new HGIS.Layer.MsTile("马氏切片地图",url,null);
	 * map.addLayer(layer);
	 * (end)
	 */
	initialize : function(name,url,params) {
		var newArguments = [];
		newArguments.push(name, url, {}, params);
		HGIS.Layer.TMS.prototype.initialize.apply(this, newArguments);
		this.url = url;
		this.layername = name;
		if(params!=null){
			this.tileOrigin.lon = params.extra.originX;
			this.tileOrigin.lat = params.extra.originY;
			this.resolutions = params.extra.resInfo;
			this.minLevel = params.minLevel;
			this.maxLevel = params.maxLevel;
		}
		
	},
	minLevel : 0,
	maxLevel : 20,
	url : "",
	layername : '.',
	alpha : true,
	type : 'png',
	tileOrigin : new HGIS.LonLat(-180, 90),
	tileOriginCorner : "tl",
	getURL : function(bounds) {
		bounds = this.adjustBounds(bounds);
		var res = this.map.getResolution();
		var center = bounds.getCenterLonLat();
		var col = Math.floor((center.lon - this.tileOrigin.lon)
				/ (res * this.tileSize.w));
		var row = Math.floor((this.tileOrigin.lat - center.lat)
				/ (res * this.tileSize.h));
		var level = this.map.getZoom() * 1 + 1;
		if (isBoundIntersect(HGIS.InitParam.initBound, bounds)
				&& level >= HGIS.InitParam.minLevel
				&& level <= HGIS.InitParam.maxLevel) {
			var tileProxyUrl = msTiledLayerUrl
					+ "?registerLayerName=" + registerLayerName
					+ "&level=" + level + "&col=" + col
					+ "&row=" + row + "&imgType=" + this.type;
			return tileProxyUrl;
		}
		else{
			return  APIAdress + "gisapi/theme/image/none.png";
		}
	},
	isBaseLayer : true,
	createBackBuffer:function() {	
		return null;
	},
	displayInLayerSwitcher : true,
	resolutions : null,
	tileOptions : {
		blankImageUrl : APIAdress + "/gisapi/theme/image/none.png", // 空白图片
		onImageError : function() { // 切片数据加载失败使用空白图片代替
			var img = this.imgDiv;
			if (img.src != null) {
				this.imageReloadAttempts++;
				if (this.imageReloadAttempts <= HGIS.IMAGE_RELOAD_ATTEMPTS) {
					this.setImgSrc(this.layer.getURL(this.bounds));
				} else {
					//HGIS.Element.addClass(img, "olImageLoadError");
					this.events.triggerEvent("loaderror");
					img.src = APIAdress + "gisapi/theme/image/none.png";
					this.onImageLoad();
				}
			}
		}
	},
	CLASS_NAME : "HGIS.Layer.MsTile"
});/**
 * Class: HGIS.Layer.StaticLayer
 * 用于静态地图或者室内图渲染
 * 
 * 继承自:
 * HGIS.Layer.XYZ
 * 
 * 示例:
 * (code)
 * var url="";
 * var options={
 * 		"srid":"4326",
 * 		"rows": [],
 * 		"cols": [],
 * 		"lods":[]
 * };
 * var l=new HGIS.Layer.StaticLayer("室内地图",url,options);
 * (end)
 */
HGIS.Layer = HGIS.Layer || {};
HGIS.Layer.StaticLayer = HGIS
		.Class(
				HGIS.Layer.XYZ,
				{
					type : 'jpg',
					isBaseLayer : true,
					tileOrigin : new HGIS.LonLat(0, 0),
					tileSize : new HGIS.Size(256, 256),
					useScales : false,
					transitionEffect : "",
					resolutions : [],
					overrideDPI : false,
					projection : 'EPSG:4326',
					tileOptions : {
						blankImageUrl : APIAdress + "gisapi/theme/image/none.png", // 空白图片
						onImageError : function() { // 切片数据加载失败使用空白图片代替
							var img = this.imgDiv;
							if (img.src != null) {
								this.imageReloadAttempts++;
								if (this.imageReloadAttempts <= HGIS.IMAGE_RELOAD_ATTEMPTS) {
									this.setImgSrc(this.layer
											.getURL(this.bounds));
								} else {
									//HGIS.Element.addClass(img,"olImageLoadError");
									this.events.triggerEvent("loaderror");
									img.src = APIAdress
											+ "/gisapi/theme/image/none.png";
									this.onImageLoad();
								}
							}
						}
					},
					/**
					 * Constructor: HGIS.Layer.StaticLayer
					 * 构造方法
					 * 
					 */
					initialize : function(name, url, options) {
						HGIS.Util.extend(this, options);
						if (options.srid) {
							this.projection = 'EPSG:' + options.srid;
						}
						if (options.rows && options.cols) {
							this.tileSize = new HGIS.Size(options.rows,
									options.cols);
						}
						this.sphericalMercator = false;
						this.units = 'm';
						this.resolutions = [];
						var n = options.lods.length;
						for (var i = 0; i < n; i++) {
							this.resolutions.push(options.lods[i].resolution);
						}
						this.serverResolutions = this.resolutions;

						this.maxExtent = new HGIS.Bounds(
								options.fullExtent.xmin,
								options.fullExtent.ymin,
								options.fullExtent.xmax,
								options.fullExtent.ymax);

						HGIS.Layer.XYZ.prototype.initialize.apply(this, [
								name, url, HGIS.Util.extend({
									maxExtent : this.maxExtent,
									resolutions : this.resolutions,
									projection : this.projection
								}, options) ]);
					},
					getURL : function(bounds) {
						var xyz = this.getXYZ(bounds);
						var x = xyz.x;
						var y = xyz.y;
						var z = xyz.z;
						var url = this.url;
						var s = '' + x + y + z;

						if (HGIS.Util.isArray(url)) {
							url = this.selectUrl(s, url);
						}
						url = url + "/TileGroup0/${z}-${x}-${y}." + this.type;

						url = HGIS.String.format(url, {
							'x' : x,
							'y' : y,
							'z' : z
						});

						return HGIS.Util.urlAppend(url, HGIS.Util
								.getParameterString(this.params));
					},
					CLASS_NAME : "HGIS.StaticLayer.StaticLayer"
				});
HGIS.Layer = HGIS.Layer || {};
/**
 * Class: HGIS.Layer.TMSLayer
 * TMSLayer，通过分辨率和切图原点来计算行列号的都可以使用该图层来接地图
 * 在部署方案中将mapType 配置为tms，如果服务地址为 http://localhost:4444/g/4/2/1.png 则配地址配成  http://localhost:4444/g/{z}/{y}/{x}.png
 * 可以支持多个图层配置 使用 | 来分隔服务地址 
 */

/**
 * Constructor: HGIS.Layer.TMSLayer
 * 构造方法
 * 
 * Parameters:
 * tileRootPath - {String} 图层服务地址 eg http://localhost:4444/g/{z}/{y}/{x}.png.
 * mapBounds - {String} 地图边界.
 * minZoom - {Int} 最小级别
 * maxZoom - {Int} 最大级别
 * extra -{Object} 参数
 * name - {String} 服务名称
 * 
 * 示例:
 * (code)
 * var url="http://localhost:1578/tiles";
 * //如果params参数为空 则切片原点默认为(-180,90)
 * var layer=new HGIS.Layer.TMSLayer(url,bounds,8,20,{},"矢量地图");
 * map.addLayer(layer);
 * (end)
 */
HGIS.Layer.TMSLayer=function(name, url, params) {
	var thisObj=this;
	thisObj.name=name;
	thisObj.url=url;
	thisObj.params=params;	
	
	this.getTileUrl= function(bounds,tileType,obj) {
		var url_img='';
		bounds = obj.adjustBounds(bounds);
		var res = obj.map.getResolution();
		var center = bounds.getCenterLonLat();
		var col = Math.floor((center.lon - obj.tileOrigin.lon) / (res * obj.tileSize.w));
		var row = Math.floor((obj.tileOrigin.lat - center.lat) / (res * obj.tileSize.h));
		var level = obj.map.getZoom();
		if (level >= obj.minLevel && level <= obj.maxLevel) {
			var tileProxyUrl="";
			var imgFormat = thisObj.url.split("^")[1] != undefined ? thisObj.url.split("^")[1]: "" ;
			if(imgFormat === ""){
				tileProxyUrl=obj.url.split("^")[0].replace("{x}", col).replace("{y}", row).replace("{z}", level);
			}else{
				tileProxyUrl=obj.url.split("^")[0].replace("{x}", col).replace("{y}", row).replace("{z}", level)+ "."+ imgFormat;
			}
			url_img= HGIS.Utils.getSafeAddress(tileProxyUrl);
		}else{			 
			url_img= HGIS.Utils.getSafeAddress(APIAdress+ "/gisapi/theme/image/none.png");			 
		}
		
		if(HGIS.Strategy.Parameters.isCache && HGIS.Strategy.Parameters.isConnected){
			return new Promise(function (resolve,reject) {
				var success_query=function (res) {
					resolve(URL.createObjectURL(res));
                };
                var error_query=function (err) {
					thisObj.takeUrlToIndexedDB(url_img,level);
                    resolve(url_img);
                };
                HGIS.Strategy.Parameters.wtc.query(url_img.hashCode(),level,success_query,error_query);
			})
		}else{
			return url_img;
		}
	};
	
	this.getTileUrl_test = function(bounds,tileType,obj) {
		if(HGIS.Strategy.Parameters.isCache && HGIS.Strategy.Parameters.isConnected){//使用promise
			thisObj.getTileUrl_promise(bounds,tileType,obj);
		}else{//使用原始的方式
			thisObj.getTileUrl_origin(bounds,tileType,obj);
		}
	};
	this.getTileUrl_origin = function(bounds,tileType,obj) {
		var url_img='';
		bounds = obj.adjustBounds(bounds);
		var res = obj.map.getResolution();
		var center = bounds.getCenterLonLat();
		var col = Math.floor((center.lon - obj.tileOrigin.lon) / (res * obj.tileSize.w));
		var row = Math.floor((obj.tileOrigin.lat - center.lat) / (res * obj.tileSize.h));
		var level = obj.map.getZoom();
		if (level >= obj.minLevel && level <= obj.maxLevel) {
			var tileProxyUrl="";
			var imgFormat = thisObj.url.split("^")[1] != undefined ? thisObj.url.split("^")[1]: "" ;
			if(imgFormat === ""){
				tileProxyUrl=obj.url.split("^")[0].replace("{x}", col).replace("{y}", row).replace("{z}", level);
			}else{
				tileProxyUrl=obj.url.split("^")[0].replace("{x}", col).replace("{y}", row).replace("{z}", level)+ "."+ imgFormat;
			}
			url_img= HGIS.Utils.getSafeAddress(tileProxyUrl);			 		 
		}else{			 
			url_img= HGIS.Utils.getSafeAddress(APIAdress+ "/gisapi/theme/image/none.png");			 
		}
		return url_img;
	};
	this.getTileUrl_promise = function(bounds,tileType,obj) {
		var url_img='';
		bounds = obj.adjustBounds(bounds);
		var res = obj.map.getResolution();
		var center = bounds.getCenterLonLat();
		var col = Math.floor((center.lon - obj.tileOrigin.lon) / (res * obj.tileSize.w));
		var row = Math.floor((obj.tileOrigin.lat - center.lat) / (res * obj.tileSize.h));
		var level = obj.map.getZoom();
		if (level >= obj.minLevel && level <= obj.maxLevel) {
			var tileProxyUrl="";
			var imgFormat = thisObj.url.split("^")[1] != undefined ? thisObj.url.split("^")[1]: "" ;
			if(imgFormat === ""){
				tileProxyUrl=obj.url.split("^")[0].replace("{x}", col).replace("{y}", row).replace("{z}", level);
			}else{
				tileProxyUrl=obj.url.split("^")[0].replace("{x}", col).replace("{y}", row).replace("{z}", level)+ "."+ imgFormat;
			}
			url_img= HGIS.Utils.getSafeAddress(tileProxyUrl);
		}else{			 
			url_img= HGIS.Utils.getSafeAddress(APIAdress+ "/gisapi/theme/image/none.png");			 
		}

		return new Promise(function (resolve,reject) {
			var success_query=function (res) {
				resolve(URL.createObjectURL(res));
            };
            var error_query=function (err) {
				thisObj.takeUrlToIndexedDB(url_img,level);
                resolve(url_img);
            };
            HGIS.Strategy.Parameters.wtc.query(url_img.hashCode(),level,success_query,error_query);
			
		});
	};

       this.takeUrlToIndexedDB=function(imgurl,level){
           var xhr = new XMLHttpRequest();
       	   xhr.open("GET", imgurl, true);
           // Set the responseType to blob
           xhr.responseType = "blob";
           xhr.addEventListener("load", function () {
               if (xhr.status === 200) {
                   HGIS.Strategy.Parameters.wtc.insert(imgurl.hashCode(),level,xhr.response);
               }else{
            	   
               }
           }, false);
           // Send XHR
           xhr.send();

    	};

	// 矢量地图
	var vecLayer = new HGIS.Layer.TMS(thisObj.name, thisObj.url, {
		serviceVersion : '.',
		layername : thisObj.name,
		alpha : true,
//		type : thisObj.url.split("^")[1] != undefined ? thisObj.url.split("^")[1]: "png",
		tileOrigin : thisObj.params.tileOrigin,
		tileOriginCorner : "tl",
		tileSize : new HGIS.Size(thisObj.params.tileSize*1, thisObj.params.tileSize*1),
		mapBounds:thisObj.params.extent||thisObj.params.bounds,
		minLevel:thisObj.params.minLevel,
		maxLevel:thisObj.params.maxLevel,
		getURL :function(bounds){
			var url=thisObj.getTileUrl(bounds,thisObj.name,this);
			return url;
		},
		createBackBuffer:function() {	
			return null;
		},
		isBaseLayer : true,
		displayInLayerSwitcher : true,
		resolutions:thisObj.params.resolutions,
		serverResolutions:thisObj.params.resolutions,
		tileOptions : {
			blankImageUrl : HGIS.Utils.getSafeAddress(APIAdress+"/gisapi/theme/image/none.png"), // 空白图片
			onImageError : function() { // 切片数据加载失败使用空白图片代替
				this.createBackBuffer=function() {	
					return null;
			    };
				var img = this.imgDiv;
				if (img.src != null) {
					this.imageReloadAttempts++;
					if (this.imageReloadAttempts <= HGIS.IMAGE_RELOAD_ATTEMPTS) {
						this.setImgSrc(this.layer.getURL(this.bounds));
					} else {
						//HGIS.Element.addClass(img, "olImageLoadError");
						this.events.triggerEvent("loaderror");
						img.src = HGIS.Utils.getSafeAddress(APIAdress+ "/gisapi/theme/image/none.png");
						this.onImageLoad();
					}
				}
			}
		}
	});
	return vecLayer;
};

/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Layer.js
 * @requires HGIS/Renderer.js
 * @requires HGIS/StyleMap.js
 * @requires HGIS/Feature/Vector.js
 * @requires HGIS/Console.js
 * @requires HGIS/Lang.js
 */

/**
 * Class: HGIS.Layer.Vector
 * Instances of HGIS.Layer.Vector are used to render vector data from
 *     a variety of sources. Create a new vector layer with the
 *     <HGIS.Layer.Vector> constructor.
 *
 * Inherits from:
 *  - <HGIS.Layer>
 */
HGIS.Layer.VectorEx = HGIS.Class(HGIS.Layer, {

    /**
     * APIProperty: events
     * {<HGIS.Events>}
     *
     * Register a listener for a particular event with the following syntax:
     * (code)
     * layer.events.register(type, obj, listener);
     * (end)
     *
     * Listeners will be called with a reference to an event object.  The
     *     properties of this event depends on exactly what happened.
     *
     * All event objects have at least the following properties:
     * object - {Object} A reference to layer.events.object.
     * element - {DOMElement} A reference to layer.events.element.
     *
     * Supported map event types (in addition to those from <HGIS.Layer.events>):
     * beforefeatureadded - Triggered before a feature is added.  Listeners
     *      will receive an object with a *feature* property referencing the
     *      feature to be added.  To stop the feature from being added, a
     *      listener should return false.
     * beforefeaturesadded - Triggered before an array of features is added.
     *      Listeners will receive an object with a *features* property
     *      referencing the feature to be added. To stop the features from
     *      being added, a listener should return false.
     * featureadded - Triggered after a feature is added.  The event
     *      object passed to listeners will have a *feature* property with a
     *      reference to the added feature.
     * featuresadded - Triggered after features are added.  The event
     *      object passed to listeners will have a *features* property with a
     *      reference to an array of added features.
     * beforefeatureremoved - Triggered before a feature is removed. Listeners
     *      will receive an object with a *feature* property referencing the
     *      feature to be removed.
     * beforefeaturesremoved - Triggered before multiple features are removed.
     *      Listeners will receive an object with a *features* property
     *      referencing the features to be removed.
     * featureremoved - Triggerd after a feature is removed. The event
     *      object passed to listeners will have a *feature* property with a
     *      reference to the removed feature.
     * featuresremoved - Triggered after features are removed. The event
     *      object passed to listeners will have a *features* property with a
     *      reference to an array of removed features.
     * beforefeatureselected - Triggered before a feature is selected.  Listeners
     *      will receive an object with a *feature* property referencing the
     *      feature to be selected. To stop the feature from being selectd, a
     *      listener should return false.
     * featureselected - Triggered after a feature is selected.  Listeners
     *      will receive an object with a *feature* property referencing the
     *      selected feature.
     * featureunselected - Triggered after a feature is unselected.
     *      Listeners will receive an object with a *feature* property
     *      referencing the unselected feature.
     * beforefeaturemodified - Triggered when a feature is selected to
     *      be modified.  Listeners will receive an object with a *feature*
     *      property referencing the selected feature.
     * featuremodified - Triggered when a feature has been modified.
     *      Listeners will receive an object with a *feature* property referencing
     *      the modified feature.
     * afterfeaturemodified - Triggered when a feature is finished being modified.
     *      Listeners will receive an object with a *feature* property referencing
     *      the modified feature.
     * vertexmodified - Triggered when a vertex within any feature geometry
     *      has been modified.  Listeners will receive an object with a
     *      *feature* property referencing the modified feature, a *vertex*
     *      property referencing the vertex modified (always a point geometry),
     *      and a *pixel* property referencing the pixel location of the
     *      modification.
     * vertexremoved - Triggered when a vertex within any feature geometry
     *      has been deleted.  Listeners will receive an object with a
     *      *feature* property referencing the modified feature, a *vertex*
     *      property referencing the vertex modified (always a point geometry),
     *      and a *pixel* property referencing the pixel location of the
     *      removal.
     * sketchstarted - Triggered when a feature sketch bound for this layer
     *      is started.  Listeners will receive an object with a *feature*
     *      property referencing the new sketch feature and a *vertex* property
     *      referencing the creation point.
     * sketchmodified - Triggered when a feature sketch bound for this layer
     *      is modified.  Listeners will receive an object with a *vertex*
     *      property referencing the modified vertex and a *feature* property
     *      referencing the sketch feature.
     * sketchcomplete - Triggered when a feature sketch bound for this layer
     *      is complete.  Listeners will receive an object with a *feature*
     *      property referencing the sketch feature.  By returning false, a
     *      listener can stop the sketch feature from being added to the layer.
     * refresh - Triggered when something wants a strategy to ask the protocol
     *      for a new set of features.
     */

    /**
     * APIProperty: isBaseLayer
     * {Boolean} The layer is a base layer.  Default is false.  Set this property
     * in the layer options.
     */
    isBaseLayer: false,

    /**
     * APIProperty: isFixed
     * {Boolean} Whether the layer remains in one place while dragging the
     * map. Note that setting this to true will move the layer to the bottom
     * of the layer stack.
     */
    isFixed: false,

    /**
     * APIProperty: features
     * {Array(<HGIS.Feature.Vector>)}
     */
    features: null,   

    /**
     * Property: filter
     * {<HGIS.Filter>} The filter set in this layer,
     *     a strategy launching read requests can combined
     *     this filter with its own filter.
     */
    filter: null,

    /**
     * Property: selectedFeatures
     * {Array(<HGIS.Feature.Vector>)}
     */
    selectedFeatures: null,

    /**
     * Property: unrenderedFeatures
     * {Object} hash of features, keyed by feature.id, that the renderer
     *     failed to draw
     */
    unrenderedFeatures: null,

    /**
     * APIProperty: reportError
     * {Boolean} report friendly error message when loading of renderer
     * fails.
     */
    reportError: true,

    /**
     * APIProperty: style
     * {Object} Default style for the layer
     */
    style: null,

    /**
     * Property: styleMap
     * {<HGIS.StyleMap>}
     */
    styleMap: null,

    /**
     * Property: strategies
     * {Array(<HGIS.Strategy>})} Optional list of strategies for the layer.
     */
    strategies: null,

    /**
     * Property: protocol
     * {<HGIS.Protocol>} Optional protocol for the layer.
     */
    protocol: null,

    /**
     * Property: renderers
     * {Array(String)} List of supported Renderer classes. Add to this list to
     * add support for additional renderers. This list is ordered:
     * the first renderer which returns true for the  'supported()'
     * method will be used, if not defined in the 'renderer' option.
     */
    renderers: ['SVG', 'VML', 'Canvas'],

    /**
     * Property: renderer
     * {<HGIS.Renderer>}
     */
    renderer: null,

    /**
     * APIProperty: rendererOptions
     * {Object} Options for the renderer. See {<HGIS.Renderer>} for
     *     supported options.
     */
    rendererOptions: null,

    /**
     * APIProperty: geometryType
     * {String} geometryType allows you to limit the types of geometries this
     * layer supports. This should be set to something like
     * "HGIS.Geometry.Point" to limit types.
     */
    geometryType: null,

    /**
     * Property: drawn
     * {Boolean} Whether the Vector Layer features have been drawn yet.
     */
    drawn: false,

    /**
     * APIProperty: ratio
     * {Float} This specifies the ratio of the size of the visiblity of the Vector Layer features to the size of the map.
     */
    ratio: 1,
    tileCount:0,
    nowTile:0,
    /**
     * Constructor: HGIS.Layer.Vector
     * Create a new vector layer
     *
     * Parameters:
     * name - {String} A name for the layer
     * options - {Object} Optional object with non-default properties to set on
     *           the layer.
     *
     * Returns:
     * {<HGIS.Layer.Vector>} A new vector layer
     */
    initialize: function(name, options) {
        HGIS.Layer.prototype.initialize.apply(this, arguments);

        // allow user-set renderer, otherwise assign one
        if (!this.renderer || !this.renderer.supported()) {
            this.assignRenderer();
        }

        // if no valid renderer found, display error
        if (!this.renderer || !this.renderer.supported()) {
            this.renderer = null;
            this.displayError();
        }

        if (!this.styleMap) {
            this.styleMap = new HGIS.StyleMap();
        }

        this.features = [];
        this.selectedFeatures = [];
        this.unrenderedFeatures = {};

        // Allow for custom layer behavior
        if(this.strategies){
            for(var i=0, len=this.strategies.length; i<len; i++) {
                this.strategies[i].setLayer(this);
            }
        }

    },

    /**
     * APIMethod: destroy
     * Destroy this layer
     */
    destroy: function() {
        if (this.strategies) {
            var strategy, i, len;
            for(i=0, len=this.strategies.length; i<len; i++) {
                strategy = this.strategies[i];
                if(strategy.autoDestroy) {
                    strategy.destroy();
                }
            }
            this.strategies = null;
        }
        if (this.protocol) {
            if(this.protocol.autoDestroy) {
                this.protocol.destroy();
            }
            this.protocol = null;
        }
        this.destroyFeatures();
        this.features = null;
        this.selectedFeatures = null;
        this.unrenderedFeatures = null;
        if (this.renderer) {
            this.renderer.destroy();
        }
        this.renderer = null;
        this.geometryType = null;
        this.drawn = null;
        HGIS.Layer.prototype.destroy.apply(this, arguments);
    },

    /**
     * Method: clone
     * Create a clone of this layer.
     *
     * Note: Features of the layer are also cloned.
     *
     * Returns:
     * {<HGIS.Layer.Vector>} An exact clone of this layer
     */
    clone: function (obj) {

        if (obj == null) {
            obj = new HGIS.Layer.Vector(this.name, this.getOptions());
        }

        //get all additions from superclasses
        obj = HGIS.Layer.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here
        var features = this.features;
        var len = features.length;
        var clonedFeatures = new Array(len);
        for(var i=0; i<len; ++i) {
            clonedFeatures[i] = features[i].clone();
        }
        obj.features = clonedFeatures;

        return obj;
    },

    /**
     * Method: refresh
     * Ask the layer to request features again and redraw them.  Triggers
     *     the refresh event if the layer is in range and visible.
     *
     * Parameters:
     * obj - {Object} Optional object with properties for any listener of
     *     the refresh event.
     */
    refresh: function(obj) {
        if(this.calculateInRange() && this.visibility) {
            this.events.triggerEvent("refresh", obj);
        }
    },

    /**
     * Method: assignRenderer
     * Iterates through the available renderer implementations and selects
     * and assigns the first one whose "supported()" function returns true.
     */
    assignRenderer: function()  {
        for (var i=0, len=this.renderers.length; i<len; i++) {
            var rendererClass = this.renderers[i];
            var renderer = (typeof rendererClass == "function") ?
                rendererClass :
                HGIS.Renderer[rendererClass];
            if (renderer && renderer.prototype.supported()) {
                this.renderer = new renderer(this.div, this.rendererOptions);
                break;
            }
        }
    },

    /**
     * Method: displayError
     * Let the user know their browser isn't supported.
     */
    displayError: function() {
        if (this.reportError) {
            HGIS.Console.userError(HGIS.i18n("browserNotSupported",
                {renderers: this. renderers.join('\n')}));
        }
    },

    /**
     * Method: setMap
     * The layer has been added to the map.
     *
     * If there is no renderer set, the layer can't be used. Remove it.
     * Otherwise, give the renderer a reference to the map and set its size.
     *
     * Parameters:
     * map - {<HGIS.Map>}
     */
    setMap: function(map) {
        HGIS.Layer.prototype.setMap.apply(this, arguments);

        if (!this.renderer) {
            this.map.removeLayer(this);
        } else {
            this.renderer.map = this.map;
            var newSize = this.map.getSize();
            newSize.w = newSize.w * this.ratio;
            newSize.h = newSize.h * this.ratio;
            this.renderer.setSize(newSize);
        }
    },

    /**
     * Method: afterAdd
     * Called at the end of the map.addLayer sequence.  At this point, the map
     *     will have a base layer.  Any autoActivate strategies will be
     *     activated here.
     */
    afterAdd: function() {
        if(this.strategies) {
            var strategy, i, len;
            for(i=0, len=this.strategies.length; i<len; i++) {
                strategy = this.strategies[i];
                if(strategy.autoActivate) {
                    strategy.activate();
                }
            }
        }
    },

    /**
     * Method: removeMap
     * The layer has been removed from the map.
     *
     * Parameters:
     * map - {<HGIS.Map>}
     */
    removeMap: function(map) {
        this.drawn = false;
        if(this.strategies) {
            var strategy, i, len;
            for(i=0, len=this.strategies.length; i<len; i++) {
                strategy = this.strategies[i];
                if(strategy.autoActivate) {
                    strategy.deactivate();
                }
            }
        }
    },

    /**
     * Method: onMapResize
     * Notify the renderer of the change in size.
     *
     */
    onMapResize: function() {
        HGIS.Layer.prototype.onMapResize.apply(this, arguments);
        var newSize = this.map.getSize();
        newSize.w = newSize.w * this.ratio;
        newSize.h = newSize.h * this.ratio;
        this.renderer.setSize(newSize);
    },

    /**
     * Method: moveTo
     *  Reset the vector layer's div so that it once again is lined up with
     *   the map. Notify the renderer of the change of extent, and in the
     *   case of a change of zoom level (resolution), have the
     *   renderer redraw features.
     *
     *  If the layer has not yet been drawn, cycle through the layer's
     *   features and draw each one.
     *
     * Parameters:
     * bounds - {<HGIS.Bounds>}
     * zoomChanged - {Boolean}
     * dragging - {Boolean}
     */
    moveTo: function(bounds, zoomChanged, dragging) {
    	//this.renderer.features
    	for(var key in this.renderer.features){//重计算原有feature的dxy
    		 var feature=this.renderer.features[key][0];
    		 var originSplit = this.caculateOrigin(feature.origin,this.map.resolution);
             var dxy = this.calculateDXY(originSplit, this.map.getExtent(),this.map.resolution);
             var oldGeom = feature.oldGeometry;
             var geom = feature.geometry;
         	if(feature.type==1){//点  将geometry[0]+dxy.x,geometry[1]+xy
         		geom[0]=oldGeom[0]+dxy.x;
         		geom[1]=oldGeom[1]+dxy.y;
         	}else if(feature.type==2){//线           	 
     	        for (var j = 0,geomLen = oldGeom.length; j < geomLen; j = j + 2) {
     	            if(geom[j]=="|"){
     	            	continue;       	            	 
     	            }
     	            geom[j] =oldGeom[j]+dxy.x;
     	            geom[j + 1] =oldGeom[j+1]+dxy.y; 
     	        }
     	        //处理道路线的名称的坐标	
     	       var oldTextCoordsStr = feature.attributes["oldTextCoords"];
 	            if(oldTextCoordsStr!==undefined&&oldTextCoordsStr!==""){ 	 	           
	            	if(feature.attributes["textCoords"] instanceof  Array){//是数组类型
	            		var oldTextCoordArr = oldTextCoordsStr.split(",");
	            		for(var k=0,kl= oldTextCoordArr.length;k<kl;k++){
	            			 var textCoord = oldTextCoordArr[k].split(" ");
	            			 feature.attributes["textCoords"][k][0] = parseInt(textCoord[0]) + dxy.x; 
	            			 feature.attributes["textCoords"][k][1] = parseInt(textCoord[1]) + dxy.y;
	    	            }
	            	}  
 	            }	            
         	}else if(feature.type==3){//面           	      
     	        for(var j=0,geomLen=oldGeom.length; j<geomLen; j=j+2){
     	            if(geom[j]=='|'){            	                
     	                continue;
     	            }
     	            geom[j] =oldGeom[j]+dxy.x;
     	            geom[j+1] =oldGeom[j+1]+dxy.y;
     	        }        
         	}   
        }// for end
        HGIS.Layer.prototype.moveTo.apply(this, arguments);
        var coordSysUnchanged = true;
        if (!dragging) {
            this.renderer.root.style.visibility = 'hidden';

            var viewSize = this.map.getSize(),
                viewWidth = viewSize.w,
                viewHeight = viewSize.h,
                offsetLeft = (viewWidth / 2 * this.ratio) - viewWidth / 2,
                offsetTop = (viewHeight / 2 * this.ratio) - viewHeight / 2;
            offsetLeft += this.map.layerContainerOriginPx.x;
            offsetLeft = -Math.round(offsetLeft);
            offsetTop += this.map.layerContainerOriginPx.y;
            offsetTop = -Math.round(offsetTop);

            this.div.style.left = offsetLeft + 'px';
            this.div.style.top = offsetTop + 'px';

            var extent = this.map.getExtent().scale(this.ratio);
            coordSysUnchanged = this.renderer.setExtent(extent, zoomChanged);

            this.renderer.root.style.visibility = 'visible';

            // Force a reflow on gecko based browsers to prevent jump/flicker.
            // This seems to happen on only certain configurations; it was originally
            // noticed in FF 2.0 and Linux.
            /*  if (HGIS.IS_GECKO === true) {
                this.div.scrollLeft = this.div.scrollLeft;
            }*/

            if (!zoomChanged && coordSysUnchanged) {            	
            	 for (var i=this.unrenderedFeatures.length-1; i>=0; i--){                      
                     this.drawFeature(this.unrenderedFeatures[i]);
                 }
            }
        }
        if (!this.drawn || zoomChanged || !coordSysUnchanged) {
            this.drawn = true;
            var maxIndex = this.features.length -1;
            for(var i = maxIndex; i>=0; i--) {
                this.renderer.locked = (i !== maxIndex);
                this.drawFeature(this.features[i]);
            }
        }
    },

    /**
     * APIMethod: display
     * Hide or show the Layer
     *
     * Parameters:
     * display - {Boolean}
     */
    display: function(display) {
        HGIS.Layer.prototype.display.apply(this, arguments);
        // we need to set the display style of the root in case it is attached
        // to a foreign layer
        var currentDisplay = this.div.style.display;
        if(currentDisplay != this.renderer.root.style.display) {
            this.renderer.root.style.display = currentDisplay;
        }
    },

    /**
     * APIMethod: addFeatures
     * Add Features to the layer.
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)}
     * options - {Object}
     */
    countTime:0,
    addFeatures: function(features, options) {
        if (!(HGIS.Util.isArray(features))) {
            features = [features];
        }    	 
        var notify = true;
        if(notify) {
            var event = {features: features};
            var ret = this.events.triggerEvent("beforefeaturesadded", event);
            if(ret === false) {
                return;
            }
            features = event.features;
        }
        // Track successfully added features for featuresadded event, since
        // beforefeatureadded can veto single features.
        var featuresAdded = [];
        for (var i=0, len=features.length; i<len; i++) {
            if (i != (features.length - 1)) {
                this.renderer.locked = true;
            } else {
                this.renderer.locked = false;
            }
            var feature = features[i];
            if (this.geometryType && !(feature.geometry instanceof this.geometryType)) {
                throw new TypeError('addFeatures: component should be an ' +
                    this.geometryType.prototype.CLASS_NAME);
            }
            //give feature reference to its layer
            if(options == undefined){
            	feature.layer = this;
            }else{
            	feature.layer = options.layer ;
            }
           /* feature.layer = this;*/
            if (!feature.style && this.style) {
                feature.style = HGIS.Util.extend({}, this.style);
            }else{
                feature.style = this.styleMap.createSymbolizer(feature);
            }
            if (notify) {
                if(this.events.triggerEvent("beforefeatureadded",
                        {feature: feature}) === false) {
                    continue;
                }
                this.preFeatureInsert(feature);
            }
            featuresAdded.push(feature);
            this.features.push(feature);
            this.drawFeature(feature,options);
            if (notify) {
                this.events.triggerEvent("featureadded",{
                    feature: feature
                });
                this.onFeatureInsert(feature);
            }
        }
        if(notify) {
            this.events.triggerEvent("featuresadded", {features: featuresAdded});
        }
    },


    /**
     * APIMethod: removeFeatures
     * Remove features from the layer.  This erases any drawn features and
     *     removes them from the layer's control.  The beforefeatureremoved
     *     and featureremoved events will be triggered for each feature.  The
     *     featuresremoved event will be triggered after all features have
     *     been removed.  To supress event triggering, use the silent option.
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} List of features to be
     *     removed.
     * options - {Object} Optional properties for changing behavior of the
     *     removal.
     *
     * Valid options:
     * silent - {Boolean} Supress event triggering.  Default is false.
     */
    removeFeatures: function(features, options) {
        if(!features || features.length === 0) {
            return;
        }
        if (features === this.features) {
            return this.removeAllFeatures(options);
        }
        if (!(HGIS.Util.isArray(features))) {
            features = [features];
        }
        if (features === this.selectedFeatures) {
            features = features.slice();
        }

        var notify = !options || !options.silent;

        if (notify) {
            this.events.triggerEvent(
                "beforefeaturesremoved", {features: features}
            );
        }

        for (var i = features.length - 1; i >= 0; i--) {
            // We remain locked so long as we're not at 0
            // and the 'next' feature has a geometry. We do the geometry check
            // because if all the features after the current one are 'null', we
            // won't call eraseGeometry, so we break the 'renderer functions
            // will always be called with locked=false *last*' rule. The end result
            // is a possible gratiutious unlocking to save a loop through the rest
            // of the list checking the remaining features every time. So long as
            // null geoms are rare, this is probably okay.
            if (i != 0 && features[i-1].geometry) {
                this.renderer.locked = true;
            } else {
                this.renderer.locked = false;
            }

            var feature = features[i];
            delete this.unrenderedFeatures[feature.id];

            if (notify) {
                this.events.triggerEvent("beforefeatureremoved", {
                    feature: feature
                });
            }

            this.features = HGIS.Util.removeItem(this.features, feature);
            // feature has no layer at this point
            feature.layer = null;

            if (feature.geometry) {
                this.renderer.eraseFeatures(feature);
            }

            //in the case that this feature is one of the selected features,
            // remove it from that array as well.
            if (HGIS.Util.indexOf(this.selectedFeatures, feature) != -1){
                HGIS.Util.removeItem(this.selectedFeatures, feature);
            }

            if (notify) {
                this.events.triggerEvent("featureremoved", {
                    feature: feature
                });
            }
        }

        if (notify) {
            this.events.triggerEvent("featuresremoved", {features: features});
        }
    },

    /**
     * APIMethod: removeAllFeatures
     * Remove all features from the layer.
     *
     * Parameters:
     * options - {Object} Optional properties for changing behavior of the
     *     removal.
     *
     * Valid options:
     * silent - {Boolean} Supress event triggering.  Default is false.
     */
    removeAllFeatures: function(options) {
        var notify = !options || !options.silent;
        var features = this.features;
        if (notify) {
            this.events.triggerEvent(
                "beforefeaturesremoved", {features: features}
            );
        }
        var feature;
        for (var i = features.length-1; i >= 0; i--) {
            feature = features[i];
            if (notify) {
                this.events.triggerEvent("beforefeatureremoved", {
                    feature: feature
                });
            }
            feature.layer = null;
            if (notify) {
                this.events.triggerEvent("featureremoved", {
                    feature: feature
                });
            }
        }
        this.renderer.clear();
        this.features = [];
        this.unrenderedFeatures = {};
        this.selectedFeatures = [];
        if (notify) {
            this.events.triggerEvent("featuresremoved", {features: features});
        }
    },

    /**
     * APIMethod: destroyFeatures
     * Erase and destroy features on the layer.
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} An optional array of
     *     features to destroy.  If not supplied, all features on the layer
     *     will be destroyed.
     * options - {Object}
     */
    destroyFeatures: function(features, options) {
        var all = (features == undefined); // evaluates to true if
                                           // features is null
        if(all) {
            features = this.features;
        }
        if(features) {
            this.removeFeatures(features, options);
            for(var i=features.length-1; i>=0; i--) {
                features[i].destroy();
            }
        }
    },

    /**
     * APIMethod: drawFeature
     * Draw (or redraw) a feature on the layer.  If the optional style argument
     * is included, this style will be used.  If no style is included, the
     * feature's style will be used.  If the feature doesn't have a style,
     * the layer's style will be used.
     *
     * This function is not designed to be used when adding features to
     * the layer (use addFeatures instead). It is meant to be used when
     * the style of a feature has changed, or in some other way needs to
     * visually updated *after* it has already been added to a layer. You
     * must add the feature to the layer for most layer-related events to
     * happen.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     * style - {String | Object} Named render intent or full symbolizer object.
     */
    drawFeature: function(feature, position) {
        // don't try to draw the feature with the renderer if the layer is not drawn itself
        if (!this.drawn) {
            return;
        }
        var style=undefined;//chj 待优化
        if (typeof style != "object") {
            if(!style && feature.state === HGIS.State.DELETE) {
                style = "delete";
            }
            var renderIntent = style || feature.renderIntent;             
            style = feature.style || this.style;
            /*if (!style) {
                style = this.styleMap.createSymbolizer(feature, renderIntent);
            }*/
        } 
        var drawn = this.renderer.drawFeature(feature, style,position);
        if (drawn === false || drawn === null) {
            this.unrenderedFeatures[feature.id] = feature;
        } else {
            delete this.unrenderedFeatures[feature.id];
        }
    },    
    /**
     * Method: eraseFeatures
     * Erase features from the layer.
     *
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)}
     */
    eraseFeatures: function(features) {
        this.renderer.eraseFeatures(features);
    },

    /**
     * Method: getFeatureFromEvent
     * Given an event, return a feature if the event occurred over one.
     * Otherwise, return null.
     *
     * Parameters:
     * evt - {Event}
     *
     * Returns:
     * {<HGIS.Feature.Vector>} A feature if one was under the event.
     */
    getFeatureFromEvent: function(evt) {
        if (!this.renderer) {
            throw new Error('getFeatureFromEvent called on layer with no ' +
                'renderer. This usually means you destroyed a ' +
                'layer, but not some handler which is associated ' +
                'with it.');
        }
        var feature = null;
        var featureId = this.renderer.getFeatureIdFromEvent(evt);
        if (featureId) {
            if (typeof featureId === "string") {
                feature = this.getFeatureById(featureId);
            } else {
                feature = featureId;
            }
        }
        return feature;
    },

    /**
     * APIMethod: getFeatureBy
     * Given a property value, return the feature if it exists in the features array
     *
     * Parameters:
     * property - {String}
     * value - {String}
     *
     * Returns:
     * {<HGIS.Feature.Vector>} A feature corresponding to the given
     * property value or null if there is no such feature.
     */
    getFeatureBy: function(property, value) {
        //TBD - would it be more efficient to use a hash for this.features?
        var feature = null;
        for(var i=0, len=this.features.length; i<len; ++i) {
            if(this.features[i][property] == value) {
                feature = this.features[i];
                break;
            }
        }
        return feature;
    },

    /**
     * APIMethod: getFeatureById
     * Given a feature id, return the feature if it exists in the features array
     *
     * Parameters:
     * featureId - {String}
     *
     * Returns:
     * {<HGIS.Feature.Vector>} A feature corresponding to the given
     * featureId or null if there is no such feature.
     */
    getFeatureById: function(featureId) {
        return this.getFeatureBy('id', featureId);
    },

    /**
     * APIMethod: getFeatureByFid
     * Given a feature fid, return the feature if it exists in the features array
     *
     * Parameters:
     * featureFid - {String}
     *
     * Returns:
     * {<HGIS.Feature.Vector>} A feature corresponding to the given
     * featureFid or null if there is no such feature.
     */
    getFeatureByFid: function(featureFid) {
        return this.getFeatureBy('fid', featureFid);
    },

    /**
     * APIMethod: getFeaturesByAttribute
     * Returns an array of features that have the given attribute key set to the
     * given value. Comparison of attribute values takes care of datatypes, e.g.
     * the string '1234' is not equal to the number 1234.
     *
     * Parameters:
     * attrName - {String}
     * attrValue - {Mixed}
     *
     * Returns:
     * Array({<HGIS.Feature.Vector>}) An array of features that have the
     * passed named attribute set to the given value.
     */
    getFeaturesByAttribute: function(attrName, attrValue) {
        var i,
            feature,
            len = this.features.length,
            foundFeatures = [];
        for(i = 0; i < len; i++) {
            feature = this.features[i];
            if(feature && feature.attributes) {
                if (feature.attributes[attrName] === attrValue) {
                    foundFeatures.push(feature);
                }
            }
        }
        return foundFeatures;
    },

    /**
     * Unselect the selected features
     * i.e. clears the featureSelection array
     * change the style back
     clearSelection: function() {

       var vectorLayer = this.map.vectorLayer;
        for (var i = 0; i < this.map.featureSelection.length; i++) {
            var featureSelection = this.map.featureSelection[i];
            vectorLayer.drawFeature(featureSelection, vectorLayer.style);
        }
        this.map.featureSelection = [];
    },
     */


    /**
     * APIMethod: onFeatureInsert
     * method called after a feature is inserted.
     * Does nothing by default. Override this if you
     * need to do something on feature updates.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     */
    onFeatureInsert: function(feature) {
    },

    /**
     * APIMethod: preFeatureInsert
     * method called before a feature is inserted.
     * Does nothing by default. Override this if you
     * need to do something when features are first added to the
     * layer, but before they are drawn, such as adjust the style.
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>}
     */
    preFeatureInsert: function(feature) {
    },

    /**
     * APIMethod: getDataExtent
     * Calculates the max extent which includes all of the features.
     *
     * Returns:
     * {<HGIS.Bounds>} or null if the layer has no features with
     * geometries.
     */
    getDataExtent: function () {
        var maxExtent = null;
        var features = this.features;
        if(features && (features.length > 0)) {
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    if (maxExtent === null) {
                        maxExtent = new HGIS.Bounds();
                    }
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
    /**
     * 根据行列号计算切片原点坐标
     * @param rowcol 行列号
     * @returns {number[]} 含有x和y值的坐标数组
     */
    caculateOrigin: function(rowcol,resolution){
        var origin = [0,0];
        var b = rowcol.split("-");
        origin[0] = HGIS.InitParam.tileOrigin.lon + (b[1])*256*resolution;
        origin[1] = HGIS.InitParam.tileOrigin.lat - (b[0])*256*resolution;
        return origin;
    },
    /**
     * 根据原点坐标和地图范围计算xy的偏移值
     * @param origin
     * @param extent
     * @returns {{x: number, y: number}}
     */
	calculateDXY: function(origin,extent,resolution){ 
		var x = (origin[0]-extent.left)/resolution;
		x = Math.round(x);
        var y = (extent.top- origin[1]) /resolution;
		y = Math.round(y);
		return {"x":x,"y":y};
	},
    CLASS_NAME: "HGIS.Layer.VectorEx"
});
HGIS.Layer = HGIS.Layer || {};
/**
 * Class: HGIS.Layer.WMTSLayer
 * WMTSLayer，通过获取标准的WMTS服务的元数据来接入地图
 * 在部署方案中将mapType 配置为wmts，如果服务地址为 http://172.17.57.15:7004/DLG_DT_9_20/wmts 则配地址配成  http://172.17.57.15:7004/DLG_DT_9_20/wmts
 */

/**
 * Constructor: HGIS.Layer.WMTSLayer
 * 构造方法
 * 
 * Parameters:
 * url - {String} 图层服务地址. 
 * layer -{Object} 图层名，即地图服务的名称
 * matrixSet - {String} 瓦片矩阵集（金字塔）的名称
 * style - {String} 瓦片矩阵集（金字塔）的名称
 * 
 * 示例:
 * (code)
 * var wmts = new HGIS.Layer.WMTS({
 *     name: "My WMTS Layer",
 *     url: "http://example.com/wmts", 
 *     layer: "layer_id",
 *     style: "default",
 *     matrixSet: "matrix_id"
 * }); 
 * map.addLayer(wmts);
 * (end)
 * 
 * 所需的属性配置如下:
 * url - {String} 服务地址 ，eg http://172.17.57.15:7004/DLG_DT_9_20/wmts .
 * layer - {String} 图层标识符.
 * style - {String} 图层样式标识符，可选参数.
 * matrixSet - {String} 瓦片矩阵集标识符，必设参数. 
 */
HGIS.Layer.WMTSLayer=function(name,url, layer, matrixSet,style,params) {
	var thisObj = this;	
	thisObj.name = name;
	thisObj.url = url.split("^")[0];
	thisObj.layer = layer;
	thisObj.matrixSet = matrixSet;
	thisObj.style = style;
	thisObj.params=params;
	// 加载瓦片地址
	this.getTileUrl = function(bounds,obj) {
		    //bounds = this.adjustBounds(bounds);
	        var url = "";
	        if (!this.tileFullExtent || this.tileFullExtent.intersectsBounds(bounds)) {
	        	var center = bounds.getCenterLonLat();            
	            var info = obj.getTileInfo(center);
	            var matrixId = obj.matrix.identifier;
	            var dimensions = obj.dimensions, params;
	            if (HGIS.Util.isArray(obj.url)) {
	                url = obj.selectUrl([
	                    obj.version, obj.style, obj.matrixSet,
	                    obj.matrix.identifier, info.row, info.col
	                ].join(","), obj.url);
	            } else {
	                url = obj.url;
	            }
	            if (obj.requestEncoding.toUpperCase() === "REST") {
	                params = obj.params;
	                if (url.indexOf("{") !== -1) {
	                    var template = url.replace(/\{/g, "${");
	                    var context = {
	                        // spec does not make clear if capital S or not
	                        style: obj.style, Style: obj.style,
	                        TileMatrixSet: obj.matrixSet,
	                        TileMatrix: obj.matrix.identifier,
	                        TileRow: info.row,
	                        TileCol: info.col
	                    };
	                    if (dimensions) {
	                        var dimension, i;
	                        for (i=dimensions.length-1; i>=0; --i) {
	                            dimension = dimensions[i];
	                            context[dimension] = params[dimension.toUpperCase()];
	                        }
	                    }
	                    url = HGIS.String.format(template, context);
	                } else {
	                    // include 'version', 'layer' and 'style' in tile resource url
	                    var path = obj.version + "/" + obj.layer + "/" + obj.style + "/";
	                    // append optional dimension path elements
	                    if (dimensions) {
	                        for (var i=0; i<dimensions.length; i++) {
	                            if (params[dimensions[i]]) {
	                                path = path + params[dimensions[i]] + "/";
	                            }
	                        }
	                    }
	                    // append other required path elements
	                    path = path + obj.matrixSet + "/" + obj.matrix.identifier + 
	                        "/" + info.row + "/" + info.col + "." + obj.formatSuffix;

	                    if (!url.match(/\/$/)) {
	                        url = url + "/";
	                    }
	                    url = url + path;
	                }
	            } else if (obj.requestEncoding.toUpperCase() === "KVP") {
	                // assemble all required parameters
	                params = {
	                    SERVICE: "WMTS",
	                    REQUEST: "GetTile",
	                    VERSION: obj.version,
	                    LAYER: obj.layer,
	                    STYLE: obj.style,
	                    TILEMATRIXSET: obj.matrixSet,
	                    TILEMATRIX: obj.matrix.identifier,
	                    TILEROW: info.row,
	                    TILECOL: info.col,
	                    FORMAT: obj.format
	                };
	                url = HGIS.Layer.Grid.prototype.getFullRequestString.apply(obj, [params]);
	            }
	            
	            return  HGIS.Utils.getSafeAddress(url);
	        }else{//请求的地图范围超出了地图本身的最大范围，返回空的透明的图片
	        	return HGIS.Utils.getSafeAddress(APIAdress+ "/gisapi/theme/image/none.png");
	        }
	          
	};
	
	var wmtsLayer = new HGIS.Layer.WMTS({
		name: thisObj.name,
		layer: thisObj.layer,	 
		url: thisObj.url,	 
		matrixSet: thisObj.matrixSet,
		style: thisObj.style,
//		matrixIds: matrixIds,
		format:thisObj.params.imageFormat,
		mapBounds:thisObj.params.extent,
		minLevel:thisObj.params.minLevel,
		maxLevel:thisObj.params.maxLevel,
		getURL :function(bounds){
			var url=thisObj.getTileUrl(bounds,this);
			return url;
		},
		createBackBuffer:function() {	
			return null;
		},
		isBaseLayer : true,
		displayInLayerSwitcher : true,	 
		tileOptions : {
			blankImageUrl : HGIS.Utils.getSafeAddress(APIAdress+"/gisapi/theme/image/none.png"), // 空白图片
			onImageError : function() { // 切片数据加载失败使用空白图片代替
				this.createBackBuffer=function() {	
					return null;
			    };
				var img = this.imgDiv;
				if (img.src != null) {
					this.imageReloadAttempts++;
					if (this.imageReloadAttempts <= HGIS.IMAGE_RELOAD_ATTEMPTS) {
						this.setImgSrc(this.layer.getURL(this.bounds));
					} else {
						//HGIS.Element.addClass(img, "olImageLoadError");
						this.events.triggerEvent("loaderror");
						img.src = HGIS.Utils.getSafeAddress(APIAdress+ "/gisapi/theme/image/none.png");
						this.onImageLoad();
					}
				}
			}
		}
	});
	return wmtsLayer;
};/**
 * Class: HGIS.MapEx
 * 扩展HGIS.Map，扩展接口详见方法说明，当然也继承了<HGIS.Map>的所有的接口.
 * 
 * 继承自:
 * <HGIS.Map>
 */
HGIS.MapEx = HGIS.Class(HGIS.Map, {
	map : null,
	
	isLoaded : false,
	/**
	* APIMethod: mapLoaded
	* 地图加载完成后回调方法.
	*/
	mapLoaded : function(){},
	
	/**
	* APIProperty: usedForStaticMap
	* 是否使用静态地图.
	*/
	usedForStaticMap : false,
	container : null,
	drawControls : null,
	
	/**
	* APIProperty: graphicLayer
	* 矢量图层.
	*/
	graphicLayer : null,
	
	/**
	* APIProperty: markerLayer
	* marker图层.
	*/
	markerLayer : null,

    /**
	 * APIProperty: isCache
	 * 是否启动地图瓦片离线缓存策略
     */
    isCache : false,
	
	/**
	 * Constructor: HGIS.MapEx
	 * 创建一个新的地图对象.
	 *
	 * Parameters:
	 * div - {Object} div 页面地图容器,使用IE9(包括IE9)以下版本浏览器,请指定高度数值.
	 * options - {Object} mapType 地图类型。天地图，山海经纬，arcgis发布的地图服务，自定义切片等.取值范围为：HikMap、SpiritMap、SpiritMap_on、GaodeMap、GaodeMap_on、 
	 * 、GoogleMap、GoogleMap_on、ArcGISMap、ArcGISMap_on、EzMap、TMSMap、WMTSMap。
	 *
	 * Examples:
	 * (code)
	 * //创建一个MapEx地图控件
	 * var map=new HGIS.MapEx("mapdiv");
	 *
	 * //创建一个带options的地图控件
	 * var options={
     *     projection: "EPSG:4326",
     *     maxExtent: new HGIS.Bounds(119, 29, 121, 31),
     *     center: new HGIS.LonLat(120, 30)
     * };
	 * var map=new HGIS.MapEx("mapdiv",options);
	 * (end)
	 */
	initialize : function(div, options) {
		//判断是否使用离线缓存
		var that = this;
		if(options && options.hasOwnProperty("isCache") && options.isCache==true){
		    HGIS.Strategy.Parameters.isCache=true;
		    HGIS.Strategy.Parameters.initDB();
		}
		HGIS.Control.prototype.initialize.apply(this, arguments);
		this.id=div.toString();
		this._map =this;
		this.container=div;
		if (!options) {
			options = {};
		}
		this.drawControls = {};
		HGIS.Map.prototype.initialize.apply(this, [div, options]);
		//去掉tileManager,在ie不会出现瓦片一块一块出来的感觉
		this.tileManager.destroy();
		//矢量图层层级调整
		this.Z_INDEX_BASE['Feature'] = this.Z_INDEX_BASE['Overlay'] - 5;
		//添加系统默认图层
		this.graphicLayer = new HGIS.Layer.Vector("系统保留矢量层", {
			displayInLayerSwitcher : false,
			isBaseLayer : false,
			renderers : ['SVG', 'Canvas', 'VML']
		});
		this.markerLayer = new HGIS.Layer.Markers("系统保留图标层");
		this._map.addLayers([this.graphicLayer,this.markerLayer]);
		// 判断地图是否启用矢量切片地图
		that.enableVtMap = false;
		
		//得到地图初始化参数后再初始化map对象
		if(!this.usedForStaticMap){
			//前后端分离 --- 前端加载显示地图
			if(!HGIS.InitParam.isFrontConfig){//走后端的地图配置
				setTimeout(function(){
					HGIS.InitParam.init(mapServerConfigURL.getMapParams,function(){
						//设置最大和最小缩放级
						that._map.maxLevel = HGIS.InitParam.maxLevel;
						that._map.minLevel = HGIS.InitParam.minLevel;
						// 判断矢量切片地图的 启用与否
						if( ( options!= undefined && options.enableVtMap === true ) ){
							that.enableVtMap = true;
						}else if(options!= undefined && options.enableVtMap === false){
							that.enableVtMap = false;
						}else if(options == undefined || options.enableVtMap === undefined ){
							that.enableVtMap = false ;
						}
						if( that.enableVtMap && options.vtStyleName ){
							that._map.vtStyleId = options.vtStyleName;
							HGIS.utils.MapStyleUtil.ifExitVtStyleByUrl(that._map.vtStyleId); //判断服务端是否存在样式文件	
						}
						// 设定初始的 地图基础图层
						that._map.loadMap();
						that._map.isLoaded = true;
						//如果需要纠偏，则从后台获取脱密因子
						if(HGIS.InitParam.factor==1 && HGIS.InitParam.reloadFactor){
							//从服务端获取脱密因子
							HGIS.tools.getFactor();
						}
					});
				},0);	
			}else{  //前后端分离后端加载显示地图
					that._map.maxLevel = HGIS.InitParam.maxLevel;
					that._map.minLevel = HGIS.InitParam.minLevel;
					// 判断矢量切片地图的 启用与否
					if( ( options!= undefined && options.enableVtMap === true ) ){
						that.enableVtMap = true;
					}else if(options!= undefined && options.enableVtMap === false){
						that.enableVtMap = false;
					}else if(options != undefined || options.enableVtMap === undefined ){
						that.enableVtMap = false ;
					}
					
					if( that.enableVtMap){
						that._map.vtStyleId = options.vtStyleName;
						that._map.styleJsonUrl = encodeURI(HGIS.utils.MapStyleUtil.getVtStylePath(that._map.vtStyleId));
					}
					setTimeout(function(){	
						that._map.loadMap();
						that._map.isLoaded = true;
					},0);
			}
		}else{
			setTimeout(function(){
				that._map.initDefaultLayerControl();
				that.mapLoaded.apply(this,arguments);
			},0);					
		}
	},
	setLayerZIndex:function(){
    
	},
	
	/**
	 * 获取地图初始化参数
	 */
	getUnits : function() {
		return HGIS.InitParam.mapUnit;
	},
	/**
	 * APIMethod: removeLayer 
	 * 删除图层
	 * 
	 * Parameter:
	 * layer - {<HGIS.Layer>} 
	 * setNewBaseLayer - {}  
	 */
	removeLayer:function(layer, setNewBaseLayer){
		if(layer.CLASS_NAME=='HGIS.Layer.GraphicLayer'){
			layer.clear();
			return;
		}
		if(this.layerRoot){
			HGIS.Util.removeItem(this.layerRoot.layers, layer);
			}
		HGIS.Map.prototype.removeLayer.apply(this, arguments);
	},
	/**
	 * APIMethod: addLayer
	 * 添加图层.
	 * 
	 * Parameter:
	 * layer - {<HGIS.Layer>} 
	 */
	addLayer:function(layer){
		if(layer.CLASS_NAME=="HGIS.Layer.GraphicLayer"){
			layer.setMap(this);
			return;
		}
		HGIS.Map.prototype.addLayer.apply(this, arguments);
		if(layer.CLASS_NAME =="HGIS.Layer.Vector"||layer.CLASS_NAME =="HgisPlot.Layer.Vector"||"HGIS.Layer.Markers"==layer.CLASS_NAME){
			this.resetVecLayers();
		}
	},
	addLayers:function(layers){
		HGIS.Map.prototype.addLayers.apply(this, arguments);
		this.resetVecLayers();
	},
	resetVecLayers:function(){
		if(this.layerRoot){
			this.layerRoot.removeMap(this);
			this.layerRoot.destroy();
		}
		var vecLayers = [];
		for(var i=0;i<this.layers.length;i++){
			var layer = this.layers[i];
			if(layer.CLASS_NAME =="HGIS.Layer.Vector"||layer.CLASS_NAME =="HgisPlot.Layer.Vector"){
				vecLayers.push(layer);
				layer.setZIndex(this.Z_INDEX_BASE.Feature);
			}else if(layer.CLASS_NAME =="HGIS.Layer.Markers"){
				layer.setZIndex(this.Z_INDEX_BASE.Popup - 1);
			}
		}
		this.layerRoot = new HGIS.Layer.Vector.RootContainer(
		    "root_container", {
		       layers: vecLayers
		   }
		);
		HGIS.Map.prototype.addLayer.apply(this,[this.layerRoot]);
		this.layerRoot.setZIndex(this.Z_INDEX_BASE.Overlay);
	},
	/**
	 * Method: resetLayersZIndex
	 * 重置所有图层的zIndex.
	 * 调用removeLayer的方法时，会自动调用resetLayersZIndex方法，它会根据Z_INDEX_BASE自动分配layer的zindex
	 * 但是最好不要这样做，因为会导致layer的zIndex错乱，因此把覆盖这个方法并置为空,这个方法也不要暴露给api调用者.
	 */
	resetLayersZIndex:function(){
		
	},
	/**
	 * APIMethod: loadMap
	 * 在创建该MapEx对象时会自动调用，会根据地图的初始化参数来初始化地图.
	 */
	loadMap:function(){
		var that = this;
		HGIS.InitParam.map=this;//把map 对象塞进命名空间里
		this._map.maxExtent=HGIS.InitParam.extent;
		if(that.enableVtMap ){//启用矢量切片
			this._map.resolutions = HGIS.InitParam.resolutions;
			if(HGIS.InitParam.hvtUrl != undefined && HGIS.InitParam.hvtUrl !==""  ){ // 为满足前后端分离后的前端独立需求
				hvtUrl = HGIS.InitParam.hvtUrl;//"/GeoData/hvt/${z}/${x}/${y}"
				hvtUrl = hvtUrl.replace("{x}", "${x}").replace("{y}", "${y}").replace("{z}", "${z}");
			}else{
				hvtUrl = HGIS.utils.MapStyleUtil.hvtUrl;
			}
			var format = new HGIS.Format.PBF();
			var strategy = new HGIS.Strategy.Grid();
			var protocol = new HGIS.Protocol.HTTP({ url: hvtUrl + ".hvt", format: format });	
			//var protocol = new HGIS.Protocol.HTTP({ url: hvtUrl , format: format });
			var scales = HGIS.utils.MapStyleUtil.getMapScales(this._map.resolutions,HGIS.InitParam.srid);
			if(HGIS.utils.MapStyleUtil.styleJson==null){
				if(this._map.vtStyleId && this._map.vtStyleId != undefined){
					HGIS.utils.MapStyleUtil.getHvtStyle(that._map.vtStyleId );
				}else{
					HGIS.utils.MapStyleUtil.styleJson = HGIS.utils.MapStyleJSON.data;	
				}		 
				setTimeout(function(){
					that._map.loadMap();
				},25);	//延迟25毫秒后再调用loadMap方法
				return;
			}else{
				var styleMap = HGIS.utils.MapStyleUtil.createStyleMap(HGIS.utils.MapStyleUtil.styleJson,scales);
				var projection;
				if(HGIS.InitParam.srid=="4326"){
					projection =  new HGIS.Projection("EPSG:4326");
				}else{
					projection =  new HGIS.Projection("EPSG:900913");
				}
				var vectors = new HGIS.Layer.VectorEx("Vector", {
					strategies: [strategy],//new HGIS.Strategy.Grid();
					protocol: protocol,// new HGIS.Protocol.HTTP({ url: hvtUrl + ".hvt", format: format });
					styleMap: styleMap,
					renderers:['VectorTile'],
					isBaseLayer: that.baseLayer === "vectorEx" ? true : false ,
					projection: projection
				});
				this._map.addLayer(vectors);	
			}
		}
		
		switch(HGIS.InitParam.mapType.toLowerCase()){
			case "googlemap":
			case "gaodemap":
			case "googlemap_on":
			case "gaodemap_on":
			case "baidumap":
				HGIS.InitParam.mapUnit="m";
				this._map.units="m";
				this._map.projection= "EPSG:900913"; 
	            this._map.displayProjection=new HGIS.Projection("EPSG:900913");
				var urls=HGIS.InitParam.vecUrl.split("|");
				for (var i=0;i<urls.length ;i++ ) {
					var vecLayer = new HGIS.Layer.TMSLayer("vec",urls[i], HGIS.InitParam);
					if(i>0)
						vecLayer.isBaseLayer=false;
					this._map.addLayer(vecLayer);
				}
				if(HGIS.InitParam.imgUrl!=""){
					urls=HGIS.InitParam.imgUrl.split("|");
					for (var j=0;j<urls.length;j++ ) {
						var imgLayer = new HGIS.Layer.TMSLayer("img",urls[j], HGIS.InitParam);
						if(j>0){
							imgLayer.isBaseLayer=false;
						}
						imgLayer.setVisibility(false);	
						this._map.addLayer(imgLayer);
					}
				}
			    break;
			case "hikmap": 
	            this._map.displayProjection=new HGIS.Projection("EPSG:4326");
	            if(HGIS.InitParam.srid=="900913"){
	            	HGIS.InitParam.mapUnit="m";	
	            	this._map.units="m";
					this._map.projection= "EPSG:900913"; 
	            }else{
	            	HGIS.InitParam.mapUnit="degrees";
	            	this._map.units="degrees";
					this._map.projection= new HGIS.Projection("EPSG:4326");
	            }
				var urls=HGIS.InitParam.vecUrl.split("|");
				for (var i=0;i<urls.length ;i++ ) {
					var vecLayer = new HGIS.Layer.TMSLayer("vec",urls[i], HGIS.InitParam);
					if(i>0)
						vecLayer.isBaseLayer=false;
					this._map.addLayer(vecLayer);
				}			
				if(HGIS.InitParam.imgUrl!=""){
					urls=HGIS.InitParam.imgUrl.split("|");
					for (var j=0;j<urls.length;j++ ) {
						var imgLayer = new HGIS.Layer.TMSLayer("img",urls[j], HGIS.InitParam);
						if(j>0){
							imgLayer.isBaseLayer=false;
						}
						imgLayer.setVisibility(false);	
						this._map.addLayer(imgLayer);						 
					}
				}
				break;
			case "spiritmap":
			case "spiritmap_on":
				HGIS.InitParam.mapUnit="degrees";
				this._map.units="degrees";
				this._map.projection= new HGIS.Projection("EPSG:4326"); 
	            this._map.displayProjection=new HGIS.Projection("EPSG:4326");
				var urls=HGIS.InitParam.vecUrl.split("|");
				for (var i=0;i<urls.length ;i++ ) {
					var vecLayer = new HGIS.Layer.TMSLayer("vec",urls[i], HGIS.InitParam);
					if(i>0)
						vecLayer.isBaseLayer=false;
					// 针对于矢量切片地图的加载显示的时候，天地图在线的矢量部分地图不予以显示
					if(that.enableVtMap ){
						vecLayer.setVisibility(false);
					}
					this._map.addLayer(vecLayer);
				}			
				if(HGIS.InitParam.imgUrl!=""){
					urls=HGIS.InitParam.imgUrl.split("|");
					for (var j=0;j<urls.length;j++ ) {
						var imgLayer = new HGIS.Layer.TMSLayer("img",urls[j], HGIS.InitParam);
						if(j>0){
							imgLayer.isBaseLayer=false;
						}
						imgLayer.setVisibility(false);	
						this._map.addLayer(imgLayer);						 
					}
				}
				break;
			case "tmsmap":
				this._map.displayProjection = new HGIS.Projection("EPSG:4326");
				if(HGIS.InitParam.srid=="900913"){
	            	HGIS.InitParam.mapUnit="m";	
	            	this._map.units="m";
					this._map.projection= "EPSG:900913"; 
	            }else{
	            	HGIS.InitParam.mapUnit="degrees";
	            	this._map.units="degrees";
					this._map.projection= new HGIS.Projection("EPSG:4326");
	            }
				var urls=HGIS.InitParam.vecUrl.split("|");
				for (var i=0;i<urls.length ;i++ ) {
					var vecLayer = new HGIS.Layer.TMSLayer("vec",urls[i], HGIS.InitParam);
					if(i>0)
						vecLayer.isBaseLayer=false;
					if(that.enableVtMap ){
						vecLayer.setVisibility(false);
					}
					this._map.addLayer(vecLayer);
				}			
				if(HGIS.InitParam.imgUrl!=""){
					urls=HGIS.InitParam.imgUrl.split("|");
					for (var j=0;j<urls.length;j++ ) {
						var imgLayer = new HGIS.Layer.TMSLayer("img",urls[j], HGIS.InitParam);
						if(j>0){
							imgLayer.isBaseLayer=false;
						}
						imgLayer.setVisibility(false);	
						this._map.addLayer(imgLayer);						 
					}
				}
				if (HGIS.InitParam.tfwUrl != "") {
					urls = HGIS.InitParam.tfwUrl.split("|");
					for (var s = 0; s < urls.length; s++) {
					  var tfwLayer = new HGIS.Layer.TMSLayer("tfw",urls[s], HGIS.InitParam);
					  if (s > 0) {
						tfwLayer.isBaseLayer = false;
					  }
					  tfwLayer.setVisibility(false);
					  this._map.addLayer(tfwLayer);
					}
				 }
				if (HGIS.InitParam.mixedUrl != "") {
					urls = HGIS.InitParam.mixedUrl.split("|");
					for (var t = 0; t < urls.length; t++) {
					  var mixedLayer = new HGIS.Layer.TMSLayer("mixed",urls[t], HGIS.InitParam);
					  if (t > 0) {
						mixedLayer.isBaseLayer = false;
					  }
					  mixedLayer.setVisibility(false);
					  this._map.addLayer(mixedLayer);
					}
				}	
				break;
			case "arcgismap_on"://arcgis 在线地图
				this._map.displayProjection = new HGIS.Projection("EPSG:4326");
				if(HGIS.InitParam.srid=="900913"){
	            	HGIS.InitParam.mapUnit="m";	
	            	this._map.units="m";
					this._map.projection= "EPSG:900913"; 
	            }else{
	            	HGIS.InitParam.mapUnit="degrees";
	            	this._map.units="degrees";
					this._map.projection= new HGIS.Projection("EPSG:4326");
	            }
				var urls=HGIS.InitParam.vecUrl.split("|");
				for (var i=0;i<urls.length ;i++ ) {
					//tileRootPath, mapBounds, minZoom, maxZoom,extra,name
					var vecLayer = new HGIS.Layer.AgsOnLayer(urls[i], HGIS.InitParam.extent,HGIS.InitParam.minLevel,HGIS.InitParam.maxLevel,HGIS.InitParam.resolutions,HGIS.InitParam.tileOrigin,"vec");
					if(i>0)
						vecLayer.isBaseLayer=false;
					this._map.addLayer(vecLayer);
				}
				if(HGIS.InitParam.imgUrl!=""){
					urls=HGIS.InitParam.imgUrl.split("|");
					for (var j=0;j<urls.length;j++ ) {
						var imgLayer = new HGIS.Layer.AgsOnLayer(urls[j], HGIS.InitParam.extent,HGIS.InitParam.minLevel,HGIS.InitParam.maxLevel,HGIS.InitParam.resolutions,HGIS.InitParam.tileOrigin,"img");
						if(j>0){
							imgLayer.isBaseLayer=false;
						}
						imgLayer.setVisibility(false);	
						this._map.addLayer(imgLayer);						 
					}
				}
				break;
			case "arcgismap"://arcgis离线地图				
				this._map.displayProjection=new HGIS.Projection("EPSG:4326");
				if(HGIS.InitParam.srid=="900913"){
	            	HGIS.InitParam.mapUnit="m";	
	            	this._map.units="m";
					this._map.projection= "EPSG:900913"; 
	            }else{
	            	HGIS.InitParam.mapUnit="degrees";
	            	this._map.units="degrees";
					this._map.projection= new HGIS.Projection("EPSG:4326");
	            }
				var urls=HGIS.InitParam.vecUrl.split("|");
				for (var i=0;i<urls.length ;i++ ) {
					//tileRootPath, mapBounds, minZoom, maxZoom,extra,name
					var vecLayer = new HGIS.Layer.AgsOffLayer(urls[i], HGIS.InitParam.extent,HGIS.InitParam.minLevel,HGIS.InitParam.maxLevel,HGIS.InitParam.resolutions,HGIS.InitParam.tileOrigin,"vec");
					if(i>0)
						vecLayer.isBaseLayer=false;
					this._map.addLayer(vecLayer);
				}
				if(HGIS.InitParam.imgUrl!=""){
					urls=HGIS.InitParam.imgUrl.split("|");
					for (var j=0;j<urls.length;j++ ) {
						var imgLayer = new HGIS.Layer.AgsOffLayer(urls[j], HGIS.InitParam.extent,HGIS.InitParam.minLevel,HGIS.InitParam.maxLevel,HGIS.InitParam.resolutions,HGIS.InitParam.tileOrigin,"img");
						if(j>0){
							imgLayer.isBaseLayer=false;
						}
						imgLayer.setVisibility(false);	
						this._map.addLayer(imgLayer);						 
					}
				}
				break;		
			case "ezmap":
				HGIS.InitParam.mapUnit="degrees";
				this._map.units="degrees";
				this._map.projection = new HGIS.Projection("EPSG:4326"); 
	            this._map.displayProjection = new HGIS.Projection("EPSG:4326");
	            
				var resInfo = HGIS.InitParam.resolutions;
				var res = [];
				var level = 0;
				var levelMax = parseInt(HGIS.InitParam.maxLevel);
				var levelOffset = parseInt(HGIS.InitParam.zoomOffset);
				for (var i = 0; i < resInfo.length; i++) {
					if (level < levelOffset) {
						level++;
						continue;
					}
					res.push(Number(resInfo[i]));
					if (levelMax != 0 && (level - levelOffset) >= levelMax) {
						break;
					}
					level++;
				}
				var vecUrl = HGIS.InitParam.vecUrl;
				var rasUrl = HGIS.InitParam.imgUrl;
				var options = {
					levelSequence : parseInt(HGIS.InitParam.levelSequence),
					levelMax : levelMax,
					ezZoomOffset : parseInt(HGIS.InitParam.zoomOffset),
					minLevel : HGIS.InitParam.minLevel,
					maxLevel : HGIS.InitParam.maxLevel,
					resolutions : res,
					mapBounds : HGIS.InitParam.extent,
					tileSize : new HGIS.Size(HGIS.InitParam.tileSize * 1, HGIS.InitParam.tileSize * 1),
					tileOrigin : HGIS.InitParam.tileOrigin
				};
				var vec = new HGIS.Layer.EzLayer("vec", vecUrl, options);
				var img = new HGIS.Layer.EzLayer("img", rasUrl, options);
				this._map.addLayers([ vec, img ]);
				break;
			case "wmtsmap":	
				this._map.displayProjection = new HGIS.Projection("EPSG:4326");
				if(HGIS.InitParam.srid=="900913"){
	            	HGIS.InitParam.mapUnit="m";	
	            	this._map.units="m";
					this._map.projection= "EPSG:900913"; 
	            }else{
	            	HGIS.InitParam.mapUnit="degrees";
	            	this._map.units="degrees";
					this._map.projection= new HGIS.Projection("EPSG:4326");
	            }
				var vecLayer = new HGIS.Layer.WMTSLayer("vec",HGIS.InitParam.vecUrl,HGIS.InitParam.layer,HGIS.InitParam.matrixSet,
						HGIS.InitParam.style,HGIS.InitParam);
				 this._map.addLayers([vecLayer]);
				 
				 if(HGIS.InitParam.imgUrl!=""){		
					 var imgLayer = new HGIS.Layer.WMTSLayer("img",HGIS.InitParam.imgUrl,HGIS.InitParam.layer,HGIS.InitParam.matrixSet,
								HGIS.InitParam.style,HGIS.InitParam);
					 this._map.addLayers([imgLayer]);
				 }
				 break;	
			default:
				break;				
		}
		//添加切换控件
		setTimeout(function(){
			var layerSwitch=new HGIS.Control.LayerSwitch();
			layerSwitch.setMap(that._map);
			that._map.addControl(layerSwitch);
		},0)

		this._map.initDefaultLayerControl();
		this._map.setCenter( this._map.center || HGIS.InitParam.center, HGIS.InitParam.initLevel,false,true);	//强制按级别定位	
		this.mapLoaded.apply(this,arguments);
	},
	/**
     * APIMethod: moveTo
     * 重写moveTo方法，使restrictedExtent参数有效，缩小地图时不能超过这个范围.
     * 
     * Parameters:
     * lonlat - {<HGIS.LonLat>}
     * zoom - {Integer}
     * options - {Object}
     */
    moveTo: function(lonlat, zoom, options) {
    	if(this._map.baseLayer==null){
    		return;
    	}
        if (lonlat != null && !(lonlat instanceof HGIS.LonLat)) {
            lonlat = new HGIS.LonLat(lonlat);
        }
        if (!options) { 
            options = {};
        }
        if (zoom != null) {
            zoom = parseFloat(zoom);
            if (!this.fractionalZoom) {
                zoom = Math.round(zoom);
            }
        }
        var requestedZoom = zoom;
        zoom = this.adjustZoom(zoom);
        if (zoom !== requestedZoom) {
            // zoom was adjusted, so keep old lonlat to avoid panning
            lonlat = this.getCenter();
        }
        // dragging is false by default
        var dragging = options.dragging || this.dragging;
        // forceZoomChange is false by default
        var forceZoomChange = options.forceZoomChange;

        if (!this.getCachedCenter() && !this.isValidLonLat(lonlat)) {
            lonlat = this.maxExtent.getCenterLonLat();
            this.center = lonlat.clone();
        }

        if(this.restrictedExtent != null) {
            // In 3.0, decide if we want to change interpretation of maxExtent.
            if(lonlat == null) { 
                lonlat = this.center; 
            }
            if(zoom == null) { 
                zoom = this.getZoom(); 
            }
            var resolution = this.getResolutionForZoom(zoom);
            var extent = this.calculateBounds(lonlat, resolution); 
            if(!this.restrictedExtent.containsBounds(extent)) {
                var maxCenter = this.restrictedExtent.getCenterLonLat(); 
                if(extent.getWidth() > this.restrictedExtent.getWidth()) { 
                    lonlat = new HGIS.LonLat(maxCenter.lon, lonlat.lat); 
                } else if(extent.left < this.restrictedExtent.left) {
                    lonlat = lonlat.add(this.restrictedExtent.left -
                                        extent.left, 0); 
                } else if(extent.right > this.restrictedExtent.right) { 
                    lonlat = lonlat.add(this.restrictedExtent.right -
                                        extent.right, 0); 
                } 
                if(extent.getHeight() > this.restrictedExtent.getHeight()) { 
                    lonlat = new HGIS.LonLat(lonlat.lon, maxCenter.lat); 
                } else if(extent.bottom < this.restrictedExtent.bottom) { 
                    lonlat = lonlat.add(0, this.restrictedExtent.bottom -
                                        extent.bottom); 
                } 
                else if(extent.top > this.restrictedExtent.top) { 
                    lonlat = lonlat.add(0, this.restrictedExtent.top -
                                        extent.top); 
                } 
                //当地图zoom小于限制视野时，zoom等于限制的视野，这样不会出现地图消失的情况
                if(zoom<=this.getZoomForExtent(this.restrictedExtent)){
                	zoom = this.getZoomForExtent(this.restrictedExtent);
                }
            }
        }
        //限制最小和最小级别
        if(zoom>this._map.maxLevel){
			zoom = this._map.maxLevel;
		}
		if(zoom<this._map.minLevel){
			zoom=this._map.minLevel;
		}
        var zoomChanged = forceZoomChange || (
                            (this.isValidZoomLevel(zoom)) && 
                            (zoom != this.getZoom()) );

        var centerChanged = (this.isValidLonLat(lonlat)) && 
                            (!lonlat.equals(this.center));

        // if neither center nor zoom will change, no need to do anything
        if (zoomChanged || centerChanged || dragging) {
            dragging || this.events.triggerEvent("movestart", {
                zoomChanged: zoomChanged
            });

            if (centerChanged) {
                if (!zoomChanged && this.center) { 
                    // if zoom hasnt changed, just slide layerContainer
                    //  (must be done before setting this.center to new value)
                    this.centerLayerContainer(lonlat);
                }
                this.center = lonlat.clone();
            }

            var res = zoomChanged ?
                this.getResolutionForZoom(zoom) : this.getResolution();
            // (re)set the layerContainerDiv's location
            if (zoomChanged || this.layerContainerOrigin == null) {
                this.layerContainerOrigin = this.getCachedCenter();
                this.layerContainerOriginPx.x = 0;
                this.layerContainerOriginPx.y = 0;
                this.applyTransform();
                var maxExtent = this.getMaxExtent({restricted: true});
                var maxExtentCenter = maxExtent.getCenterLonLat();
                var lonDelta = this.center.lon - maxExtentCenter.lon;
                var latDelta = maxExtentCenter.lat - this.center.lat;
                var extentWidth = Math.round(maxExtent.getWidth() / res);
                var extentHeight = Math.round(maxExtent.getHeight() / res);
                this.minPx = {
                    x: (this.size.w - extentWidth) / 2 - lonDelta / res,
                    y: (this.size.h - extentHeight) / 2 - latDelta / res
                };
                this.maxPx = {
                    x: this.minPx.x + Math.round(maxExtent.getWidth() / res),
                    y: this.minPx.y + Math.round(maxExtent.getHeight() / res)
                };
            }

            if (zoomChanged) {
                this.zoom = zoom;
                this.resolution = res;
            }    
            
            var bounds = this.getExtent();
            
            //send the move call to the baselayer and all the overlays    

            if(this.baseLayer.visibility) {
                this.baseLayer.moveTo(bounds, zoomChanged, options.dragging);
                options.dragging || this.baseLayer.events.triggerEvent(
                    "moveend", {zoomChanged: zoomChanged}
                );
            }
            
            bounds = this.baseLayer.getExtent();
            
            for (var i=this.layers.length-1; i>=0; --i) {
                var layer = this.layers[i];
                if (layer !== this.baseLayer && !layer.isBaseLayer) {
                    var inRange = layer.calculateInRange();
                    if (layer.inRange != inRange) {
                        // the inRange property has changed. If the layer is
                        // no longer in range, we turn it off right away. If
                        // the layer is no longer out of range, the moveTo
                        // call below will turn on the layer.
                        layer.inRange = inRange;
                        if (!inRange) {
                            layer.display(false);
                        }
                        this.events.triggerEvent("changelayer", {
                            layer: layer, property: "visibility"
                        });
                    }
                    if (inRange && layer.visibility) {
                        layer.moveTo(bounds, zoomChanged, options.dragging);
                        options.dragging || layer.events.triggerEvent(
                            "moveend", {zoomChanged: zoomChanged}
                        );
                    }
                }                
            }
            
            this.events.triggerEvent("move");
            dragging || this.events.triggerEvent("moveend");

            if (zoomChanged || centerChanged) {
                //redraw popups
            	var bound = this.getExtent();
                for (var i=0, len=this.popups.length; i<len; i++) {
                	//this.popups[i].updatePosition();
                	var lonlat = this.popups[i].lonlat;
                	var flag = false;
                	// 判断弹框位置点是否超出视图范围
                	if(lonlat.lon < bound.right && lonlat.lon > bound.left && lonlat.lat > bound.bottom && lonlat.lat < bound.top ){
                		flag = true ; // 视图内为 true 
                	}
                	// 在视图内部时进行重绘 && 更改位置
                	if(this.popups[i].changeAnchorIfOutOfView == true && flag == true){
                		this.popups[i].draw();
                		this.popups[i].updatePosition();
                	}else if(this.popups[i].changeAnchorIfOutOfView == true && flag == false){// 如果需要改变锚点的情况下，同时已经超出了地图的范围，此时将地图弹框予以销毁
                		this.popups[i].destroy();												//，不在进行变换 
                	}else if(this.popups[i].changeAnchorIfOutOfView == false){// 如在不需要改变锚点和超出视图的情况下，只更新位置信息，是否关闭有应用层面来控制
                		this.popups[i].updatePosition();
                	}else{  // (this.popups[i].changeAnchorIfOutOfView == undefined)  针对
                		this.popups[i].updatePosition();
                	}
                }
				//当级别改变时才触发zoomend事件
				if(zoomChanged){
					this.events.triggerEvent("zoomend");
				}
            }
            
        }
    },
    /**
     * APIMethod: initDefaultLayerControl
     * 给地图绑定默认的Control.
     * 包括：HGIS.Control.SelectFeature，HGIS.Control.ModifyFeature
     */
	initDefaultLayerControl : function(){
		this._map.graphicLayer.events.register('beforefeaturemodified', this._map.graphicLayer, function(evt) {
				var feature = evt.feature;
				if (feature.events && feature.events.listeners['beforefeaturemodified']) {
					var events = feature.events.listeners['beforefeaturemodified'];
					for (var i = 0; i < events.length; i++) {
						events[i].func.apply(feature, [evt]);
					}
				}
			});

		this._map.graphicLayer.events.register('featuremodified', this._map.graphicLayer, function(evt) {
			var feature = evt.feature;
			if (feature.events && feature.events.listeners['featuremodified']) {
				var events = feature.events.listeners['featuremodified'];
				for (var i = 0; i < events.length; i++) {
					events[i].func.apply(feature, [evt]);
				}
			}
		});

		this._map.graphicLayer.events.register('afterfeaturemodified', this._map.graphicLayer, function(evt) {
			var feature = evt.feature;
			if (feature.events && feature.events.listeners['afterfeaturemodified']) {
				var events = feature.events.listeners['afterfeaturemodified'];
				for (var i = 0; i < events.length; i++) {
					events[i].func.apply(feature, [evt]);
				}
			}
		});

		this._map.graphicLayer.modify = new HGIS.Control.ModifyFeature(this._map.graphicLayer, {
			mode : HGIS.Control.ModifyFeature.DRAG | HGIS.Control.ModifyFeature.RESHAPE,
			toggle : false,
			clickout : true,
			standalone : true,
			autoActivate : true,
			documentDrag : false,
			handleMapEvents:function(evt){
				if (evt.property == "order") {
					this.moveLayerToTop();
				}
			}
		});
		//默认不激活，在需要使用的时候激活		
		this._map.addControl(this._map.graphicLayer.modify);
		this._map.graphicLayer.modify.deactivate();
		
		var isdelay = false;
		var isdoubleclick = false;
		var timer = null;
		this._map.selectFeatureControl = new HGIS.Control.SelectFeature(this._map.graphicLayer, {
			callbacks : {
				click : function(currentFeature) {
					if (!isdelay) {
						isdelay = true;
						isdoubleclick = false;
						timer = setTimeout(function() {
							if (!isdoubleclick) {
								isdoubleclick = false;
								isdelay = false;
								if (currentFeature.events && currentFeature.events.listeners["click"] !== undefined) {
									var events = currentFeature.events.listeners["click"];
									for (var i = 0; i < events.length; i++) {
										events[i].func.apply(currentFeature, [currentFeature]);
									}
								}
								clearTimeout(timer);
							}
						}, 200);
					}
				},
				dblclick : function(currentFeature) {
					if(timer){
						clearTimeout(timer);
						timer = null;
					}
					isdoubleclick = true;
					isdelay = false;
					if (currentFeature.events && currentFeature.events.listeners["dblclick"] !== undefined) {
						var events = currentFeature.events.listeners["dblclick"];
						for (var i = 0; i < events.length; i++) {
							events[i].func.apply(currentFeature, [currentFeature]);
						}
					}
				},
				over : function(currentFeature) {
					if (currentFeature.events && currentFeature.events.listeners["mouseover"] !== undefined) {
						var events = currentFeature.events.listeners["mouseover"];
						for (var i = 0; i < events.length; i++) {
							events[i].func.apply(currentFeature, [currentFeature]);
						}
					}
				},
				out : function(currentFeature) {
					if (currentFeature.events && currentFeature.events.listeners["mouseout"] !== undefined) {
						var events = currentFeature.events.listeners["mouseout"];
						for (var i = 0; i < events.length; i++) {
							events[i].func.apply(currentFeature, [currentFeature]);
						}
					}
				},
				rightClick:function(currentFeature){
					if (currentFeature.events && currentFeature.events.listeners["rightclick"] !== undefined) {
						var events = currentFeature.events.listeners["rightclick"];
						for (var i = 0; i < events.length; i++) {
							events[i].func.apply(currentFeature, [currentFeature]);
						}
					}
				}
			},
			// 添加点击事件
			hover : false
		});
		this._map.selectFeatureControl.handlers.feature.stopDown = false;
		//解决矢量图层zindex增加的问题
		this._map.selectFeatureControl.handlers.feature.handleMapEvents = function(evt){
			if (evt.property == "order") {
				this.moveLayerToTop();
			}
		};
		this._map.addControl(this._map.selectFeatureControl);
		this._map.selectFeatureControl.activate();
	},
	/**
	 * APIMethod: getDefaultRenderer
	 * 获取默认的矢量图层渲染器.
	 */
	getDefaultRenderer : function() {
		var renderer = HGIS.Util.getParameters(window.location.href).renderer;
		renderer = (renderer) ? [renderer] : HGIS.Layer.Vector.prototype.renderers;
		return renderer;
	},
	/**
	 * APIMethod: clear
	 * 清除地图上所有矢量图层（非底图）中的要素.
	 * 该方法不移除图层本身，清除内容包括feature,vector,弹框.
	 */
	clear : function() {
		var layers = this._map.layers;
		for ( var i = 0; i < layers.length; i = i + 1) {
				
				if (layers[i].features) {// 清理条件：非底图、且为地图叠加层
				 layers[i].removeAllFeatures();
			    }else if(layers[i].CLASS_NAME=="HGIS.GraphicLayer"){
					layers[i].clear();				
				}else if(layers[i].CLASS_NAME=="HGIS.Layer.Markers"){
					layers[i].clearMarkers();
				}
		}
		var popups = this._map.popups;// 清除弹框
			for ( var i = 0; i < popups.length; i = i + 1) {
				this.removePopup(popups[i]);
			}
	},

	/**
	 * APIMethod: measureArea
	 * 测面积
	 * 
	 * Parameters:
	 * callback -{<HGIS.Function>} 回调函数，包含了测量结果
	 */
	measureArea : function(callback) {
		this.flag = false;
		// 存在测面积组件则激活
		for ( var i = 0; i < this._map.controls.length; i = i + 1) {
			if (this._map.controls[i].type == 9) {
				areaMeasure = this._map.controls[i].activate();
				this.flag = true;
				break;
			}
		}
		// 不存在测面积组件则创建一个
		if (!this.flag) {
			var areaMeasure = new HGIS.Control.Measure(HGIS.Handler.Polygon, {
				persist : true,
				type : 9,
				eventListeners : {
					"measure" : function(event) {
						callback(event);
						areaMeasure.deactivate();
					}
				},
				handlerOptions : {
					layerOptions : {
						styleMap : new HGIS.StyleMap({
							strokeWidth : 2,
							strokeOpacity : 1,
							strokeColor : "#666666",
							fillColor : "white",
							fillOpacity : 0.3
						})
					}
				}
			});
			this.addControl(areaMeasure);
			areaMeasure.activate();
		}
	},
	
	/**
	 * APIMethod: measureDist
	 * 测距离.
	 * 
	 * Parameters:
	 * callback -{<HGIS.Function>} 回调函数，包含了测量结果
	 */
	measureDist : function(callback) {
		this.flag = false;
		// 存在则激活，
		for ( var i = 0; i < this._map.controls.length; i = i + 1) {
			if (this._map.controls[i].type == 10) {
				this._map.controls[i].activate();
				this.flag = true;
				break;
			}
		}
		// 不存在创建并激活
		if (!this.flag) {
			var control = new HGIS.Control.Measure(HGIS.Handler.Path, {
				type : 10,
				persist : true,
				eventListeners : {
					"measure" : function(event) {
						callback(event);
						control.deactivate();
					}
				},
				handlerOptions : {
					layerOptions : {
						styleMap : new HGIS.StyleMap({
							strokeWidth : 3,
							strokeOpacity : 1,
							strokeColor : "#666666",
							strokeDashstyle : "dash"
						})
					}
				}
			});
			this._map.addControl(control);
			control.activate();
		}
	},
	/**
	 * APIMethod: zoomInExt
	 * 拉框放大控件.
	 * 
	 * Parameters:
	 * keepOn -{Boolean} 是否保持当前状态
	 */
	zoomInExt : function(keepOn) {
			var that = this;
			var control;
			var layer = this._map.getDefaultLayer();
			if (!this.drawControls["rectangle"]) {
					control = new HGIS.Control.DrawFeature(layer, HGIS.Handler.RegularPolygon, {
						handlerOptions : {
							sides : 4,
							irregular : true
						}
					});
					this.drawControls["rectangle"] = control;
					this.addControl(control);
				} else {
						control = this.drawControls["rectangle"];
					}
			control.activate();
			control.events.remove("featureadded");
			control.events.on({
				"featureadded" : function(evt) {
					var center = evt.feature.geometry.bounds.getCenterLonLat();
					that._map.setCenter(center, that._map.getZoom() + 1, false, false);
					evt.object.layer.removeFeatures([evt.feature]);
					//不继续拉框的情况下，禁用当前控件
					if(!keepOn){
						control.deactivate();
					}
				}
			});
	
	},
	/**
	 * APIMethod: zoomOutExt
	 * 拉框缩小控件.
	 * 
	 * Parameters:
	 * keepOn -{Boolean} 是否保持当前状态
	 */
	zoomOutExt : function(keepOn) {
		 var that = this;
		 var control;
		 var layer = this._map.getDefaultLayer();
			if (!this.drawControls["rectangle"]) {
				control = new HGIS.Control.DrawFeature(layer, HGIS.Handler.RegularPolygon, {
					handlerOptions : {
						sides : 4,
						irregular : true
					}
				});
				this.drawControls["rectangle"] = control;
				this.addControl(control);
			} else {
				control = this.drawControls["rectangle"];
			}
			control.activate();
			control.events.remove("featureadded");
			control.events.on({
				"featureadded" : function(evt) {
					var center = evt.feature.geometry.bounds.getCenterLonLat();
					that._map.setCenter(center, that._map.getZoom() - 1, false, false);
					evt.object.layer.removeFeatures([evt.feature]);
					//不继续拉框的情况下，禁用当前控件
					if(!keepOn){
						control.deactivate();
					}
				}
			});
			
	
	},
	/**
	 * APIMethod: hisNav
	 * 前后视图控件.
	 */
	hisNav : function() {
	// 存在则激活
		var nav = "undefind";
		for ( var i = 0; i < this._map.controls.length; i = i + 1) {
			if (this._map.controls[i].type == 6) {
				nav = this._map.controls[i];
				nav.activate();
				break;
			}
		}
		// 不存在则创建并激活
		if (nav == "undefind") {
			nav = new HGIS.Control.NavigationHistory();
			nav.type = 6;
			this._map.addControl(nav);
			nav.activate();
		}
		return nav;
	},
	/**
	 * APIMethod: stopdraw
	 * 停止地图绘制.
	 */
	stopdraw : function() {
		for (var control in this.drawControls) {
			this.drawControls[control].deactivate();
		}
		this.curDrawControl = null;
		this.hideTip();
	},
	maximizeChanged:false,
	/**
	 * APIMethod: draw
	 * 绘制几何体.
	 * 
	 * Parameters:
	 * type - {String}支持绘制以下7种类型。point：点；polyline：折线；freeline:流式线；circle：圆；ellipse：椭圆；polygon：任意多边形；rectangle：矩形
	 * layer - {<HGIS.Layer.Vecotr>} 
	 * resFormat - {String}返回的数据格式。支持wkt，默认为geometry
	 * title - {String}绘制显示的提示信息。null表示不显示提示信息
	 * callback - {<HGIS.Function>}回调函数。回调对象的参数中包含了空间几何体
	 * cancelback - {<HGIS.Function>}Esc取消操作回调函数
	 * options - {String} 绘制操作结束后的可选参数。
	 * 
	 * 可选参数：
	 * * keepOn:画完之后是否继续，true 为继续画，false停止绘制；
	 * * ifClear,画完之后的图形是否要保留在地图上，为true时不保留，为false时保留 
	 */
	draw : function(type,layer,resFormat,title,options, callback,cancelback) {
		this.stopdraw();
		var that = this;
		var me = this,control = null;
		//显示提示信息
		var tipstr="双击完成，Esc键退出";
		if(title){
			tipstr=title;
			if(tipstr=="default"){
				tipstr="双击完成，Esc键退出";
			}
			this.showTip(tipstr,cancelback);
		}
		
		if (this.graphicLayer === null) {
			throw HGIS.language[HGIS.InitParam.language]["map_noInit"];	//"地图未初始化完成"
			return;
		}
		var tempLayer=layer?layer:this.graphicLayer;
		// 画点操作
		if (type === "point") {
			if (!this.drawControls["point"]) {
				control = new HGIS.Control.DrawFeature(tempLayer, HGIS.Handler.Point);
				this.drawControls["point"] = control;
				this.addControl(control);
			} else {
				control = this.drawControls["point"];
			}
		}else if (type === "polyline") {// 画线操作
			if (!this.drawControls["polyline"]) {
				control = new HGIS.Control.DrawFeature(tempLayer, HGIS.Handler.Path);
				this.drawControls["polyline"] = control;
				this.addControl(control);
			} else {
				control = this.drawControls["polyline"];
			}
		}else if (type === "rectangle") {// 画框操作
			if (!this.drawControls["rectangle"]) {
				control = new HGIS.Control.DrawFeature(tempLayer, HGIS.Handler.RegularPolygon, {
					handlerOptions : {
						sides : 4,
						irregular : true
					},
					callbacks : {
						'down' : function() {
							//me.hideTip();
						}
					}
				});
				this.drawControls["rectangle"] = control;
				this.addControl(control);
			} else {
				control = this.drawControls["rectangle"];
			}
		}else if (type === "polygon") {// 画面操作
			if (!this.drawControls["polygon"]) {
				control = new HGIS.Control.DrawFeature(tempLayer, HGIS.Handler.Polygon);
				this.drawControls["polygon"] = control;
				this.addControl(control);
			} else {
				control = this.drawControls["polygon"];
			}
		}else 	if (type === "circle") {		// 画圆操作
			if (!this.drawControls["circle"]) {
				control = new HGIS.Control.DrawFeature(tempLayer, HGIS.Handler.RegularPolygon, {
					handlerOptions : {
						sides : 100,
						irregular : false
					}
				});
				this.drawControls["circle"] = control;
				this.addControl(control);
			} else {
				control = this.drawControls["circle"];
			}
		}else if(type=="ellipse"){// 画椭圆
			if (!this.drawControls["ellipse"]) {
				control = new HGIS.Control.DrawFeature(tempLayer, HGIS.Handler.RegularPolygon, { // 画椭圆控件
					handlerOptions : {
						sides : 100,// 条边，接近于圆
						irregular : true
					}
				});
				this.drawControls["ellipse"] = control;
				this.addControl(control);
			} else {
				control = this.drawControls["ellipse"];
			}
		}else if(type=="freeline"){	// 画流式线
			if (!this.drawControls["freeline"]) {
				control= new HGIS.Control.DrawFeature(tempLayer, HGIS.Handler.Path, { // 流式线
						handlerOptions : {
							freehand : true
						}
					});
				 
				this.drawControls["freeline"] = control;
				this.addControl(control);
			} else {
				control = this.drawControls["freeline"];
			}
		}else{
			alert( HGIS.language[HGIS.InitParam.language]["brows_noSupport_AJAX"] );	//"不被支持的操作类型"
			return;
		}
		control.events.remove("featureadded");
		// 为当前control注册返回内容。
		control.events.on({ 
			"featureadded" : function(evt) {
				me.hideTip();
				control.map.removeControl(control);
				var geom=evt.feature.geometry;
				//每次绘制完成后，layer的的ZIndex会被置顶，因此这里先记录当前ZIndex，然后把ZIndex还原
				var zIndex = control.layer.getZIndex();
				//判断要继续画的情况
				if (options) {// 不要继续画的情况
					if (!options.keepOn) {
						control.deactivate();
						control.events.remove("featureadded");
						document.getElementById(that.container).onmouseover=null;
						if(me.maximizeChanged){
							var overViewControls = me.getControlsByClass('HGIS.Control.OverviewMapEx');
							if(overViewControls.length > 0 && overViewControls[0]){
								overViewControls[0].maximizeControl();
							}
							me.maximizeChanged = false;
						}
					}else{
						if(title){
							me.showTip(tipstr);
						}
					}
					// 绘制后的草图，不保留到地图上
					if (options.ifClear) {
						
						tempLayer.removeFeatures([evt.feature]);
						if(evt.feature){
							evt.feature.destroy();
						}
						tempLayer.redraw();
					}
				}else{//options未定义时，如果有title也显示提示。
					if(title){
						me.showTip(tipstr);
					}
				}
				//把绘制结果返回给调用者，并限定格式
				if (callback) {
					//返回格式限定
					if (resFormat == "wkt") {//返回wkt
						var wktobj = new HGIS.Format.WKT();
						var wktstr = wktobj.extractGeometry(geom);
						callback(wktstr);
					} else {//返回geometry
						callback(geom);
					}
				}
				//每次绘制完成后，layer的的ZIndex会被置顶，因此这里先记录当前ZIndex，然后把ZIndex还原
				control.layer.setZIndex(zIndex);	
			}
		});
		control.activate();
	},
	/**
	 * APIMethod: showTip
	 * 显示提示.
	 * 
	 * Parameters:
	 * content - {String}显示提示内容
	 * callback - {String}Esc回调方法
	 */
	showTip : function(content,callback) {
		//第一次进行初始化
		if(!this.mapTip){
			//解决一些特殊情况下出现esc不起作用的情况
			this.events.register('keydown',this,function(evt){
				if(evt.keyCode==27){
					this.stopdraw();
					//Esc操作回调
					if(callback && typeof callback === 'function'){
						callback();
					}
				}
			});
			var keyControl = new HGIS.Control.KeyboardDefaults({autoActivate:true,defaultKeyPress:function(evt){
						if(evt.keyCode==27){
							this.map.stopdraw();
							//Esc操作回调
							if(callback && typeof callback === 'function'){
								callback();
							}
						}
					}});
		    this.addControl(keyControl);
			this.mapTip = new HGIS.Control.MouseTipControl({tipContent:content});
			this.addControl(this.mapTip);
			this.mapTip.activate();
		}else{
			this.mapTip.setTipContent(content);
			this.mapTip.show();
		}
	},
	/**
	 * APIMethod: hideTip
	 * 隐藏提示.
	 */
	hideTip : function() {
		if(this.mapTip){
			this.mapTip.hide();
		}
	},
	snapShot : function(params) {
		var layer = this._map.getDefaultLayer();
		// 画矩形控件
		var snapshotC = new HGIS.Control.DrawFeature(layer, HGIS.Handler.RegularPolygon, {
			"featureAdded" : function(feature) {
				var bounds = feature.geometry.bounds;
				// 处理截图对象
			var scpMgr = new CaptureManager();
			scpMgr.CaptureRect(0, 0, 300, 300);
		},
		handlerOptions : {
			sides : 4,
			irregular : true,
			angle : 0
		}
		});
		this._map.addControl(snapshotC);
		snapshotC.activate();
	},
	/**
	 * APIMethod: addDefaultLayer
	 * 添加系统默认临时层
	 */
	addDefaultLayer : function() {
		var layer = new HGIS.Layer.Vector("系统临时层", {
			displayInLayerSwitcher : false,
			isBaseLayer : false,
			renderers : ['SVG', 'Canvas', 'VML']
		});
		this._map.addLayers([layer]);
	},
	/**
	 * APIMethod: getDefaultLayer 
	 * 获取系统默认矢量层
	 */
	getDefaultLayer : function() {
		return this.graphicLayer;
	},
	
	/**
	 * APIMethod: degreeSpanToMeter 
	 * 给出一个度数，求出在这个位置附近，指定跨度能代表当地距离的近似能代表多少米.注意，该方法不是一个严肃的方法，不能返回精确值
	 * 
	 * 约束条件：我们认为地球是一个十分完美的球体,地球半径为6371393米。在这个前提下，影响返回值的最大因素是纬度，
	 * 例如在赤道附近，经度相同，纬度的跨度约长111公里，而越往两极地区，这个值越小，到了南北极则为0.
	 * 
	 * Parameters:
	 * lat - {Number} 表示纬度数值.
	 * type - {String} 度的类型说明，若lat为弧度，请将type设为"arc",若为角度，请将type设为"degrees".默认为"degrees".
	 * 
	 * Returns:
	 * {Number} 长度单位，米
	 */
	degreeSpanToMeter : function(lat, type) {
		var arcDegree = (type == "arc") ? lat : lat * Math.PI / 180;
		var R = Math.cos(arcDegree) * 6371393;// 纬度span所在圆的半径,单位为米
		var meterSpan = Math.abs(Math.PI * R / 180);
		return meterSpan;
	},
	/**
	 * APIMethod: meterToDegree 
	 * 给出一个长度单位，计算出在当前地区，1米能代表多少度。注意，该方法不是一个严肃的方法，不能返回精确值，仅供参考。
	 * 
	 * 
	 * Parameters:
	 * lat - {Number} 地理坐标系下纬度值.
	 * type - {String} 度的类型说明，若lat为弧度，请将type设为"arc",若为角度，请将type设为"degrees".默认为"degrees".
	 * 
	 * Returns:
	 * {Number} 角度单位，度
	 */
	meterToDegree:function(lat, type){
		return 1/this.degreeSpanToMeter(lat, type);
	},
	/**
	 * APIMethod: getDistance 
	 * 给出两个坐标点，计算两个点的距离，在地理坐标系下假设地球为完整椭球体，长半轴为: 6378137米,短半轴为: 6356752.3142米。
	 * 
	 * Parameters:
	 * p1- {<HGIS.Geometry.Point>} 第一个点.
	 * p1- {<HGIS.Geometry.Point>} 第二个点.
	 * 
	 * Returns:
	 * {Number} 长度,单位米
	 */
	getDistance : function(p1, p2) {
		var lonlat1=new HGIS.LonLat(p1.x,p1.y);
		var lonlat2=new HGIS.LonLat(p2.x,p2.y);
		var distance=0;
		if(HGIS.InitParam.geodesic){
			distance= HGIS.Util.distVincenty(lonlat1,lonlat2);
		}else{
			distance =p1.distanceTo( p2);
		}
		return distance;
	}, 

	/**
	 * APIMethod: clearIndexedDB
	 * 清空indexedDB中的地图瓦片缓存
	 * 
	 */
	clearIndexedDB:function () {
        HGIS.Strategy.Parameters.clearDB();
    },
	
	CLASS_NAME : "HGIS.MapEx"
});
/**
 * HGIS.Marker.MarkerEx 
 * MarkerEx 图标拓展类
 */
HGIS.Marker = HGIS.Marker || {};
HGIS.Marker.MarkerEx = HGIS
		.Class({
			
			/**
			 * Property: icon
			 * 
			 * 图标
			 */
			icon : null,

			started : false,

			stopDown : true,
			/**
			 * Property: dragging
			 */
			dragging : false,

			last : null,

			mouseIconPx : null,

			start : null,

			lastMoveEvt : null,

			oldOnselectstart : null,

			interval : 0,

			timeoutId : null,

			documentDrag : true,

			documentEvents : null,

			active : false,

			/**
			 * HGIS.Marker.MarkerEx
			 * 构造方法。实例化一个MarkerEx对象
			 * 
			 * 
			 * lonlat - {<HGIS.LonLat>} Marker位置
			 * icon - {<HGIS.Icon>} Marker的图标
			 * 
			 */
			initialize : function(lonlat, icon) {
				this.lonlat = lonlat;
				var newIcon = icon ? icon : HGIS.Marker.defaultIcon();
				if (this.icon == null) {
					this.icon = newIcon;
				} else {
					this.icon.url = newIcon.url;
					this.icon.size = newIcon.size;
					this.icon.offset = newIcon.offset;
					this.icon.calculateOffset = newIcon.calculateOffset;
				}
				
				//综合安防 调整项
				this.icon.div = this.icon.div || this.icon.imageDiv;
				this.events = new HGIS.Events(this, this.icon.div, null, true, { includeXY: true });
								
//				this.events = new HGIS.Events(this, this.icon.div);
				if (this.documentDrag === true) {
					var me = this;
					this._docMove = function(evt) {
						me.mousemove({
							xy : {
								x : evt.clientX,
								y : evt.clientY
							},
							element : document,
							target : evt.target
						});
					};
					this._docUp = function(evt) {
						me.mouseup({
							xy : {
								x : evt.clientX,
								y : evt.clientY
							},
							target : evt.srcElement
						});
					};
				}
			},

			callbacks : null,
			scope : null,
			
			/**
			 * Method: activateEdit
			 * 激活，进入编辑状态。
			 */
			activateEdit : function(callbacks, scope) {
				this.scope = scope ? scope : this;
				this.callbacks = callbacks;
				if (this.active) {
					return false;
				}
				this.events.register("mousedown", this, this.dragstart);
				this.active = true;
			},
			
			/**
			 * Method: deactivateEdit
			 * 禁用编辑
			 */
			deactivateEdit : function(type) {
				if (type) {
					if (this.callbacks && this.callbacks.hasOwnProperty(type)) {
						delete this.callbacks[type];
					}
					var hasProperty = false;
					for ( var i in this.callbacks) {
						hasProperty = true;
						break;
					}
					if (hasProperty) {
						return;
					}
				}
				this.active = false;
				this.events.unregister("mousedown", this, this.dragstart);
				delete this.callbacks;
			},
			
			/**
			 * Method: dragstart
			 * 开始拖拽在该对象activateEdit后开始执行
			 */
			dragstart : function(evt) {
				var propagate = true;
				this.dragging = false;
				if (this.checkModifiers(evt) && (HGIS.Event.isLeftClick(evt))) {
					this.started = true;
					this.start = this.map.getLayerPxFromLonLat(this.lonlat);
					this.mouseIconPx = new HGIS.Pixel(evt.offsetX, evt.offsetY);
					var target = evt.srcElement;
					while (target !== this.icon.div) {
						this.mouseIconPx = this.mouseIconPx.add(
								target.offsetLeft, target.offsetTop);
						target = target.parentNode;
					}

					HGIS.Event.stop(evt);

					if (!this.oldOnselectstart) {
						this.oldOnselectstart = document.onselectstart ? document.onselectstart
								: HGIS.Function.True;
					}
					document.onselectstart = HGIS.Function.False;

					propagate = !this.stopDown;

					this.addDocumentEvents();
					this.down(evt, this);
					this.callback("down", [ this ]);
				} else {
					this.started = false;
					this.start = null;
				}
			
				return propagate;
			},
			/**
			 * Method: checkModifiers
			 * 判断键盘的ctrl shift alt 键是否按下。
			 */
			checkModifiers : function(evt) {
				if (this.keyMask == null) {
					return true;
				}
				var keyModifiers = (evt.shiftKey ? HGIS.Handler.MOD_SHIFT : 0)
						| (evt.ctrlKey ? HGIS.Handler.MOD_CTRL : 0)
						| (evt.altKey ? HGIS.Handler.MOD_ALT : 0);
				return (keyModifiers == this.keyMask);
			},
			/**
			 * Method: addDocumentEvents
			 * 在编辑状态激活拖拽时添加说表的移动和释放事件，移动是 拖动图标，释放是停止拖放
			 */
			addDocumentEvents : function() {
				this.documentEvents = true;
				HGIS.Event.observe(document, "mousemove", this._docMove);
				HGIS.Event.observe(document, "mouseup", this._docUp);
			},
			down : function(evt, scope) {
			},
			move : function(evt, scope) {
			},
			up : function(evt, scope) {
			},
			callback : function(name, args) {
				if (name && this.callbacks[name]) {
					this.callbacks[name].apply(this.scope, args);
				}
			},
			mousemove : function(evt) {
				return this.dragmove(evt);
			},
			/**
			 * Method: dragmove
			 * 移动图标事件
			 */ 
			dragmove : function(evt) {
				if (this.documentDrag === true && this.documentEvents) {
					this.adjustXY(evt);
				}
				this.moveThis(evt);
				this.down(evt, this);
				this.callback("move", [ this ]);

				return true;
			},
			moveThis : function(evt) {
				var pixel = evt.xy;
				var mouseLonlat = this.map.getLonLatFromPixel(pixel);
				var px = this.map.getLayerPxFromLonLat(mouseLonlat);

				var offsetPx = px.add(-this.mouseIconPx.x, -this.mouseIconPx.y);
				this.moveTo(offsetPx);
			},
			adjustXY : function(evt) {
				var pos = HGIS.Util.pagePosition(this.map.viewPortDiv);
				evt.xy.x -= pos[0];
				evt.xy.y -= pos[1];
			},
			mouseup : function(evt) {
				return this.dragend(evt);
			},
			/**
			 * Method: dragend
			 * 拖放结束事件
			 */
			dragend : function(evt) {
				if (this.started) {
					if (this.documentDrag === true && this.documentEvents) {
						this.adjustXY(evt);
						this.removeDocumentEvents();
					}
					var dragged = (this.start != this.map
							.getLayerPxFromLonLat(this.lonlat));
					// alert(dragged)
					this.started = false;
					this.dragging = false;
					document.onselectstart = this.oldOnselectstart;
					this.up(evt, this);
					this.callback("up", [ this ]);
				}
				return true;
			},
			/**
			 * Method: removeDocumentEvents
			 * 移除鼠标的拖放和释放事件
			 */
			removeDocumentEvents : function() {
				HGIS.Element.removeClass(document.body, "olDragDown");
				this.documentEvents = false;
				HGIS.Event.stopObserving(document, "mousemove", this._docMove);
				HGIS.Event.stopObserving(document, "mouseup", this._docUp);
			},

			/**
			 * Method: destroy
			 * 销毁
			 */
			destroy : function() {
				// erase any drawn features
				this.erase();

				this.map = null;

				this.events.destroy();
				this.events = null;

				if (this.icon != null) {
					this.icon.destroy();
					this.icon = null;
				}
			},

			draw : function(px) {
				return this.icon.draw(px);
			},

			erase : function() {
				if (this.icon != null) {
					this.icon.erase();
				}
			},
			/**
			 * Method: moveToPosition
			 * 移动到指定位置
			 */
			moveToPosition : function(geometry) {
				this.lonlat = new HGIS.LonLat(geometry.x, geometry.y);
				this.layer.drawMarker(this);
			},
			moveTo : function(px) {
				if ((px != null) && (this.icon != null)) {
					// 为了防止移动的时候，偏移了2次，于是提前偏移回来一次
					px.x = px.x - this.icon.offset.x;
					px.y = px.y - this.icon.offset.y;

					this.icon.moveTo(px);
				}
				this.lonlat = this.map.getLonLatFromLayerPx(px);
			},

			isDrawn : function() {
				var isDrawn = (this.icon && this.icon.isDrawn());
				return isDrawn;
			},
			
			/**
			 * Method: onScreen
			 * 判断MarkerEx是否在屏幕范围内
			 */
			onScreen : function() {

				var onScreen = false;
				if (this.map) {
					var screenBounds = this.map.getExtent();
					onScreen = screenBounds.containsLonLat(this.lonlat);
				}
				return onScreen;
			},

			inflate : function(inflate) {
				if (this.icon) {
					this.icon.setSize({
						w : this.icon.size.w * inflate,
						h : this.icon.size.h * inflate
					});
				}
			},

			/**
			 * Method: setOpacity
			 * 设置MarkerEx图标的透明度
			 */
			setOpacity : function(opacity) {
				this.icon.setOpacity(opacity);
			},
			/**
			 * Method: setUrl
			 * 
			 * Parameters:
			 * url: - {String} MarkerEx图标的图片地址
			 */
			setUrl : function(url) {
				this.icon.setUrl(url);
			},

			display : function(display) {
				this.icon.display(display);
			},
			CLASS_NAME : "HGIS.Marker.MarkerEx"
		});/**
 * Class: HGIS.Plot.Dashboard
 * 仪表盘.本类与GIS无关，是一个加载到浏览器上的dom对象，一般用于配合行车速度的显示.
 * 
 * 使用示例:
 * (code)
 * 	var dashboard;
 *  var i=10;
 *  //显示仪表盘
 *  function showDsb() {
 *		var opt = {
 *		el : document.getElementById("dsbd"),
 *		begin : 60,
 *		end : 300,
 *		longDivide : 10,
 *		shortDivide : 5,
 *		min : 0,
 *		max : 240,
 *		start : 0
 *		dashboard = new HGIS.Plot.Dashboard(opt);
 *		dashboard.show();
 *	}
 *  //改变仪表盘的值
 *	function changval() {
 *		if(i<=230){
 *			i=i+10;
 *		}
 *		dashboard.setValue(i);
 *	}
 * (end)
 */
HGIS.Plot=HGIS.Plot||{};
HGIS.Plot.Dashboard = function(opt) {
	var thisObj = this;
	/**
	 * APIProperty: dashboard
	 * 仪表盘的容器
	 */
	var dashboard = null, // 仪表盘的容器
	/**
	 * APIProperty: pointer
	 * 指针
	 */
	pointer = null, // 指针
	/**
	 * APIProperty: radius
	 * 半径
	 */
	radius = 0, 
	
	longDivide = 0, 
	shortDivide = 0, 
	min = 0, 
	max = 0,
	/**
	 * APIProperty: diameter
	 * 直径
	 */
	diameter = 0,
	/**
	 * APIProperty: startRadian
	 * 开始的弧度值
	 */
	startRadian = 0,
	/**
	 * APIProperty: totalRadian
	 * 最小值和最大值之间的弧度
	 */
	totalRadian = 0,
	/**
	 * APIProperty: totalRadian
	 * 每个较长刻度之间的弧度值
	 */
	longEveryRadian = 0,
	/**
	 * APIProperty: shortEveryRadian
	 * 每个较短刻度之间的弧度值
	 */ 
	shortEveryRadian = 0,
	/**
	 * APIProperty: longRadiusScale
	 * 较长刻度形成的圆的半径占外层圆的比例
	 */ 
	longRadiusScale = 0,
	/**
	 * APIProperty: shortRadiusScale
	 * 较短刻度形成的圆的半径占外层圆的比例
	 */ 
	shortRadiusScale = 0,
	/**
	 * APIProperty: textDiff
	 * 每个显示的文本数字的间隔
	 */ 
	textDiff = 0,
	/**
	 * APIProperty: stCxt
	 * 存放canvas画布
	 */ 
	stCxt = null, 
	dyCxt = null;
	thisObj.el=null;
	thisObj.opt=opt;
	/**
	 * APIProperty: settings
	 * 仪表盘的设置信息
	 * 
	 * 示例:
	 * (code)
	 * var settings = {	
	 *			el : null,
	 *			begin : 0,// 最小范围角度
	 *			end : 360,// 最大范围角度
	 *			min : 0,// 最小数值
	 *			max : 12,// 最大的数值
	 *			hasLast : true,// 是否要画最后一个刻度
	 *			radius : 150,// 半径
	 *			longDivide : 12,// 在规定角度内分成几个长刻度
	 *			shortDivide : 5,// 一个长刻度分成几个小刻度
	 *			longLine : 20,// 长刻度的长度
	 *			shortLine : 10,// 短刻度的长度
	 *			pointerLine : 135,// 指针长度
	 *			start : 0,// 指针开始的值
	 *			circleBg : "#000",// 最大的圆的颜色
	 *			concentricBg : "#222",// 同心小圆的颜色
	 *			borderColor : "#fff",// 大圆的边框
	 *			longLineColor : "#fff",// 长刻度线颜色
	 *			shortLineColor : "#00F5FF",// 短刻度线颜色
	 *			pointerColor : "#CD3700",// 指针颜色
	 *			textColor : "#fff"// 数字颜色
		 *		}
	 * (end)
	 */
	thisObj.settings = {
			/* 仪表盘容器，必填选项 */
			el : null,
			/* 数值参数 */
			begin : 0,// 最小范围角度
			end : 360,// 最大范围角度
			min : 0,// 最小数值
			max : 12,// 最大的数值
			hasLast : true,// 是否要画最后一个刻度
			radius : 150,// 半径
			longDivide : 12,// 在规定角度内分成几个长刻度
			shortDivide : 5,// 一个长刻度分成几个小刻度
			longLine : 20,// 长刻度的长度
			shortLine : 10,// 短刻度的长度
			pointerLine : 135,// 指针长度
			start : 0,// 指针开始的值
			/* 颜色参数 */
			circleBg : "#000",// 最大的圆的颜色
			concentricBg : "#222",// 同心小圆的颜色
			borderColor : "#fff",// 大圆的边框
			longLineColor : "#fff",// 长刻度线颜色
			shortLineColor : "#00F5FF",// 短刻度线颜色
			pointerColor : "#CD3700",// 指针颜色
			textColor : "#fff"// 数字颜色
		};
	/** 
	 * APIMethod: show
	 * 显示仪表盘
	 */
	this.show = function() {
		thisObj.el = thisObj.opt.el;
		thisObj.extend(thisObj.settings, thisObj.opt);
		thisObj.init.call(this);
	};

	/**
	 * APIMethod: extend
	 * 拓展settings的设置项
	 * 
	 * Parameters:
	 * settings - {Object}设置项
	 * opt - {Object} 拓展设置项
	 */
	this.extend = function(settings, opt) {
		for ( var i in opt) {
			settings[i] = opt[i];
		}
	};
	this.init = function() {
		thisObj.initVar.call(this);
		if (navigator.userAgent.indexOf('MSIE') >= 0) {
			thisObj.version = "VML";
			thisObj.bodyInitByIE.call(this);
			thisObj.pointerInitByIE.call(this);
		} else {
			thisObj.version = "canvas";
			thisObj.bodyInitByCanvas.call(this);
			thisObj.pointerInitByCanvas.call(this);
		}
	};
	this.initVar = function() {
		radius = this.settings.radius, longDivide = this.settings.longDivide,
				shortDivide = this.settings.shortDivide,
				min = this.settings.min, max = this.settings.max,
				// 直径
				diameter = radius * 2,
				// 开始的弧度值
				startRadian = this.settings.begin / 180 * Math.PI,
				// 最小值和最大值之间的弧度
				totalRadian = (this.settings.end - this.settings.begin) / 180
						* Math.PI,
				// 每个较长刻度之间的弧度值
				longEveryRadian = totalRadian / longDivide,
				// 每个较短刻度之间的弧度值
				shortEveryRadian = totalRadian / (shortDivide * longDivide),
				// 较长刻度形成的圆的半径占外层圆的比例
				longRadiusScale = (radius - this.settings.longLine) / radius,
				// 较短刻度形成的圆的半径占外层圆的比例
				shortRadiusScale = (radius - this.settings.shortLine) / radius,
				// 每个显示的文本数字的间隔
				textDiff = (max - min) / longDivide;
	};
	
	this.setValue=function(val){
		var min = this.settings.min,
			max = this.settings.max,
			radius = this.settings.radius,
			startRadian = this.settings.begin / 180 * Math.PI,
			totalRadian = (this.settings.end - this.settings.begin) / 180 * Math.PI;
		val = Math.min(Math.max(min,val),max);
		var scale = (val - min) / (max - min),
			radian = scale * totalRadian + startRadian;
		//支持canvas
		if(this.version == "canvas"){
			dyCxt.save();
			dyCxt.clearRect(0,0,diameter,diameter);
			dyCxt.beginPath();
			dyCxt.translate(radius,radius);
			dyCxt.rotate(radian);
			dyCxt.moveTo(0,0);
			dyCxt.lineTo(0,radius - 2);
			dyCxt.lineWidth = 2;
			dyCxt.strokeStyle = this.settings.pointerColor;
			dyCxt.stroke();
			dyCxt.restore();
		//ie
		}else{
			var pos = {
				x: radius * Math.sin(-radian),
				y: radius * Math.cos(-radian)
			};
			pointer.setAttribute("to",pos.x+','+pos.y);
		}
	
	};
	
	
	this.bodyInitByIE=function(){
		var boardHtml = [];
		dashboard = document.createElement("<div class='hik_gis_dashboard' style='position: relative;width:"+ diameter +"px;height:"+ diameter +"px;'>");
		var element=document.createElement("<v:Oval style='position: absolute;z-index: 5;width:"+ diameter +"px; height:"+ diameter +"px; left:0; top:0' fillcolor='"+ this.settings.circleBg +"' strokecolor='"+ this.settings.borderColor +"' strokeweight='2pt'/>");
		thisObj.el.appendChild(dashboard).appendChild(element);
		//画大刻度
		var longDivideNum = thisObj.settings.hasLast ? longDivide : longDivide - 1,
			shortDivideNum = thisObj.settings.hasLast ? longDivide * shortDivide : longDivide * shortDivide - 1;
		for(var i = 0; i <= longDivideNum; i++){
			var radian = longEveryRadian * i + startRadian;
			var pos = {
				x: radius * Math.sin(-radian),
				y: radius * Math.cos(-radian)
			};
			//画文字
			var textbox = document.createElement("v:textbox");
			textbox.style.position = "absolute";
			textbox.style.zIndex = "5";
			textbox.style.color = this.settings.textColor;
			textbox.style.fontWeight = "bold";
			textbox.innerText = parseInt(min + i * textDiff).toString();
			dashboard.appendChild(textbox);
			textbox.style.left = radius + pos.x * (longRadiusScale * 0.96) - (Math.sin(-radian) + 1) / 2 * textbox.offsetWidth + "px";
			textbox.style.top = radius + pos.y * (longRadiusScale * 0.96) - (Math.cos(-radian) + 1) / 2 * textbox.offsetHeight + "px";
			
		boardHtml.push("<v:line style='position: absolute;z-index: 5;left:"+ radius +"px;top:"+ radius +"px;' from='" + (pos.x * longRadiusScale) + "," + (pos.y * longRadiusScale) + "' to='" + (pos.x) + "," + (pos.y) + "' strokecolor='"+ thisObj.settings.longLineColor +"' strokeweight='2pt'/>");
		}
		//画小刻度
		for(var i = 0; i <= shortDivideNum; i++){
			if(i % shortDivide != 0){
				var radian = shortEveryRadian * i + startRadian;
				var pos = {
					x: radius * Math.sin(-radian),
					y: radius * Math.cos(-radian)
				};			
				boardHtml.push("<v:line style='position: absolute;z-index: 5;left:"+ radius +"px;top:"+ radius +"px;' from='" + (pos.x * shortRadiusScale) + "," + (pos.y * shortRadiusScale) + "' to='" + (pos.x) + "," + (pos.y) + "' strokecolor='"+ this.settings.shortLineColor +"' strokeweight='1pt'/>");
			}	
		}
		dashboard.innerHTML += boardHtml.join('');
		
		/*内部小圆，优化样式*/
		var smallCircleScale = 0.4,
			pointerCircleRaius = 4;
		//添加小圆
		dashboard.appendChild(document.createElement("<v:Oval style='position: absolute;z-index: 5;left:"+ (radius - radius * smallCircleScale/2) +"px;top:"+ (radius - radius * smallCircleScale/2) +"px;width:"+ radius * smallCircleScale +"px;height:"+ radius * smallCircleScale +"px' strokecolor='"+ this.settings.concentricBg +"' fillcolor='"+ this.settings.concentricBg +"'/>"));
		//添加指针起始的小圆
		dashboard.appendChild(document.createElement("<v:Oval style='position: absolute;z-index: 5;left:"+ (radius - pointerCircleRaius) +"px;top:"+ (radius - pointerCircleRaius) +"px;width:"+ pointerCircleRaius * 2 +"px;height:"+ pointerCircleRaius * 2 +"px' strokecolor='"+ this.settings.pointerColor +"' fillcolor='"+ this.settings.pointerColor +"'/>"));
	};
	this.pointerInitByIE=function(){
		pointer = document.createElement("<v:line style='position: absolute;z-index: 5;left:"+ radius +"px;top:"+ radius +"px;' from='0,0' to='0,"+ radius +"' strokecolor='"+ this.settings.pointerColor +"' strokeweight='2pt'/>");
		//添加指针
		dashboard.appendChild(pointer);
		thisObj.setValue(this.settings.start);
	};
	this.bodyInitByCanvas=function(){
		dashboard = document.createElement("div");
		dashboard.setAttribute("style","position: relative;width:"+ diameter +"px;height:"+ diameter +"px;");
		thisObj.el.appendChild(dashboard);
		var staticCanvas = document.createElement("canvas");
		staticCanvas.setAttribute("style","position: absolute; top: 0; left: 0;");
		staticCanvas.innerText = "你的浏览器不支持canvas标签";
		staticCanvas.width = diameter;
		staticCanvas.height = diameter;
		
		var dynamicCanvas = staticCanvas.cloneNode(true); 

		dashboard.appendChild(staticCanvas);
		dashboard.appendChild(dynamicCanvas);
		
		stCxt = staticCanvas.getContext("2d"),
		dyCxt = dynamicCanvas.getContext("2d");
		//画大圆
		stCxt.save();
		stCxt.beginPath();
		stCxt.arc(radius,radius,radius - 2,0,Math.PI * 2,true);
		stCxt.closePath();
		stCxt.fillStyle = this.settings.circleBg;
		stCxt.fill();
		stCxt.lineWidth = 2;
		stCxt.strokeStyle = this.settings.borderColor;
		stCxt.stroke();
		stCxt.restore();
		
		var longDivideNum = this.settings.hasLast ? longDivide : longDivide - 1,
			shortDivideNum = this.settings.hasLast ? longDivide * shortDivide : longDivide * shortDivide - 1;
		//画长刻度和文字
		for(var i = 0; i <= longDivideNum; i++){
			stCxt.beginPath();
			var radian = longEveryRadian * i + startRadian;
			//画长刻度
			stCxt.save();
			stCxt.translate(radius,radius);
			stCxt.rotate(radian);
			stCxt.lineWidth = 2;
			stCxt.strokeStyle = this.settings.longLineColor;
			stCxt.moveTo(0,radius - 2);
			stCxt.lineTo(0,radius - this.settings.longLine - 2);
			stCxt.stroke();
			
			//写文字
			var txt = parseInt(min + i * textDiff).toString();
			stCxt.fillStyle = this.settings.textColor;
			stCxt.font = "bold 16px serif";
			var txtAttr = stCxt.measureText(txt);
			stCxt.translate(0,radius - this.settings.longLine - 8);
			stCxt.rotate(2 * Math.PI - radian);
			stCxt.fillText(txt,-(Math.sin(-radian) + 1) / 2 * (txtAttr.width),Math.sin(radian / 2) * 10);	
			stCxt.restore();
		}
		//画短刻度
		for(var i = 0; i <= shortDivideNum; i++){
			if(i % shortDivide != 0){
				stCxt.beginPath();
				var radian = shortEveryRadian * i + startRadian;
				stCxt.save();
				stCxt.translate(radius,radius);
				stCxt.rotate(radian);
				stCxt.lineWidth = 1;
				stCxt.strokeStyle = this.settings.shortLineColor;
				stCxt.moveTo(0,radius - 2);
				stCxt.lineTo(0,radius - this.settings.shortLine - 2);
				stCxt.stroke();
				stCxt.restore();
			}
		}
		
		/*内部小圆，优化样式*/
		var smallCircleScale = 0.4,
			pointerCircleRaius = 4;
		stCxt.save();
		stCxt.beginPath();
		stCxt.arc(radius,radius,radius * smallCircleScale / 2,0,Math.PI * 2,true);
		stCxt.fillStyle = this.settings.concentricBg;
		stCxt.fill();
		
		stCxt.beginPath();
		stCxt.arc(radius,radius,pointerCircleRaius,0,Math.PI * 2,true);
		stCxt.fillStyle = this.settings.pointerColor;
		stCxt.fill();
		stCxt.restore();
	};
	this.pointerInitByCanvas=function(){
		dyCxt.save();
		dyCxt.beginPath();
		dyCxt.moveTo(radius,radius);
		dyCxt.lineTo(radius,radius * 2 - 2);
		dyCxt.strokeStyle = this.settings.pointerColor;
		dyCxt.lineWidth = 2;
		dyCxt.stroke();
		dyCxt.restore();
		thisObj.setValue(this.settings.start);
	};
	
};
/**
 * Class: HGIS.Plot.EditSector
 * 可编辑的扇形
 */
HGIS.Plot = HGIS.Plot || {};
/**
 * 
 */
HGIS.Plot.EditSector = HGIS
		.Class({
			/**
			 * Constructor: HGIS.Plot.EditSector
			 * 构造函数
			 * 
			 * Parameters:
			 * map - {<HGIS.MapEx>} 地图对象
			 * sectorOptions - {Object} 扇形的参数
			 * options - {Object} 扇形样式和拖动时的回调参数 
			 * 
			 * 示例:
			 * (code)
			 * var editSector = new HGIS.Plot.EditSector(map,{ center:point,
             * 												radius:500, 
             * 												direction:90, 
             * 												angle:90 },{
             * 												  sectorStyle:style1,
             * 												  dragPointStyle: style2,
             * 												  callback:func1});
             * (end)
			 */
			initialize : function(map, sectorOptions, options) {
				// 扇形参数，圆心，半径，朝向，张角
				this.center = sectorOptions.center;
				this.radius = sectorOptions.radius;
				this.direction = sectorOptions.direction;
				this.angle = sectorOptions.angle;
				
				this.sectorFt = null ;
				this.dragPointFeature = null ;
				this.anglePointFeature = null ;
				
				// 拖动时的回调
				this.callback = options.callback;
				// 默认扇形样式
				var defaultSectorStyle = {
					strokeColor : "#000000",
					fillOpacity : 0.5,
					fillColor : "red"
				};
				// 扇形样式
				this.sectorStyle = options.sectorStyle ? options.sectorStyle
						: defaultSectorStyle;
				// 初始化可拖拽点对象
				var defaultDragStyle = {
					graphicName : "square",
					pointRadius : 3,
					fillColor : "#0000ff",
					strokeColor : "#0000ff"
				};

				// 拖拽点的样式
				this.dragPointStyle = options.dragPointStyle ? options.dragPointStyle
						: defaultDragStyle;

				this.map = map;
				//对options中传入的layer 进行判别
				this.layer = options.layer instanceof HGIS.Layer.Vector ? options.layer:null;
				this.modifyControl = null;
				this.initLayer();
				this.initControl();
				this.map.zoomToExtent(this.sectorFt.geometry.getBounds());
				// 默认触发选中
				this.modifyControl.selectFeature(this.sectorFt);
			},
			/**
			 * APIMethod: updateSector
			 * 传入参数更新扇形
			 * 
			 * Parameters:
			 * 
			 * radius - {Number} 扇形的半径
			 * 
			 * direction - {Number} 扇形角平分线的指向
			 * 
			 * angle - {Number} 扇形的夹角
			 *     
			 *       
			 */
			updateSector : function(radius, direction, angle,center) {
				if(radius != "NaN" && direction != "NaN" && angle != "NaN"){
					this.removeFeatues();
					this.dragPointFeature = null ;
					this.anglePointFeature = null ;
					var newCenter = center? center :this.center ;
					var sectorGeom = HGIS.Utils.createSector(newCenter, radius,
							direction, angle);
					this.center = newCenter;
					this.radius = radius;
					this.direction = direction;
					this.angle = angle;
					this.sectorFt = new HGIS.Feature.Vector(sectorGeom, this,
							this.sectorStyle);
					this.layer.addFeatures([ this.sectorFt ]);
					this.modifyControl.selectFeature(this.sectorFt);
					this.map.zoomToExtent(this.sectorFt.geometry.getBounds());
				}
			},
			
			/** 
			 * APIMethod: initLayer
			 * 初始化可编辑扇形的绘制图层，并放到map对象上去，该要素是放在 {<HGIS.Layer.Vector>}上的
			 * 在构造方法中会自动调用
			 */
			initLayer : function() {
				if(this.layer == null){
					this.layer = new HGIS.Layer.Vector('editSertorLayerName');
				}
				var sectorGeom = HGIS.Utils.createSector(this.center, this.radius,
						this.direction, this.angle);
				this.sectorFt = new HGIS.Feature.Vector(sectorGeom, this,
						this.sectorStyle);
				this.map.addLayer(this.layer);
				this.layer.addFeatures([ this.sectorFt ]);
			},
			/** 
			 * APIMethod: initControl
			 * 初始化扇形的编辑控件.
			 * <HGIS.Control.ModifyFeature> 在构造方法中会自动调用
			 */
			initControl : function() {
				this.modifyControl = new HGIS.Control.ModifyFeature(
						this.layer);
				this.modifyControl.mode = HGIS.Control.ModifyFeature.ROTATE
						| HGIS.Control.ModifyFeature.RESIZE;
				var thisObj = this;
				var ptLength = this.sectorFt.geometry.getVertices().length;

				this.modifyControl.selectFeature = function(feature) {
					if (!this.standalone
							|| this.beforeSelectFeature(feature) !== false) {			
						this.feature = feature;
						this.modified = false;
						this.resetVertices();
						//this.dragControl.activate();
						this.onModificationStart(this.feature);
					}
					// keep track of geometry modifications
					var modified = feature.modified;
					if (feature.geometry && !(modified && modified.geometry)) {
						this._originalGeometry = feature.geometry.clone();
					}
				};				
				this.modifyControl.unselectFeature = function(feature) {

				};
				this.modifyControl.collectRadiusHandle = function() {
					thisObj.getPointPosition();
					if (!this.rotateHandle) {
						var geometry = this.feature.geometry;
						var originGeometry = this.feature.geometry
								.getVertices()[0];
						var radiusGeometry = this.feature.geometry
								.getVertices()[parseInt(ptLength / 2)].clone();
						this.dragPointFeature = new HGIS.Feature.Vector(
								radiusGeometry, null, thisObj.dragPointStyle);
						var resize = (this.mode & HGIS.Control.ModifyFeature.RESIZE);
						var reshape = (this.mode & HGIS.Control.ModifyFeature.RESHAPE);
						var rotate = (this.mode & HGIS.Control.ModifyFeature.ROTATE);
						
						var self = this;
						
						// 旋转和缩放的回调
						radiusGeometry.move = function(x, y) {
							HGIS.Geometry.Point.prototype.move.call(this,
									x, y);
							var dx1 = this.x - originGeometry.x;
							var dy1 = this.y - originGeometry.y;
							var dx0 = dx1 - x;
							var dy0 = dy1 - y;
							if (rotate) {
								var a0 = Math.atan2(dy0, dx0);
								var a1 = Math.atan2(dy1, dx1);
								var angle = a1 - a0;
								angle *= 180 / Math.PI;
								geometry.rotate(angle, originGeometry);
							}
							if (resize) {
								var scale, ratio;
								// 'resize' together with 'reshape' implies that
								// the aspect
								// ratio of the geometry will not be preserved
								// whilst resizing
								if (reshape) {
									scale = dy1 / dy0;
									ratio = (dx1 / dx0) / scale;
								} else {
									var l0 = Math.sqrt((dx0 * dx0)
											+ (dy0 * dy0));
									var l1 = Math.sqrt((dx1 * dx1)
											+ (dy1 * dy1));
									scale = l1 / l0;
								}
								geometry.resize(scale, originGeometry, ratio);
							}
							self.angleGeometry.x = geometry.getVertices()[1].x;
							self.angleGeometry.y = geometry.getVertices()[1].y;
							thisObj.calculateRaidus();
							thisObj.calculateDirection();
							// 计算当前angleGeometry相对于中心线的方位
							thisObj.getPointPosition();
							thisObj.layer.drawFeature(self.angleHandle);
							if (thisObj.callback) {
								thisObj.callback(thisObj.getJsonObj());
							}
						};
						this.dragPointFeature._sketch = true;
						this.rotateHandle = this.dragPointFeature;
						// this.radiusHandle.renderIntent =
						// this.vertexRenderIntent;
						this.layer.addFeatures([ this.rotateHandle ]);
					}

					if (!this.angleGeometry) {
						this.angleGeometry = this.feature.geometry
								.getVertices()[1].clone();
						this.angleGeometry.angle = 1;
						this.anglePointFeature = new HGIS.Feature.Vector(
								this.angleGeometry, null,
								thisObj.dragPointStyle);
						// 改变张角angle的回调
						this.angleGeometry.move = function(x, y) {
							HGIS.Geometry.Point.prototype.move.call(this,
									x, y);

							var angle = HGIS.Plot.getVectorAngle(originGeometry, this,
									geometry.getVertices()[ptLength - 1]);

							var position = HGIS.Plot.getPointPositionToLine(
									this,
									{
										x1 : thisObj.center.x,
										y1 : thisObj.center.y,
										x2 : geometry.getVertices()[parseInt(ptLength / 2)].x,
										y2 : geometry.getVertices()[parseInt(ptLength / 2)].y
									});
							// 计算当前angleGeometry相对于中心线的方位，如果方位变化，说明转到临界点了，则直接返回
							if (thisObj.pointPosition != position) {
								this.x = geometry.getVertices()[1].x;
								this.y = geometry.getVertices()[1].y;
								return;
							}
							var sectorGeom = HGIS.Utils.createSector(originGeometry,
									thisObj.radius, thisObj.direction,
									thisObj.angle);
							thisObj.angle = angle;
							for (var i = 0; i < sectorGeom.getVertices().length; i++) {
								geometry.getVertices()[i].x = sectorGeom
										.getVertices()[i].x;
								geometry.getVertices()[i].y = sectorGeom
										.getVertices()[i].y;
							}
							this.x = geometry.getVertices()[1].x;
							this.y = geometry.getVertices()[1].y;
							self.rotateHandle.geometry.x = self.feature.geometry
									.getVertices()[parseInt(ptLength / 2)].x;
							self.rotateHandle.geometry.y = self.feature.geometry
									.getVertices()[parseInt(ptLength / 2)].y;
							self.layer.drawFeature(self.rotateHandle);
							if (thisObj.callback) {
								thisObj.callback(thisObj.getJsonObj());
							}
						};
						this.anglePointFeature._sketch = true;
						this.angleHandle = this.anglePointFeature;
						// this.angleHandle.renderIntent =
						// this.vertexRenderIntent;
						this.layer.addFeatures([ this.angleHandle ], {
							silent : true
						});
					}
				};
				this.map.addControl(this.modifyControl);
				this.modifyControl.activate();
			},
			/**
			 * getPointPosition
			 * 获取点的位置
			 */
			getPointPosition : function() {
				var geometry = this.sectorFt.geometry;
				var ptLength = geometry.getVertices().length;
				var position = HGIS.Plot.getPointPositionToLine({
					x : geometry.getVertices()[1].x,
					y : geometry.getVertices()[1].y
				}, {
					x1 : this.center.x,
					y1 : this.center.y,
					x2 : geometry.getVertices()[parseInt(ptLength / 2)].x,
					y2 : geometry.getVertices()[parseInt(ptLength / 2)].y
				});
				this.pointPosition = position;
			},
			getJsonObj : function() {
				var obj = {
					center : this.center,
					radius : this.radius,
					direction : this.direction,
					angle : this.angle
				};
				return obj;
			},
			/**
			 * APIMethod: calculateRaidus
			 * 根据编辑后的图形计算半径
			 */
			calculateRaidus : function() {
				var l1 = new HGIS.LonLat(this.center.x, this.center.y);
				var l2 = new HGIS.LonLat(this.sectorFt.geometry
						.getVertices()[1].x, this.sectorFt.geometry
						.getVertices()[1].y);
				this.radius = HGIS.Utils.caculateDistance(l1, l2);// km-m
			},
			/**
			 * APIMethod: calculateDirection
			 * 根据编辑后的图形计算朝向
			 */
			calculateDirection : function() {
				var ptLength = this.sectorFt.geometry.getVertices().length;
				var direction = HGIS.Plot.getDirection(
						this.center,
						this.sectorFt.geometry.getVertices()[parseInt(ptLength / 2)]);
				if (direction < 0) {
					direction = 360 + direction;
				}
				this.direction = direction;
			},
			
			/**
			 * APIMethod: getVectorAngle
			 * 根据编辑后的图形计算方位角
			 * 
			 * Parameters:
			 * 
			 * center - {<JSON>} 包含x和y的json对象
			 * 
			 * p1 - {<JSON>} 包含x和y的json对象
			 * 
			 * p2 - {<JSON>} 包含x和y的json对象
			 * 
			 * Returns:
			 * 
			 * angle - {<float>} 方向角。
			 */
			getVectorAngle : function(center, p1, p2) {
				var v1 = {
					x : p1.x - center.x,
					y : p1.y - center.y
				};
				var v2 = {
					x : p2.x - center.x,
					y : p2.y - center.y
				};
				// 向量内积 x1*x2+y1*y2
				var neiji = v1.x * v2.x + v1.y * v2.y;
				// 向量的模
				var v1M = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
				var v2M = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
				var angle = HGIS.Util.deg(Math.acos(neiji / (v1M * v2M)));
				if (v1.x * v2.y - v1.y * v2.x <= 0) {
					angle = 360 - angle;
				}
				return angle;
			},
			
			/**
			 * APIMethod: getPointPositionToLine
			 * 计算点和线的关系
			 * 
			 * Parameters:
			 * 
			 * point - {<JSON>} 包含x和y的json对象
			 * 
			 * line - {<JSON>} 包含x1、y1、x2、y2的json对象
			 * 
			 * Returns:
			 * 
			 * t - {<int>} 表示点线关系的值0、1或2. 0表示点在线上，1表示点在线的左侧，2表示点在线的右侧。
			 */
			getPointPositionToLine : function(point, line) {
				var t = (line.y1 - line.y2) * point.x + (line.x2 - line.x1)
						* point.y + line.x1 * line.y2 - line.x2 * line.y1;
				// Tmp > 0 在左侧
				// Tmp = 0 在线上
				// Tmp < 0 在右侧
				if (t > 0) {
					t = 1;
				} else if (t < 0) {
					t = 2;
				} else {
					t = 0;
				}
				return t;
			},
			
			/**
			 * APIMethod: getDirection
			 * 计算两点之间连线的方向
			 * 
			 * Parameters:
			 * 
			 * p1 - {<JSON>} 包含x和y的json对象
			 * 
			 * p2 - {<JSON>} 包含x和y的json对象
			 * 
			 * Returns:
			 * 
			 * angle - {<float>} 方向角。
			 */
			getDirection : function(p1, p2) {
				var angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
				angle = HGIS.Util.deg(angle);
				if (angle < 0) {
					angle += 360;
				}
				return angle;
			},
			/**
			 * APIMethod: removeFeatues
			 * 移除扇形对象
			 */
			removeFeatues : function() {
				if (this.sectorFt) {
					this.layer.removeFeatures([ this.sectorFt,
							this.modifyControl.dragPointFeature,this.modifyControl.anglePointFeature ]);
					this.modifyControl.rotateHandle=null;
					this.modifyControl.angleGeometry=null;
				}
			},
			/**
			 * APIMethod: destroy
			 * 释放图层数据和鼠标资源，务必在可拖动的扇形结束后执行
			 */
			destroy : function() {
				this.removeFeatues();
				if(this.layer != null && this.layer.name == 'editSertorLayerName'){
					this.map.removeLayer(this.layer);
					this.layer.destroy();
					this.layer = null;
				}
			},
			
			CLASS_NAME : "HGIS.Plot.EditSector"
		});
/*
**
 * 获取向量的夹角
 */
HGIS.Plot.getVectorAngle = function(center,p1,p2){
	var v1 = {x:p1.x - center.x,y:p1.y - center.y};
	var v2 = {x:p2.x - center.x,y:p2.y - center.y};
	//向量内积 x1*x2+y1*y2
	var neiji = v1.x*v2.x +  v1.y*v2.y;
	//向量的模
	var v1M = Math.sqrt(v1.x*v1.x+v1.y*v1.y);
	var v2M = Math.sqrt(v2.x*v2.x+v2.y*v2.y);
	var angle = HGIS.Util.deg(Math.acos(neiji/(v1M*v2M)));
	if(v1.x * v2.y - v1.y * v2.x <= 0){
		angle = 360 - angle;
	}
	return angle;
};
/**
 * 获取点到线的方位
 * 0-显示；1-左侧；2-右侧
 */
HGIS.Plot.getPointPositionToLine = function(point,line){
	var t = (line.y1 - line.y2)*point.x + (line.x2 - line.x1)*point.y + line.x1*line.y2 - line.x2*line.y1;
	//Tmp > 0 在左侧
	//Tmp = 0 在线上
	//Tmp < 0 在右侧
	if (t > 0) {
		t = 1;
	} else if (t < 0) {
		t = 2;
	} else {
		t = 0;
	}
	return t;
};
/**
 * 得到两点的方向
 */
HGIS.Plot.getDirection = function(p1,p2){
	var angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
	angle = HGIS.Util.deg(angle);
	if(angle<0){
			angle += 360;
		}
	return angle;
};
/**
 * Class: HGIS.Plot.MapOperate
 * 地图基本操作类
 * 
 * 示例:
 * (code)
 * var mc=new HGIS.Plot.MapOperate(map);
 * mc.measureDistance();
 * (end)
 */
HGIS.Plot = HGIS.Plot || {};
HGIS.Plot.MapOperate = HGIS.Class({
	// 基本操作的地图对象
	map : null,
	// 测量工具
	measureControls : null,

	zoomBox : null,
	mouseDownLonlat : null,// 获取当前鼠标所在的坐标
	// 测量标签显示测量结果
	poiMarkers : null, // addpoi中存储到这里
	tipMarker : null, // 也存储到poiMarkers中
	drawLayer : null,
	sketchSymbolizers : null,
	host : null,	 
	/*
	 * Constructor: HGIS.Plot.MapOperate
	 * 构造函数
	 */
	initialize : function(map) {
		// 设施操作的地图对象
		this.map = map;
		this.maxZoomLevel = this.map.getNumZoomLevels();
		this.drawLayer = new HGIS.Layer.Vector("measure_layers", {
				renderers : ['SVG', 'Canvas', 'VML']
			});
		map.addLayer(this.drawLayer);
		// 样式，测量是绘制的线和面的样式
		this.sketchSymbolizers = {
			"Point" : {
				pointRadius : 2,
				graphicName : "circle",
				fillColor : "#ffffff",
				fillOpacity : 0.3,
				strokeWidth : 2,
				strokeOpacity : 1,
				strokeColor : "#DD0000"
			},
			"PointDraw" : {
				pointRadius : 3,
				graphicName : "circle",
				fillColor : "#ffffff",
				fillOpacity : 0.8,
				strokeWidth : 2,
				strokeOpacity : 1,
				strokeColor : "#DD0000",
				graphicZIndex : 10
			},
			"Line" : {
				strokeWidth : 2,
				strokeOpacity : 1,
				strokeColor : "#DD0000",
				graphicZIndex : 5
			},
			"Polygon" : {
				strokeWidth : 2,
				strokeOpacity : 1,
				strokeColor : "#DD0000",
				fillColor : "#DD0000",
				fillOpacity : 0.2
			},
			"text" : {
				labelXOffset : 5,
				labelYOffset : 0,
				labelAlign : 'cm',
				labelOutlineWidth : 1,
				labelOutlineColor : 'red',
				fontColor : '#ff0000'
			},
			"icon" : {
				graphicTitle : HGIS.language[HGIS.InitParam.language]["close"],
				backgroundGraphic : HGIS._getScriptLocation() + 'skin/images/w_close_red.png',
				backgroundWidth : 12,
				backgroundHeight : 12,
				backgroundXOffset : 5,
				backgroundYOffset : -20
			}
		};
		var style = new HGIS.Style();
		style.addRules([new HGIS.Rule({
			symbolizer : this.sketchSymbolizers
		})]);
		var styleMap = new HGIS.StyleMap({
			"default" : style
		});
		var options = {
			handlerOptions : {
				style : "default",
				layerOptions : {
					styleMap : styleMap
				},
				persist : true
			},
			geodesic : true,			 
			partialDelay:1//设置点击的间隔时间为1ms，小于该值measurepartial不被响应
		};
		// 测量工具
		this.measureControls = {
			line : new HGIS.Control.Measure(HGIS.Handler.Path, options),
			polygon : new HGIS.Control.Measure(HGIS.Handler.Polygon, options)
		};

		var control;
		// 测试回调函数
		var measureHandler = HGIS.Function.bindAsEventListener(this.handleMeasurements, this);
		var measurepartialHandler = HGIS.Function.bindAsEventListener(this.handleMeasurepartial, this);
		for (var key in this.measureControls) {
			control = this.measureControls[key];
			control.events.on({
				"measure" : measureHandler,
				"measurepartial" : measurepartialHandler
			});
			this.map.addControl(control);
		};
		this.poiMarkers = new HGIS.Layer.Markers( "Markers" );//this.map.markersLayer;
		this.map.addLayer(this.poiMarkers);
		this.map.setLayerZIndex(this.poiMarkers, 10);

	},

	/**
	 * APIMethod: toggleDrawControl
	 * 绘制工具激活控制
	 * 
	 * Parameters:
	 * element - {String} 要激活的控制，遍历所有控制，激活当前控制，取消其他控制
	 */
	toggleDrawControl : function(element) {
		for (key in drawControls) {
			var control = drawControls[key];
			if (element == key) {
				control.activate();
			} else {
				control.deactivate();
			}
		}
	},
	disdraw : function() {
		var drawControls = this.map.controls ;
		if(drawControls == null){
			return;
		}
		for (key in drawControls) {
			var control = drawControls[key];
			control.deactivate();
		}
		this.map.curDrawControl = null;
		this.map.hideTip();
		this.map.pan();
	},

	setMove : function() {
		this.deactivateContrl();
	},
	/**
	 * APIMethod: deactivateContrl
	 * 取消激活当前地图操作的所有控制  地图的单击，缩放 提示 测量等
	 */
	deactivateContrl : function() {
		this.map.clickFun = null;
		if (this.zoomBox != null) {
			this.zoomBox.deactivate();
		}
		if (this.tipMarker) {
			this.poiMarkers.removeMarker(this.tipMarker);
			this.tipMarker = null;
		}
		if (this.measureControls != null) {
			for (var key in this.measureControls) {
				control = this.measureControls[key];
				control.deactivate();
			};
		}
	},

	/**
	 * APIMethod: measureDeactivate
	 * 停止测量操作 清除测量控制，但不清除绘制的vector
	 */
	measureDeactivate : function() {
		var thisObj = this;
		var control = this.measureControls['line'];
		control.deactivate();
		this._onMeasureDistance = false;
		control = this.measureControls['polygon'];
		control.deactivate();
		
		this.map.hideTip();//隐藏文字提示
		this.map.div.style.cursor ='';
		if (this.tipMarker) {
			this.poiMarkers.removeMarker(this.tipMarker);
			this.tipMarker = null;
		}
	},
	/**
	 * APIMethod: stopMeasure
	 * 停止测量操作 清除测量控制，同时清除绘制的vector
	 */
	stopMeasure : function() {
		var control = this.measureControls['line'];
		control.deactivate();
		control = this.measureControls['polygon'];
		control.deactivate();		
		if (this._measurefeatures && this._measurefeatures.length > 0 && this._onMeasureDistance) {
			var lastMesMak = this._measureMarkers[this._measureCount][this._measureMarkers[this._measureCount].length-1];
			//只清除没有绘制完成的最近的一次绘制
			if(typeof lastMesMak!="undefined"&&lastMesMak.icon.html.indexOf("measure_end")<0){
				// 清除vector
				for (var i = 0; i < this._measurefeatures[this._measureCount].length; i++) {
					var thisvector = this._measurefeatures[this._measureCount][i];
					thisvector.destroy();
				};
				this._measurefeatures[this._measureCount] = [];
				for (var i = 0; i < this._measureMarkers[this._measureCount].length; i++) {
					var thismarker = this._measureMarkers[this._measureCount][i];
					this.poiMarkers.removeMarker(thismarker);
					thismarker.destroy();
				}
				this._measureMarkers[this._measureCount] = [];
			}
			
		}
		
		if (this.tipMarker) {
			this.poiMarkers.removeMarker(this.tipMarker);
			this.tipMarker = null;
		}
		//取消Esc事件监听
		this.map.events.unregister('keydown',this,this.handleEscKeyDown);
		
	},
	/**
	 * APIMethod: measureDistance
	 * 执行测量距离
	 */
	measureDistance : function(callback) {	 
		if(typeof callback=="function"){
			this.callback = callback;
		}
		//改变鼠标形状为手型		 
		this.map.div.style.cursor ='pointer';//'crosshair';// 'pointer';
		this.map.showTip(HGIS.language[HGIS.InitParam.language]["escmeasure"]);//显示文字提示
		if(this.measureControls['polygon'].active)
		   this.stopMeasure();  
		
		//下面两行解决点击测距之后直接点击测面会将最后一次绘制的测距线清除掉的问题。
//		this._measurefeatures = [];
//	    this._measureMarkers = [];
		
		var control = this.measureControls['line'];
		control.activate();
		if (this.zoomBox != null) {
			this.zoomBox.deactivate();
		};
		if (this.tipMarker) {
			this.poiMarkers.removeMarker(this.tipMarker);
			this.tipMarker = null;
		};
		this.map.setLayerZIndex(this.poiMarkers, 10);
		this._onMeasureDistance = true;
		
		//解决一些特殊情况下出现esc不起作用的情况
		this.map.events.register('keydown',this,this.handleEscKeyDown);
		//esc事件监听
		var thisObj = this;
		document.onkeydown=function(event){
			 var e = event || window.event ;	//|| arguments.callee.caller.arguments[0]
			 if(e && e.keyCode==27){ // 按 Esc 
				 thisObj.stopMeasure();	
				 thisObj.map.div.style.cursor ='default';//改变鼠标形状为默认样式
				 thisObj.map.hideTip();//隐藏文字提示
			 }          
		}; 
	},
	/**
	 * APIMethod: measureArea 
	 * 测量面积
	 */
	measureArea : function(callback) {
		if(typeof callback=="function"){
			this.callback = callback;
		}
		this.map.div.style.cursor ='pointer';//改变鼠标形状为手型	
		this.map.showTip(HGIS.language[HGIS.InitParam.language]["escmeasure"]);
		
		if(this.measureControls['line'].active)
		     this.stopMeasure();
		
		var control = this.measureControls['polygon'];
		control.activate();	
	
		if (this.zoomBox != null) {
			this.zoomBox.deactivate();
		};
		if (this.tipMarker) {
			this.poiMarkers.removeMarker(this.tipMarker);
			this.tipMarker = null;
		};	
		this.map.setLayerZIndex(this.poiMarkers, 10);
		
		//解决一些特殊情况下出现esc不起作用的情况
		this.map.events.register('keydown',this,this.handleEscKeyDown);
		//esc事件监听
		var thisObj = this;
		document.onkeydown=function(event){
			 var e = event || window.event || arguments.callee.caller.arguments[0];
			 if(e && e.keyCode==27){ // 按 Esc 
				 thisObj.stopMeasure();	
				 thisObj.map.div.style.cursor ='default';//改变鼠标形状为默认样式
				 thisObj.map.hideTip();//隐藏文字提示
			 }          
		}; 
	},
	handleEscKeyDown:function(evt){
		if(evt && evt.keyCode==27){
			 this.stopMeasure();
			 this.map.div.style.cursor ='default';
			 this.map.hideTip();
		}
	},
	makerStyle : null,
	_measurefeatures : [],//存储绘制的线要素
	_measureMarkers : [],//存储绘制的线上的marker
	_measureAreaFeatures : [],//存储绘制的面要素
	_measureAreaMarkers : [],//存储面要素上的marker
	_measureCount : 0,
	handleMeasurements : function(event) {
		this.measureDeactivate();
		var geometry = event.geometry;
		var units = event.units;
		var order = event.order;
		var measure = event.measure;
		var out = "";
		if (order == 1) { // 测距
			out = measure.toFixed(2) + (units == "m" ? HGIS.language[HGIS.InitParam.language]["m"] : HGIS.language[HGIS.InitParam.language]["km"]);
		} else {
			out = measure.toFixed(2) + (units == "m" ? HGIS.language[HGIS.InitParam.language]["m2"] :HGIS.language[HGIS.InitParam.language]["km2"]);
		}
		//out = out;
		var geometryArray = geometry.getVertices();
		if (geometryArray.length > 1) {
			var pointX = geometryArray[geometryArray.length - 1].x;
			var pointY = geometryArray[geometryArray.length - 1].y;
			var point = new HGIS.Geometry.Point(pointX, pointY);

			var geometryFetrue;
			if (order == 1) {//测距离
				if(event.measure==0){
					return;
				}
				var vector = new HGIS.Feature.Vector(geometryArray[geometryArray.length - 1], {},
				this.sketchSymbolizers.PointDraw);
				this.drawLayer.addFeatures([vector]);
				if (this._measurefeatures[this._measureCount] == undefined) {
					this._measurefeatures[this._measureCount] = [];
				}
				this._measurefeatures[this._measureCount].push(vector);
				var html = "";
				html += "<DIV class='measure_end'>" + "<SPAN style=''>"+HGIS.language[HGIS.InitParam.language]["length"]+"：</SPAN><SPAN>" + out + '</SPAN></DIV>';
				var closeDiv = document.createElement("div");
				closeDiv.title =HGIS.language[HGIS.InitParam.language]["clear"]; //"清除";
				closeDiv.className = "measure_close";
				var thisObj = this;
				closeDiv.mCount = this._measureCount;
				closeDiv.onclick = function(event) {
					var count = this.mCount;
					// 清除vector
					thisObj.drawLayer.removeFeatures(thisObj._measurefeatures[count]);
					//for (var i = 0; i < thisObj._measurefeatures[count].length; i++) {
					for (var i = thisObj._measurefeatures[count].length - 1; i >= 0; i--) {
						var thisvector = thisObj._measurefeatures[count][i];
						thisvector.destroy();
					}
					thisObj._measurefeatures[count] = [];
					
					// 清除marker
					//for (var i = 0; i < thisObj._measureMarkers[count].length; i++) {
					for (var i = thisObj._measureMarkers[count].length - 1; i >= 0 ; i--) {
						var thismarker = thisObj._measureMarkers[count][i];
						thisObj.poiMarkers.removeMarker(thismarker);
						thismarker.destroy();
					}
					thisObj._measureMarkers[count] = [];
					
					thisObj._measureCount--;
					
				};
				var markerIcon = new HGIS.Symbolizer.HtmlIcon(html, {}, {
					x : 10,
					y : -5
				});
				var marker = new HGIS.Marker(new HGIS.LonLat(pointX, pointY), markerIcon);
				this.poiMarkers.addMarker(marker);
				markerIcon.div.appendChild(closeDiv);
				
				geometryFetrue = new HGIS.Feature.Vector(geometry, {}, this.sketchSymbolizers['Line']);
				this._measurefeatures[this._measureCount].push(geometryFetrue);
				if (this._measureMarkers[this._measureCount] == undefined) {
					this._measureMarkers[this._measureCount] = [];
				}
				this._measureMarkers[this._measureCount].push(marker);
			} else {//测面积
				geometryFetrue = new HGIS.Feature.Vector(geometry, {}, this.sketchSymbolizers['Polygon']);
				var html = "";
				html = "<DIV class='measure_end'>" + "<SPAN style=''>"+HGIS.language[HGIS.InitParam.language]["area"]+"：</SPAN><SPAN>" + out + '</SPAN></DIV>';
				var closeDiv = document.createElement("div");
				closeDiv.title =HGIS.language[HGIS.InitParam.language]["clear"];
				closeDiv.className = "measure_close";
				var thisObj = this;
				closeDiv.mCount = this._measureCount;
				closeDiv.onclick = function(event) {
					var count = this.mCount;
					// 清除vector
					thisObj.drawLayer.removeFeatures([thisObj._measureAreaFeatures[count]]);
					var thisvector = thisObj._measurefeatures[count];
					thisObj._measurefeatures[count] = null;
					
					// 清除marker
					var thismarker = thisObj._measureAreaMarkers[count];
					thisObj.poiMarkers.removeMarker(thismarker);
					thismarker.destroy();
					thisObj._measureAreaMarkers[count] = null;
					
					thisObj._measureCount--;
					
				};

				var lonlat = geometry.getBounds().getCenterLonLat();
				var markerIcon = new HGIS.Symbolizer.HtmlIcon(html, {}, {
					x : 10,
					y : -5
				});
				var marker = new HGIS.Marker(lonlat, markerIcon);
				this.poiMarkers.addMarker(marker);
				markerIcon.div.appendChild(closeDiv);
				this._measureAreaFeatures[this._measureCount] = geometryFetrue;
				this._measureAreaMarkers[this._measureCount] = marker;
			}
			this.drawLayer.addFeatures([geometryFetrue]);
		} else {
			return;
		}
		
		this.map.div.style.cursor ='default';//将鼠标形状恢复为默认样式
		//执行回调函数
		if(this.callback){
			this.callback();
		}
	},
	handleMeasurepartial : function(event) {
		var geometry = event.geometry;
		var units = event.units;
		var order = event.order;
		var measure = event.measure;
		var geometryArray = geometry.getVertices();
		if (geometryArray.length < 3) {//不是面
			this._measureCount++;
			this._measurefeatures[this._measureCount] = [];
			this._measureMarkers[this._measureCount] = [];
			this._measureAreaFeatures[this._measureCount] = [];
			this._measureAreaMarkers[this._measureCount] = [];
		}
		var out = "";
		if (order == 1) {
			var vector = new HGIS.Feature.Vector(geometryArray[geometryArray.length - 1], {},
			this.sketchSymbolizers.PointDraw);
			this.drawLayer.addFeatures([vector]);
			if (this._measurefeatures[this._measureCount] == undefined) {
				this._measurefeatures[this._measureCount] = [];
			}
			this._measurefeatures[this._measureCount].push(vector);
			var html = '<LABEL class="measurelength_lable"><DIV class="measurelength_divleft"><DIV class="measurelength_divright">';
			var pointX = geometryArray[geometryArray.length - 1].x;
			var pointY = geometryArray[geometryArray.length - 1].y;
			if (geometryArray.length < 3) {
				html += HGIS.language[HGIS.InitParam.language]["start"] + '</DIV>' + '</DIV></LABEL>';
			} else {
				html += "<DIV id='mesurelength' value='" + measure.toFixed(2) + "'>" + measure.toFixed(2) + (units == "m" ? HGIS.language[HGIS.InitParam.language]["m"] : HGIS.language[HGIS.InitParam.language]["km"])
				        + '</DIV></DIV>' + '</DIV></LABEL>';
			}
			var markerIcon = new HGIS.Symbolizer.HtmlIcon(html, {}, {
				x : 10,
				y : -2
			});
			var marker = new HGIS.Marker(new HGIS.LonLat(pointX, pointY), markerIcon);
			if (this._measureMarkers[this._measureCount] == undefined) {
				this._measureMarkers[this._measureCount] = [];
			}
			this._measureMarkers[this._measureCount].push(marker);
			this.poiMarkers.addMarker(marker);
		} else {
			out = "面积" + measure.toFixed(3) + (units == "m" ? HGIS.language[HGIS.InitParam.language]["m2"] : HGIS.language[HGIS.InitParam.language]["km2"]);
		}	
	},
	/**
	 * APIMethod: clear
	 * 清除该控件的所有操作痕迹
	 */
	clear : function() {
		this.measureDeactivate();
		this.drawLayer.removeAllFeatures();
		this.poiMarkers.clearMarkers();
		for (var i in this._measureMarkers) {
			var markers = this._measureMarkers[i];
			for (var n=0; n < markers.length;n++) {
				var mark = markers[n];
				if(mark){
					this.poiMarkers.removeMarker(mark);
					mark.destroy();
					delete markers[n];
				}
			}
			delete this._measureMarkers[i];
		}
		for (var i in this._measurefeatures) {
			this.drawLayer.removeFeatures(this._measurefeatures[i]);
			delete this._measurefeatures[i];
		}

		for (var i in this._measureAreaFeatures) {
			this.drawLayer.removeFeatures(this._measureAreaFeatures[i]);
			delete this._measureAreaFeatures[i];
		}

		for (var i in this._measureAreaMarkers) {
			var marker = this._measureAreaMarkers[i];
			if (marker != null && marker.CLASS_NAME) {
				this.poiMarkers.removeMarker(marker);
				marker.destroy();
			}
			delete this._measureAreaMarkers[i];
		}
		this._measureCount = 0;
		this._measurefeatures = [];
		this._measureAreaMarkers = [];
		this._measureAreaFeatures = [];
		this._measureMarkers = [];
	}, 	// 类名
	CLASS_NAME : "HGIS.Plot.MapOperate" 
});



/**
 * Class: HGIS.Plot.MovedCircle
 * 可移动的圆对象
 * 
 * 示例:
 * (code)
 * var options = {
 * 			center:center, 
 * 			radius:radius,
 * 			isDragCenter : true, 
 * 			map : map, 
 * 			callback:callback,
 * 			centerStyle:centerStyle
 * 	};
 * var movedCircle = new HGIS.Plot.MovedCircle(vecLayer, options);
 * (end)           
 */
HGIS.Plot = HGIS.Plot || {};
HGIS.Plot.MovedCircle = HGIS
		.Class({
			_self : null,
			/**
			 * Constructor: HGIS.Plot.MovedCircle
			 * 
			 * Parameters:
			 * layer - {String} 图层名称
			 * options - {Object} 对象参数,包括： { 
			 * 	    -   -  center : 圆中心点, 
			 *      -   -   radius : 圆半径, 
			 * 		-   -  circleStyle : 圆样式,
             * 		-   -  dragPointStyle : 拖拽点样式 
             * 		-   -  centerStyle : 中心点样式 
             * 		-	-  createCricleMethod : 创建圆的方法；分别为equality和similar两类
             * 		-   -  isDragCenter ： {Boolean} 圆心是否显示
             * 		-   -  callback :拖拽结束后回调函数,返回参数{center:新中心点,radius:新半径,circle:新圆对象}
             *  }
			 */
			initialize : function(layer, options) {
				this._self = this;
				this.name = name || "MovedCircle";
				this.map = options.map || HGIS.initParam.map;
				this.center = options.center;
				this.radius = options.radius;
				this.circleStyle = options.circleStyle;
				this.dragPointStyle = options.dragPointStyle;
				this.centerStyle = options.centerStyle;
				this.callback = options.callback;
				this.isDragCenter = options.isDragCenter;// 是否显示拖拽点
				this.createCricleMethod = options.createCricleMethod ==="equality" ? "equality" : "similar";
				this.layer = layer;
				this.dragCtrl = null;
				this.circle = null;
				this.dragPoint = null;
				this.circleFeature = null;
				this.dragFeature = null;
				this.centerFeature = null;
				this.initLayer();
				this.initDragControl();
			},
			/**
			 * APIMethod: initLayer
			 * 初始化图层，在构造方法中会自动调用
			 */
			initLayer : function() {
				// 初始化圆对象
				var defaultCircleStyle = {
					strokeColor : "#000000",
					fillOpacity : 0.5,
					fillColor : "red"
				};
				var circleStyle = this.circleStyle || defaultCircleStyle;
				if(this.radius<=0){
					return;
				}
				//this.circle = HGIS.Utils.createCircle(this.center, this.radius);
				if(this.createCricleMethod === "equality"){
					this.circle = HGIS.Utils.createCircleByEquidistance(this.center, this.radius);
				}else{
					this.circle = HGIS.Utils.createCircle(this.center, this.radius);
				}
				
				this.circleFeature = new HGIS.Feature.Vector(this.circle, null, circleStyle);
				// 初始化可拖拽点对象
				var defaultDragStyle = {
					graphicName : "square",
					pointRadius : 3,
					fillColor : "#0000ff",
					strokeColor : "#0000ff"
				};
				var dragStyle = this.dragPointStyle || defaultDragStyle;
				if (!dragStyle.label) {
					dragStyle.label = Math.floor(this.radius) + HGIS.language[HGIS.InitParam.language]["m"];
					dragStyle.labelYOffset = 15;
					dragStyle.labelXOffset = 20;
				}
				var x = this.circle.getVertices()[0].x;
				var y = this.circle.getVertices()[0].y;
				this.dragPoint = new HGIS.Geometry.Point(x, y);
				this.dragFeature = new HGIS.Feature.Vector(this.dragPoint, null, dragStyle);
				this.dragFeature.fid = "candrag";
				// 初始化中心点坐标
				var defaultCenterStyle = {
					graphicName : "circle",
					pointRadius : 5,
					fillColor : "#00ff00"
				};
				var centerStyle = this.centerStyle || defaultCenterStyle;
				this.center = new HGIS.Geometry.Point(this.center.x, this.center.y);
				this.centerFeature = new HGIS.Feature.Vector(this.center, null, centerStyle);
				if (this.isDragCenter) {
					this.layer.addFeatures([ this.centerFeature ]);
				}
				// 装载数据
				this.layer.addFeatures([ this.circleFeature, this.dragFeature ]);
				this.layer.redraw();
			},
			/**
			 * APIMethod: initDragControl
			 * 初始化控制，在构造方法中会自动调用
			 */
			initDragControl : function() {
				var thisObj = this;
				var src = null;
				var len = 0;

				// 判断控件是否已经添加，如果已添加需要移除，否则第二次新建圆并移动半径时会有bug
				var controls = this.map.getControlsBy('id', 'id_movedCircleControl');
				if (controls.length > 0) {
					for (var i = 0; i < controls.length; i++) {
						controls[i].deactivate();
						this.map.removeControl(controls[i]);
					}
				}

				this.dragCtrl = new HGIS.Control.DragFeature(
						this.layer,
						{
							// feature:this.dragFeature,
							id : 'id_movedCircleControl',
							// 针对可拖动图层进行限制，只允许点多动
							geometryTypes : [ "HGIS.Geometry.Point" ],
							onStart : function(evt) {
								// 保存原始的x和y坐标
								src = {
									x : evt.geometry.x,
									y : evt.geometry.y
								};
							},
							onDrag : function(evt) {
								// 如果是拖动点，执行圆的放大缩小
								if (evt.fid == "candrag") {
									var defaultStyle = {
										strokeColor : "#000000",
										fillOpacity : 0.5,
										fillColor : "red"
									};
									var style = thisObj.circleStyle
											|| defaultStyle;
									//len = thisObj.map.getDistance(src,evt.geometry);
									len=HGIS.Utils.caculateDistance(src,
											evt.geometry);

									// 如果拖住点横坐标小于原始保存的点横坐标，说明是沿x逆向拖拽
									if (evt.geometry.x < src.x) {
										len = -len;
									}
									thisObj.radius=parseFloat(thisObj.radius);
									var radius = thisObj.radius+len;

									// 删除图层内所有对象，之所以删除中心点，是为了防止中心点被后添加的圆环覆盖
									thisObj.removeFeatues();
									thisObj.circle.destroy();

									// 重新绘制圆环
//									thisObj.circle = HGIS.Utils.createCircle(
//											thisObj.center, radius);
									if(thisObj.createCricleMethod === "equality"){
										thisObj.circle = HGIS.Utils.createCircleByEquidistance(thisObj.center, radius);
									}else{
										thisObj.circle = HGIS.Utils.createCircle(thisObj.center, radius);
									}
									// 重新设置拖拽点坐标
									thisObj.dragPoint.x = thisObj.circle
											.getVertices()[0].x;
									thisObj.dragPoint.y = thisObj.circle
											.getVertices()[0].y;

									// 设置动态圆半径
									evt.style.label = Math.floor(Math
											.abs(radius))
											+ HGIS.language[HGIS.InitParam.language]["m"];
									evt.style.labelYOffset = 10;
									evt.style.labelXOffset = 20;

									thisObj.circleFeature = new HGIS.Feature.Vector(
											thisObj.circle, null, style);

									if (thisObj.isDragCenter) {
										thisObj.layer
												.addFeatures([ thisObj.centerFeature ]);
									}
									// 重新添加要素至图层内，保持数组中feature的顺序，防止面覆盖点
									thisObj.layer.addFeatures([
											thisObj.circleFeature,
											thisObj.dragFeature ]);
									thisObj.layer.redraw();
								}
								// 拖动圆心，执行整个圆的移动
								else {
									thisObj.move(evt.geometry.x - src.x,
											evt.geometry.y - src.y);
									src.x = evt.geometry.x;
									src.y = evt.geometry.y;
								}
							},
							onComplete : function(evt) {
								thisObj.radius = thisObj.radius + len;
								thisObj.callback({
									center : thisObj.center,
									radius : thisObj.radius,
									circle : thisObj.circle
								});
							}
						});
				this.map.addControl(this.dragCtrl);
				this.dragCtrl.activate();
			},
			/**
			 * APIMethod: moveTo
			 * 将圆移动到目标中心点处
			 */
			moveTo : function() {
				// 获得移动向量
				var vector = {
					x : center.x - this.center.x,
					y : center.y - this.center.y
				};
				this.center.move(vector.x, vector.y);
				this.dragPoint.move(vector.x, vector.y);
				this.circle.move(vector.x, vector.y);
				this.layer.redraw();
			},
			/**
			 * APIMethod: move
			 * 移动整个拖动圆图层
			 * 
			 * Parameters:
			 * dx - {Number} 移动的横向量，单位度
			 * dy - {Number} 移动的纵向量，单位度
			 */
			move : function(dx, dy) {
				this.dragPoint.move(dx, dy);
				this.circle.move(dx, dy);
				this.layer.redraw();
			},
			
			/**
			 * APIMethod: removeFeatues
			 * 移除圆对象
			 */
			removeFeatues : function() {
				if (this.circleFeature) {
					this.layer.removeFeatures([ this.circleFeature,
							this.dragFeature ]);
				}
				if (this.isDragCenter) {
					this.layer.removeFeatures([ this.centerFeature ]);
				}
			},
			/**
			 * APIMethod: destroy
			 * 释放图层数据和鼠标资源，务必在可拖动的圆结束后执行
			 */
			destroy : function() {
				this.removeFeatues();
				if (this.dragCtrl) {
					this.dragCtrl.destroy();
					this.dragCtrl = null;
				}
			},
			/**
			 * APIMethod: getLayer
			 * 获取当前图层
			 */
			getLayer : function() {
				return this.layer;
			},
			/**
			 * APIMethod: getCtrl
			 * 获取当前拖动Control
			 */
			getCtrl : function() {
				return this.dragCtrl;
			},
			/**
			 * APIMethod: deactivate
			 * 取消激活拖动Control
			 */
			deactivate : function() {
				if (this.dragCtrl.active) {
					this.dragCtrl.deactivate();
				}
			},
			/**
			 * APIMethod: activate
			 * 激活拖动Control
			 */
			activate : function() {
				if (!this.dragCtrl.active) {
					this.dragCtrl.activate();
				}
			},
			CLASS_NAME : "HGIS.Plot.MovedCircle"
		});
/**
 * Class: HGIS.Plot.Pie
 * 在矢量图层上构造一个用于创建饼状图的实例
 * 
 * Parameters:
 * layer - {<HGIS.Layer.Vector>} 承载饼状图的矢量图层，请确保该图层在地图上已存在
 * pieAlpha - {Number} 饼状图的透明度,0~1,数值越大，越不透明。默认值1。
 * pieRadius - {Number} 饼状图的半径，正整数，单位：米，默认值1000米。
 * 
 * 示例:
 * (code)
 * var pie=new HGIS.Plot.Pie(vectorLayer,1,10);
 * pie.Create
 * (end)
 */
HGIS.Plot=HGIS.Plot||{};
HGIS.Plot.Pie = function(layer,pieRadius,pieAlpha) {
	var thisObj=this;
	thisObj.pieStartAngle=0;// 默认正东朝向
	thisObj.pieRadius=pieRadius?pieRadius:1000;
	thisObj.pieAlpha=pieAlpha?pieAlpha:1;
	thisObj.map=layer.map;
	thisObj.sides = 360;// 暂时采用一边一度的方式画扇形
	
	/**
	 * APIMethod: createPie
	 * 创建一个饼状图
	 * 
	 * Parameters:
	 * data - {Object} 饼状图数据。一个数组，包含了组成饼状图各部分数据项。每个数据项由三个指标item,num,color组成。<br>
	 *            item表示类型，在数组中不要重复出现，因系统会根据此项归类；num表示数量；color表示颜色，16进制或RGB值都可以。例如：[{item:"海康份额",num:16,color:"#fffff"}]
	 * pieCenter - {<HGIS.Geometry.Point>} 饼状图的中心点经纬度
	 * labelStyle - {Object} 表示饼状图每部分的样式，json对象。例：{labelText:"两抢案",labelStyle:{"HGIS中的文字标注样式"}}。如果不传，系统会给出默认标示。
	 * sectorId - {String} 饼状图各部分的标识
	 */
	this.createPie=function(data,pieCenter,labelStyle,classText){
		var classT=classText?classText:"default";
		var sum=0;// 总数
		for(var k=0;k<data.length;k=k+1){
			sum=sum+data[k].num*1;
		}
		// 针对每一项，给出一个扇形
		var startAngle=0;
		for(var j=0;j<data.length;j=j+1){
			data[j].degree=Math.floor((data[j].num/sum)*360);// 每一项数据应转过多少弧度
			data[j].startAngle=startAngle;// 每一类数据的起始角,一项结束角度就是下一项的起始角度
			startAngle=startAngle+data[j].degree;
		}
		// 针对每一项，给出一个扇形
		var startAngle=0,rotatedAngle;
		for(var j=0;j<data.length;j=j+1){
			var itemAngle=(data[j].num/sum)*360;// 单项扇形应占角度
			//获取layer的坐系
		
			//var distSpan=layer.map.degreeSpanToMeter(pieCenter.y,"degree");// 计算摄像头所在位置每一度能代表多少米
			//var radius=pieRadius/distSpan;// 把参数visibleDist转化为地图单位
			
			var radius=pieRadius;
			var points = new Array();// 单项扇形组成的数组
			points.push(pieCenter);// 首先中心点作为单项扇形中心点要添加进来
			for ( var i = 0; i <=thisObj.sides; i = i + 1) {
				var sideN = i * ((itemAngle) / 360);// angle除以360=第i条边/总边数，那么sideN表示共有多少条边
				rotatedAngle = startAngle + (sideN * 2 * Math.PI / thisObj.sides);// 第i条边所转过的角度
			    var x = pieCenter.x + (radius * Math.cos(rotatedAngle));
				var y = pieCenter.y + (radius * Math.sin(rotatedAngle));
				var p=new HGIS.Geometry.Point(x, y);// 新生成了一个点，
				points.push(p);
			}
			var ring = new HGIS.Geometry.LinearRing(points);
			var attr={item:data[j].item,num:data[j].num};
			var labelText=data[j].item+'\/'+Math.round(data[j].num/sum*100)+"%";
			var style={fillColor:data[j].color,fillOpacity:pieAlpha,label:labelText}
			var sector= new HGIS.Feature.Vector(ring,data[j],style);
			sector.attributes.sectorClass=classT;
			layer.addFeatures([sector]);
		  	startAngle=rotatedAngle;
		  }
	
	};
	/**
	 * APIMethod: getSectorsByClass
	 * 根据fid获取一个饼图对象
	 * 
	 * Parameters:
	 * sectorClass - {String} 饼状图标识
	 * 
	 * Returns:
	 * {Array} 返回pies {Array} HGIS.Layer.Vector
	 */
	this.getSectorsByClass=function(sectorClass){
		var features=layer.getFeaturesByAttribute("sectorClass",sectorClass);
		return features;
	};
	/**
	 * APIMethod: addMouseEvt
	 * 注册饼状图鼠标事件，响应于饼状图的各个部分
	 * 
	 * Parameters:
	 * isHover - {Boolean} 是否响应鼠标滑过事件
	 * highlightOnly - {Boolean} 是否高亮显示
	 * selectStyle - {Object} 鼠标选中时的样式
	 * callback - {Object} 事件触发后的回调函数
	 */
	this.addMouseEvt = function(isHover,highlightOnly,selectStyle,callback) {
		var controls=thisObj.map.getControlsBy("id","pieMounseControl");
		var exsits=false;// 是否存在鼠标控件的标志
		// 遍历地图上符合上述条件的的控件。 存在这个控件且处于未激活状态，则强制激活之
		for(var i=0;i<controls.length;i=i+1){
			var control=controls[i];
			if(control.id=="pieMounseControl"){
				control.activate();
				exsits=true;
				break;
			}
		}
		// 控件不存在，则需创建之
		if(!exsits){
			var selectControl = new HGIS.Control.SelectFeature(layer, {
				id:"pieMounseControl",
				clickout : true,
				multiple : false,
				hover : isHover,
			    highlightOnly: highlightOnly,
				selectStyle:selectStyle,
				toggleKey : "ctrlKey",
				box : false,
				clickFeature : function(feature) {
					callback(feature);
			}
			});
			thisObj.map.addControl(selectControl);
			selectControl.activate();
		}
	};
};

/**
 * Class: HGIS.Plot.Sector
 * 扇形类
 */
HGIS.Plot =HGIS.Plot|| {};
HGIS.Plot.Sector = {
	/**
	 * APIProperty: plotSectorSelf
	 * {<HGIS.Plot.Sector>} 当前对象实例
	 */
	plotSectorSelf : null, //
	/**
	 * APIProperty: vectors
	 * 扇形标绘的依附图层
	 */
	vectors : null,
	/**
	 * APIProperty: _map
	 * 地图对象
	 */
	_map : null,
	/**
	 * APIProperty: controlPoints
	 * {Array} 扇形控制点
	 */
	controlPoints : [], //扇形控制点
	/**
	 * APIProperty: sectorRadius
	 * {Number} 扇形半径,由前两个控制点组成
	 */
	sectorRadius : 0, //扇形半径,由前两个控制点组成
	/**
	 * APIProperty: tempSectorPoints
	 * {Array} 鼠标绘制过程中生成的临时扇形点对象
	 */
	tempSectorPoints : [], //
	/**
	 * APIProperty: tempSector
	 * {<HGIS.Plot.Sector>} 临时的扇形对象
	 */
	tempSector : null, //临时的扇形对象
	/**
	 * APIProperty: tempControlVectors
	 * {Array} 在地图上显示的扇形临时控制点矢量要素
	 */
	tempControlVectors : [], //在地图上显示的扇形临时控制点矢量要素
	/**
	 * APIMethod: setLayer
	 * 设置扇形标绘的依附图层
	 * 
	 * Parameters:
	 * vectors - {HGIS.Layer.Vector} 扇形标绘的依附图层
	 */
	setLayer : function(vectors) {
		this.vectors = vectors;
		this._map = this.vectors.map;
		plotSectorSelf = this;
		//转换度让权
	},
	/**
	 * APIMethod: addToControlPoints
	 * 添加扇形的控制点
	 * 
	 * Parameters:
	 * controlPoint - {<HGIS.Geometry.Point>}控制点
	 */
	addToControlPoints : function(controlPoint) {
		this.controlPoints.push(controlPoint);
		//把前两个控制点添加到图层上
		var tempControlVector = new HGIS.Feature.Vector(controlPoint);
		plotSectorSelf.tempControlVectors.push(tempControlVector);
		plotSectorSelf.vectors.addFeatures(plotSectorSelf.tempControlVectors);
	},
	/**
	 * APIMethod: caculateSectorRadius
	 * 利用控制点的前两个点计算扇形半径。
	 */
	caculateSectorRadius : function() {
		var p1 = this.controlPoints[0];
		var p2 = this.controlPoints[1];
		plotSectorSelf.sectorRadius = p1.distanceTo(p2);
	},
	/**
	 * APIMethod: caculateArcPoint
	 * 计算扇形圆弧当前的实际经纬度点。这个算法比较冒险
	 * 
	 * Parameters:
	 * point - {<HGIS.Geometry.Point>} 鼠标移动事件产生的经纬度点
	 *
	 * Returns:
	 * {<HGIS.Geometry.Point>} 扇形弧段上的实际点
	 */
	caculateArcPoint : function(startPoint, movePoint, radius) {
		var angle = this.calulateXYAnagle(startPoint, movePoint);

		var x, y;
		//正向x轴上
		if(angle == 0) {
			x = startPoint.x + radius;
			y = startPoint.y;
		}
		if(angle > 0 && angle < Math.PI / 2)//第一象限
		{
			x = startPoint.x + radius * Math.cos(angle);
			y = startPoint.y + radius * Math.sin(angle);
		} else if(angle == Math.PI / 2)//正向y轴
		{
			x = startPoint.x;
			y = startPoint.y + radius;
		} else if(angle > Math.PI / 2 && angle < Math.PI)//第二象限
		{
			x = startPoint.x - radius * Math.cos(Math.PI - angle);
			y = startPoint.y + radius * Math.sin(Math.PI - angle);
		} else if(angle == Math.PI)//负向x轴
		{
			x = startPoint.x - radius;
			y = startPoint.y;
		} else if(angle > Math.PI && angle < Math.PI * 3 / 2)//第三象限
		{
			x = startPoint.x - radius * Math.cos(angle - Math.PI);
			y = startPoint.y - radius * Math.sin(angle - Math.PI);
		} else if(angle == Math.PI * 3 / 2)//负向Y轴
		{
			x = startPoint.x;
			y = startPoint.y - radius;
		} else if(angle > Math.PI * 3 / 2 && angle < Math.PI * 2)//第四象限
		{
			x = startPoint.x + radius * Math.cos(2 * Math.PI - angle);
			y = startPoint.y - radius * Math.sin(2 * Math.PI - angle);
		}
		return new HGIS.Geometry.Point(x, y);
	},
	/**
	 * APIMethod: calulateXYAnagle
	 * 计算扇形开始边的角度
	 * 
	 * Parameters:
	 * startPoint - {<HGIS.Geometry.Point>} 起点
	 * endPoint - {<HGIS.Geometry.Point>} 终点
	 * 
	 * Returns:
	 * {Number} 返回角度
	 */
	//计算起线角
	calulateXYAnagle : function(startPoint, endPoint) {
		var startx = startPoint.x;
		var starty = startPoint.y;
		var endx = endPoint.x;
		var endy = endPoint.y;
		if(startx == endx) {
			if(endy > starty)
				return Math.PI / 2;
			else
				return Math.PI * 3 / 2;
		} else if(starty == endy) {
			if(endx > startx)
				return 0;
			else
				return Math.PI;
		} else {
			var angle = Math.atan(Math.abs((endy - starty) / (endx - startx)));
			if(endx > startx && endy > starty)//第一象限
			{
				return angle;
			} else if(endx < startx && endy > starty)//第二象限
			{
				return Math.PI - angle;
			} else if(endx < startx && endy < starty)//第三象限
			{
				return angle + Math.PI;
			} else {
				return 2 * Math.PI - angle;
			}
		}
	},
	/**
	 * APIMethod: caculateLength
	 * 计算两点间的距离
	 * 
	 * Parameters:
	 * startPoint - {<HGIS.Geometry.Point>} 起点
	 * endPoint - {<HGIS.Geometry.Point>} 终点
	 * 
	 * Returns:
	 * {Number} 返回距离
	 */
	caculateLength : function(startPoint, endPoint) {
		return startPoint.distanceTo(endPoint);
	},
	//计算方位角
	/**
	 * APIMethod: calulateDirectionAnagle
	 * 计算两边的方位角
	 * 
	 * Parameters:
	 * startAnagle - {Number} 起边弧度
	 * endAnagle - {Number} 终边弧度
	 * direction - {Number} 方向 1 正向 -1 反向
	 * 
	 * Returns:
	 * {Number} 返回方位角
	 */
	calulateDirectionAnagle : function(startAnagle, endAnagle, direction) {
		//斜边长度
		return startAnagle + (endAnagle - startAnagle) / 2 + direction * Math.PI;
	},
	/**
	 * APIMethod: beginDrawArcLine
	 * 绘制弧线
	 * 
	 * Parameters:
	 * evt 鼠标移动事件
	 */
	beginDrawArcLine : function(evt) {
		//清除之前的扇形对象，以便绘制新的扇形对象
		if(plotSectorSelf.tempSector) {
			plotSectorSelf.vectors.removeFeatures([plotSectorSelf.tempSector]);
		}
		//从鼠标位置获取几何体对象,显示到地图上。
		var pixel = new HGIS.Pixel(evt.x, evt.y);
		var lonlat = plotSectorSelf.vectors.map.getLonLatFromPixel(pixel);
		var oldPoint = new HGIS.Geometry.Point(lonlat.lon, lonlat.lat);
		//对这个geom进行约束
		newPoint = this.caculateArcPoint(this.controlPoints[0], oldPoint, this.sectorRadius)

		//	newPoint = plotSectorSelf.caculateArcPoint(oldPoint);
		//生成新的线，并添加到地图上
		plotSectorSelf.tempSectorPoints.push(newPoint);
		var lineRing = new HGIS.Geometry.LinearRing(plotSectorSelf.tempSectorPoints);
		var polyGeom = new HGIS.Geometry.Polygon([lineRing]);
		plotSectorSelf.tempSector = new HGIS.Feature.Vector(polyGeom);
		plotSectorSelf.tempSector.attributes.orignPoint = plotSectorSelf.controlPoints[0];
		//鼠标移动生成的临时点添加到弧线数据组中
		plotSectorSelf.vectors.addFeatures([plotSectorSelf.tempSector]);
	},
	/**
	 * APIMethod: caculateDirection
	 * 计算鼠标是在有起点和重点构成的线顺时针移动还是捏始终
	 * 
	 * Parameters:
	 * startPoint  - {<HGIS.Geometry.Point>} 起点
	 * endPoint  - {<HGIS.Geometry.Point>} 起点
	 * movePoint  - {<HGIS.Geometry.Point>} 移动点
	 * 
	 *  Returns:
	 *  {Number} 顺时针1 逆时针0
	 */
	caculateDirection : function(startPoint, endPoint, movePoint) {
		var startAngle = this.calulateXYAnagle(startPoint, endPoint);
		var endAngle = this.calulateXYAnagle(startPoint, movePoint);
		//如果角度
		if(endAngle > startAngle && endAngle < Math.PI + startAngle) {
			//逆时针
			return 0;
		} else {
			//顺时针
			return 1;
		}
	},
	/**
	 * APIMethod: draw
	 * 添加绘制可视域控件.
	 * 思路：
	 * 1、首先，前两个控件点用画线的方式实现。其中第一个点决定圆心，第二个决定半径与起始边。
	 * 2、完成后修改直线方式，改为画流式线。流式线绘制结束时的geometry决定第三条边
	 */
	draw : function() {
		var drawSectorControl = new HGIS.Control.DragFeature(plotSectorSelf.vectors);
		HGIS.Util.extend(drawSectorControl, {
			draw : function() {
				var handler = new HGIS.Handler.Path(drawSectorControl, {
					maxVertices : 3//画直线部最多只加两个节点，第一点确定圆心，第二点确定超始角。两点距离确定半径
				});
				handler.activate();
				//鼠标按下时观察控制点个数
				handler.down = function(evt) {
					var pixel = new HGIS.Pixel(evt.x, evt.y);
					var lonlat = this.layer.map.getLonLatFromPixel(pixel);
					var controlPoint = new HGIS.Geometry.Point(lonlat.lon, lonlat.lat);
					//控制点最多不能超过三个。否则表示绘制结束，则禁用控件
					if(plotSectorSelf.controlPoints.length == 0) {
						plotSectorSelf.addToControlPoints(controlPoint);
					} else if(plotSectorSelf.controlPoints.length <= 1) {
						plotSectorSelf.addToControlPoints(controlPoint);
						//把控制点的前两个点连成一条直线，显示在地图上
						this.control.addFirstEdge();
						//把扇形半径计算出来
						plotSectorSelf.caculateSectorRadius();
						//两个控制点绘制完后，启用鼠标移动事件，开始画弧段
						plotSectorSelf.tempSectorPoints = plotSectorSelf.controlPoints;
						this.move = function(evt) {
							plotSectorSelf.beginDrawArcLine(evt);
						};
					} else {
						//再加一个就三个了,可以结束绘制控件了
						plotSectorSelf.addToControlPoints(controlPoint);
						//禁用控制器
						this.deactivate();
						//首先清除掉之前的临时要素
						plotSectorSelf.vectors.removeFeatures(plotSectorSelf.tempControlVectors);
						//再把最新的扇形加上来
						plotSectorSelf.tempSector.attributes.orignPoint = plotSectorSelf.controlPoints[0];
						//鼠标移动生成的临时点添加到弧线数据组中
						plotSectorSelf.vectors.addFeatures([plotSectorSelf.tempSector]);
					}
				};
			},
			//添加第一条扇形边
			addFirstEdge : function() {
				var lineStr = new HGIS.Geometry.LineString(this.controlPoints);
				var lineVector = new HGIS.Feature.Vector(lineStr);
				plotSectorSelf.vectors.addFeatures([lineVector]);
			}
		});
		this._map.addControl(drawSectorControl);
	},
	/**
	 * APIProperty: RotateControl
	 * 扇形旋转控件
	 */
	RotateControl : HGIS.Class(HGIS.Control.ModifyFeature, {
		collectRadiusHandle : function(orignPoint) {
			var geometry = this.feature.geometry;
			var bounds = geometry.getBounds();
			//var originGeometry = new HGIS.Geometry.Point(center.lon, center.lat);
			var originGeometry = this.feature.attributes.orignPoint;
			var radiusGeometry = new HGIS.Geometry.Point(bounds.right, bounds.bottom);
			var radius = new HGIS.Feature.Vector(radiusGeometry);
			var resize = (this.mode & HGIS.Control.ModifyFeature.RESIZE);
			var reshape = (this.mode & HGIS.Control.ModifyFeature.RESHAPE);
			var rotate = (this.mode & HGIS.Control.ModifyFeature.ROTATE);
			radiusGeometry.move = function(x, y) {
				HGIS.Geometry.Point.prototype.move.call(this, x, y);
				var dx1 = this.x - originGeometry.x;
				var dy1 = this.y - originGeometry.y;
				var dx0 = dx1 - x;
				var dy0 = dy1 - y;
				if(rotate) {
					var a0 = Math.atan2(dy0, dx0);
					var a1 = Math.atan2(dy1, dx1);
					var angle = a1 - a0;
					angle *= 180 / Math.PI;
					geometry.rotate(angle, originGeometry);
				}
				if(resize) {
					var scale, ratio;
					// 'resize' together with 'reshape' implies that the aspect
					// ratio of the geometry will not be preserved whilst resizing
					if(reshape) {
						scale = dy1 / dy0;
						ratio = (dx1 / dx0) / scale;
					} else {
						var l0 = Math.sqrt((dx0 * dx0) + (dy0 * dy0));
						var l1 = Math.sqrt((dx1 * dx1) + (dy1 * dy1));
						scale = l1 / l0;
					}
					geometry.resize(scale, originGeometry, ratio);
				}
			};
			radius._sketch = true;
			this.radiusHandle = radius;
			this.radiusHandle.renderIntent = this.vertexRenderIntent;
			this.layer.addFeatures([this.radiusHandle], {
				silent : true
			});
		}
	}),

	/**
	 * APIMethod: modify
	 * 修改扇形
	 * 包括修改角度大小与改变朝向
	 */
	modify : function(vector, orignPoint) {
		//var originGeometry = this.feature.attributes.orignPoint;
		//var layer=vector.layer;
		this.Sector.setLayer(vectors);

		var rotateControl = new plotSectorSelf.RotateControl(plotSectorSelf.vectors);
		rotateControl.mode = HGIS.Control.ModifyFeature.RESIZE;
		rotateControl.mode |= HGIS.Control.ModifyFeature.ROTATE;
		plotSectorSelf._map.addControl(rotateControl);
		rotateControl.activate();
	}
};
/**
 * Class: HGIS.Plot.ViewShed
 * 可视域对象类 描述摄像头可视范围的几何体对象. 可视域反应了监控点能探测到的地理区域。对于一个标准的可视域对象，以正北方向为起点，逆时针方向为正,起点为0度，终点为360度；沿逆时针方向绘制可视域，具体的可视域要根据实际参数调整。为了形象地表示可视域，本类给出了生成渐变效果选项。
 * 
 * Parameters:
 * layer - {<HGIS.Layer.GraphicLayer>} 这些可视域将会在哪个图层上展示，构造可视域对象之前，请确保此图已添加到地图上
 * options - {Object} 可选参数,json格式。有以下几个选项可参考：
 *  -       -  usingEventCenter - {Boolean} true表示利用当前中心点与单个可视域之间的位置关系来确定可视域朝向；若设为false,则表示可视域的朝向来自球机参数等其它渠道，false时调用createByCenter方法时，eventCenter默认为与originPoint重合。
 *  -       -  eventCenter - {<HGIS.Geometry.Point>} 事发中心点。若usingEventCenter为false,则此参数将不起作用
 * 	-	    -  viewShedStyle -  可视域样式，若不传则用默认样式。
 *  -       -  dura - {Number} 可视域的渐变效果层次数，默认为1,变量为等于或大于1的正整数。
 *  -       -  duraSides - {Number} 可视域弧段边数，默认为100，变量为正整数。   
 *            
 * 示例:
 * (code)
 * var originPoint = new HGIS.Geometry.Point(120.219, 30.211);
 * var options = {
 * 		"usingEventCenter" : true,// 使用指定点确定扇形朝向,为false或不设置createByCenter方法将不起作用
 *		"eventCenter" : eventPoint,//geometry对象，若usingEventCenter为false,那么这个参数将不起作用
 *		"dura" : 2,
 *		"viewShedStyle" : null
 *		"duraSides":100  //可视域弧边数，默认为100,
 *	};
 * var viewShed = new HGIS.Plot.ViewShed(layer, options);
 * var shedAngle =90;
 * var edgeLength =10;
 * var azimuths =40;
 * var sector = viewShed.createBySpecified(originPoint, edgeLength,azimuths, shedAngle);
 * (end)
 */
HGIS.Plot=HGIS.Plot||{};
HGIS.Plot.ViewShed = function(layer, options) {
	var thisObj = this;
	thisObj.dura = (options.dura && options.dura > 0) ? options.dura : 1;// 正整数。可视域的渐变效果，该数值表示分多少级渐变，默认为1。
	// 默认的可视域样式
	thisObj.defaultStyle = (options.viewShedStyle != null) ? options.viewShedStyle
			: {
				fillOpacity : 0.5,
				strokeWidth : 0,
				fillColor : "blue"
			};
	thisObj.duraSides = (options.duraSides > 0) ? options.duraSides : 100;// 可视域弧形边，默认有100条小边微积组成
	thisObj.usingEventCenter = options.usingEventCenter ? true :false;

	/**
	 * APIMethod: createBySpecified
	 * 给出可视域的各项参数，创建可视域
	 * 
	 * Parameters:
	 * origin - {<HGIS.Geometry.Point>} 以摄像头所在位置为可视域中心点
	 * radius - {Number} 摄像头可视距离为可视域半径,单位米
	 * azimuths - {Number} 方位角，也就是摄像头的朝向
	 * shedAngle - {Number} 可视角度范围(0-180度之间)。单位度，度分秒格式，例：96.35
	 * 
	 * Returns:
	 * {<HGIS.Feature.Vector>} 返回可视域
	 */
	this.createBySpecified = function(origin, radius, azimuths, shedAngle) {
		//限定可视角度的范围
		if(shedAngle <= 0 || shedAngle > 180){
			return;
		}
		var rings = [];// 可视域环数组，用来存储每一个圆弧上的点
		// 起始点弧度 ，球机以正北为方向，本系统以正东为起始方向，因此+90
		var startAngle = (azimuths - shedAngle / 2.0 + 90) * (Math.PI / 180.0);
		
		// 如果thisObj.dura为1，那么不层叠显示可视域
		var _radius=radius;
		for (var j = thisObj.dura; j > 0; j = j - 1) {
			//修改半径
			_radius = (radius / thisObj.dura) * j;
			var ring = HGIS.Utils.createSector(origin,_radius,azimuths + 90,shedAngle,thisObj.duraSides);
			rings.push(ring);
		}
		var sector = null;	 
		
		for (var i = 0; i < rings.length; i++) {
			sector = new HGIS.Feature.Vector(rings[i]);
			sector.attributes.startAngle = startAngle;
			sector.style = thisObj.defaultStyle;
			layer.addFeatures([ sector ]);
		}
		return sector;
	};

	/**
	 * APIMethod: createByCenter
	 * 通过中心点和eventCenter构建可视域，可视域方位角由options中的eventCenter和originPoint共同决定
	 * 
	 * Parameters:
	 * originPoint - {<HGIS.Geometry.Point>}
	 * 以摄像头所在位置为可视域中心点
	 * radius - {Number} 摄像头可视距离为可视域半径,单位米
	 * shedAngle - {Number} 可视角度范围(0-180度之间)。单位度，度分秒格式，例：96.35
	 * 
	 */
	this.createByCenter = function(originPoint, radius, shedAngle) {
		//限定可视角度的范围
		if(shedAngle <= 0 || shedAngle > 180){
			return;
		}
		if(HGIS.InitParam.mapUnit=="degrees"){
			var distSpan = layer.map.degreeSpanToMeter(originPoint.y, "degrees");
			radius = radius / distSpan;
		};
		var rings = new Array();
		var angle = Math.PI * (1 / thisObj.duraSides);
		//如果usingEventCenter 为false，则取默认为originPoint
		thisObj.eventCenter = thisObj.usingEventCenter ? options.eventCenter : originPoint;
		//如果中心点和事件点在同一个位置则 设置可视域起点为球机的默认方向，因本系统以正东方向为起始方向，所以需要+90
		var centerLineAngle;
		if(originPoint.x == thisObj.eventCenter.x && originPoint.y == thisObj.eventCenter.y){
			centerLineAngle = 90;
		}else{
			//根据摄像头中心点和事件点位置，确定摄像头的方位角
			centerLineAngle = thisObj.direct(originPoint, thisObj.eventCenter,shedAngle);
		}
		var rotation = centerLineAngle;
		angle += (rotation / 180) * Math.PI;
		
		var rotatedAngle, x, y;
		var avgRadius = radius / thisObj.dura;
		for (var j = thisObj.dura; j >= 1; j = j - 1) {
			var points = [];
			points.push(originPoint);
			radius = avgRadius * j;
			for (var i = 0; i < thisObj.duraSides; i = i + 1) {
				var an = i * ((shedAngle) / 360);
				rotatedAngle = angle + (an * 2 * Math.PI / thisObj.duraSides);
				x = originPoint.x + (radius * Math.cos(rotatedAngle));
				y = originPoint.y + (radius * Math.sin(rotatedAngle));
				points.push(new HGIS.Geometry.Point(x, y));
			}
			var ring = new HGIS.Geometry.LinearRing(points);
			rings.push(ring);
		}
		
		var sector = null;		
		for (var i = 0; i < rings.length; i++) {
			sector = new HGIS.Feature.Vector(rings[i]);
			sector.style = thisObj.defaultStyle;
			layer.addFeatures([ sector ]);
		}
		return sector;
	}

	/**
	 * Method: direct
	 * 利用反正切来确定可视域起始线在象限中的角度.
	 * 
	 * Parameters:
	 * thisPoint - {<HGIS.Geometry.Point>} 摄像头所在位置.
	 * targetPoint - {<HGIS.Geometry.Point>} 弧上中心点.
	 * shedAngle - {Number} 可视域的角度
	 */
	this.direct = function(thisPoint, targetPoint, shedAngle) {
		var difLat = targetPoint.y - thisPoint.y;// 纬度差
		var difLon = targetPoint.x - thisPoint.x;// 经度差
		var atan = Math.atan2(difLat, difLon); // 象限弧度
		var cenerLineAngle = 180 * atan / Math.PI;// 中心法线所指方向
		var startAngle = cenerLineAngle - shedAngle / 2;
		return startAngle;

	};

	/**
	 * APIMethod: highLightEffect
	 * 高亮显示可视域区域
	 * 
	 * Parameters:
	 * isHighLight - {Boolean}  是否添加高亮显示可视域的效果。true表示需要高亮显示，false表示无需高亮显示
	 * highLightStyle - 高亮显示样式
	 * callback - {Function}  回调事件
	 */
	this.highLightEffect = function(isHighLight,highLightStyle,callback) {
		if(isHighLight){
			var highlightCtrl = layer.map.getControl("highlightCtrlId");
			if(highlightCtrl==null){
				var highlightCtrl = new HGIS.Control.SelectFeature(layer, {
					id:"highlightCtrlId",
					clickout : true,
					multiple : true,
					hover : true,
					highlightOnly :false,
					selectStyle:{
						fillColor : "#FF0000",//"#ee9900",
						fillOpacity : 0.5
					},
					 
					clickFeature : function(feature) {			 
						callback(feature);
					}			
				});
				highlightCtrl.events.register('featurehighlighted',layer,function(e){				 
						e.feature.layer.drawFeature(e.feature,highLightStyle);
					});
				layer.map.addControl(highlightCtrl);
				highlightCtrl.activate();
			}
		}else{
			return;
		}
	};
}
/**
 * Class: HGIS.Popup.InfoWindow
 * 地图上的弹窗控件。
 * 
 * 继承自:
 * - <HGIS.Popup.FramedCloud>
 * 
 * Examples:
 * (code)
 * var id="pop_id";
 * var lonlat=new HGIS.LonLat(120,30);
 * var contentSize=new HGIS.Size('auto','auto');
 * var titleHTML="00";
 * var contentHTML="00";
 * var anchor={
 *			size:new HGIS.Size(10,10),
 *			offset:new HGIS.Pixel(0,0)
 *		},
 * var closeBox=true; 
 * var closeBoxCallback=function(){};
 * 
 * var pop=new HGIS.Popup.InfoWindow(id,lonlat,contentSize,titleHTML,contentHTML,anchor,closeBox,closeBoxCallback);
 * (end)
 */
HGIS.Popup = HGIS.Popup || {};
HGIS.Popup.InfoWindow = HGIS.Class( HGIS.Popup.FramedCloud,{
		titleDisplayClass : "titleDisplayClass",
		titleHTML : "00",
		subContentHTML : "00",
		positionOffSet : null,
		positionBlocks : {
			"tr" : {
				'offset' : new HGIS.Pixel(-45, -30),
				'padding' : new HGIS.Bounds(8, 0, 8, 9),
				'blocks' : [ { // top-left
					size : new HGIS.Size('auto', 'auto'),
					anchor : new HGIS.Bounds(0, 19, 22, 0),
					position : new HGIS.Pixel(0, 0)
				}, { // top-right
					size : new HGIS.Size(22, 'auto'),
					anchor : new HGIS.Bounds(null, 19, 0, 0),
					position : new HGIS.Pixel(-1238, 0)
				}, { // bottom-left
					size : new HGIS.Size('auto', 19),
					anchor : new HGIS.Bounds(0, 0, 22, null),
					position : new HGIS.Pixel(0, -631)
				}, { // bottom-right
					size : new HGIS.Size(22, 19),
					anchor : new HGIS.Bounds(null, 0, 0, null),
					position : new HGIS.Pixel(-1238, -631)
				}, { // stem
					size : new HGIS.Size(81, 35),
					anchor : new HGIS.Bounds(0, -32, null, null),
					position : new HGIS.Pixel(-215, -687)
				} ]
			}
		},
		/**
		 * Constructor: HGIS.Popup.InfoWindow
		 * 地图弹窗的构造方法
		 * 
		 * Parameters:
		 * id: - {String} 控件id
		 * lonlat - {<HGIS.LonLat>} 位置
		 * contentSize - {Number} 内容框的大小
		 * titile - {String} 标题
		 * contenHTML - {String} 内容
		 * anchor - {Object} 弹窗的锚点.  必须暴露大小和偏移
		 * closeBox - {Boolean} 是否有关闭按钮					
		 * closeBoxCallback - {Object} 关闭的回调函数,自定义.如果提供，HGIS关闭时默认执行此回调，
		 */
		initialize : function(id, lonlat, contentSize, titleHTML,
				contentHTML, anchor, closeBox, closeBoxCallback) {
			if (anchor.offset) {
				this.positionOffSet = anchor.offset;
			} else {
				this.positionOffSet = new HGIS.Pixel(0, 0);
			}
			this.imageSrc = HGIS.Util
					.getImageLocation('cloud-popup-relative.png');
			this.autoSize = false;

			var newArguments = [ id, lonlat, contentSize,
					contentHTML, anchor, closeBox, closeBoxCallback ];
			HGIS.Popup.Framed.prototype.initialize.apply(this,
					newArguments);

			this.contentDisplayClass = "hgis_FramedCloudPopupContent";
			// HGIS.Popup.Framed.prototype.initialize.apply(this,
			// arguments);
			// this.fixedRelativePosition = true;
			this.contentDiv.className = this.contentDisplayClass;

			this.groupDiv.style.position = "absolute";
			this.groupDiv.style.top = "0px";
			this.groupDiv.style.left = "0px";
			this.groupDiv.style.height = "100%";
			this.groupDiv.style.width = "100%";
			this.groupDiv.style.overflow = "visible";

			this.titleHTML = (titleHTML != null) ? titleHTML : "";
			this.subContentHTML = (contentHTML != null) ? contentHTML
					: "";
			this.contentHTML = this.titleContent();
		},
		/**
		 * APIMethod: titleContent 
		 * 返回包含标题和信息框内容的html字符串
		 */
		titleContent : function() {
			var newcontentHTML = "<div class='"
					+ this.titleDisplayClass + "'>"
					+ this.titleHTML + "</div><div>"
					+ this.subContentHTML + "</div>";
			return newcontentHTML;
		},

		/**
		 * APIMethod: setTitle
		 * 设置标题
		 * 
		 * Parameters:
		 * titleHTML: - {String} 标题
		 */
		setTitle : function(titleHTML) {
			this.titleHTML = titleHTML;
			this.contentHTML = this.titleContent();
			this.setContentHTML(this.contentHTML);
		},
		
		/**
		 * APIMethod: setContent
		 * 设置内容
		 * 
		 * Parameters:
		 * contentHTML: - {String} 内容
		 */
		setContent : function(contentHTML) {
			this.subContentHTML = contentHTML;
			this.contentHTML = this.titleContent();
			this.setContentHTML(this.contentHTML);
		},
		
		/**
		 * Method: getSafeContentSize
		 * 获取弹窗的尺寸
		 * 
		 * Parameters:
		 * size: - {Object} 大小
		 */
		getSafeContentSize : function(size) {

			var safeContentSize = size.clone();

			// if our contentDiv has a css 'padding' set on it by a
			// stylesheet, we
			// must add that to the desired "size".
			var contentDivPadding = this.getContentDivPadding();
			var wPadding = contentDivPadding.left
					+ contentDivPadding.right;
			var hPadding = contentDivPadding.top
					+ contentDivPadding.bottom;

			// take into account the popup's 'padding' property
			this.fixPadding();
			wPadding += this.padding.left + this.padding.right;
			hPadding += this.padding.top + this.padding.bottom;

			if (this.closeDiv) {
				var closeDivWidth = parseInt(this.closeDiv.style.width);
				wPadding += closeDivWidth + contentDivPadding.right;
			}

			// prevent the popup from being smaller than a specified
			// minimal size
			if (this.minSize) {
				safeContentSize.w = Math.max(safeContentSize.w,
						(this.minSize.w - wPadding));
				safeContentSize.h = Math.max(safeContentSize.h,
						(this.minSize.h - hPadding));
			}

			// prevent the popup from being bigger than a specified
			// maximum size
			if (this.maxSize) {
				safeContentSize.w = Math.min(safeContentSize.w,
						(this.maxSize.w - wPadding));
				safeContentSize.h = Math.min(safeContentSize.h,
						(this.maxSize.h - hPadding));
			}

			// make sure the desired size to set doesn't result in a
			// popup that
			// is bigger than the map's viewport.
			//
			if (this.map && this.map.size) {

				var extraX = 0, extraY = 0;
				if (this.keepInMap && !this.panMapIfOutOfView) {
					var px = this.map
							.getPixelFromLonLat(this.lonlat);
					switch (this.relativePosition) {
					case "tr":
						extraX = px.x;
						extraY = this.map.size.h - px.y;
						break;
					case "tl":
						extraX = this.map.size.w - px.x;
						extraY = this.map.size.h - px.y;
						break;
					case "bl":
						extraX = this.map.size.w - px.x;
						extraY = px.y;
						break;
					case "br":
						extraX = px.x;
						extraY = px.y;
						break;
					default:
						extraX = px.x;
						extraY = this.map.size.h - px.y;
						break;
					}
				}

				var maxY = this.map.size.h
						- this.map.paddingForPopups.top
						- this.map.paddingForPopups.bottom
						- hPadding - extraY;

				var maxX = this.map.size.w
						- this.map.paddingForPopups.left
						- this.map.paddingForPopups.right
						- wPadding - extraX;

				safeContentSize.w = Math.min(safeContentSize.w,
						maxX);
				safeContentSize.h = Math.min(safeContentSize.h,
						maxY);
			}

			return safeContentSize;
		},
		/**
		 * Method: updateSize
		 * 自动更新大小适配内容
		 */
		updateSize : function() {

			// determine actual render dimensions of the contents by
			// putting its
			// contents into a fake contentDiv (for the CSS) and
			// then measuring it
			var preparedHTML = "<div class='"
					+ this.contentDisplayClass + "'>"
					+ this.contentDiv.innerHTML + "</div>";

			var containerElement = (this.map) ? this.map.div
					: document.body;
			var realSize = HGIS.Util.getRenderedDimensions(
					preparedHTML, null, {
						displayClass : this.displayClass,
						containerElement : containerElement
					});

			// is the "real" size of the div is safe to display in
			// our map?
			var safeSize = this.getSafeContentSize(realSize);

			var newSize = null;
			if (safeSize.equals(realSize)) {
				// real size of content is small enough to fit on
				// the map,
				// so we use real size.
				newSize = realSize;

			} else {

				// make a new 'size' object with the clipped
				// dimensions
				// set or null if not clipped.
				var fixedSize = {
					w : (safeSize.w < realSize.w) ? safeSize.w
							: null,
					h : (safeSize.h < realSize.h) ? safeSize.h
							: null
				};

				if (fixedSize.w && fixedSize.h) {
					// content is too big in both directions, so we
					// will use
					// max popup size (safeSize), knowing well that
					// it will
					// overflow both ways.
					newSize = safeSize;
				} else {
					// content is clipped in only one direction, so
					// we need to
					// run getRenderedDimensions() again with a
					// fixed dimension
					var clippedSize = HGIS.Util
							.getRenderedDimensions(
									preparedHTML,
									fixedSize,
									{
										displayClass : this.contentDisplayClass,
										containerElement : containerElement
									});

					// if the clipped size is still the same as the
					// safeSize,
					// that means that our content must be fixed in
					// the
					// offending direction. If overflow is 'auto',
					// this means
					// we are going to have a scrollbar for sure, so
					// we must
					// adjust for that.
					//
					var currentOverflow = HGIS.Element.getStyle(
							this.contentDiv, "overflow");
					if ((currentOverflow != "hidden")
							&& (clippedSize.equals(safeSize))) {
						var scrollBar = HGIS.Util
								.getScrollbarWidth();
						if (fixedSize.w) {
							clippedSize.h += scrollBar;
						} else {
							clippedSize.w += scrollBar;
						}
					}

					newSize = this.getSafeContentSize(clippedSize);
				}
			}
			if (this.autoSize) {
				if (newSize.w < 120) {
					newSize.w = 120;
				}
				if (newSize.h < 30) {
					newSize.h = 30;
				}
			}
			this.setSize(newSize);
		},
		/**
		 * APIMethod: setSize
		 * 设置尺寸以适应弹窗的大小.
		 * 
		 * Parameters: 
		 * contentSize - {<HGIS.Size>} 弹窗内容div的新尺寸
		 */
		setSize : function(contentSize) {
			this.size = contentSize.clone();

			// if our contentDiv has a css 'padding' set on it by a
			// stylesheet, we
			// must add that to the desired "size".
			var contentDivPadding = this.getContentDivPadding();
			var wPadding = contentDivPadding.left
					+ contentDivPadding.right;
			var hPadding = contentDivPadding.top
					+ contentDivPadding.bottom;

			// take into account the popup's 'padding' property
			this.fixPadding();
			wPadding += this.padding.left + this.padding.right;
			hPadding += this.padding.top + this.padding.bottom;

			// make extra space for the close div
			if (this.closeDiv) {
				var closeDivWidth = parseInt(this.closeDiv.style.width);
				wPadding += closeDivWidth + contentDivPadding.right;
			}

			// increase size of the main popup div to take into
			// account the
			// users's desired padding and close div.
			this.size.w += wPadding;
			// this.size.h += hPadding;

			// now if our browser is IE, we need to actually make
			// the contents
			// div itself bigger to take its own padding into
			// effect. this makes
			// me want to shoot someone, but so it goes.
			if (HGIS.BROWSER_NAME == "msie") {
				this.contentSize.w += contentDivPadding.left
						+ contentDivPadding.right;
				this.contentSize.h += contentDivPadding.bottom
						+ contentDivPadding.top;
			}

			if (this.div != null) {
				this.div.style.width = this.size.w + "px";
				this.div.style.height = this.size.h + "px";
				this.div.style.overflow = "visible";
			}
			if (this.contentDiv != null) {
				this.contentDiv.style.width = contentSize.w + "px";
				this.contentDiv.style.height = contentSize.h + "px";
			}

			if ((this.lonlat) && (this.map)) {
				var px = this.map.getLayerPxFromLonLat(this.lonlat);
				if (this.positionOffSet != null) {
					px = px.offset(this.positionOffSet);
				}
				this.moveTo(px);
			}

			this.updateBlocks();
		},
		/**
		 * Method: calculateRelativePosition
		 * 
		 * Parameters: 
		 * px - {<HGIS.Pixel>}
		 * Returns: - {String} 返回弹窗放置的相对位置
		 */
		calculateRelativePosition : function(px) {

			return 'tr';
		},
		/**
		 * APIMethod: createBlocks
		 */
		createBlocks : function() {
			this.blocks = [];

			// since all positions contain the same number of
			// blocks, we can
			// just pick the first position and use its blocks array
			// to create
			// our blocks array
			var firstPosition = null;
			for ( var key in this.positionBlocks) {
				firstPosition = key;
				break;
			}

			var position = this.positionBlocks[firstPosition];
			for (var i = 0; i < position.blocks.length; i++) {
				var block = {};
				this.blocks.push(block);

				var divId = this.id + '_FrameDecorationDiv_' + i;
				block.div = HGIS.Util.createDiv(divId, null, null,
						null, "absolute", null, "hidden", null);

				var imgId = this.id + '_FrameDecorationImg_' + i;
				var imageCreator = (this.isAlphaImage) ? HGIS.Util.createAlphaImageDiv
						: HGIS.Util.createImage;

				block.image = imageCreator(imgId, null,
						this.imageSize, this.imageSrc, "absolute",
						null, null, null);

				block.div.appendChild(block.image);
				this.groupDiv.appendChild(block.div);
			}
		},
		/**
		 * Method: updateBlocks 
		 * 内部的方法，触发在初始化时弹出的相对位置发生了变化。这个函数负责重新定位弹出的块的位置。
		 */
		updateBlocks : function() {
			if (!this.blocks) {
				this.createBlocks();
			}

			if (this.size && this.relativePosition) {
				var position = this.positionBlocks[this.relativePosition];
				for (var i = 0; i < position.blocks.length; i++) {

					var positionBlock = position.blocks[i];
					var block = this.blocks[i];

					// adjust sizes
					var l = positionBlock.anchor.left;
					var b = positionBlock.anchor.bottom;
					var r = positionBlock.anchor.right;
					var t = positionBlock.anchor.top;

					// note that we use the isNaN() test here
					// because if the
					// size object is initialized with a "auto"
					// parameter, the
					// size constructor calls parseFloat() on the
					// string,
					// which will turn it into NaN
					//
					var w = (isNaN(positionBlock.size.w)) ? this.size.w
							- (r + l)
							: positionBlock.size.w;

					var h = (isNaN(positionBlock.size.h)) ? this.size.h
							- (b + t)
							: positionBlock.size.h;

					block.div.style.width = (w < 0 ? 0 : w) + 'px';
					block.div.style.height = (h < 0 ? 0 : h) + 'px';

					block.div.style.left = (l != null) ? l + 'px'
							: '';
					block.div.style.bottom = (b != null) ? b + 'px'
							: '';
					block.div.style.right = (r != null) ? r + 'px'
							: '';
					block.div.style.top = (t != null) ? t + 'px'
							: '';

					block.image.style.left = positionBlock.position.x
							+ 'px';
					block.image.style.top = positionBlock.position.y
							+ 'px';
				}

				this.contentDiv.style.left = this.padding.left - 8
						+ "px";
				this.contentDiv.style.top = this.padding.top - 9
						+ "px";
				this.contentDiv.style.width = "100%";
			}
		},
		 
		/**
		 * Method: updatePosition
		 * 更新绝对位置
		 */ 					 
		updatePosition : function() {
			if ((this.lonlat) && (this.map)) {
				var px = this.map.getLayerPxFromLonLat(this.lonlat);
				if (px && this.positionOffSet) {
					px = px.offset(this.positionOffSet);
					this.moveTo(px);
				}
			}
		},
		/**
		 * Method: updateRelativePosition
		 * 更新相对位置
		 */
		updateRelativePosition : function() {

			// update the padding
			this.padding = this.positionBlocks[this.relativePosition].padding;

			// update the position of our close box to new padding
			if (this.closeDiv) {
				// use the content div's css padding to determine if
				// we should
				// padd the close div
				var contentDivPadding = this.getContentDivPadding();

				this.closeDiv.style.right = contentDivPadding.right
						+ this.padding.right + "px";
				this.closeDiv.style.top = /* contentDivPadding.top + */
				this.padding.top + "px";
			}

			this.updateBlocks();
		},
		CLASS_NAME : "HGIS.Popup.InfoWindow"
});/**
 * 绘制线上的文字
 *  注意：这里虽然对提供了字体样式、大小、字间距的接口，但是不要轻易传递这两个属性，否则展示会混乱
 * @param paint
 * @param textStyle
 * @param dxy
 * @returns
 */
function drawTextByPath_new(paint,textStyle,dxy){
    var options={
        //字体
        label:'',
        //坐标和角度
        textCoords:"",
        //是否倒叙
        textReverse:"",
        charSpace:4
    };
    for (var i in textStyle) {
        options[i] = textStyle[i];
    }
    //判断是否绘字文字 
    if(options.textCoords==undefined || options.textCoords=="" || options.textCoords.length==0){ 
        return;
    }
    var coordsArray=new Array();
    var q=0,ql=0;
    //处理坐标字符串
    var tempArr=options.textCoords.split(",");
    var temp;//这里表示每一个字的坐标,
    for(q=0,ql=tempArr.length;q<ql;q++){
    	temp=tempArr[q].split(" ");
    	coordsArray.push([
			parseInt(temp[0])+dxy.x,
			parseInt(temp[1])+dxy.y,
			temp[2]
		]);
    }
    
    //检测canvas底图中是否已绘制
    var textSize = (paint.measureText(options.label).width / options.label.length) + options.charSpace; //字符大小（长宽，用于分配位置）
    for(q=0,ql=coordsArray.length;q<ql;q++){
    	temp=paint.getImageData(coordsArray[q][0]-textSize/2,coordsArray[q][1]-textSize/2,textSize,textSize);
        if(_collisionAnalysis(temp,textSize,textSize)){
            return;
        }
    };
    
    for(q=0,ql=coordsArray.length;q<ql;q++){
    	//绘字文字
        paint.translate(coordsArray[q][0],coordsArray[q][1]);
        paint.rotate(coordsArray[q][2]);
       /* if(!!textStyle.labelOutlineWidth){//需要绘制描边
            paint.strokeStyle = textStyle.labelOutlineColor;
            paint.strokeText(options.label[q],0,0);
        }*/
        //paint.fillStyle = textStyle.fillStyle;
        if(options.textReverse==0){//正常
            paint.fillText(options.label[q],0,0);
        }else if(options.textReverse==1){//倒序
            paint.fillText(options.label[ql-1-q],0,0);
        }
        paint.rotate(-coordsArray[q][2]);
        paint.translate(-coordsArray[q][0],-coordsArray[q][1]);
    }
    paint.restore();
}
//test
function drawTextByPath(paint,textStyle){
    var options={
        //字体
        label:'',
        //字体大小
        font:"12px 'Microsoft YaHei'",
        //字体颜色
        fillStyle:'black',
        //字符间距
        charSpace:6,
        textAlign:"center",
        textBaseline:"middle",
        textCoords:"",
        textReverse:""
    };    
    
    
    for (var i in textStyle) {
        options[i] = textStyle[i];
    }
    //判断是否绘制文字 
    if(options.textCoords==undefined || options.textCoords=="" || options.textCoords.length==0){ 
        return;
    }
    //处理坐标字符串
   
    var coordsArray =options.textCoords;//每一个字的坐标
    //设置文字样式
    paint.font = options.font;
    paint.textAlign = options.textAlign;
    paint.textBaseline = options.textBaseline;
    paint.fillStyle = options.fontColor;

    //检测canvas底图中是否已绘制
    var textSize = (paint.measureText(options.label).width / options.label.length) + options.charSpace; //字符大小（长宽，用于分配位置）
    var charOffset = textSize/2;
    for(var t=0,tempL=coordsArray.length;t<tempL;t=t+1){
        var imgData=paint.getImageData(coordsArray[t][0]-charOffset,coordsArray[t][1]-charOffset,textSize,textSize);
        if(_collisionAnalysis(imgData,textSize,textSize)){
            return;
        }
    };
    paint.save();
    for(var j=0,jl=coordsArray.length;j<jl;j++){
    	//绘字文字
        paint.translate(coordsArray[j][0],coordsArray[j][1]);
        paint.rotate(coordsArray[j][2]);
       /* if(!!textStyle.labelOutlineWidth){//需要绘制描边
            paint.strokeStyle = textStyle.labelOutlineColor;
            paint.strokeText(options.label[j],0,0);
        }*/
        paint.fillStyle = textStyle.fillStyle;
        if(options.textReverse==0){//正常
            paint.fillText(options.label[j],0,0);
        }else if(options.textReverse==1){//倒序
            paint.fillText(options.label[jl-1-j],0,0);
        }
        paint.rotate(-coordsArray[j][2]);
        paint.translate(-coordsArray[j][0],-coordsArray[j][1]);
    }
    paint.restore();
}
function drawTextByPath_bk(paint,textStyle,dxy){
    var options={
        //字体
        label:'',
        //字体大小
        font:"12px 'Microsoft YaHei'",
        //字体颜色
        fillStyle:'black',
        //字符间距
        charSpace:6,
        textAlign:"center",
        textBaseline:"middle",
        textCoords:"",
        textReverse:""
    };    
    
    var coordsArray=[];//new Array(options.label.length);
    for (var i in textStyle) {
        options[i] = textStyle[i];
    }
    //判断是否绘制文字 
    if(options.textCoords==undefined || options.textCoords=="" || options.textCoords.length==0){ 
        return;
    }
    //处理坐标字符串
    var tempArr=options.textCoords.split(",");
    var charArr;//每一个字的坐标
    var dx=dxy.x;
    var dy=dxy.y;
    for(var q=0,ql=tempArr.length;q<ql;q++){
    	charArr=tempArr[q].split(" ");
    	coordsArray.push([
			parseInt(charArr[0])+dx,
			parseInt(charArr[1])+dy,
			charArr[2]
		]);
    }

    //设置文字样式
    paint.font = options.font;
    paint.textAlign = options.textAlign;
    paint.textBaseline = options.textBaseline;
    paint.fillStyle = options.fontColor;

    //检测canvas底图中是否已绘制
    var textSize = (paint.measureText(options.label).width / options.label.length) + options.charSpace; //字符大小（长宽，用于分配位置）
    var charOffset = textSize/2;
    for(var t=0,tempL=coordsArray.length;t<tempL;t=t+1){
        var imgData=paint.getImageData(coordsArray[t][0]-charOffset,coordsArray[t][1]-charOffset,textSize,textSize);
        if(_collisionAnalysis(imgData,textSize,textSize)){
            return;
        }
    };
    paint.save();
    for(var j=0,jl=coordsArray.length;j<jl;j++){
    	//绘字文字
        paint.translate(coordsArray[j][0],coordsArray[j][1]);
        paint.rotate(coordsArray[j][2]);
       /* if(!!textStyle.labelOutlineWidth){//需要绘制描边
            paint.strokeStyle = textStyle.labelOutlineColor;
            paint.strokeText(options.label[j],0,0);
        }*/
        paint.fillStyle = textStyle.fillStyle;
        if(options.textReverse==0){//正常
            paint.fillText(options.label[j],0,0);
        }else if(options.textReverse==1){//倒序
            paint.fillText(options.label[jl-1-j],0,0);
        }
        paint.rotate(-coordsArray[j][2]);
        paint.translate(-coordsArray[j][0],-coordsArray[j][1]);
    }
    paint.restore();
}
function _collisionAnalysis(imgData,width,height){
    for(var i=0,j=0; i<width&&j<height; i++,j++){
        var alpha = imgData.data[((i * (imgData.width * 4)) + (j* 4)) +3];
        if(typeof(alpha)=='undefined')alpha=0;
        if(alpha!=0){
            return true;
        }
    }
    return false;
}/* Copyright (c) 2006-2013 by HGIS Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the HGIS distribution or repository for the
 * full text of the license. */

/**
 * @requires HGIS/Renderer.js
 */

/**
 * Class: HGIS.Renderer.Canvas 
 * A renderer based on the 2D 'canvas' drawing element.
 * 
 * Inherits:
 *  - <HGIS.Renderer>
 */
HGIS.Renderer.VectorTile = HGIS.Class(HGIS.Renderer, {    
   
    /**
     * Property: hitContext
     * {Canvas} The canvas context object.显示图标和文字。
     */
    hitContext : null,
    
    /**
     * Property: hitOverflow
     * {Number} The method for converting feature identifiers to color values
     *     supports 16777215 sequential values.  Two features cannot be 
     *     predictably detected if their identifiers differ by more than this
     *     value.  The hitOverflow allows for bigger numbers (but the 
     *     difference in values is still limited).
     */
    hitOverflow: 0,

    /**
     * Property: canvas
     * {Canvas} The canvas context object.
     */
    canvas: null,
    
    /**
     * Property: lineCanvas
     * {Canvas} 用于绘制线的canvas，解决线的描边被面压盖的问题
     */
    lineCanvas: null,
    lineContext: null,
    
    /**
     * Property: tempCanvas
     * {Canvas} 临时的canvas， 用于实现要素闪烁的效果
     */
    tempCanvas: null,

    /**
     * Property: features
     * {Object} Internal object of feature/style pairs for use in redrawing the layer.
     */
    features: null,
    
    /**
     * Property: pendingRedraw
     * {Boolean} The renderer needs a redraw call to render features added while
     *     the renderer was locked.
     */
    pendingRedraw: false,
    
    /**
     * Property: resolution
     * {Array} 当前的地图分辨率
     *      
     */
    resolution: null,
    
    /**
     * Property: cachedSymbolBounds
     * {Object} Internal cache of calculated symbol extents.
     */
    cachedSymbolBounds: {},
    //
    curExtent: null,

    curLevel: -1,
    /**
     *  中文汉字的行高
     */
    lineHeight: 0,
    /**
     * 存放POI数据，方便识别点
     */
    poiArray:[],
    /**
     *  循环时用的时间标记,次数
     */
    time: null,

    rectOpacity: 1,
    /**
     *  创建iconfont需要的两个h2标签
     */
    bgH2: null,
    frH2: null,
    /**
     * Constructor: HGIS.Renderer.Canvas
     *
     * Parameters:
     * containerID - {<String>}
     * options - {Object} Optional properties to be set on the renderer.
     */
    initialize: function(containerID, options) {
        HGIS.Renderer.prototype.initialize.apply(this, arguments);
        this.features = {};
        this.root = document.createElement("canvas");
        this.root.style.zIndex = 0;
        var bgColor = "#F9F9F9";
        if(HGIS.utils.MapStyleUtil.styleJson.rules){  
        	 bgColor = HGIS.utils.MapStyleUtil.getLandColor();      	 
        } 
        this.root.style.background = bgColor;
         
        this.root.style.position = "absolute";
        this.root.style.left = "0px";
        this.root.style.top = "0px";
        this.root.style.margin = "5px";
        this.container.appendChild(this.root);
        this.canvas = this.root.getContext("2d");
        
        this.lineCanvas = document.createElement("canvas");
        this.lineCanvas.style.background = "transparent";//"rgba(255,255,255,0)";
        this.lineCanvas.style.position = "absolute";
        this.lineCanvas.style.left = "0px";
        this.lineCanvas.style.top = "0px";
        this.lineCanvas.style.margin = "5px";
        
        this.lineContext = this.lineCanvas.getContext("2d");
        this.lineContext.lineCap = "round";//"square";//"butt";//"round";
        this.lineContext.lineJoin = "bevel";//默认为miter 尖角    bevel是斜角  round是圆角
        this.container.appendChild(this.lineCanvas);        	
       
        
        this.hitCanvas = document.createElement("canvas");
        this.hitCanvas.style.background = "transparent";//"rgba(255,255,255,0)";
        this.hitCanvas.style.position = "absolute";
        this.hitCanvas.style.left = "0px";
        this.hitCanvas.style.top = "0px";
        this.hitCanvas.style.margin = "5px";
        this.hitContext = this.hitCanvas.getContext("2d");           
        this.hitContext.font = "7px Arial";
        this.hitContext.textAlign ="center";
        this.hitContext.textBaseline = "middle";
        this.hitContext.lineWidth = 1;
        this.container.appendChild(this.hitCanvas);

        this.bgH2 = document.createElement('h2');
        this.frH2 = document.createElement('h2');
        this.bgH2.className = 'iconfont';
        this.frH2.className = 'iconfont';
        this.bgH2.innerHTML = "&#57345;";//边框图形的10进制unicode编码 &#57345;
        this.lineHeight = this.hitContext.measureText('我').height || this.hitContext.measureText('我').width;      
       
    },
    
    /**
     * Method: setExtent
     * Set the visible part of the layer.
     *
     * Parameters:
     * extent - {<HGIS.Bounds>}
     * resolutionChanged - {Boolean}
     *
     * Returns:
     * {Boolean} true to notify the layer that the new extent does not exceed
     *     the coordinate range, and the features will not need to be redrawn.
     *     False otherwise.
     */
    setExtent: function() {
        HGIS.Renderer.prototype.setExtent.apply(this, arguments);
        // always redraw features
        return false;
    },
    
    /** 
     * Method: eraseGeometry
     * Erase a geometry from the renderer. Because the Canvas renderer has
     *     'memory' of the features that it has drawn, we have to remove the
     *     feature so it doesn't redraw.   
     * 
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * featureId - {String}
     */
    eraseGeometry: function(geometry, featureId) {
        this.eraseFeatures(this.features[featureId][0]);
    },

    /**
     * APIMethod: supported
     * 
     * Returns:
     * {Boolean} Whether or not the browser supports the renderer class
     */
    supported: function() {
        return HGIS.CANVAS_SUPPORTED;
    },    
    
    /**
     * Method: setSize
     * Sets the size of the drawing surface.
     *
     * Once the size is updated, redraw the canvas.
     *
     * Parameters:
     * size - {<HGIS.Size>} 
     */
    setSize: function(size) {
        this.size = size.clone();
        var root = this.root;
        root.style.width = size.w + "px";
        root.style.height = size.h + "px";
        root.width = size.w;
        root.height = size.h;
        this.resolution = this.map.resolution;
        
        var lineCanvas = this.lineCanvas;
        lineCanvas.style.width = size.w + "px";
        lineCanvas.style.height = size.h + "px";
        lineCanvas.width = size.w;
        lineCanvas.height = size.h;
        
       
        var hitCanvas = this.hitCanvas;
        hitCanvas.style.width = size.w + "px";
        hitCanvas.style.height = size.h + "px";
        hitCanvas.width = size.w;
        hitCanvas.height = size.h;
         
    },
    /**
     * Method: drawFeature
     * Draw the feature. Stores the feature in the features list,
     * then redraws the layer. 
     *
     * Parameters:
     * feature - {<HGIS.Feature.Vector>} 
     * style - {<Object>} 
     *
     * Returns:
     * {Boolean} The feature has been drawn completely.  If the feature has no
     *     geometry, undefined will be returned.  If the feature is not rendered
     *     for other reasons, false will be returned.
     */
    drawFeature: function(feature, style) {
        var rendered = true;
        if (feature.geometry) {
            style = style||feature.style;//this.applyDefaultSymbolizer(style || feature.style);

            var worldBounds = this.map.getMaxExtent();
            if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {
                worldBounds = this.map.getMaxExtent();
            }            
            //解析行列号，计算切片原点
            var b = this.caculateOrigin(feature.origin);
            var dd = this.map.resolution * 256;
            var left = Number(b[0] - dd*2 ), right = Number(b[0]) + dd * 2, bottom = Number(b[1] - dd*2), top = Number(b[1]) + dd * 2;
            var bounds = new HGIS.Bounds(left, bottom, right, top);            
            var intersects = bounds.intersectsBounds(this.extent, {worldBounds: worldBounds});
            rendered = (style.display !== "none") && !!bounds && (intersects);
            if (rendered) {
                this.features[feature.id] = [feature,style];
            }else {
                delete(this.features[feature.id]);
            }
            //this.redraw();
            this.pendingRedraw = true;
        }
        if (this.pendingRedraw && !this.locked) {
        	/*
        	console.log("总瓦片数:"+this.tileCount);
        	console.log("404:"+this.count404);
        	console.log("有效瓦片数:"+(this.tileCount-this.count404));
        	console.log("position:"+position);//下一步争取404那边累加的能传过来，动态改变渲染触发阈值  陈宏杰 2018年4月20日18:50:54
        	console.log("剩余瓦片数:"+(this.tileCount-position-this.count404));
        	if(position){//因为除非首屏加载,否则是没有这个position参数的,例如拖动地图
//        		if((this.tileCount-position)==this.tileCount/2){//一半的时候临时渲染一下，不至于全白
//            		this.redraw();
//            	}
//        		if((this.tileCount-position)<this.tileCount-this.count404){//当切片差值小于总切片数量一半时,开始无条件绘制,这里假定404的一定小于一半
//            		this.redraw();
//            	}
        		if(this.tileCount-position-this.count404<10){//当切片差值小于10时,开始渲染
        			console.log("开始绘制了");
            		this.redraw();
            	}
        	}else{//拖动地图还是无条件绘制
        		this.redraw();
        	}*/
        	this.redraw();
            this.pendingRedraw = false;
        }
        return rendered;
    },  
    /**
     * Method: redraw
     * The real 'meat' of the function: any time things have changed,
     *     redraw() can be called to loop over all the data and (you guessed
     *     it) redraw it.  Unlike Elements-based Renderers, we can't interact
     *     with things once they're drawn, to remove them, for example, so
     *     instead we have to just clear everything and draw from scratch.
     */
    redraw: function() {    	
        if (!this.locked && Object.keys(this.features).length>0) {        	      	
        	var width = this.root.width;
            var height = this.root.height;             
            
            var objKeys = Object.keys(this.features);
            objKeys = objKeys.sort();//这里写所需要的规则            
           
            var currentType = objKeys[0].substr(0,3);//从索引为0的位置开始取三个数字，表示要素类型            
            var sameTypefeatures=[];//保存类型相同的所有要素
            var currentStyle = this.features[objKeys[0]][1];//第一个要素类型对应的样式  
            
            this.canvas.clearRect(0, 0, width, height);//先清除所有的,不然会反复绘制
            this.lineContext.clearRect(0, 0, width, height);             
            this.hitContext.clearRect(0, 0, width, height);             
            
            for(var i=0, len=objKeys.length; i<len; i++){ 
            	var feature = this.features[objKeys[i]][0];
            	if(objKeys[i].substr(0,3)!==currentType){
            		//绘制前面相同的要素
            		this.drawFeatures(sameTypefeatures,currentStyle);
            		 
            		currentType = objKeys[i].substr(0,3);                		 
            		currentStyle = this.features[objKeys[i]][1];
            		sameTypefeatures=[];
            	}            	        	 
            	sameTypefeatures.push(this.features[objKeys[i]][0]);             	
            }
            this.drawFeatures(sameTypefeatures,currentStyle);//绘制最后一批类型相同的要素     
        }
    },
    /**
     * 根据指定的样式绘制类型相同的要素集合
     * @features 相同要素类的要素集合
     * @style 要素类的样式
     * @context canvas的上下文环境
     */
    drawFeatures:function(features,style,context){   	
    	if(features.length>0){   
    		var currContext = null;
	    	switch(features[0].type){//判断几何类型     
		    	case 1:
		    		currContext=context?context:this.hitContext;
		    		//设置绘制状态
		        	this.setCanvasContextStyleState("point",style,currContext,true);       	
		        	//批量绘制相同类型的要素
		        	for(var i=features.length-1; i>=0; i--){  
		        		var feature = features[i];
		        		style = feature.style;     			
		        		this.drawPoint(feature.geometry,style, currContext);
		        	}
		        	//绘制标注文字        	 
	        		this.setCanvasContextStyleState("text",style,currContext); 
	        		for(var i=features.length-1; i>=0; i--){  	        			
		        		var feature = features[i];
		        		style = feature.style;
		        		if(style.label && style.label!="undefined")
		        			this.drawPointText([feature.geometry[0],feature.geometry[1]], style, currContext);		        		 
		        	}
		    		break;
		    	case 2:	
		    		currContext=context?context:this.lineContext;
		        	//批量绘制相同类型的要素      
		        	if(style.outlineWidth){		        		
		        		var outlineStyle = new HGIS.Style();  
		        		 outlineStyle.strokeColor  = style.outlineColor;
		                 outlineStyle.strokeWidth = style.outlineWidth;
		                 outlineStyle.strokeLinecap = style.outLinecap;
		                 outlineStyle.strokeDashstyle = style.outlineDashstyle;
		               //设置线边框的绘制状态
				        this.setCanvasContextStyleState("polyline",outlineStyle,currContext);
				        currContext.globalCompositeOperation="destination-over"; 
				       
				        currContext.beginPath(); 
		        		for(var i=features.length-1; i>=0; i--){  
			        		var feature = features[i];
			        		//var lineGeomArray = this.decodeLine(feature.geometry);
			        		this.drawSimpleLine(feature.geometry,outlineStyle,currContext);
			        	}
		        		currContext.stroke();
		        		currContext.globalCompositeOperation="source-over";
		        	}		        	
		        	//设置线填充的绘制状态
		        	this.setCanvasContextStyleState("polyline",style,currContext);
		        	currContext.beginPath(); 
		        	for(var i=features.length-1; i>=0; i--){  
		        		var feature = features[i];		        		
		        		//var lineGeomArray = this.decodeLine(feature.geometry); 	        		
		        		this.drawSimpleLine(feature.geometry,feature.style,currContext);
		        	}
		        	currContext.stroke();
	        		//绘制标注文字        	 
	        		this.setCanvasContextStyleState("text",style,currContext); 
	        		for(var i=features.length-1; i>=0; i--){          			 
		        		var feature = features[i];
		        		if(feature.style.label&&feature.attributes['textCoords']!==""){		        			 
		        			style={};	
		        			style.fontColor = feature.style.fontColor;
			        		style.textCoords = feature.attributes['textCoords'];
			        		//console.log("drawlineText: " + style.textCoords);
				        	style.textReverse = feature.attributes['textReverse'];
				        	style.label = feature.style.label;
			        		this.drawLineText(style,this.hitContext);
		        		}
		        	}		 
		    		break;
		    	case 3:		
		    		currContext=context?context:this.canvas;
		    		//设置绘制状态
		        	this.setCanvasContextStyleState("polygon",style,currContext);  
		        	this.canvas.beginPath(); 
		        	var polygonArr = [];
		        	//批量绘制相同类型的面要素
		        	for(var i=0,len=features.length; i<len; i++){  
		        		var feature = features[i];	        		
		        		var polygon = this.drawPolygon(feature.geometry,style, currContext);
		        		polygonArr.push(polygon);
		        	}
		        	currContext.closePath();
		        	currContext.fill();		        	 
		        	//绘制面的标注
		        	this.setCanvasContextStyleState("text",style, this.hitContext);
		        	var preLabel = "";
		        	for(var i=0,len=features.length; i<len; i++){  
		        		var feature = features[i];
		        		style = feature.style;		        		
		        		if(style.label&&style.label!=preLabel){	//标注不为空且不与前一个标注相同 &&style.label!=preLabel	        			 
		        			 var inPolygon = this.textInPolygon(feature.geometry,style.label,feature.attributes.hashcode);
		        	         if(inPolygon){
		        	           	var center = this.getCenterByPointArr(polygonArr[i]);
		        	           	this.drawPolygonText(center, style, this.hitContext);	
		        	           	preLabel = style.label;
		        	         }
		        	     }
		        	}
		        	break;
		    	default:
		    		break;
	    	}	    
    	}    	 
    },
    /**
     * 根据样式和类型设置context的状态
     * @param type
     * @param style
     * @param context
     */
    setCanvasContextStyleState: function(type, style, context){
        if (type === "polygon") {//基于矢量切片的面都不能带边框，只有填充色和透明度
            if(style['fillOpacity'] != context.globalAlpha)
                context.globalAlpha = style['fillOpacity'];
            if(style['fillColor'] != context.fillStyle )
                context.fillStyle = style['fillColor'];           
        } else if (type === "polyline") {        	
            context.globalAlpha = style['strokeOpacity'];
            context.strokeStyle = style['strokeColor'];
            context.lineWidth = style['strokeWidth'];
            context.strokeDashstyle = style["strokeDashstyle"];
            if(context.strokeDashstyle==="dash") {
                context.setLineDash([15, 15]);
            } else{
                context.setLineDash([0, 0]);
            }
            context.lineCap = style['strokeLinecap'];   //"round";        
         } else if(type === "point"){            
            context.fillStyle = style.backgroundFillColor;//字体图标符号的填充色'rgb(255, 255, 255)';
            context.strokeStyle = style.strokeColor;//'rgb(203, 108, 93)';
            context.font = style.iconFont + " iconfont";//'16px iconfont';         
        	context.lineWidth = 1;
        	this.bgH2.innerHTML = style.backgroundGraphic;////边框图形的10进制unicode编码 &#57345;
        	this.frH2.innerHTML = style.externalGraphic;//"&#61461;";
        	
        } else if(type==="text"){
           var fontStyle = [style.fontStyle ? style.fontStyle : "normal",
                "normal",
                style.fontWeight ? style.fontWeight : "normal",
                style.fontSize ? style.fontSize : "1em",
                style.fontFamily ? style.fontFamily : "sans-serif"].join(" ");
            //fontStyle = "normal normal 7px Verdana";//Microsoft Yahei";
            if(context.font != fontStyle)
                context.font = fontStyle;
            context.textAlign ="center";
            context.textBaseline = "middle";
            context.fillStyle = style.fontColor;
            if (style.labelOutlineWidth) {
                context.globalAlpha = style.labelOutlineOpacity || style.fontOpacity || 1.0;
                if(context.strokeStyle != style.labelOutlineColor)
                    context.strokeStyle = style.labelOutlineColor;
                if(context.lineWidth != style.labelOutlineWidth)
                    context.lineWidth = style.labelOutlineWidth;
            }
        } else {
            context.globalAlpha = 1.0;
            context.lineWidth = 1;
        }
    },
   
    
    /**
     * 绘制面状要素
     * @param geometry
     * @param origin
     * @param style
     * @param canvasContext
     */
    drawPolygon: function(geometry, style, context, hashcode) {       
        var pointArr = [];
        var geomLen = geometry.length;
        context.moveTo(geometry[0], geometry[1]);
        pointArr.push([geometry[0], geometry[1]]);
        for(var i=2; i<geomLen; i=i+2){
            if(geometry[i]=='|'){
                context.moveTo(geometry[i+2], geometry[i+3]);
                i=i+2;
                continue;
            }
            context.lineTo(geometry[i], geometry[i+1]);
            pointArr.push([geometry[i], geometry[i+1]]);
        }        
        return pointArr;       
    },
    /**
     * 判断文字是否能放在面内
     */
    textInPolygon : function(geom,text,hashcode){       	
    	//根据hashcode计算是否放置标注及标注放置的位置。
/*    	var maxNum=0; 
    	var maxNumRow=15;
    	for(var i=0;i<32;i++){
    		var num=0;
    		for(var j=0;j<32;j++){
    			if(hashcode[i][j]==1){
    				num = num + 1;
    			}
    		}
    		if(num>maxNum){
    			maxNum = num;
    			maxNumRow = i;
    		}
    	} 
    	polygonWidth = maxNum * 8;*/
    	
    	var inPolygon = true;     
    	var xArr = [];
    	//取geom数组中的偶数索引的值组成新的数组
    	for(var i=0,len=geom.length-1; i<len; i=i+2){
    		xArr.push(geom[i]);
    	}    	
    	xArr.sort(function(val1,val2){return val1-val2;});//升序排列
    	var polygonWidth = xArr[xArr.length-1] - xArr[0];
    	var textWidth = this.hitContext.measureText(text).width;
    	if(textWidth > polygonWidth)
    		inPolygon = false;
    	
    	return inPolygon;
    },    
    /**
     * 绘制点，包含多点
     * @param geometry
     * @param origin
     * @param style
     * @param canvasContext
     */    
	drawPoint: function(geometry, style, context,isCollisionJudgeNeeded) {
		var width = 20, height=20;
	    var xOffset = 0;//-(0.5 * width);
        var yOffset = -(0.5 * height);
     
        var geomLen = geometry.length;
        if(geomLen > 1) {        
            var ptX = geometry[0] + xOffset;
            var ptY = geometry[1] + yOffset; 
            if(isCollisionJudgeNeeded){//true 需要判断是否存在冲突
	            var iconData = context.getImageData(ptX, ptY, 20, 20);            
	            if(this.collisionAnalysisDiagonal(iconData, 20, 20)){return;}
            }                   
            context.fillText(this.bgH2.textContent, ptX, ptY);//背景填充
            context.strokeText(this.bgH2.textContent, ptX, ptY);//背景描边
            context.save();
            context.fillStyle = style.strokeColor;//'rgb(219,60,49)';
            context.fillText(this.frH2.textContent, ptX, ptY);//图形填充
            context.restore();
            //绘制标注
            /*if(style.label && style.label!="undefined"){
            	console.log(style.label);
                this.drawPointText([geometry[0],geometry[1]], style, context);
                //this.addToPOIArray(ptX, ptY, origin,geometry,style);
            }*/
        }
	},
	previousPOI:null,
	previousStrokeColor:"",
	previousOuterStrokeColor:"",
	redrawIcon: function(geometry, origin, style) {
		this.previousPOI={};
		this.previousPOI.geometry=geometry;
		this.previousPOI.origin=origin;
		this.previousPOI.style=style;
        var context = this.hitContext;
        var width = 20, height=30;
        var xOffset =  0;//-(0.5 * width);
        var yOffset =  -(0.5 * height);
        var originSplit = this.caculateOrigin(origin);
        var dxy = this.calculateDXY(originSplit, this.extent);
        var geomLen = geometry.length;
        if(geomLen > 1) {
            coordX = geometry[0] + dxy.x;
            coordY = geometry[1] + dxy.y;
            var ptX = coordX + xOffset;//图标左上角的x坐标
            var ptY = coordY + yOffset;//图标左上角的y坐标
            var iconData=this.hitContext.getImageData(ptX, ptY, 20, 20);
            if(this.collisionAnalysisDiagonal(iconData, 20, 20)){return;}
            context.globalAlpha = 1.0;
            context.save();
            this.bgH2.innerHTML = style.backgroundGraphic;//边框图形的10进制unicode编码 &#57345;
            this.frH2.innerHTML = style.externalGraphic;//"&#61461;";
            this.setCanvasContextStyleState("point",style,this.hitContext);
            context.strokeText(this.bgH2.textContent, ptX, ptY);
            context.fillStyle = style.strokeColor; 
            context.fillText(this.frH2.textContent, ptX, ptY);
        }
    },
    resetPreviousPOI:function(){
    	if(this.previousPOI!=null){//如果不为空,重置
	    	var $previousPOI=this.previousPOI;
	    	var style=$previousPOI.style;
	    	var origin =$previousPOI.origin;
	    	var geometry=$previousPOI.geometry;
	    	 var context = this.hitContext;
	         var width = 20, height=30;
	         var xOffset =  0;//-(0.5 * width);
	         var yOffset =  -(0.5 * height);
	         var originSplit = this.caculateOrigin(origin);
	         var dxy = this.calculateDXY(originSplit, this.extent);
	         var geomLen = geometry.length;
	         if(geomLen > 1) {
	             coordX = geometry[0] + dxy.x;
	             coordY = geometry[1] + dxy.y;
	             var ptX = coordX + xOffset;//图标左上角的x坐标
	             var ptY = coordY + yOffset;//图标左上角的y坐标
	             var iconData=this.hitContext.getImageData(ptX, ptY, 20, 20);
	             if(this.collisionAnalysisDiagonal(iconData, 20, 20)){return;}
	             context.globalAlpha = 1.0;
	             context.save();
	             this.bgH2.innerHTML = style.backgroundGraphic;//边框图形的10进制unicode编码 &#57345;
	             this.frH2.innerHTML = style.externalGraphic;//"&#61461;";
	             style.strokeColor=this.previousStrokeColor;
	             style.outerStrokeColor=this.previousOuterStrokeColor;
	             this.setCanvasContextStyleState("point",style,this.hitContext);
	             context.strokeText(this.bgH2.textContent, ptX, ptY);
//	             console.log(this.previousStrokeColor);
	             context.fillStyle = this.previousStrokeColor; 
	             context.fillText(this.frH2.textContent, ptX, ptY);
	         }
	     }
         this.previousPOI=null;
         this.previousStrokeColor="";
         this.previousOuterStrokeColor="";
    },
    /**
     * Method: drawIconAndText
     * Called to draw IconFont graphics.
     *
     * Parameters:
     * geometry - {<HGIS.Geometry>}
     * style    - {Object}
     * featureId - {String}
     */
    drawIconAndText: function(geometry, origin, style, context,isCollisionJudgeNeeded) {            
        var width = 20, height=20;
        var xOffset = 0;//-(0.5 * width);
        var yOffset = -(0.75 * height);

        var originSplit = this.caculateOrigin(origin);
        var dxy = this.calculateDXY(originSplit, this.extent);
        var geomLen = geometry.length;
        if(geomLen > 1) {
            coordX = geometry[0] + dxy.x;
            coordY = geometry[1] + dxy.y;
            var ptX = coordX + xOffset;
            var ptY = coordY + yOffset; 
            if(isCollisionJudgeNeeded){//true 需要判断是否存在冲突
	            var iconData = context.getImageData(ptX, ptY, 20, 20);            
	            if(this.collisionAnalysisDiagonal(iconData, 20, 20)){return;}
            }
            /*context.globalAlpha = 1.0;
            context.save();
*/

            this.bgH2.innerHTML = style.backgroundGraphic;//边框图形的10进制unicode编码 &#57345;
            this.frH2.innerHTML = style.externalGraphic;//"&#61461;";

            //this.setCanvasContextStyleState("point",style,context);         
            context.fillText(this.bgH2.textContent, ptX, ptY);
            context.strokeText(this.bgH2.textContent, ptX, ptY);
            context.fillStyle = style.strokeColor;//'rgb(219,60,49)';
            context.fillText(this.frH2.textContent, ptX, ptY);
            //绘制标注
            if(style.label && style.label!="undefined"&&style.label!=""){
                this.drawPointText([coordX,coordY], style, context);
                this.addToPOIArray(ptX, ptY, origin,geometry,style);
            }
        }
    },
    /**
     * 根据点位置绘制iconfont图标和标注文字，绘制简标时使用
     * @param pt 要标注的点坐标
     * @param style
     * @param canvasContext
     */
    drawIconFontLabelByPt: function(pt, style, canvasContext) {
        var context = this.hitContext;
        if(canvasContext){
            context = canvasContext;
        }
        var x = pt[0];
        var y = pt[1];
        var iconData=this.hitContext.getImageData(x,y,40,20);
        if(this.collisionAnalysisDiagonal(iconData,40,20)){return;}
        context.globalAlpha = 1.0;
        context.save();
        var h1 = document.createElement('h2');
        h1.className = 'iconfont';
        h1.innerHTML = style.labelGraphic;
        var content1 = h1.textContent;
        context.fillStyle = style.labelGraphicColor;//字体图标符号的填充色'rgb(255, 255, 255)';
        context.strokeStyle = style.labelGraphicColor;//'rgb(203, 108, 93)';
        context.font = style.iconFont + " iconfont";//'16px iconfont';
        context.fillText(content1,x,y);
        //context.strokeText(content1,x,y);
        context.save();
        //this.drawPointText([x,y],style);
    },

    /**
     * 解析线数据，返回线数组
     * @param lineGeom
     * @param origin
     * @returns {Array}
     */
    decodeLine: function(lineGeom, dxy){        
        var newGeometry = [];//生成新的数组给绘制线使用
        var geomLen = lineGeom.length;
        for ( var i = 0; i < geomLen; i = i + 2) {
            if(lineGeom[i]=="|"){
            	newGeometry.push(lineGeom[i]);
            }
            newGeometry.push(lineGeom[i] + dxy.x);
            newGeometry.push(lineGeom[i + 1] + dxy.y);
        }
        return newGeometry;
    },
    /**
     * 绘制简单线符号
     * @param geomArray
     * @param style
     * @param canvasContext
     */
    drawSimpleLine: function(lineGeom,style,lineContext){                    
        var geomLen = lineGeom.length;   
        lineContext.moveTo(lineGeom[0], lineGeom[1]);
        for ( var i = 2; i < geomLen; i = i + 2) {
            if(lineGeom[i]=="|"){
            	lineContext.moveTo(lineGeom[i+2], lineGeom[i+3]);
            	continue;
            }
            lineContext.lineTo(lineGeom[i], lineGeom[i+1]);
        }     
    }, 
    /**
     * 为线绘制标注
     * @param geometry
     * @param origin
     * @param style
     */
    drawLineText: function (style,context){ 
    	context = context?context:this.hitContext;
        drawTextByPath(context,style);
    },
    /**
     * 根据原点坐标和地图范围计算xy的偏移值
     * @param origin
     * @param extent
     * @returns {{x: number, y: number}}
     */
	calculateDXY: function(origin,extent){ 
		var resolution = this.map.resolution;	
		 
		var x = (origin[0]-extent.left)/resolution;
		x = Math.round(x);
		 
        var y = (extent.top- origin[1]) /resolution;
		y = Math.round(y);
		return {"x":x,"y":y};
	},
    /**
     * 根据点数组计算中心点
     * @param pointArr
     * @returns {*[]}
     */
	getCenterByPointArr : function(pointArr){
        var pointXArr = [];
        var pointYArr = [];
        for(var i=0,len=pointArr.length; i<len; i++){
            pointXArr.push(pointArr[i][0]);
            pointYArr.push(pointArr[i][1]);
        }
        var xmin =  Math.min.apply(Math, pointXArr);
        var ymin =  Math.min.apply(Math, pointYArr);
        var xmax =  Math.max.apply(Math, pointXArr);
        var ymax =  Math.max.apply(Math, pointYArr);
        var centerX = (xmin + xmax)/2;
        var centerY = (ymin + ymax)/2;
        return [centerX,centerY];
    },
    /**
     * Method: drawPolygonText
     * This method is only called by the renderer itself.
     *
     * Parameters:
     * location - {<HGIS.Point>}
     * style    - {Object}
     */
    drawPolygonText: function(pt, style,context) { 
        var labelRows = style.label.split('\n');
        var numRows = labelRows.length;        
        //pt[1] += this.lineHeight*vfactor*(numRows-1);
        if(numRows===1){
        	if(style.labelBackgroundColor){//需要绘制文字矩形背景
                context.save();
                context.fillStyle = style.labelBackgroundColor;
                var wordWidth = context.measureText(labelRows[0]).width;
                context.fillRect(pt[0] - wordWidth/2 - 4, pt[1] - this.lineHeight,wordWidth + 8, this.lineHeight + 12);
                context.restore();
            }               
            if (style.labelOutlineWidth) {
            	context.strokeText(labelRows[0], pt[0], pt[1] + 1);                   
            }
            context.fillStyle = style.fontColor;//设置字体的颜色         
        	context.fillText(labelRows[0], pt[0], pt[1] + this.lineHeight);
        }else if(numRows===2){
        	context.fillText(labelRows[0], pt[0], pt[1] + this.lineHeight);
        	context.fillText(labelRows[1], pt[0], pt[1] + this.lineHeight + this.lineHeight);
        }
       /* 
        for (var i = 0; i < numRows; i++) {
           if(style.labelBackgroundColor){//需要绘制文字矩形背景
                context.save();
                context.fillStyle = style.labelBackgroundColor;
                var wordWidth = context.measureText(labelRows[i]).width;
                context.fillRect(pt[0] - wordWidth/2 - 4, pt[1] - this.lineHeight,wordWidth + 8, this.lineHeight + 12);
                context.restore();
            }               
            if (style.labelOutlineWidth) {
            	context.strokeText(labelRows[i], pt[0], pt[1] + (this.lineHeight*i) + 1);                   
            }
            context.fillStyle = style.fontColor;//设置字体的颜色
            context.fillText(labelRows[i], pt[0], pt[1] + (this.lineHeight*i));
        }    */  
    },
    drawPointText: function(pt, style, context) {
    	context.save();        
        var labelRows = style.label.split('\n');
        var numRows = labelRows.length;
        if (context.fillText) {           
            var vfactor = HGIS.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[1]];
            if (vfactor == null) { vfactor = -.5;}
            var lineHeight = this.lineHeight;//我们标注一般是中文,所以测量中文的,经测试,得到的值和sytle的json中的fontSize一样
            pt[1] += lineHeight * vfactor * (numRows-1);
			//开始 进行碰撞分析 第1个字和最后一个字,如果都没有碰撞,那么允许渲染
            if(numRows==1){//一行的
				//先分析第一个字
            	var firstLetterData = context.getImageData(pt[0],pt[1],lineHeight,lineHeight);	//x-->pt[0],y-->pt[1],width,height-->lineHight
            	if(this.collisionAnalysis2(firstLetterData,lineHeight,lineHeight)){return;}//如果检测到,return
                //再分析最后一个字
            	//var fontSize=Number(style.fontSize.substring(0,style.fontSize.lastIndexOf("px")));
            	var secondLetterData = context.getImageData(pt[0] + lineHeight * labelRows[0].length, pt[1], lineHeight, lineHeight);	//x-->pt[0]+多少字*字的宽度, y-->pt[1], width,height-->lineHight
            	if(this.collisionAnalysis2(secondLetterData,lineHeight,lineHeight)){return;}//如果检测到,return
				//如果字数大于3,分析中间的字
                if(labelRows[0].length>3){
                    var midIndex = Math.floor(labelRows[0].length/2);
                    var middleLetterData = context.getImageData(pt[0] + lineHeight * midIndex,pt[1],lineHeight,lineHeight);
            		if(this.collisionAnalysis2(middleLetterData,lineHeight,lineHeight)){return;}//如果检测到,return
				}
            }else if(numRows==2){//两行的
				//先分析第一行第一个字
            	var firstLineFirstLetterData = context.getImageData(pt[0],pt[1],lineHeight,lineHeight);	//x-->pt[0],y-->pt[1],width,height-->lineHight
            	if(this.collisionAnalysis2(firstLineFirstLetterData,lineHeight,lineHeight)){return;}//如果检测到,return
                //再分析第一行最后一个字
            	var firstSecondLetterData = context.getImageData(pt[0] + lineHeight * labelRows[0].length,pt[1],lineHeight,lineHeight);	//x-->pt[0]+第一行多少字*字的宽度, y-->pt[1], width,height-->lineHight
                //如果第一行字数大于3,分析中间的字
                if(labelRows[0].length>3){
                    var midIndex = Math.floor(labelRows[0].length/2);
                    var middleLetterData = context.getImageData(pt[0] + lineHeight * midIndex,pt[1],lineHeight,lineHeight);
                    if(this.collisionAnalysis2(middleLetterData,lineHeight,lineHeight)){return;}//如果检测到,return
                }
            	if(this.collisionAnalysis2(firstSecondLetterData,lineHeight,lineHeight)){return;}//如果检测到,return
				//分析第二行第一个字
            	var secondFirstLetterData = context.getImageData(pt[0],pt[1]+lineHeight,lineHeight,lineHeight);	//x-->pt[0],y-->pt[1]+字的高度+2像素 这里加2是为了稍微间隔一点防止检测到第一行的rgb数据,width,height-->lineHight
            	if(this.collisionAnalysis2(secondFirstLetterData,lineHeight,lineHeight)){return;}//如果检测到,return
                //再分析第二行最后一个字
            	var secondLineSecondLetterData = context.getImageData(pt[0]+lineHeight*labelRows[1].length,pt[1]+lineHeight,lineHeight,lineHeight);	//x-->pt[0]+第二行多少字*字的宽度, y-->pt[1]+字的高度+2像素 这里加2是为了稍微间隔一点防止检测到第一行的rgb数据, width,height-->lineHight
            	if(this.collisionAnalysis2(secondLineSecondLetterData,lineHeight,lineHeight)){return;}//如果检测到,return
                //如果第二行字数大于3,分析中间的字
                if(labelRows[1].length>3){
                    var midIndex = Math.floor(labelRows[1].length/2);
                    var middleLetterData = context.getImageData(pt[0]+lineHeight*midIndex,pt[1]+lineHeight,lineHeight,lineHeight);
                    if(this.collisionAnalysis2(middleLetterData,lineHeight,lineHeight)){return;}//如果检测到,return
                }
            }
            context.fillStyle = style.fontColor;
            if(numRows===1)
            	context.fillText(labelRows[0], pt[0], pt[1] + lineHeight);
            else if(numRows===2){
            	context.fillText(labelRows[0], pt[0], pt[1] + lineHeight);
            	context.fillText(labelRows[1], pt[0], pt[1] + lineHeight + lineHeight);
            }    
        }
        context.restore();      
    },
    /**
     * 标注避让分析 单字单对角线检测
     * @param imgData
     * @param width
     * @param height
     * @returns {boolean}
     */
    collisionAnalysis2: function(imgData,width,height){
         for(var i=0,j=0; i<width&&j<height; i++,j++){
                var red = imgData.data[((i * (imgData.width * 4)) + (j* 4)) ];
                var green = imgData.data[((i * (imgData.width * 4)) + (j* 4)) +1];
                var blue = imgData.data[((i * (imgData.width * 4)) + (j* 4)) +2];
                var alpha = imgData.data[((i * (imgData.width * 4)) + (j* 4)) +3];
                //if(((red!=0||green!=0||blue!=0)&&alpha!=0)||(red==0&&green==0&&blue==0&&alpha!=0)){//rgb只要有不等于0的,且透明度必须不为0 + rgb全部为0 且透明度不为0(即黑色)
                if(typeof(alpha)=='undefined')alpha=0;
                if(alpha!=0){
                      return true;
                }
         }
        return false;
    },

    /**
     * 标注避让分析 字体区域双对角线检测
     * @param imgData
     * @param width
     * @param height
     * @returns {boolean}
     */
    collisionAnalysisDiagonal: function(imgData, width, height){
		var flag1=false,flag2=false;
		//先 左上 右下  
        for(var i=0,j=0; i<width&&j<height; i++,j++){
        	var pos = i * (imgData.width * 4) + (j* 4);
            var red = imgData.data[pos];
            var green = imgData.data[pos +1];
            var blue = imgData.data[pos +2];
            var alpha = imgData.data[pos +3];
            if(typeof(alpha)=='undefined')alpha=0;
            if(alpha!=0){
                  flag1= true;
            }
        }
		//再右上左下
         for(var i=width-1,j=0; i>=0&&j<height; i--,j++){
        	 	var pos = i * (imgData.width * 4) + (j* 4);
                var red = imgData.data[pos];
                var green = imgData.data[pos +1];
                var blue = imgData.data[pos +2];
                var alpha = imgData.data[pos +3];
                if(typeof(alpha)=='undefined')alpha=0;
                if(alpha!=0){
                      flag2= true;
                }
        }
        return flag1||flag2;
    },
    /**
     * 标注碰撞分析 只检测左上角
     * @param imgData
     * @param width
     * @param height
     * @returns {boolean}
     */
   collisionAnalysisLeftConrner: function(imgData, width, height){
         for(var i=0; i<width/2; i++){
            for(var j=0; j<height/2; j++){
                var red=imgData.data[((i * (imgData.width * 4)) + (j* 4)) ];
                var green=imgData.data[((i * (imgData.width * 4)) + (j* 4)) +1];
                var blue=imgData.data[((i * (imgData.width * 4)) + (j* 4)) +2];
                var alpha=imgData.data[((i * (imgData.width * 4)) + (j* 4)) +3];
                if(((red!=0||green!=0||blue!=0)&&alpha!=0)||(red==0&&green==0&&blue==0&&alpha!=0)){//rgb只要有不等于0的,且透明度必须不为0 + rgb全部为0 且透明度不为0(即黑色)
                      return true;
                }
            }
        }
        return false;
    },
    /**
     * Method: featureIdToHex
     * Convert a feature ID string into an RGB hex string.
     *
     * Parameters:
     * featureId - {String} Feature id
     *
     * Returns:
     * {String} RGB hex string.
     */
    featureIdToHex: function(featureId) {
        var id = Number(featureId.split("_").pop()) + 1; // zero for no feature
        if (id >= 16777216) {
            this.hitOverflow = id - 16777215;
            id = id % 16777216 + 1;
        }
        var hex = "000000" + id.toString(16);
        var len = hex.length;
        hex = "#" + hex.substring(len-6, len);
        return hex;
    },
    /**
     * 根据传入的要素类型和样式，改变地图的样式style对象
     * @featureType 要素类
     * @style 要素类对应的样式
     */
    changeMapStyle: function(featureType, style, level){
    	var features=[];
        var rules = this.map.baseLayer.styleMap.styles["default"].rules;
        for(var i=rules.length-1; i>=0; i--){
            if(rules[i].featureType==featureType){
                if(level>=rules[i].minLevel && level<=rules[i].maxLevel){
                	this.map.baseLayer.styleMap.styles["default"].rules[i].symbolizer = style;
                }
            }
        }
        var objKeys = Object.keys(this.features);
        
        for (var i=0, len=objKeys.length; i<len; i++) {            
            var feature = this.features[objKeys[i]][0];
            feature.style = feature.layer.styleMap.createSymbolizer(feature);   
        }        
        this.redraw();
    },
    /**
     * 根据行列号计算切片原点坐标
     * @param rowcol 行列号
     * @returns {number[]} 含有x和y值的坐标数组
     */
    caculateOrigin: function(rowcol){
        var origin = [0,0];
        var b = rowcol.split("-");
        origin[0] = HGIS.InitParam.tileOrigin.lon + (b[1])*256*this.map.resolution;
        origin[1] = HGIS.InitParam.tileOrigin.lat - (b[0])*256*this.map.resolution;
        return origin;
    },
    //解码执行指令
    decodeCommandType : function(commandInteger) {
        return commandInteger & 0x7;
    },
    //解码执行次数
    decodeCount : function(commandInteger) {
        return commandInteger >> 3;
    },
    //解码参数指令
    decodeParameterInteger : function(coord) {
        return ((coord >> 1) ^ (-(coord & 1)));
    },
    /**
     * drawFeaturesSameType
     * @param features
     * @param style
     */
    drawFeaturesSameType: function(features, style){
        if(this.tempCanvas==null) {
            this.tempCanvas = document.createElement("canvas");
            this.tempCanvas.style.background = "transparent";//"rgba(255,255,255,0)";
            this.tempCanvas.style.position = "absolute";
            this.tempCanvas.style.left = "0px";
            this.tempCanvas.style.top = "0px";
            this.tempCanvas.style.margin = "5px";
            this.tempCanvas.style.opacity = 0.5;

            this.tempCanvas.style.width = this.size.w + "px";
            this.tempCanvas.style.height = this.size.h + "px";
            this.tempCanvas.width = this.size.w;
            this.tempCanvas.height = this.size.h;
            this.container.appendChild(this.tempCanvas);
        }
        var tempContext = this.tempCanvas.getContext("2d");
        
        this.drawFeatures(features,style,tempContext);   
    },
    /*
     * 开始闪烁循环
     */
    startLoop: function(){
        if(this.tempCanvas==null) {
            return;
        }
        var canvasOpacity = this.tempCanvas.style.opacity;
        if(canvasOpacity>0){
            this.hidden(this.tempCanvas,0.8,-0.005);
        }else{
            this.hidden(this.tempCanvas,0,0.005);
        }
    },
    /**
     * 根据透明度渐变隐藏
     * @param canvas
     * @param opacity
     * @param increment
     */
    hidden: function(canvas, opacity, increment){
        var $this=this;
        $this.time = setInterval(function(){
            opacity+= increment;
            canvas.style.opacity = opacity;
            if(opacity < 0){
                window.clearInterval($this.time);
                $this.startLoop();
            }else if(opacity > 0.8){
                window.clearInterval($this.time);
                $this.startLoop();
            }
        },1);
    },
    /**
     * 停止闪烁循环
     * @param ifDelete 是否要移除tempCanvas并置空
     */
    stopLoop: function(ifClear){
        if(ifClear==undefined)
        	ifClear=true;
        if(this.tempCanvas==null)return;
        this.tempCanvas.style.opacity="0";
        if(this.time){
            window.clearInterval(this.time);
        }
        if(ifClear){
        	this.container.removeChild(this.tempCanvas);
            this.tempCanvas = null;
        }       
    },
    /**
     * 添加x y和text到poiArray数组中
     * @param x
     * @param y
     * @param text
     */
    addToPOIArray: function(x, y, origin,geometry,style){
        var obj = {};
        obj.x = x;
        obj.y = y;
        obj.origin=origin;
        obj.geometry=geometry;
        obj.style = style;
        this.poiArray.push(obj);
    },
    /**
     * Method: getLocalXY
     * transform geographic xy into pixel xy
     *
     * Parameters: 
     * point - {<HGIS.Geometry.Point>}
     */
    getLocalXY: function(point) {
        var resolution = this.getResolution();
        var extent = this.extent;
        var x = ((point.x - this.featureDx) / resolution + (-extent.left / resolution));
        var y = ((extent.top / resolution) - point.y / resolution);
        return [x, y];
    },
    /**
     * Method: clear
     * Clear all vectors from the renderer.
     */    
    clear: function() {
    	this.features = {};
    	var width = this.root.width;
        var height = this.root.height;        
        this.canvas.clearRect(0, 0, width, height);        
        this.lineContext.clearRect(0,0,width,height);       
        this.hitContext.clearRect(0, 0, width, height);         
    },

    /**
     * Method: getFeatureIdFromEvent
     * Returns a feature id from an event on the renderer.  
     * 
     * Parameters:
     * evt - {<HGIS.Event>} 
     *
     * Returns:
     * {<HGIS.Feature.Vector} A feature or undefined.  This method returns a 
     *     feature instead of a feature id to avoid an unnecessary lookup on the
     *     layer.
     */
    getFeatureIdFromEvent: function(evt) {
        var featureId, feature;
        if (this.root.style.display !== "none") {
            // this dragging check should go in the feature handler
            if (!this.map.dragging) {
                var xy = evt.xy;
                var x = xy.x | 0;
                var y = xy.y | 0;
                var data = this.hitContext.getImageData(x, y, 1, 1).data;
                if (data[3] === 255) { // antialiased
                    var id = data[2] + (256 * (data[1] + (256 * data[0])));
                    if (id) {
                        featureId = "HGIS_Feature_Vector_" + (id - 1 + this.hitOverflow);
                        try {
                            feature = this.features[featureId][0];
                        } catch(err) {
                            // Because of antialiasing on the canvas, when the hit location is at a point where the edge of
                            // one symbol intersects the interior of another symbol, a wrong hit color (and therefore id) results.
                            // todo: set Antialiasing = 'off' on the hitContext as soon as browsers allow it.
                        }
                    }
                }
            }
        }
        return feature;
    },
    
    /**
     * Method: eraseFeatures 
     * This is called by the layer to erase features; removes the feature from
     *     the list, then redraws the layer.
     * 
     * Parameters:
     * features - {Array(<HGIS.Feature.Vector>)} 
     */
    eraseFeatures: function(features) {
        if(!(HGIS.Util.isArray(features))) {
            features = [features];
        }
        var feaLen = features.length;
        for(var i=0; i< feaLen; ++i) {
            delete this.features[features[i].id];
        }
        this.redraw();
    },    
    CLASS_NAME: "HGIS.Renderer.VectorTile"
});

/**
 * Constant: HGIS.Renderer.Canvas.LABEL_ALIGN
 * {Object}
 */
HGIS.Renderer.VectorTile.LABEL_ALIGN = {
    "l": "left",
    "r": "right",
    "t": "top",
    "b": "bottom"
};

/**
 * Constant: HGIS.Renderer.Canvas.LABEL_FACTOR
 * {Object}
 */
HGIS.Renderer.VectorTile.LABEL_FACTOR = {
    "l": 0,
    "r": -1,
    "t": 0,
    "b": -1
};

/**
 * Constant: HGIS.Renderer.Canvas.drawImageScaleFactor
 * {Number} Scale factor to apply to the canvas drawImage arguments. This
 *     is always 1 except for Android 2.1 devices, to work around
 *     http://code.google.com/p/android/issues/detail?id=5141.
 */
HGIS.Renderer.VectorTile.drawImageScaleFactor = null;HGIS.Services = HGIS.Services || {};
/**
 * Class: HGIS.Services.GeoSearcher
 * 
 * 地理编码后台请求类
 */
HGIS.Services.GeoSearcher = function() {
	/**
	 * APIFunction: search
	 * 地理检索器,用来检索地图上的任意地理要素. 特别地，搜索以某点为中心的附近地理要素.
	 * 
	 * 1、以该点为中心，附近距离为半径组成的圆，该圆的组成请参见本API中的其它方法，本类中不直接提供
	 * 
	 * 2、如果需要按距离排序，请设置sort为distance,HGIS将以圆的质心为基准，由近排序。否则HGIS不会排序
	 * 
	 * 3、keyword,featureTypet等是可选项，除非你希望对查询内容有所限定
	 * 
	 * 4、topN设为1、distanceSort设为true、SpatialAgs.spatialOperation为Intersects，HGIS将返回距离质心最近的一条地物
	 * 
	 * 参数:
	 * keyword - {String} 关键字。关键字包括中文名、英文名、中文地址、英文地址、中文名拼音五项。关键字若不提供，HGIS将按空间条件进行搜索，如果空间条件也不提供，HGIS将终止搜索。
	 * SpatialAgs - {JSON} 空间查询参数.详解请参见下列(1)
	 * featureType - {JSONArray}  一个JSON数组，要查询的地理要素类型。如果提供，HGIS搜索范围仅限于这些类型，否则时查询全部地理要素。详解请参见下列(2)
	 * responseFormat - {JSON}  查询结果格式，HGIS的返回结果统一为JSON格式。但返回内容允许调用者进行限定，提供的格式选项参见下列（3）
	 * successHandler - {Object} 查询成功的回调函数
	 * errorHandler - {Object} 查询失败的回调函数
	 * 
	 * --------------------------------------------------------------关于部分重点参数的详细解释--------------------------------------------------------------
	 *    
	 * (1) SpatialAgs选项说明 ：
	 * 
	 * geometry - {HGIS.Geometry} 一个用表示任意地理几何体，一般情况下为面状几何体(注意：本API暂不支持自相交的面状几何体、相交和相切的组合多边形)。如果为null，则HGIS将不会考虑空间条件，再设spatialOperation已无意义。
	 * distSort - {Boolean} 是否按距离排序，由近及远。距离的计算是从查询目标的质心到参数几何体的质心。如果此参数被设置，那么系统将优先按距离排序。
	 * distInRes - {Boolean} 返回结果中是否包含距离.此处的距离指的是查询结果的质心到geometry参数质心的距离。
	 * buffer - {Double} [可选项],设置几何体的缓冲范围，如果参数中buffer中设置了后会对Geometry进行缓冲后按照缓冲后的面进行空间分析,常用场景，点的缓冲和线的正向缓冲，面的话不用设置，单位应同坐标系单位一致。
	 * spatialOperation - 拓扑关系。如果不提供，系统使用默认的Intersects拓扑关系进行空间运算。HGIS支持的拓扑关系查询，简介如下：
	 * 
	 *    - Contains：包含。查询要素几何体完全包含查询条件几何体时，命中
	 *    - Intersects：相交。参与计算的几何体至少有一个交点。
	 *    - IsWithin：在....以内。一个几何完全包含在另一个几何体的内部。 
	 *    
	 *     ( 以下几种空间关系当前版本暂不支持，升级新版本做验证
 	 *      	BBoxIntersects：对于参与相交计算的几何体来说，其边界盒相交的就算相交；
	 *      	BBoxWithin ：是否包含在边界合以内；
	 *          IsEqualTo：相等。两个几何体完全相同的情况下认为是相等；
	 *    		Overlaps：重叠。参与运算的几何体有公共的点，但不是所有点都是公共的。)
	 * 
	 * (2) 地理要素种类.
	 *   一个JSON数组，要查询的地理要素类型,如果提供，HGIS搜索范围仅限于这些类型，否则查询全部地理要素。数组中的每一个JSON对象都包含两个键值对，其中baseType表示基础类型，subType表示子类型数组，不设子类型表示查询当前类型下的全部子类型，格式如下：
	 *   
	 *   (code)
	 *      format - [{"superType":String,"subType":Array}]
	 *   (end)
	 *  
	 *  获取地理要素类型请参见{<HGIS.Data.featureType>}常量，以下列出了HGIS支持的地理要素类型摘要:
	 *  
	 * - poi - 兴趣点。包含113种子类型，如商店、厕所、车站、银行等。
	 * - road - 道路。道路没有子类型，道路下属包含公路、铁路、札道等，在此统一用道路表示
	 * - district - 行政区域。包括三种子类型，town:乡镇,county:区县,city:地级市。因组成行政区几何体结点较多，数据在传输过程中可能存在性能瓶颈，因此涉及到行政区时不建议把responseFormat.geomInRes参数设为true
	 * - area - 兴趣面区域。兴趣面包括小区、绿地等。
	 * 详细的类型对照请参照 http://<ip>:<port>/hgis-web/help/dataClass.htm.
	 * 关于地理要素类型参数的一个示例：
	 *  
	 *   (code)
	 *   [
	 *	  {"superType": "POI",   --基础类型
	 *	   "subType": ["155","266"]      --子类型
	 *    },
	 *	  {
	 *	    "superType": "AREA",  --基础类型
	 *	    "subType": ["RESAREA_PG", "VEGETATION_A_PG"] --子类型
	 *	  },
	 *	  {"superType": "DISTRICT"},   --基础类型。不设子类型,HGIS会考虑当前基类型下的全部子类型
	 *
	 *    {....}
	 *	]
	 *   (end)
	 * 
	 * (3) 查询结果格式， 包括排序，分组，分页，数量限制，是否返回几何体信息等。详见下列说明：
	 * 
	 *   geomInRes - {Boolean} 搜索结果中是否包含几何体信息。如果为true,那么空间信息将以wkt格式返回.
	 *   isSortByName - {Boolean} 是否按名称排序，如果distanceSort已设置为true，则此参数无效. 
	 *   isGrouped - {Boolean} 是否分组，为true时，HGIS会按地理要素类型(featureType.superType进行分组,子类型分组暂不支持)，false表示无需分组。默认值false 
	 *   maxItemsPerGroup - {Number} 每组最多返回的的记录数。仅在isGrouped为true时生效
	 *   isPaged - {Boolean}  是否需要分页。为false时，HGIS将不会对结果进行分页处理,以下关于分页的参数设置都将无效.默认为false
	 *   pageSize  - {Number}  单页大小,即每页最多显示几条记录.默认值10
	 *   pageNum - {Number} 当前页码，从1开始起算.默认值1，表示第一页
	 *   isPageSum - {Boolean}  是否返回总页数.默认值false,表示不返回
	 *   isTotal - {Boolean} 是否返回查询结果总数.默认值true,表示返回。
	 *   topN - {Number|String} 返回结果大小限制,一个大于0的整数，“unlimit”表示不受限制。只在isgroup为false时生效, isPaged为false时完全生效。如果此参数未被设置，系统默认最多返回1000条记录（这主要考虑到基础地理数据量过大，不设上限的返回数据将可能导致浏览器崩溃）。
	 */
	this.search = function(keyword,SpatialAgs, featureType,responseFormat,successHandler, errorHandler) {
		var data={};
		var params={};//最终要传给后台的参数
		/**-------------没有条件不查询,只要满足条件之一都可查询------------------------*/
		if(!keyword&&!SpatialAgs.geometry&&keyword==""){
			alert( HGIS.language[HGIS.InitParam.language]["HGIS_noKnow"] );	//"HGIS不清楚你想找啥？"
			return ;
		}

		if(keyword!=null&&keyword!="undefined"&&keyword!=""){
			params.keyword=keyword;
		}
		
		/**----------------拆解、组合空间参数-------------------**/
		if(SpatialAgs.geometry){
			var wkt=new HGIS.Format.WKT();
			var vector=new HGIS.Feature.Vector(SpatialAgs.geometry);
			params.geometry=wkt.write(vector);
			params.spatialOperation=SpatialAgs.spatialOperation?SpatialAgs.spatialOperation:"Intersects";//空间几何体存在的情况下，空间操作符才有效
			params.distSort=SpatialAgs.distSort!=true?false:true;
			params.distInRes=SpatialAgs.distInRes!=true?false:true;
		}
		//设置缓冲
		if(SpatialAgs.buffer){
			params.buffer=SpatialAgs.buffer;
		}
		/**----------------拆解组合featureType参数-------------------**/
		params.featureType=featureType?featureType:"all";
		/**----------------拆解、组合非空间参数-------------------**/
		if(responseFormat){
			params.geomInRes=responseFormat.geomInRes!=true?false:true;
			params.isPaged=responseFormat.isPaged!=true?false:true;
			if(params.isPaged){
				params.pageSize=responseFormat.pageSize?responseFormat.pageSize:10;//默认分页大小为10
				params.pageNum=responseFormat.pageNum?responseFormat.pageNum:1;
				params.isPageSum=responseFormat.isPageSum!=true?false:true;//总页数是否返回
				params.isTotal=responseFormat.isTotal?responseFormat.isTotal:true;
			}
			params.isTotal=responseFormat.isTotal!=false?true:false;
			if(!isNaN(responseFormat.topN)){//是一个数字的情况下
				params.topN=responseFormat.topN;
			}else if(responseFormat.topN=="unlimit"){
				params.topN="unlimit";
			}else{
				params.topN=1000;//除此之外，系统默认返回1000条
			}
			
			//分组选项
			params.isGrouped=responseFormat.isGrouped!=true?false:true;
			if(params.isGrouped){//分组选项
				params.maxItemsPerGroup=responseFormat.maxItemsPerGroup&&!isNaN(responseFormat.maxItemsPerGroup)?responseFormat.maxItemsPerGroup:10;
			}else{
			}
			params.isSortByName=responseFormat.isSortByName!=true?false:true;
		}else{
			//默认值
			params.geomInRes=false;
			params.isPaged=false;
			params.isGrouped=true;
			params.isTotal=true;
			params.topN=1000;
			responseFormat.isSortByName=false;
		}
		var param={"params":JSON.stringify(params)};
		var url=geoSearchUrl.fullTextSearch;;
		/**----------------请求开始---------------------------------*/
		HGIS.Utils.send(url,param,"POST","json",successHandler,errorHandler);
	};
	
	
	
	/**
	 * APIMethod: queryFeatureById
	 * 根据图元唯一标识与图元类型查询图元详细信息
	 * 
	 * Parameters:
	 * userId - {String} 图元标志
	 * featureType - {String} 图元所属类型
	 * successHandler - {Object} 查询成功的回调函数
	 * errorHandler - {Object} 查询失败的回调函数
	 * proxy - {Boolean} 是否使用代理
	 */
	this.queryFeatureById = function(userId, featureType, successHandler, errorHandler) {
		
		var params = {
			"userId" : userId,
			"featureType" : featureType
		};
		var url="";
		if(HGIS.ProxyUrl){
			url=HGIS.ProxyUrl;
			params.url= geoSearchUrl.queryFeatureById;
		}else{
			url= geoSearchUrl.queryFeatureById;
		}
		HGIS.Utils.send(url,JSON.stringify(params),"POST","json",successHandler,errorHandler);
	};
	this.secondQuery = function(fid,subtype, successHandler, errorHandler) {
		
		var params = {
			"subtype" : subtype,
			"fid" : fid
		};
		var url="";
		if(HGIS.ProxyUrl){
			url=HGIS.ProxyUrl;
			params.url= geoSearchUrl.secondQuery;
		}else{
			url= geoSearchUrl.secondQuery;
		}
		HGIS.Utils.send(url,JSON.stringify(params),"POST","json",successHandler,errorHandler);
	};



	/**
	 * Method: trimComma
	 * 去掉前后的逗号，中间逗号以 " or "代替。不对外暴露
	 * 
	 * Parameters:
	 * s - {String} 处理的字符串
	 */
	this.trimComma = function(s) {
		var len = s.length;
		// 去掉字符串后面的空格
		for ( var i = 0; i < len; i++) {
			var lastIndex = s.lastIndexOf(',');
			if (s.length == lastIndex + 1) {
				s = s.substring(0, lastIndex);
			}
		}

		// 去掉字符串前面的空格
		for ( var i = 0; i < len; i++) {
			var index = s.indexOf(",");
			if (index == 0) {
				s = s.substring(1);
			}
		}

		// 中间的空格以or代替
		s = s.replace(",", " or ");
		return s;
	};

	/**
	 * Method: trimLRBlank
	 * 去掉最左与最右的空间，中间空格以" and "代替。不对外暴露
	 * 	 
	 * Parameters:
	 * s - {String} 处理的字符串
	 */
	this.trimLRBlank = function(s) {
		if (s == null)
			return "";
		var whitespace = new String(" \t\n\r");
		var str = new String(s);
		// 去掉字符串最右边的空格
		if (whitespace.indexOf(str.charAt(str.length - 1)) != -1) {
			var i = str.length - 1;
			while (i >= 0 && whitespace.indexOf(str.charAt(i)) != -1) {
				i--;
			}
			str = str.substring(0, i + 1);
		}
		// 去掉最左边的空格
		if (whitespace.indexOf(str.charAt(0)) != -1) {
			var j = 0, i = str.length;
			while (j < i && whitespace.indexOf(str.charAt(j)) != -1) {
				j++;
			}
			str = str.substring(j, i);
		}
		// 其余空格以 " and " 代替
		str = str.replace(/\s/g, " and ");
		return str;
	};

	/**
	 * APIMethod: getCrossRoad
	 * 根据两条道路名称获取道路路口信息
	 * 
	 * Parameters:
	 * road1Name - {String} 道路名
	 * road2Name - {String} 道路名
	 * tolerance - {Double} 道路路口合并容差值
	 * geometry - {Geometry} 查询范围 
	 * resultFunction - {Object} 查询成功后的回调函数
	 * faultFunction - {Object} 查询失败后的回调函数
	 */
	this.getCrossRoad = function(road1Name ,road2Name,tolerance,geometry , resultFunction, faultFunction) {
		var params = {};
	    params.road1 = road1Name;
	    params.road2 = road2Name;
	    params.tolerance = tolerance ;
	    if(parseInt(tolerance) === NaN  || parseInt(tolerance) < 0  ){
	    	throw HGIS.language[HGIS.InitParam.language]["Tolerance_val_noReasonable"];	//"提供的容差值不合理。"
			return;
	    }
	    params.geometry = geometry;
        var url= geoSearchUrl.queryCrossRoads;
        HGIS.Utils.send( url , params,"post","json" ,resultFunction,faultFunction);
	};

};

/**
 * Class: HGIS.Services.RouteNetAnlyse
 * 路径分析类
 */
HGIS.Services =HGIS.Services || {};
HGIS.Services.RouteNetAnlyse = function() {
	// 如果给出的停靠点个数据不对，直接销毁当前对象，并报错
	var thisObj = this;
	thisObj.anlyseRes;// 分析结果，不对外暴露
	/**
	 * APIProperty: stopNodes
	 * 所有的停靠点
	 */
	thisObj.stopNodes = new Array();// 本次路径分析的所有节点
	thisObj.stopXYs = new Array();// 本次路径分析的所有节点
	/**
	 * APIMethod: clearAllStopNodes
	 * 清除当前路径分析对象中的所有节点
	 */
	this.clearAllStopNodes = function() {
		thisObj.stopNodes = new Array();
	};
	this.clearAllStopXYs = function() {
		thisObj.stopXYs = new Array();
	};
	/**
	 * APIMethod: setStopNodes
	 * 设置停靠点.
	 * 给定一个位置，设定当前所在地物位置，并确定路网节点所给点的位置。兴趣点未找到就以“未命名”代替。同时该方法会确定最近一个的路网节点
	 * 
	 * Parameters:
	 * point - {<HGIS.Geometry.Point>} 停靠点
	 * callback - {Object} 添加停靠点成功后的回调函数
	 */
	this.setStopNodes = function(point, callback) {
		var params = {
			"x" : point.x,
			"y" : point.y
		};
		var param={"data":JSON.stringify(params)}
		HGIS.Utils.send(routeNetAnlyseURL.nearlyRoadNode,param,"post", "json", function(res) {
			callback(res);
			thisObj.stopNodes.push(res.nodeId);
		}, function(info) {
			alert( HGIS.language[HGIS.InitParam.language]["err_msg"] +":"+ info); //"错误信息："
		}, false);
	};

	/**
	 * APIMethod: setStopXY
	 * 设置停靠点经纬度.
	 * 给定一个位置，设定当前所在位置， 
	 * 
	 * Parameters:
	 * x -   停靠点经度
	 * y -   停靠点纬度
	 */
	this.setStopXY = function(x,y) {
		var param = { "x" : x, "y" : y };
		this.stopXYs.push(param);
	};
	
	/**
	 * APIMethod: shortestPath
	 * 迪杰斯特拉 查询最短路径,此方法返回所有结果，异步后台调用
	 * 
	 * Parameters:
	 * callback - {Object} 查询成功后的回调函数
	 */
	this.shortestPath = function(callback) {
		if (thisObj.stopNodes.length < 2) {
			throw HGIS.language[HGIS.InitParam.language]["least_twoPoint"];	//"至少要给出一个起点及终点。" 
			return;
		} else {
			//测试数据
			 //thisObj.stopNodes=["11038945","6302842"];
			 var params = {
				"stopsNodes" : thisObj.stopNodes
				//"data" : thisObj.stopNodes
			};
			var param={"data":JSON.stringify(thisObj.stopNodes)};
			HGIS.Utils.send(routeNetAnlyseURL.shortestPath,param, "post","json", callback, this.anlyseError);
		}

	};
	
	/**
	 * APIMethod: AStarShortestPathByNodeId
	 * 通过NodeId使用A星算法进行最短路径查询,此方法返回所有结果，异步后台调用
	 * 
	 * Parameters:
	 * callback - {Object} 查询成功后的回调函数
	 */
	this.AStarShortestPathByNodeId = function(callback) {
		if (thisObj.stopNodes.length < 2) {
			throw HGIS.language[HGIS.InitParam.language]["least_twoPoint"];	//"至少要给出一个起点及终点"
			  return;
		} else {
			 var params = { "stopsNodes" : thisObj.stopNodes };
			var param={"data":JSON.stringify(thisObj.stopNodes)};
			HGIS.Utils.send(routeNetAnlyseURL.AStarShortestPathByNodeId,param, "post","json", callback, this.anlyseError);
		}
	};

	/**
	 * APIMethod: AStarShortestPathByXY
	 * 通过设置经过点利用A星算法最短路径查询,此方法返回所有结果，异步后台调用
	 * 
	 * Parameters:
	 * callback - {Object} 查询成功后的回调函数
	 */
	this.AStarShortestPathByXY = function(callback) {
		if (thisObj.stopXYs.length < 2) {
			throw HGIS.language[HGIS.InitParam.language]["least_twoPoint"];	//"至少要给出一个起点及终点"
			return;
		} else {
			var params = { "stopsXYs" : thisObj.stopXYs };
			var param={"data":JSON.stringify(thisObj.stopXYs)};
			HGIS.Utils.send(routeNetAnlyseURL.AStarShortestPathByXY,param, "post","json", callback, this.anlyseError);
		}
	};
	/** 
	 * 生成分析报告
	 */
	this.analysisReport = function() {

	};
	// 不连通的部分。如果你所给出的位置距路径起始位置还有一段距离，那么此方法将为返回这段近似路段
	this.unThroughSeg = function() {

	};
	// 路径分析返回成功调用，该方法不对外暴露
	this.anlyseSuccess = function(res) {
		alert(res);
	};
	// 路径分析失败调用，该方法不对外暴露
	this.anlyseError = function(errorInfo) {
		alert(errorInfo);
	};

};HGIS.Strategy = HGIS.Strategy || {};


/**
 * IndexedDB工作时所需的参数
 *
 */
HGIS.Strategy.Parameters= {
    //是否启用indexedDB缓存，该参数可对外暴露
    isCache: false,

    //是否与数据库链接成功
    isConnected: false,

    //维持的WebTileCache的一个实例
    wtc: null,

    //初始化数据库
    initDB: function () {

        //用来给以后
        String.prototype.hashCode = function() {
            var hash = 0, i, chr;
            if (this.length === 0) return hash;
            for (i = 0; i < this.length; i++) {
                chr   = this.charCodeAt(i);
                hash  = ((hash << 5) - hash) + chr;
                hash |= 0; // Convert to 32bit integer
            }
            return hash.toString();
        };


        this.wtc = new HGIS.Strategy.WebTileCache();
        if ((typeof(Promise) !== "function") || (!this.wtc.isSupported())) {//浏览器不支持indexedDB,还要判断是否支持promise
            this.wtc = null;
            HGIS.Strategy.Parameters.isCache = false;
            alert( HGIS.language[HGIS.InitParam.language]["noSupport_idxDB"] );	//"不支持IndexedDB"
        } else {//浏览器支持indexedDB，建表
            //console.log("支持IndexedDB");
            var successHandler_create = function (res) {
                //console.log("数据库创建/连接成功");
                //this.isConnected = true;//建表成功时改变参数为true，后边可以执行增查操作
                HGIS.Strategy.Parameters.isConnected=true;
                HGIS.Strategy.Parameters.isCache = true;
            };
            var errorHandler_create = function (errorStr) {
                alert( HGIS.language[HGIS.InitParam.language]["DB_fail"] );	//"数据库创建/连接失败" 
                HGIS.Strategy.Parameters.isConnected = false;//建表成功时改变参数为false，后边不执行增查操作
            };
            var ts = HGIS.InitParam.maxLevel;//获取最大级别
            this.wtc.createTileDB({totalLevels: ts}, successHandler_create, errorHandler_create);
        }
    },
    //清空数据库
    clearDB:function(){
        if (this.wtc==null){
            var temp=new HGIS.Strategy.WebTileCache();
            if(!temp.isSupported()){
                temp=null;
            }else{
                var success_create=function (res) {
                    temp.clearTileDB();
                };
                var error_create=function (errorStr) {
                    temp=null;
                };
                temp.createTileDB({
                    version:1.0,
                    totalLevels:this.options.maxZoom,
                    dbname:"HGIS_Cache"
                },success_create,error_create);
            }
        }else{
            this.wtc.clearTileDB();
        }
    }
};


/**
 * 本类用于创建基于浏览器的切片缓存数据库。缓存策略采用的是IndexDB
 */
HGIS.Strategy.WebTileCache = function() {
    var thisObj = this;
    // 统一数据库对象
    var indexedDB = window.indexedDB || window.msIndexedDB || window.mozIndexedDB || window.webkitIndexedDB;
    // 统一事务
    var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
    // 始终维持一个database
    var database;
    // 用来构建对数据库图片的索引
    //var URL = window.URL || window.webkitURL;
    // 内部 常调用的变量
    var _request,_transaction,_index;

    thisObj.options={
        // 数据库版本号
        version:1.0,
        // 对象存储空间的级数
        totalLevels:20,
        // 数据库默认名称
        dbname:"HGIS_Cache"
    };


    /**
     * 判断是否支持数据库的创建
     *
     */
    this.isSupported = function() {
        return indexedDB ? true : false;
    };

    /**
     * 判断数据库指定数据库是否已经存在
     *
     */
    this.exsits = function(dbname) {

    };

    /**
     * 创建数据库
     *
     */
    this.createTileDB = function(opts,successHandler,errorHandler) {
        if(database){
            //alert("【创建据库失败】已存在一个IDBDatabase实例，请先关闭该IDBDatabase的实例");
            errorHandler("创建据库失败！");
        }else{
            thisObj._initTable(opts,successHandler,errorHandler);
        }
    };
    this._initTable = function(opts,successHandler,errorHandler){
        thisObj.extend(thisObj.options,opts);
        _request = indexedDB.open(thisObj.options.dbname,thisObj.options.version);
        _request.onsuccess = function(event){
            database = event.target.result;
            successHandler(database);
        };
        // 创建数据库失败
        _request.onerror=function(){
            errorHandler("初始化切片对象存储空间失败！");
        };

        // 执行数据库对象存储空间的创建工作
        _request.onupgradeneeded=function(event){
            // 连接成功则建对象存储空间（表）
            database = event.target.result;
            thisObj._createTables(database);
        };
    };
    this.extend = function(options, opts) {
        for ( var i in opts) {
            options[i] = opts[i];
        }
    };
    this._createTables = function(database){
        var objectStore;
        for(var i=0;i<=thisObj.options.totalLevels;i++){
            if(i<=15){
                if(!database.objectStoreNames.contains("0-15")){
                    // 主键设为tileId
                    objectStore=database.createObjectStore("0-15",{keyPath: "tileId"});
                    // 建立索引
                    objectStore.createIndex("tileId" , "tileId" , { unique: true });
                }
            }else{
                if(!database.objectStoreNames.contains(String(i))){
                    // 主键设为tileId
                    objectStore=database.createObjectStore(String(i),{keyPath: "tileId"});
                    // 建立索引
                    objectStore.createIndex("tileId" , "tileId" , { unique: true });
                }
            }
        }
    };

    /**
     * 删除数据库，谨慎使用
     *
     *
     */
    this.deleteTileDB = function() {
        database.close();
        _request = indexedDB.deleteDatabase(database.name);
        _request.onsuccess = function(event){
            alert(HGIS.language[HGIS.InitParam.language]["del_DB_success"]);	//"【删除数据库成功】" 
        };
        // 删除数据库失败
        _request.onerror=function(){
            alert( HGIS.language[HGIS.InitParam.language]["del_DB_err"]);	//"【删除数据库失败】"
        };
    };

    this.clearTileDB=function () {
        var lObj='';
        for(var i=15;i<thisObj.options.totalLevels;i++){
            if(i==15){
                lObj="0-15";
            }else{
                lObj=i;
            }

            if(database.objectStoreNames.contains(String(lObj))){
                database.transaction(lObj,"readwrite").objectStore(lObj).clear().onsuccess=function (event) {
                    //console.log("清空数据库。。。");
                };
            }
        }
        return 1;
    }

    /**
     * 查询数据
     * @param tileKey　　　　　　　关键字
     * @param level　　　　　　　　显示级别
     * @param successHandler　　
     * @param errorHandler
     */
    this.query = function(tileKey,level,successHandler,errorHandler) {
        // 构造表名
        var objName=level>15?String(level):"0-15";
        // 获取索引
        _index=database.transaction(objName).objectStore(objName).index("tileId");
        // 通过索引获取数据
        _request=_index.get(tileKey);

        _request.onerror = function(event){
            errorHandler("[WebTileCache]-query查詢失敗");
            //errorHandler("indexedDB中该切片不存在");
            //console.log("获取切片失败");
        };
        _request.onsuccess = function(event){
            if(typeof (event.target.result)!="undefined"){
                //console.log("=======有數據+++");
                successHandler(event.target.result.tile);
            }else{
                //console.log("=======undefined--");
                errorHandler("[WebTileCache]-query數據爲空");
            }

        };
    };


    /**
     * 插入记录
     * @param tileKey　　　　关键字
     * @param level　　　　　显示级别
     * @param tile　　　　　　切片数据
     */
    this.insert = function(tileKey,level,tile) {
        var objName=level>15?String(level):"0-15";
        if((typeof (database))=="undefined"){
            alert( HGIS.language[HGIS.InitParam.language]["no_instant"] );	//"database未实例化"
        }
        // 获取读写模式下的事务，此种模式不仅可以读，还可以写
        _transaction=database.transaction(objName,"readwrite");
        var temp={
            'tileId':tileKey,
            'tile':tile
        };
        _request = _transaction.objectStore(objName).add(temp);
        _request.onsuccess = function(event){
            //successHandler(event.target.result);
            //console.log("[WebTileCache]保存切片成功");
        };
        // 插入切片失败
        _request.onerror=function(){
            //errorHandler("要插入的对象已存在！");
            //console.log("[WebTileCache]保存的切片已存在");
        };
    };

};


/**
 * Class: HGIS.Symbolizer.CompositeSymbol
 * 组合符号，将多种其他符号组合而成的复合符号，多用于图标和文本符号的组合。
 * 
 */
HGIS.Symbolizer.CompositeSymbol = HGIS
		.Class({
			symbols : [],
			div : null,
			type : 'compositesymbol',
			// 文字的对齐方式，‘-’前的表示为所处位置，后的表示对齐方式
			textPosition : 'bottom-center',
			// 边框颜色
			borderLineColor : null,
			// 边框样式
			borderLineStyle : 'solid',
			// 边框宽度
			borderLineWidth : 0,
			// 鼠标滑过样式
			cursor : 'pointer',

			selected : false,

			initialize : function(symbols) {
				this.symbols = symbols;
			},
			draw : function() {
				if (!this.pictureSymbol || !this.textSymbol) {
					for (var i = 0; i < this.symbols.length; i++) {
						var symbol = this.symbols[i];
						if (symbol.type === 'picturemarkersymbol'
								&& !this.pictureSymbol) {
							this.pictureSymbol = symbol;
						}
						if (symbol.type === 'textsymbol' && !this.textSymbol) {
							this.textSymbol = symbol;
						}
					}
				}
				// if (!this.pictureSymbol || !this.textSymbol) {
				// return '';
				// }

				var divs = [], borderDiv = [], imgDiv = [], textDiv = [];
				divs.push('<div style="position:absolute;cursor:' + this.cursor
						+ ';');
				// divs.push('background-color:#ffffff;filter:alpha(opacity=100);opacity:1;');
				imgDiv.push('<img src="' + this.pictureSymbol.url
						+ '" style="position:absolute;');
				textDiv.push('<div style="position:absolute;');
				textDiv.push('white-space:nowrap;text-overflow:ellipsis;overflow:hidden;');

				var pictureWidth = parseInt(this.pictureSymbol.width), pictureHeight = parseInt(this.pictureSymbol.height);
				imgDiv.push('width:' + pictureWidth + 'px;height:'
						+ pictureHeight + 'px;');

				var text = this.textSymbol.text || '';
				var textSize = HGIS.Util.getTextSize(text,
						this.textSymbol.fontSize, this.textSymbol.fontFamily);

				var maxWidth = 100;
				if (this.textSymbol.fontSize * 6 > maxWidth) {
					maxWidth = this.textSymbol.fontSize * 6;
				}
				var textWidth = parseInt(this.textSymbol.width
						|| (((textSize.width + 4) > maxWidth) ? maxWidth
								: textSize.width + 4));

				var textHeight = parseInt(this.textSymbol.height
						|| (textSize.height));
				textDiv.push('width:' + textWidth + 'px;height:' + textHeight
						+ 'px;');
				textDiv.push('font-size:' + this.textSymbol.fontSize
						+ 'px;font-family:\'' + this.textSymbol.fontFamily
						+ '\';');

				var offsetX = 0, offsetY = 0;
				this.width = pictureWidth;
				this.height = pictureHeight;

				if (this.textPosition.indexOf('bottom-') > -1) {
					this.width = textWidth > this.width ? textWidth
							: this.width;
					this.height += (textHeight + 2);
					offsetY = -pictureHeight / 2;

					imgDiv.push('top:0px;');
					textDiv.push('bottom:0px;');
				} else if (this.textPosition.indexOf('top-') > -1) {
					this.width = textWidth > this.width ? textWidth
							: this.width;
					this.height += (textHeight + 2);
					offsetY = -this.height + (pictureHeight / 2);

					imgDiv.push('bottom:0px;');
					textDiv.push('top:0px;');
				} else if (this.textPosition.indexOf('left-') > -1) {
					this.width += (textWidth + 2);
					this.height = textHeight > this.height ? textHeight
							: this.height;
					offsetX = -this.width + (pictureWidth / 2);

					imgDiv.push('right:0px;');
					textDiv.push('left:0px;text-align:center;');
				} else if (this.textPosition.indexOf('right-') > -1) {
					this.width += (textWidth + 2);
					this.height = textHeight > this.height ? textHeight
							: this.height;
					offsetX = -pictureWidth / 2;

					imgDiv.push('left:0px;');
					textDiv.push('right:0px;text-align:center;');
				}

				divs.push('width:' + this.width + 'px;height:' + this.height
						+ 'px;');

				if (this.textPosition.indexOf('-left') > -1) {
					offsetX = -pictureWidth / 2;
					imgDiv.push('left:0px;');
					textDiv.push('left:0px;text-align:left;line-height:'
							+ textHeight + 'px;');
				} else if (this.textPosition.indexOf('-center') > -1) {
					offsetX = -this.width / 2;
					imgDiv.push('left:'
							+ (this.width - parseInt(this.pictureSymbol.width))
							/ 2 + 'px;');
					textDiv.push('left:' + (this.width - textWidth) / 2
							+ 'px;text-align:center;line-height:' + textHeight
							+ 'px;');
				} else if (this.textPosition.indexOf('-right') > -1) {
					offsetX = -this.width + (pictureWidth / 2);
					imgDiv.push('right:0px;');
					textDiv.push('right:0px;text-align:right;line-height:'
							+ textHeight + 'px;');
				} else if (this.textPosition.indexOf('-top') > -1) {
					offsetY = -pictureHeight / 2;
					imgDiv.push('top:0px;');
					textDiv.push('top:0px;');
				} else if (this.textPosition.indexOf('-bottom') > -1) {
					offsetY = -this.height + (pictureHeight / 2);
					imgDiv.push('bottom:0px;');
					textDiv.push('bottom:0px;');
				} else if (this.textPosition.indexOf('-middle') > -1) {
					offsetY = -this.height / 2;
					imgDiv.push('top:'
									+ (this.height - parseInt(this.pictureSymbol.height))/ 2 + 'px;');
					textDiv.push('top:' + (this.height - textHeight) / 2
							+ 'px;line-height:' + textHeight + 'px;');
				}

				if (this.xoffset) {
					offsetX = offsetX + this.xoffset;
				}
				if (this.yoffset) {
					offsetY = offsetY + this.yoffset;
				}
				divs.push('left:' + offsetX + 'px;top:' + offsetY + 'px;" ');
				divs.push('title="' + text + '">');

				imgDiv.push('"/>');
				if (this.textSymbol.color) {
					textDiv.push('color:' + this.textSymbol.color.to0x() + ';');
				}
				textDiv.push('">' + text + '</div>');

				divs = divs.concat(imgDiv);
				divs = divs.concat(textDiv);

				if (this.borderLineColor && this.borderLineStyle
						&& this.borderLineWidth) {
					borderDiv.push('<div style="position:absolute;');
					borderDiv.push('width:' + this.width + 'px;height:'
							+ this.height + 'px;');
					// 边框
					borderDiv.push('border:' + this.borderLineWidth + 'px '
							+ this.borderLineStyle + ' '
							+ this.borderLineColor.to0x() + ';top:-'
							+ this.borderLineWidth + 'px;left:-'
							+ this.borderLineWidth + 'px;');
					// 透明度
					borderDiv.push('filter:alpha(opacity='
							+ (this.borderLineColor.a * 100) + ');opacity:'
							+ this.borderLineColor.a + ';');
					borderDiv.push('"></div>');
					divs = divs.concat(borderDiv);
				}

				if (this.selected) {
					divs.push('<div style="position:absolute;height:100%;width:100%;');
					divs.push('border: 2px solid #FF64FF;padding:2px;top:-4px;left:-4px;"></div>');
				}

				divs.push('</div>');

				this.div = divs.join('');
				return this.div;

			},
			toJson : function() {
				var _symbols = [];
				var length = this.symbols.length;
				for (var i = 0; i < length; i++) {
					var symbol = this.symbols[i];
					_symbols.push(symbol.toJson());
				}
				var json = {
					type : "hikCS",
					symbols : _symbols
				};
				return json;
			}
		});

HGIS.Symbolizer=HGIS.Symbolizer||{};
/**
 * Function: HGIS.Symbolizer.CreateHtmlIcon
 * 创建一个HtmlIcon图标。
 */

/** 
	 * 
	 * Parameters:
	 * options -包含width、height、img、info、offset的键值对。
	 *  
	 * 示例:
	 * (code)
	 * var options={
	 *    "width": 40,
	 *    "height":20,
	 *    "img":"1.png",
	 *    "info":"sss",
	 *    "offset":0
	 * }
	 * var hicon= HGIS.Symbolizer.CreateHtmlIcon(options);
	 * (end)
	 */
HGIS.Symbolizer.CreateHtmlIcon = function(styleOptions){
	var div = document.createElement('div');
	div.style.width = styleOptions.width+'px';
	div.style.height = styleOptions.height+'px';
	div.style['text-align'] = 'center';
	div.style.backgroundImage = 'url('+styleOptions.img+')';
	div.style.backgroundRepeat = 'no-repeat';
	var span = document.createElement('span');
	span.style.position = 'relative';
	span.style.top = '-20px';
	span.style.color = '#fff';
	span.style['font-size'] = '18px';
	span.style.left = '18px';
	span.innerText = styleOptions.info;
	span.style.backgroundColor = 'blue';
	span.style.width = '20px';
	span.style.height = '22px';
	div.appendChild(span);
	var htmlIcon = new HGIS.HtmlIcon(div.outerHTML,null, styleOptions.offset);
	return htmlIcon;
};HGIS.Symbolizer = HGIS.Symbolizer || {};
/**
 * Class: HGIS.Symbolizer.FillSymbol 
 * 填充符号类，是一个虚类
 */
HGIS.Symbolizer.FillSymbol = HGIS
		.Class(
				HGIS.Symbolizer.Symbol,
				{
					outline : null,
					initialize : function(options) {
						HGIS.Symbolizer.Symbol.prototype.initialize.apply(this,
								[ options ]);
						if (options && typeof (options) === "object"
								&& options.outline) {
							this.outline = new HGIS.Symbolizer.SimpleLineSymbol(
									options.outline);
						}
					},
					setOutline : function(outline) {
						this.outline = outline;
						return this;
					},
					toJson : function() {
						var json = {};
						if (this.outline !== null) {
							json.outline = this.outline.toJson();
						}
						if (this.color !== null) {
							json.color = this.color.toJson();
						}
						return json;
					}
				});
/**
 * Class: HGIS.Symbolizer.Font
 * HGIS.Symbolizer.Font 
 * 字体类
 */
HGIS.Symbolizer = HGIS.Symbolizer || {};
/**
 * Constructor: HGIS.Symbolizer.Font
 * 
 * Parameters:
 * size - {<>} 地图对象实例
 * style  {<HGIS.Object>}样式对象
 * variant 变体   normal | small-caps（小型的大写字母字体，只对英文起作用）
 * weight 字体的粗细 normal（正常）,bold（粗体）,bolder（特粗）,lighter（细体），100、200、300、400、500、600、700、800、900
 * family 字体名称
 */
HGIS.Symbolizer.Font = HGIS.Class({
	initialize : function(size, style, variant, weight, family) {
		if (size) {
			if (typeof (size) === "object") {
				HGIS.Util.extend(this, size);
			} else {
				this.size = size;
				if (style !== undefined) {
					this.style = style;
				}
				if (variant !== undefined) {
					this.variant = variant;
				}
				if (weight !== undefined) {
					this.weight = weight;
				}
				if (family !== undefined) {
					this.family = family;
				}
			}
		}
	},
	setSize : function(size) {
		this.size = size;
		return this;
	},
	setStyle : function(style) {
		this.style = style;
		return this;
	},
	setVariant : function(variant) {
		this.variant = variant;
		return this;
	},
	setWeight : function(weight) {
		this.weight = weight;
		return this;
	},
	setFamily : function(family) {
		this.family = family;
		return this;
	},
	toJson : function() {
		return {
			size : this.size,
			style : this.style,
			variant : this.variant,
			decoration : this.decoration,
			weight : this.weight,
			family : this.family
		};
	}
});
HGIS.Util.extend(HGIS.Symbolizer.Font, {
	STYLE_NORMAL : "normal",
	STYLE_ITALIC : "italic",
	STYLE_OBLIQUE : "oblique",
	VARIANT_NORMAL : "normal",
	VARIANT_SMALLCAPS : "small-caps",
	WEIGHT_NORMAL : "normal",
	WEIGHT_BOLD : "bold",
	WEIGHT_BOLDER : "bolder",
	WEIGHT_LIGHTER : "lighter"
});/**
 * Class: HGIS.Symbolizer.HtmlIcon
 * HtmlIcon类
 * 
 * 继承自:
 * {<HGIS.Icon>}
 */
HGIS.Symbolizer=HGIS.Symbolizer||{};
HGIS.Symbolizer.HtmlIcon = HGIS.Class(HGIS.Icon, {
	html : null,

	size : null,

	offset : null,

	calculateOffset : null,

	div : null,

	px : null,

	/**
	 * Constructor: HGIS.Symbolizer.HtmlIcon
	 * 构造方法
	 * 
	 * Parameters:
	 * html - {String} HtmlIcon 的内容，html格式
	 * size - {Number} 大小
	 * offset -{Number} 偏移 
	 * calculateOffset -{Number}  暂时无用
	 */
	initialize : function(html, size, offset, calculateOffset) {
		this.html = html;
		this.size = size;
		this.offset = offset || {
			x : 0,
			y : 0
		};

		this.calculateOffset = calculateOffset;
		var id = HGIS.Util.createUniqueID("HGIS_Icon_");
		this.div = document.createElement('div');
		this.div.id = id;
	},
	/**
	 * APIMethod: destroy
	 * 销毁该对象
	 */
	destroy : function() {
		this.erase();
		// HGIS.Event.stopObservingElement(this.div.firstChild);
		this.div.innerHTML = "";
		this.div = null;
		
	},

	clone : function() {
		return new HikGIS.HtmlIcon(this.html, this.size, this.offset, this.calculateOffset);
	},
	/**
	 * APIMethod: setHtml
	 * 设置该symbol的内容
	 * 
	 * Parameters:
	 * html - {String} HtmlIcon 的内容，超文本格式
	 */
	setHtml : function(html) {
		if (html != null) {
			this.html = html;
		}
		this.draw();
	},
	/**
	 * APIMethod: draw
	 * 将该symbol 绘制到界面上
	 * 
	 * px: {<HGIS.Geometry.Point>} 绘制的位置
	 */
	draw : function(px) {
		if (this.size && this.size.width) {
			this.div.style.width = this.size.width + "px";
		}
		if (this.size && this.size.height) {
			this.div.style.height = this.size.height + "px";
		}
		this.div.style.position = "absolute";
		this.div.style.cursor="pointer";
		this.div.innerHTML = this.html;
		this.moveTo(px);
		return this.div;
	},

	/**
	 * APIMethod: erase
	 * 移除该symbol
	 */
	erase : function() {
		if (this.div != null && this.div.parentNode != null) {
			HGIS.Element.remove(this.div);
		}
	},
	
	/**
	 * APIMethod: setOpacity
	 * 设置透明度
	 * 
	 * Parameters:
	 * opacity - {Number} 透明度
	 */
	setOpacity : function(opacity) {
		var element = this.div;
		if (parseFloat(opacity) >= 0.0 && parseFloat(opacity) < 1.0) {
			element.style.filter = 'alpha(opacity=' + (opacity * 100) + ')';
			element.style.opacity = opacity;
		} else if (parseFloat(opacity) == 1.0) {
			element.style.filter = '';
			element.style.opacity = '';
		}
	},
	/**
	 * APIMethod: moveTo
	 * 移动该symbol
	 * 
	 * Parameters:
	 * px - {<HGIS.Geometry.Point>} 移动到目标位置 
	 */
	moveTo : function(px) {
		if (px != null) {
			this.px = px;
		}

		if (this.div != null) {
			if (this.px == null) {
				this.display(false);
			} else {
				if (this.calculateOffset) {
					this.offset = this.calculateOffset(this.size);
				}
				HGIS.Util.modifyDOMElement(this.div, null, {
					x : this.px.x + this.offset.x ,
					y : this.px.y + this.offset.y
				});
			}
		}
	},
    
	/**
	 * APIMethod: display
	 * 是否显示.
	 * 
	 * Parameters:
	 * display - {String} 是否显示 
	 */
	display : function(display) {
		this.div.style.display = (display) ? "" : "none";
	},

	/**
	 * APIMethod: isDrawn
	 * 判断该icon是否绘制
	 * 
	 * Returns:
	 * {Boolean}
	 */
	isDrawn : function() {
		var isDrawn = (this.div && this.div.parentNode && (this.div.parentNode.nodeType != 11));

		return isDrawn;
	},
	CLASS_NAME : "HGIS.Symbolizer.HtmlIcon"
});/**
 * Class: HGIS.Symbolizer.HtmlSymbol 
 * Html符号类
 */
HGIS.Symbolizer.HtmlSymbol = HGIS.Class(HGIS.Symbolizer.Symbol, {
	type : "htmlsymbol",
	size : null,
	initialize : function(html, size, offset) {
		this.html = html;
		this.size = size ? size : null;
		this.offset = offset ? offset : {
			x : 0,
			y : 0
		};
		HGIS.Symbolizer.Symbol.prototype.initialize.apply(this, [ html, size,
				offset ]);
	},
	setHtml : function(html) {
		this.html = html;
	},
	setOffset : function(offset) {
		this.offset = offset;
	}
});/**
 * Class: ImageTextIcon
 * ImageTextIcon
 * 
 * 继承自:
 * HGIS.Icon
 */
HGIS.Symbolizer=HGIS.Symbolizer||{};
HGIS.Symbolizer.ImageTextIcon = HGIS.Class(HGIS.Icon,{
	html : null,
	symbols : [],
	div : null,
	type : 'ImageTextIcon',
	/**
	 * APIProperty: textPosition
	 * 文字的对齐方式，‘-’前的表示为所处位置，后的表示对齐方式
	 */ 
	textPosition : 'top-center',
	/**
	 * APIProperty: textBorder
	 * 边框样式 默认'none'
	 */
	textBorder : 'none',
	/**
	 * APIProperty: cursor
	 * 鼠标滑过样式
	 */
	cursor : 'pointer',
	/**
	 * APIProperty: textBackgroundColor
	 * text背景颜色 默认'#7d48c8'
	 */
	textBackgroundColor:'#7d48c8' ,
	/**
	 * APIProperty: gap
	 * text与Image间距 默认'2'
	 */
	gap: 2,
	/**
	 * APIProperty: selected
	 * 是否选中标志位 默认'false'
	 */
	selected : false,
	/**
	 * APIProperty: showTitle
	 * 鼠标悬浮是否显示Text 默认'false'
	 */
	showTitle : false,
	/**
	 * APIProperty: showText
	 * 是否显示Text 默认'true'
	 */
	showText : true,
	/**
	 * Constructor: HGIS.Symbolizer.ImageTextIcon
	 * 构造函数
	 * 
	 * Parameters:
	 * options - {Object}  通过设置一下属性来设置
	 * {
	 * 		imgUrl
	 * 		imgWidth
	 * 		imgHeight
	 *      selImgUrl
	 *      text
	 *      textBackgroundColor
	 *      textPosition
	 *      textBorderRadius
	 *		textBgPadding
	 *      fontSize
	 *      fontFamily
	 *      textColor
	 *      textBorder
	 *      gap
	 *      showTitle
	 *      showText
	 *      maxWidth
	 *      offset
	 * }
	 */
	initialize : function(options) {
		this.options = options;
		//图片路径
		this.imgUrl = options.imgUrl;
		//图片宽高
		this.imgWidth = options.imgWidth;
		this.imgHeight = options.imgHeight;
		//选中或者hover的图片样式路径
		this.selImgUrl = options.selImgUrl;
		
		//如果没有颜色，默认深蓝色背景
		this.text = options.text;
		this.textBackgroundColor = options.textBackgroundColor?options.textBackgroundColor:'#7d48c8';//深蓝色
		this.textPosition = options.textPosition?options.textPosition:this.textPosition;
		//新增
		this.textBorderRadius = options.borderRadius?options.borderRadius:"1px";
		this.textBgPadding = options.textBgPadding?options.textBgPadding:"1px";
		
		this.fontSize = options.fontSize?options.fontSize:'13';
		this.fontFamily = options.fontFamily?options.fontFamily:'\'宋体\'';
		this.textColor = options.textColor?options.textColor:'#ccc';
		this.textBorder = options.textBorder?options.textBorder:'none';
		this.gap = options.gap?options.gap:2;
		
		this.showTitle = options.showTitle || false;
		this.showText = typeof options.showText === 'boolean' ? options.showText : true;
		//文字最大宽度，默认不限制这里设为10000
		this.maxWidth = options.maxWidth?options.maxWidth:10000;
		
		var id = HGIS.Util.createUniqueID("HGIS_Icon_");
		this.div = document.createElement('div');
		this.div.id = id;
		if(this.showTitle){
			this.div.title = this.text;
		}
		this.offset = options.offset || {
			x : 0,
			y : 0
		};
		
		this.html = this.getHtml();
		
	},
	/**
	 * APIMethod: erase
	 * 移除该Icon
	 */
	erase: function() {
    	 if (this.div != null && this.div.parentNode != null) {
				HGIS.Element.remove(this.div);
			}
     },
     /**
 	 * APIMethod: display
 	 * 设置该icon Style的display
 	 */
    display : function(display) {
		this.div.style.display = (display) ? "" : "none";
	},
	 /**
 	 * APIMethod: isDrawn
 	 * 获取该对象是否完成绘制
 	 */
    isDrawn : function() {
		var isDrawn = (this.div && this.div.parentNode && (this.div.parentNode.nodeType != 11));

		return isDrawn;
	},
	 /**
 	 * APIMethod: setImage
 	 * 修改图标
 	 * 
 	 * Parameters:
 	 * imgUrl: - {String} 图片路径
 	 */
	setImage:function(imgUrl){
		this.div.getElementsByTagName('img')[0].src = imgUrl;
	},
	/**
	 * APIMethod: select 
	 * 选择后的图标样式
	 */
	select:function(){
		this.selected = true;
		if(this.selImgUrl){
			this.div.getElementsByTagName('img')[0].src = this.selImgUrl;
		}	
	},
	/**
	 * APIMethod: unselect 
	 * 取消选择后的图标样式
	 */
	unselect:function(){
		this.selected = false;
		this.div.getElementsByTagName('img')[0].src = this.imgUrl;
	},
	
	/**
	 * APIMethod: getHtml 
	 * 获取对象的内容
	 */
	getHtml : function() {
		var img = document.createElement('img');
		var textSpan = document.createElement('span');
		if(!this.selected){
			//未选中时的样式
			img.src = this.imgUrl;
			img.style.position = 'absolute';
		}else{
			//如果未传入选中图片样式则使用普通图片样式
			if(typeof this.selImgUrl=='undefined'){
				img.src = this.imgUrl;
				img.sytle.position = 'absolute';
			}else{
				img.src = this.selImgUrl;
				img.sytle.position = 'absolute';
			}
		}
		textSpan.style.position = 'absolute';
		//文字背景色
		textSpan.style.whiteSpace = 'nowrap';
		textSpan.style.textOverflow = 'ellipsis';
		textSpan.style.overflow = 'hidden';
		textSpan.style.background = this.textBackgroundColor;
		textSpan.style.border = this.textBorder;
		textSpan.style.borderRadius= this.textBorderRadius;
		textSpan.style.padding= this.textBgPadding;
		textSpan.style.color = '#fff';
		
		var pictureWidth = parseInt(this.imgWidth),
			pictureHeight = parseInt(this.imgHeight);
		img.style.width = pictureWidth+'px';
		img.style.height = pictureHeight+'px';
		var text = this.text || '';
		textSpan.innerText = this.text;
		var textSize = this.getTextSize(text, this.fontSize, this.fontFamily);

		var maxWidth = this.maxWidth;
		if (this.fontSize * 6 > maxWidth) {
			maxWidth = this.fontSize * 6;
		}
		var textWidth = parseInt(this.textWidth || ( ((textSize.width + 4) > maxWidth) 
				? maxWidth : textSize.width + 4 ));
		
		var textHeight = parseInt(( textSize.height ));
		//文字最小宽度15
		var minWidth = 15;
		textWidth = textWidth<minWidth?minWidth:textWidth;
		textSpan.style.width = textWidth + 'px';
		textSpan.style.height = textHeight + 'px';
		textSpan.style.fontSize = this.fontSize + 'px';
		textSpan.style.fontFamily = this.fontFamily;
		
		this.width = pictureWidth;
		this.height = pictureHeight;
		//垂直方向位置
		if (this.textPosition.indexOf('bottom') > -1) {
			this.height += (textHeight + this.gap);
			textSpan.style.top = parseInt(this.imgHeight/2 + this.gap)+'px';
		}else if(this.textPosition.indexOf('middle') > -1){
			this.height = textHeight > this.height ? textHeight : this.height;
			textSpan.style.top = -parseInt(textHeight/2)+'px';
		}else if(this.textPosition.indexOf('top') > -1) {
			this.height += (textHeight + this.gap);
			textSpan.style.top = -parseInt(this.imgHeight/2 + textHeight + this.gap)+'px';
		} 
		//竖直方向位置
		if (this.textPosition.indexOf('left') > -1) {
			this.width += (textWidth + this.gap);
			textSpan.style.left = -parseInt(textWidth + this.imgWidth/2 + this.gap) + 'px' ;
		}else if(this.textPosition.indexOf('center') > -1) {
			this.width = textWidth > this.width ? textWidth : this.width;
			textSpan.style.left = -parseInt(textWidth/2)+'px';
		}else if(this.textPosition.indexOf('right') > -1) {
			this.width += (textWidth + this.gap);
			textSpan.style.left = parseInt(this.imgWidth/2 + this.gap) + 'px' ;
		}
		textSpan.style.textAlign = 'center';
		textSpan.style.lineHeight = textHeight+'px';
		//图片的中心点和真实经纬度对齐
		img.style.left = -(parseInt(this.imgWidth/2))+'px';
		img.style.top = -(parseInt(this.imgHeight/2))+'px';
		if (this.textColor) {
			textSpan.style.color = this.textColor;
		}
		this.div.appendChild(img);
		if (this.text && this.showText) {
			this.div.appendChild(textSpan);
		}
	},
	/**
	 * APIMethod: draw
	 * 将该对象绘制到舞台上
	 * 
	 * Parameters:
	 * px - {<HGIS.Geometry.Point>} 绘制的位置
	 */
	draw : function(px) {
		if (this.size && this.size.width) {
			this.div.style.width = this.size.width + "px";
		}
		if (this.size && this.size.height) {
			this.div.style.height = this.size.height + "px";
		}
		this.div.style.position = "absolute";
		this.div.style.cursor="pointer";
		//this.div.innerHTML = this.html;
		this.moveTo(px);
		return this.div;
	},
	/**
	 * APIMethod: moveTo
	 * 移动该symbol
	 * 
	 * Parameters:
	 * px - {<HGIS.Geometry.Point>} 移动到目标位置 
	 */
    moveTo: function (px) {
    	if (px != null) {
			this.px = px;
		}

		if (this.div != null) {
			if (this.px == null) {
				this.display(false);
			} else {
				if (this.calculateOffset) {
					this.offset = this.calculateOffset(this.size);
				}
				HGIS.Util.modifyDOMElement(this.div, null, {
					x : this.px.x + this.offset.x ,
					y : this.px.y + this.offset.y
				});
			}
		}
    },
    /**
     * APIMethod: getTextSize
     * 获取Icon内容的长度
     * 
     * 	Parameters:
     * text　－ {String} 内容
     * fontSize - {Number} 字体的大小 
     * fontFamily - {String} 字体
     */
    getTextSize:function(text, fontSize, fontFamily) {
    	var textWidthSpan = document.getElementById('text_width_span');
    	if (!textWidthSpan) {
    		textWidthSpan = document.createElement("span");
    		document.body.appendChild(textWidthSpan);
    		textWidthSpan.setAttribute('id', 'text_width_span');
    		textWidthSpan.style.position = 'absolute';
    		textWidthSpan.style.top = '-10000px';
    		textWidthSpan.style.left = '-10000px';
    	}
    	textWidthSpan.style.fontSize = '14px';
    	textWidthSpan.style.fontFamily = '\'宋体\'';
    	if (fontSize) {
    		textWidthSpan.style.fontSize = fontSize + 'px';
    	}
    	if (fontFamily) {
    		textWidthSpan.style.fontFamily = '\'' + fontFamily + '\'';
    	}
    	textWidthSpan.innerText = text;
    	var browser=navigator.appName;
    	if(browser=="Microsoft Internet Explorer") 
    	{ 
    		var b_version=navigator.appVersion;
    		var version=b_version.split(";"); 
    		var trim_Version=version[1].replace(/[ ]/g,""); 
    		if( trim_Version=="MSIE9.0"){
    			return {
    				width : textWidthSpan.offsetWidth+13,
    				height : textWidthSpan.offsetHeight
    			};
    		}
    	} 
    	return {
    		width : textWidthSpan.offsetWidth+4,//增加4px解决ie下宽度不够的问题
    		height : textWidthSpan.offsetHeight
    	};
    },
	CLASS_NAME: "HGIS.Symbolizer.ImageTextIcon"
});

/**
 * Class: HGIS.Symbolizer.LineSymbol 
 * 填充符号类
 */
HGIS.Symbolizer.LineSymbol = HGIS.Class(HGIS.Symbolizer.Symbol, {
	width : 1,
	initialize : function(options) {
		HGIS.Symbolizer.Symbol.prototype.initialize.apply(this, [ options ]);
		if (typeof (options) === "object") {
			this.width = options.width;
		} else {
			this.width = 1;
		}
	},
	/**
	 * APIMethod: setWidth
	 * 设置线符号的宽度
	 * 
	 * Parameters:
	 * width - {Integer } 线符号的宽度	  
	 */
	setWidth : function(width) {
		this.width = width;
		return this;
	},
	/**
	 * APIMethod: toJson
	 * 设置线符号的宽度
	 * 
	 * Returns:
	 * 包含width和color的json对象	  
	 */
	toJson : function() {
		return {
			width : this.width,
			color : this.color.toJson()
		};
	}
});
/**
 * Class: HGIS.Symbolizer.MapLabel
 * 地图标签类,地图标签将会在引擎服务端持久化.
 * 
 * 思路:
 * 1、用户决定在什么时机操作地图记忆. 
 * 2、每次请求成功后，都把当前的请求路径、参数、返回数据格式、处理函数记下来.
 * 3、添加标签，地图蒙版，记下用户名、地图比例级别、中心点。持久化的引擎服务端.
 * 4、查询标签，根据当前用户名从数据库中取出参数，解析成params，提取标准请求。向后台发起相同的请求 
 */
HGIS.Symbolizer = HGIS.Symbolizer || {};
HGIS.Symbolizer.MapLabel = function() {
	/**
	 * Method: queryLabel
	 * 查询标签
	 * 
	 * Parameters:
	 * labelValues - {Object} 标签的任意值,json格式。系统将根据这个键值对在数据库中进行全字段匹配搜索
	 * callback - {Object} 回调函数，查询返回的结果包含在回调函数的参数中，这个参数表明了当前标签曾经干过的事情。
	 */
	this.queryLabel = function(labelValues, callback) {
		HGIS.Utils.send(mapLabelURL.queryLabelURL,JSON.stringify(params),"POST","json",function(res) {
			if (callback) {
				callback(res);
			}
		});
	};
	/**
	 * Method: addLabel 
	 * 添加标签
	 * 
	 * Parameters:
	 * labelName - {String} 标签名称
	 * creater - {String} 创建者
	 * instrution - {String} 标签说明
	 * bizParams - {Object} 业务参数
	 * bounds - {<HGIS.Bounds>} 当前地图范围
	 * callback - {Object}  回调函数。其中的参数指示插入成败
	 */
	this.addLabel = function(labelName, creater, instrution, bizParams, bounds,
			callback) {
		var params = {
			labelName : labelName,
			creater : creater,
			params : bizParams,
			instruction : instrution,
			bounds : bounds
		};
		HGIS.Utils.send(mapLabelURL.addLabelURL,JSON.stringify(params),"POST","json", function(res) {
			if (res.ReturnInfo == "sorry") {
				alert( HGIS.language[HGIS.InitParam.language]["insert_err"] );	//"插入失败，该标签在数据库中可能已经存在"
			} else {
				if (callback) {
					callback(res);
				}
			}
		});
	};

	/**
	 * Method: updateLabel
	 * 修改标签
	 * 
	 * Parameters:
	 * labelID - {String} 标签ID
	 * labelName - {String} 标签名称
	 * instrution - {String} 标签说明
	 * callback - {Object}  回调函数。其中的参数指示插入成败
	 */
	this.updateLabel = function(labelID, labelName, instruction, callback) {
		var thisParams = {
			labelID : labelID,
			labelName : labelName,
			instruction : instruction
		};
		
		HGIS.Utils.send(mapLabelURL.updateLabelURL,JSON.stringify(thisParams),"POST","json", function(res) {
			callback(res);
		});
	};

	/**
	 * Method: delLabel
	 * 根据labelId删除标签 
	 * 
	 * labelID - {String} 标签ID
	 * callback - {Object} 回调函数。其中的参数指示删除成败
	 */
	this.delLabel = function(labelID, callback) {
		var params = {
			labelID : labelID
		};

		HGIS.Utils.send(mapLabelURL.delLabelURL,JSON.stringify(params),"POST","json", function(res) {
			callback(res);
		});
	};

};
/**
 * Class: HGIS.Symbolizer.MarkerSymbol
 * HGIS.Symbolizer.MarkerSymbol 
 * 点符号
 */
HGIS.Symbolizer = HGIS.Symbolizer || {};
/**
 * Constructor: HGIS.Symbolizer.MarkerSymbol
 * 
 */

HGIS.Symbolizer.MarkerSymbol = HGIS.Class(HGIS.Symbolizer.Symbol, {
	angle : 0,
	xoffset : 0,
	yoffset : 0,
	size : 12,
	initialize : function(options) {
		HGIS.Symbolizer.Symbol.prototype.initialize.apply(this, [ options ]);
	},
	setAngle : function(angle) {
		this.angle = angle;
		return this;
	},
	setSize : function(size) {
		this.size = size;
		return this;
	},
	setOffset : function(x, y) {
		this.xoffset = x;
		this.yoffset = y;
		return this;
	},
	toJson : function() {
		return {
			size : this.size,
			angle : this.angle,
			xoffset : this.xoffset,
			yoffset : this.yoffset,
			color : this.color.toJson()
		};
	},
	angle : 0,
	xoffset : 0,
	yoffset : 0,
	size : 12
});/**
 * Class: HGIS.Symbolizer.PictureFillSymbol
 * HGIS.Symbolizer.PictureFillSymbol 
 * 图片填充符号
 */
HGIS.Symbolizer = HGIS.Symbolizer || {};
/**
 * Constructor: HGIS.Symbolizer.PictureFillSymbol
 * 
 */
HGIS.Symbolizer.PictureFillSymbol = HGIS.Class(
		HGIS.Symbolizer.SimpleFillSymbol, {
			initialize : function(url, outline, width, height) {
				HGIS.Symbolizer.SimpleFillSymbol.prototype.initialize.apply(
						this, [ url, outline, width, height ]);
				if (url) {
					if (typeof (url) === "string") {
						this.url = url;
						if (outline !== undefined) {
							this.outline = outline;
						}
						if (width !== undefined) {
							this.width = width;
						}
						if (height !== undefined) {
							this.height = height;
						}
					} else {
						this.xoffset = url.xoffset;
						this.yoffset = url.yoffset;
						this.width = url.width;
						this.height = url.height;
					}
				}
			},
			type : "picturefillsymbol",
			xscale : 1,
			yscale : 1,
			xoffset : 0,
			yoffset : 0,
			width : 20,
			height : 20,
			setWidth : function(width) {
				this.width = width;
				return this;
			},
			setHeight : function(height) {
				this.height = height;
				return this;
			},
			setOffset : function(x, y) {
				this.xoffset = x;
				this.yoffset = y;
				return this;
			},
			setUrl : function(url) {
				if (url !== this.url) {
					delete this.imageData;
					delete this.contentType;
				}
				this.url = url;
				return this;
			},
			setXScale : function(xscale) {
				this.xscale = xscale;
				return this;
			},
			setYScale : function(yscale) {
				this.yscale = yscale;
				return this;
			},
			getStroke : function() {
				return this.outline && this.outline.getStroke();
			},
			getFill : function() {
				return {
					src : this.url,
					width : (this.width * this.xscale),
					height : (this.height * this.yscale),
					x : this.xoffset,
					y : this.yoffset
				};
			},
			toJson : function() {
				var json = {
					type : "hikPFS",
					url : url,
					contentType : this.contentType,
					width : this.width,
					height : this.height,
					xoffset : this.xoffset,
					yoffset : this.yoffset,
					xscale : this.xscale,
					yscale : this.yscale
				};
				if (this.outline) {
					json.outline = this.outline.toJson();
				}
				return json;
			}
		});
/**
 * Class: HGIS.Symbolizer.PictureMarkerSymbol
 * HGIS.Symbolizer.PictureMarkerSymbol 
 * 图片点符号
 */
HGIS.Symbolizer = HGIS.Symbolizer || {};
/**
 * Constructor: HGIS.Symbolizer.PictureMarkerSymbol
 * 
 */ 
HGIS.Symbolizer.PictureMarkerSymbol = HGIS.Class(HGIS.Symbolizer.MarkerSymbol,
		{
			// 图片路径
			url : null,
			// 是否随地图缩放而缩放
			scalable : false,
			// 基准分辨率，当scalable为true时有效
			standardResolution : 0.0001,
			// 鼠标滑过样式
			cursor : '',
			source : null,
			title : '',
			initialize : function(url, width, height) {
				HGIS.Symbolizer.Symbol.prototype.initialize.apply(this, [ url,
						width, height ]);
				if (url) {
					if (typeof (url) == "string") {
						this.url = url;
						this.source = this.url;
						if (width) {
							this.width = width;
						}
						if (height) {
							this.height = height;
						}
					} else {
						this.width = url.width;
						this.height = url.height;
						this.source = url.url;
						this.url = url.url;
						this.scalable = url.scalable || false;
						this.standardResolution = url.standardResolution;
						this.cursor = url.cursor;
						this.resizable = url.resizable || false;
						this.title = url.title;
					}
				}
			},
			type : "picturemarkersymbol",
			getStroke : function() {
				return null;
			},
			getFill : function() {
				return null;
			},
			setWidth : function(width) {
				this.width = width;
				return this;
			},
			setHeight : function(height) {
				this.height = height;
				return this;
			},
			setUrl : function(url) {
				if (url !== this.url) {
					delete this.imageData;
					delete this.contentType;
				}
				this.url = url;
				this.source = this.url;
				return this;
			},
			toJson : function() {
				return this;
			}
		});

/**
 * Class: HGIS.Symbolizer.SimpleFillSymbol
 * HGIS.Symbolizer.SimpleFillSymbol 
 * 图片点符号
 */
HGIS.Symbolizer = HGIS.Symbolizer || {};
/**
 * Constructor: HGIS.Symbolizer.SimpleFillSymbol
 * 
 */ 
HGIS.Symbolizer.SimpleFillSymbol = HGIS.Class(HGIS.Symbolizer.FillSymbol, {
	style : "solid",
	initialize : function(style, outline, color) {
		HGIS.Symbolizer.FillSymbol.prototype.initialize.apply(this, [ style,
				outline, color ]);
		if (style) {
			if (typeof (style) === "string") {
				this.style = style;
				if (outline !== undefined) {
					this.outline = outline;
				}
				if (color !== undefined) {
					this.color = color;
				}
			}
		}
	},
	type : "simplefillsymbol",
	setStyle : function(style) {
		this.style = style;
		return this;
	},
	getStroke : function() {
		return this.outline && this.outline.getStroke();
	},
	getFill : function() {
		return this.color;
	},
	toJson : function() {
		var json = {
			type : "hikSFS",
			style : this.style
		};
		if (this.outline !== null) {
			json.outline = this.outline.toJson();
		}
		if (this.color !== null) {
			json.color = this.color.toJson();
		}
		return json;
	}
});
HGIS.Util.extend(HGIS.Symbolizer.SimpleFillSymbol, {
	STYLE_SOLID : "solid",
	STYLE_NULL : "none",
	STYLE_HORIZONTAL : "horizontal",
	STYLE_VERTICAL : "vertical",
	STYLE_FORWARD_DIAGONAL : "forwarddiagonal",
	STYLE_BACKWARD_DIAGONAL : "backwarddiagonal",
	STYLE_CROSS : "cross",
	STYLE_DIAGONAL_CROSS : "diagonalcross",
	STYLE_FORWARDDIAGONAL : "forwarddiagonal",
	STYLE_BACKWARDDIAGONAL : "backwarddiagonal",
	STYLE_DIAGONALCROSS : "diagonalcross"
});
/**
 * Class: HGIS.Symbolizer.SimpleLineSymbol
 * HGIS.Symbolizer.SimpleLineSymbol 
 * 图片点符号
 */
HGIS.Symbolizer = HGIS.Symbolizer || {};
/**
 * Constructor: HGIS.Symbolizer.SimpleLineSymbol
 * 
 */ 
HGIS.Symbolizer.SimpleLineSymbol = HGIS.Class(HGIS.Symbolizer.LineSymbol, {
	initialize : function(style, color, width) {
		HGIS.Symbolizer.LineSymbol.prototype.initialize.apply(this, [ style,
				color, width ]);
		if (style) {
			if (typeof (style) === "string") {
				this.style = style;
				if (color) {
					this.color = color;
				}
				if (width) {
					this.width = width;
				}
			}
		}
	},
	type : "simplelinesymbol",
	style : "solid", // [solid,dash,dot,dashdot,longdashdotdot,none,insideframe]
	setStyle : function(style) {
		this.style = style;
		return this;
	},
	getStroke : function() {
		return {
			color : this.color,
			style : this.style,
			width : this.width
		};
	},
	getFill : function() {
		return null;
	},
	toJson : function() {
		return {
			type : "hikSLS",
			style : this.style,
			width : this.width,
			color : this.color.toJson()
		};
	}
});
HGIS.Util.extend(HGIS.Symbolizer.SimpleLineSymbol, {
	STYLE_SOLID : "solid",
	STYLE_DASH : "dash",
	STYLE_DOT : "dot",
	STYLE_DASHDOT : "dashdot",
	STYLE_DASHDOTDOT : "longdashdotdot",
	STYLE_NULL : "none"
});
/**
 * Class: HGIS.Symbolizer.SimpleMarkerSymbol
 * HGIS.Symbolizer.SimpleMarkerSymbol 
 * 简单点符号
 */
HGIS.Symbolizer = HGIS.Symbolizer || {};
/**
 * Constructor: HGIS.Symbolizer.SimpleMarkerSymbol
 * 
 */
HGIS.Symbolizer.SimpleMarkerSymbol = HGIS.Class(HGIS.Symbolizer.MarkerSymbol, {
	initialize : function(style, size, outline, color) {
		HGIS.Symbolizer.MarkerSymbol.prototype.initialize.apply(this, [ style,
				size, outline, color ]);
		if (style) {
			if (typeof (style) === "string") {
				this.style = style;
				if (size) {
					this.size = size;
				}
				if (outline) {
					this.outline = outline;
				}
				if (color) {
					this.color = color;
				}
			}
		}
	},
	type : "simplemarkersymbol",
	style : "circle",
	outline : null,
	setStyle : function(style) {
		this.style = style;
		return this;
	},
	setOutline : function(outline) {
		this.outline = outline;
		return this;
	},
	getStroke : function() {
		return this.outline && this.outline.getStroke();
	},
	getFill : function() {
		return this.color;
	},
	toJson : function() {
		var obj = {
			type : "hikSMS",
			angle : this.angle,
			xoffset : this.xoffset,
			yoffset : this.yoffset,
			size : this.size,
			style : this.style,
			color : this.color.toJson()
		};
		if (this.outline != null) {
			obj.outline = this.outline.toJson();
		}
		return obj;
	}
});

HGIS.Util.extend(HGIS.Symbolizer.SimpleMarkerSymbol, {
	STYLE_CIRCLE : "circle",
	STYLE_SQUARE : "square",
	STYLE_CROSS : "cross",
	STYLE_X : "x",
	STYLE_DIAMOND : "diamond",// 无效
	STYLE_TARGET : "target"// 无效
});HGIS.Symbolizer = HGIS.Symbolizer || {};
HGIS.Symbolizer.RGBColor = HGIS.Class({
	r : 0,
	g : 0,
	b : 0,
	a : 0,
	initialize : function(r, g, b, a) {
		if (r)
			this.r = r;
		if (g)
			this.g = g;
		if (b)
			this.b = b;
		if (a != 0)
			this.a = a;
	},
	toJson : function() {
		return [ this.r, this.g, this.b, Math.round(this.a * 255) ];
	},
	/**
	 * 将一个数字转换为16进制字符串
	 * 
	 * @param {}
	 *            num
	 * @return {}
	 */
	toNumberTo0x : function(num) {
		if (num > 255) {
			return "FF";
		}
		var a = Math.floor(num / 16);
		var b = num % 16;
		return "" + this.paserNum(a) + this.paserNum(b);
	},
	/**
	 * 将小于16的数字转换为对应的16进制字符
	 * 
	 * @param {}
	 *            a
	 * @return {String}
	 */
	paserNum : function(a) {
		switch (a) {
		case 10:
			return "A";
		case 11:
			return "B";
		case 12:
			return "C";
		case 13:
			return "D";
		case 14:
			return "E";
		case 15:
			return "F";
		default:
			return a + "";
		}
	},
	/**
	 * 将颜色字符串转换为对应的16进制字符
	 * 
	 * @return {}
	 */
	to0x : function() {
		return "#" + this.toNumberTo0x(this.r) + this.toNumberTo0x(this.g)
				+ this.toNumberTo0x(this.b);
	},
	/**
	 * 从16进制字符串（如'#FFFFFF'）中获得颜色属性
	 * 
	 * @param {string}
	 *            hex 16进制的颜色表达式
	 */
	fromHex : function(hex) {
		// 不合格的颜色表达式
		if (hex.indexOf('#') !== 0) {
			return;
		}
		// 加上'#'不足7位，需补足7位
		while (hex.length < 7) {
			hex = hex + '0';
		}

		var rs = hex.substring(1, 3);
		this.r = parseInt(rs, 16);
		var gs = hex.substring(3, 5);
		this.g = parseInt(gs, 16);
		var bs = hex.substring(5, 7);
		this.b = parseInt(bs, 16);
	},
	/**
	 * 复制一个Color对象
	 */
	clone : function() {
		return new HGIS.Symbolizer.RGBColor(parseInt(this.r + ''),
				parseInt(this.g + ''), parseInt(this.b + ''), parseFloat(this.a
						+ ''));
	}
});



/**
 * Class: HGIS.Symbolizer.Symbol 
 * HGIS的符号类，是一个虚类
 */
HGIS.Symbolizer.Symbol = HGIS.Class({
	color : new HGIS.Symbolizer.RGBColor(0, 0, 0, 1),
	type : null,
	_stroke : null,
	_fill : null,
	initialize : function(options) {
		if (options && typeof (options) == "object") {
			HGIS.Util.extend(this, options);
		}
	},
	setColor : function(color) {
		this.color = color;
		return this;
	},
	toJson : function() {
		return {
			color : this.color.toJson()
		};
	}
});/**
 * Class: HGIS.Symbolizer.TextSymbol
 * HGIS.Symbolizer.TextSymbol 
 * 文本符号类
 * 继承于 HGIS.Symbolizer.Symbol
 */
HGIS.Symbolizer = HGIS.Symbolizer || {};
/**
 * Constructor: HGIS.Symbolizer.TextSymbol
 * 
 * Parameters:
 * text - {<HGIS.String>} 文本字符串
 * font - {<HGIS.Symbolizer.Font>} 字体对象
 * color - {<HGIS.Symbolizer.RGBColor>} 颜色对象
 */
HGIS.Symbolizer.TextSymbol = HGIS
		.Class(
				HGIS.Symbolizer.Symbol,
				{
					initialize : function(text, font, color) {
						HGIS.Symbolizer.Symbol.prototype.initialize.apply(this,
								[ text, font, color ]);
						if (text) {
							if (typeof (text) === "object") {
								HGIS.Util.extend(this, text);
								this.color = new HGIS.Symbolizer.RGBColor(
										this.color);
								this.type = "textsymbol";
								this.font = new HGIS.Symbolizer.Font(this.font);
							} else {
								this.text = text;
								if (font) {
									this.font = font;
								}
								if (color) {
									this.color = color;
								}
							}
						}
					},
					angle : 0,
					xoffset : 0,
					yoffset : 0,
					div : "",
					type : 'textsymbol',
					// 显示文字
					text : null,
					// 文字样式
					// font : null,
					fontSize : 13,
					fontFamily : '宋体',
					// 文字颜色
					color : null,
					// 文字所处位置
					placement : 'middle',// [middle,start,above,below,end]
					// 背景颜色
					backgroundColor : null,
					// 背景样式
					backgroundStyle : 'solid',
					// 边框颜色
					borderLineColor : null,
					// 边框样式
					borderLineStyle : 'solid',
					// 边框宽度
					borderLineWidth : 0,
					// 鼠标滑过样式
					cursor : '',

					selected : false,
					draw : function() {
						this.text = this.text || '';
						this.fontSize = parseInt(this.fontSize);
						this.textSize = HGIS.Util.getTextSize(
								this.text, this.fontSize, this.fontFamily);

						var maxWidth = 100;
						if (this.fontSize * 6 > maxWidth) {
							maxWidth = this.fontSize * 6;
						}

						var width = this.width
								|| ((this.textSize.width + 6 > maxWidth) ? maxWidth
										: (this.textSize.width + 6));
						var height = this.height || (this.textSize.height + 6);

						var left = -width / 2, top = -height / 2;
						if (this.xoffset) {
							left = left + this.xoffset;
						}
						if (this.yoffset) {
							top = top - this.yoffset;
						}

						var divs = [];
						divs.push('<div style="position:absolute;cursor:'
								+ this.cursor + ';');
						divs.push('height:' + height + 'px;width:' + width
								+ 'px;');
						divs.push('left:' + left + 'px;top:' + top
								+ 'px;" title="' + this.text + '">');
						var selectedPadding = 2;
						divs.push('<div style="position:absolute;height:100%;width:100%;');
						if (this.borderLineWidth && this.borderLineStyle
								&& this.borderLineColor) {
							// 边框
							divs.push('border:' + this.borderLineWidth + 'px '
									+ this.borderLineStyle + ' '
									+ this.borderLineColor.to0x() + ';top:-'
									+ this.borderLineWidth + 'px;left:-'
									+ this.borderLineWidth + 'px;');
							// 透明度
							divs.push('filter:alpha(opacity='
									+ (this.borderLineColor.a * 100)
									+ ');opacity:' + this.borderLineColor.a
									+ ';');
							selectedPadding += this.borderLineWidth;
						}
						divs.push('"></div>');
						if (this.selected) {
							divs.push('<div style="position:absolute;height:100%;width:100%;');
							divs.push('border: 2px solid #FF64FF;padding:'
									+ selectedPadding + 'px;');
							var topLeft = selectedPadding * 2 - 2;
							divs.push('top:-' + topLeft + 'px;left:-' + topLeft
									+ 'px;"></div>')
						}

						divs.push('<div style="position:absolute;height:100%;width:100%;');
						if (this.backgroundColor) {
							// 背景色
							divs.push('background-color:'
									+ this.backgroundColor.to0x() + ';');
							// 透明度
							divs.push('filter:alpha(opacity='
									+ (this.backgroundColor.a * 100)
									+ ');opacity:' + this.backgroundColor.a
									+ ';');
						}
						divs.push('"></div><div style="position:absolute;height:100%;width:100%;');
						divs.push('white-space:nowrap;text-overflow:ellipsis;overflow:hidden;');
						if (this.color) {
							// 字体颜色
							divs.push('color:' + this.color.to0x() + ';');
							// 透明度
							divs.push('filter:alpha(opacity='
									+ (this.color.a * 100) + ');opacity:'
									+ this.color.a + ';');
						}

						if (this.fontFamily) {
							// 字体
							divs.push('font-family:\'' + this.fontFamily
									+ '\';');
						}

						if (this.fontSize) {
							// 字体大小
							divs.push('font-size:' + this.fontSize + 'px;');
						}

						switch (this.placement) {
						case 'start':
							divs.push('text-align:left;line-height:' + height
									+ 'px;');
							break;
						case 'end':
							divs.push('text-align:right;line-height:' + height
									+ 'px;');
							break;
						case 'above':
							divs.push('text-align:center;');
							break;
						case 'below':
							divs.push('text-align:center;bottom:0;');
							break;
						default:
							divs.push('text-align:center;line-height:' + height
									+ 'px;');
							break;
						}

						divs.push('">' + this.text + '</div></div>');

						this.div = divs.join('');
						return this.div;
					},
					setFont : function(font) {
						this.font = font;
						return this;
					},
					setAngle : function(angle) {
						this.angle = angle;
						return this;
					},
					setOffset : function(x, y) {
						this.xoffset = x;
						this.yoffset = y;
						return this;
					},
					setText : function(text) {
						this.text = text;
						return this;
					},
					toJson : function() {
						return {
							type : "hikTS",
							backgroundColor : this.backgroundColor !== null ? this.backgroundColor
									.toJson()
									: null,
							borderLineColor : this.borderLineColor !== null ? this.borderLineColor
									.toJson()
									: null,
							angle : this.angle,
							xoffset : this.xoffset,
							yoffset : this.yoffset,
							text : this.text,
							placement : this.placement == 'middle'
									|| this.placement == 'start'
									|| this.placement == 'above'
									|| this.placement == 'below'
									|| this.placement == 'end' ? this.placement
									: 'middle',
							font : this.font !== null ? this.font.toJson()
									: null,
							color : this.color !== null ? this.color.toJson()
									: null
						};
					}
				});
HGIS.Util.extend(HGIS.Symbolizer.TextSymbol, {
	ALIGN_START : "start",
	ALIGN_MIDDLE : "middle",
	ALIGN_END : "end",
	DECORATION_NONE : "none",
	DECORATION_UNDERLINE : "underline",
	DECORATION_OVERLINE : "overline",
	DECORATION_LINETHROUGH : "line-through"
});

/**
 * Function: HGIS.Util.getTextSize
 * 
 * Parameters:
 * text - {<HGIS.String>} 文本字符串
 * fontSize {HGIS.Integer}- 字体大小，单位为px。
 * fontFamily {} 字体名称
 */
HGIS.Util.getTextSize = function(text, fontSize, fontFamily) {
	var textWidthSpan = document.getElementById('text_width_span');
	if (!textWidthSpan) {
		textWidthSpan = document.createElement("span");
		document.body.appendChild(textWidthSpan);
		textWidthSpan.setAttribute('id', 'text_width_span');
		textWidthSpan.style.position = 'absolute';
		textWidthSpan.style.top = '-10000px';
		textWidthSpan.style.left = '-10000px';
	}
	textWidthSpan.style.fontSize = '13px';
	textWidthSpan.style.fontFamily = '\'宋体\'';
	if (fontSize) {
		textWidthSpan.style.fontSize = fontSize + 'px';
	}
	if (fontFamily) {
		textWidthSpan.style.fontFamily = '\'' + fontFamily + '\'';
	}
	textWidthSpan.innerText = text;
	return {
		width : textWidthSpan.offsetWidth,
		height : textWidthSpan.offsetHeight
	};
};
/**
 * Class: HGIS.Symbolizer.TextTag
 * HGIS.Symbolizer.TextTag 
 * 文本标签类
 */
HGIS.Symbolizer = HGIS.Symbolizer || {};
/**
 * Constructor: HGIS.Symbolizer.TextTag
 * 
 * Parameters:
 * map - {<HGIS.MapEx>} 地图对象实例
 */
HGIS.Symbolizer.TextTag = function(map) {
	var thisObj = this;
	thisObj.poueSuffix = "hgis_textTag";// popue唯一标识的后缀,特此声明
	thisObj.curtag = null;
	thisObj.style={
			fontColor : "#003366",
			textAlign : "center",
			fontFamily: "楷体",
			textDecoration:"none",
			textDecoration: "normal",
			fontStyle: "italic"
		};
	
	/**
	 * APIMethod: create
	 * 创建文本标签
	 * 
	 * Parameters:
	 * id - {String } 文本标签唯一标识
	 * lonlat - {<HGIS.LonLat>} 标签所在位置（左上角）,经纬度
	 * style - 用来修饰标签字体的键值对
	 * text - 标签内容
	 * readOnly - rue表示只读，false表示可读写，默认为false。
	 */
	this.create = function(id, lonlat, text, readOnly, style) {
		if(!style){
			style=thisObj.style;
		}
		var popueId = id + thisObj.poueSuffix;
		// 如果之前这个ID的标签存在，那么先删除掉。再继续创建动作
		if (this.getTagById(id)) {
			this.remove(this.getTagById(id));
		}
		// 如果没有定义大小标签大小，那么标签将自动设设置大小
		var div = document.createElement("div");
		var textarea = document.createElement("textarea");
		textarea.id = popueId + "_text";
		// 浏览器兼容性判断
		var browersType = HGIS.Utils.getExploreType();//Util.getExploreType();// 浏览器类型
		if (browersType == "MSIE") {
			textarea.value = text;
		} else {
			textarea.textContent = text;
		}
		textarea.readOnly = readOnly ? readOnly : false;// 是否只读

		// 文本框默认宽度(列数)计算
		var _fontSize = style.fontSize ? style.fontSize.replace("px","")*1 : 10;// 字体大小
		textarea.cols = Math.min(text.length * 1, 40)+2;
		// 文本框默认高度(行数)计算
		textarea.rows= Math.floor(text.length / 40)+2;// 计算有几行
		// 样式设置
		textarea.style.textAlign = style.textAlign ? style.textAlign:thisObj.style.textAlign;
		// 如果已给出了宽高，则按照给出的宽高来
		if (style.height) {
			textarea.style.height = style.height;
		}
		if (style.width) {
			textarea.style.width = style.width
		}
		textarea.style.color = style.fontColor ? style.fontColor:thisObj.style.fontColor;
		textarea.style.fontSize = _fontSize+"px";
		textarea.style.fontFamily = style.fontFamily ? style.fontFamily:thisObj.style.fontFamily;
		textarea.style.textDecoration = style.textDecoration ? style.textDecoration:thisObj.style.textDecoration;
		textarea.style.fontWeight = style.fontWeight ? style.fontWeight:thisObj.style.textDecoration;
		textarea.style.fontStyle = style.fontStyle ? style.fontStyle:thisObj.style.fontStyle;
		div.appendChild(textarea);
		// 以弹框的形式显示标签
		var tag = new HGIS.Popup(popueId, lonlat, null, div.innerHTML,null, false, null);
		tag.autoSize = true;
		tag.padding = 1;
		tag.style = style ? style : null;
		tag.tagId = id;
		thisObj.curtag = tag;
		map.addPopup(tag);
		return tag;
	};

	 /** APIMethod: addTagEvent
	  * 
	  */
	this.getSelectTag = function() {
		return thisObj.curtag;
	};
	/**
	 * APIMethod: addTagEvent
	 * 为指定标签注册事件
	 * 
	 * Parameters:
	 * eventType - 事件类型
	 * tag - 标签对象
	 * handler - 处理方法
	 * 
	 */
	thisObj.addTagEvent = function(eventType, tag, handler) {
		tag.events.register(eventType, null, function() {
			handler(this);
		});
	};
	/**
	 * APIMethod: removeTagListener
	 * 删除指定标签、指定事件
	 * 
	 * Parameters:
	 * eventType - 事件类型
	 * tag -  标签对象
	 */
	thisObj.removeTagListener = function(eventType, tag) {
		tag.events.remove(eventType);

	};
	/**
	 * APIMethod: removeAllTagsListener
	 * 删除所有标签的指定事件
	 * 
	 * Parameters:
	 * eventType - 事件类型
	 */
	thisObj.removeAllTagsListener = function(eventType) {
		var arr = thisObj.getAllTags();
		for ( var i = 0; i < arr.length; i = i + 1) {
			arr[i].events.remove(eventType);
		}
	};
	/**
	 * APIMethod: getTagById
	 * 获取标签
	 * 
	 * Parameters:
	 * id - 标签的唯一标识
	 */
	this.getTagById = function(tagId) {
		var tag = null;
		var popueId = tagId + thisObj.poueSuffix;
		for ( var i = 0; i < map.popups.length; i = i + 1) {
			if (map.popups[i].id == popueId) {
				tag = map.popups[i];
				break;
			}
		}
		return tag;
	};

	/**
	 * APIMethod: remove
	 * 删除标签
	 * 
	 * Parameters:
	 * tag - 标签对象
	 */
	this.remove = function(tag) {
		if (tag == thisObj.curtag) {
			tag.destroy();
			thisObj.curtag = null;
		} else if (tag) {
			tag.destroy();
		}
	};

	/**
	 * APIMethod: getTagVal
	 * 获取标签内容
	 * 
	 * Parameters:
	 * tag - 标签对象
	 * 
	 * Returns:
	 * {String} 标签中的文本对象
	 */
	this.getTagVal = function(tag) {
		var textareaId = tag.id + "_text";
		var dom = document.getElementById(textareaId);
		var val = dom.value.replace(/[ ]/g, "");
		return val;
	};

	/**
	 * APIMethod: changeStyleById
	 * 改变标签样式
	 * 
	 * Parameters:
	 * tagid - 标签ID
	 * style - 新的标签样式
	 */
	this.changeStyleById = function(tagid, style) {
		var popue_textareaid = tagid + thisObj.poueSuffix + "_text";
		var textarea = document.getElementById(popue_textareaid);
		if (style && textarea) {
			textarea.style.textAlign = style.textAlign ? style.textAlign
					: "center";
			textarea.style.height = style.height ? style.height : "30px";
			textarea.style.width = style.width ? style.width : "80px";
			textarea.style.color = style.fontColor ? style.fontColor
					: "#003366";
			textarea.style.fontSize = style.fontSize ? style.fontSize : "10px";
			textarea.style.fontFamily = style.fontFamily ? style.fontFamily
					: "楷体";
			textarea.style.textDecoration = style.textDecoration ? style.textDecoration
					: "none ";
			textarea.style.fontWeight = style.fontWeight ? style.fontWeight
					: "normal";
			textarea.style.fontStyle = style.fontStyle ? style.fontStyle
					: "italic";
		}
		var tag = this.getTagById(tagid);
		tag.style = style;

	};
	/**
	 * APIMethod: removeAll
	 * 删除所有标签。两个for方法自有理由，不要随意更改
	 * 
	 */
	this.removeAll = function() {
		// 先取出所有的标签类型的 popue
		var arr = new Array();
		for ( var i = 0; i < map.popups.length; i = i + 1) {
			var idstr = new String(map.popups[i].id);
			var idindex = idstr.indexOf(thisObj.poueSuffix);
			if (idindex != -1) {
				var popid = idstr.substr(0, idindex);
				arr.push(popid);
			}
		}
		// 删除所有标签类型的POPUE
		for ( var j = 0; j < arr.length; j = j + 1) {
			var tag = this.getTagById(arr[j]);
			this.remove(tag);
		}

		thisObj.curtag = null;
	};

	/**
	 * APIMethod: setReadOnly
	 * 设置文本标签的只读属性。
	 * 
	 * Parameters:
	 * enable - 是否只读，true表示只读，false表示可读写
	 * tag - 一个标签。如果参数不传则系统默认对当前所有标签有效，否则只对传入的标签有效
	 */
	this.setReadOnly = function(enable, tag) {
		if (!tag) {
			for ( var i = 0; i < map.popups.length; i = i + 1) {
				var idstr = new String(map.popups[i].id);
				var textareaid = idstr + "_text";
				var textarea = document.getElementById(textareaid);
				textarea.readOnly = enable;// 是否只读
			}
		} else {
			var idstr = new String(tag.id);
			var textareaid = idstr + "_text";
			var textarea = document.getElementById(textareaid);
			textarea.readOnly = enable;// 是否只读

		}
	};

	/**
	 * APIMethod: getStyleByTag
	 * 获取指定tag样式
	 * 
	 * Parameters:
	 * tag-
	 */
	this.getStyleByTag = function(tag) {
		return tag.style;
	};
	/**
	 * APIMethod: getAllTags
	 * 获取所有地图文本标签
	 */
	this.getAllTags = function() {
		// 先取出所有的标签类型的 popue
		var arr = new Array();
		for ( var i = 0; i < map.popups.length; i = i + 1) {
			var idstr = new String(map.popups[i].id);
			var idindex = idstr.indexOf(thisObj.poueSuffix);
			if (idindex != -1) {
				var tag = map.popups[i];
				arr.push(tag);
			}
		}
		return arr;
	};
};
/**
 * Property: geomTopologyURL
 * {Object} - 几何体空间运算服务地址,json对象，拥有的列表如下.
 * 
 * 服务列表：
 * * geomTopologyURL.intersect 获取两个几合体的交集
 * * geomTopologyURL.union  几何体取并集
 * * geomTopologyURL.difference 取差集
 * * geomTopologyURL.convexHull 求凸包
 * * geomTopologyURL.buffer 求缓冲区
 * * geomTopologyURL.isContain 包含
 * * geomTopologyURL.getArea 获取多边形面积
 * * geomTopologyURL.getReverse 计算所有坐标序列的相反顺序，构建一个新的几何体
 */
var hostUrl=APIAdress.replace("hgis-web","hgis-services");
	hostUrl=hostUrl.replace("hgis-services/hgisFrontLib","hgis-services");	//方便在hgis-services测试，修改请求的相对路径
var geomTopologyURL = {
	intersect : hostUrl + "rest/services/geomRelation/intersect",// 获取两个几合体的交集
	union : hostUrl + "rest/services/geomRelation/union",// 几何体并集
	difference : hostUrl + "rest/services/geomRelation/difference",// 取差集
	convexHull : hostUrl + "rest/services/geomRelation/convexHull",// 求凸包
	buffer : hostUrl + "rest/services/geomRelation/buffer",// 求缓冲区
	isContain : hostUrl + "rest/services/geomRelation/isContain",// 包含测试
	reverseGeometry : hostUrl + "rest/services/geomRelation/reverseGeometry",// 包含测试
	getArea : hostUrl + "rest/services/geomRelation/getArea"// 获取多边形面积
};
/**
 * Property: geoSearchUrl
 * {<Object>} - 地理编码URL,json对象.
 * 
 * 服务列表:
 * * geoCoder 地图正向查询
 * * positiveSecondQuery 地图正向查询，二次查询
 * * untiGeoCoder 地图反查
 */
var geoSearchUrl = {
	fullTextSearch : hostUrl + "rest/services/geoSearch/fullTextSearch",
	queryFeatureById : hostUrl + "rest/services/fullMapSearch/queryFeatureById",
	queryCrossRoads : hostUrl + "rest/services/crossRoads/queryCrossRoads" //路标路口查询地址
};


/**
 * Property: mapServerConfigURL
 * 地图服务端配置.
 */
var mapServerConfigURL = {
	getMapParams : hostUrl+"rest/services/sysConf/getMapParams",// 当前正在使用的地图类型配置
	saveMapParams: hostUrl+"rest/services/sysConf/saveMapParams",//保存地图配置参数
	getAgsParams: hostUrl+"rest/services/sysConf/getAgsParams",//通过arcgis在线地址获取地图参数
	getOffAgsParams: hostUrl+"rest/services/sysConf/getOffAgsParams",//通过arcgis离线切片包获取地图参数
	getDefaultMapParams: hostUrl+"rest/services/sysConf/getDefaultMapParams",//获取map文件夹下第一个地图类型的地图参数
	switchMapParams: hostUrl+"rest/services/sysConf/switchMapParams",//根据传入的地图类型，获取相关地图参数
	initEngine: hostUrl+"rest/services/sysConf/initEngine",//初始化HGIS引擎的配置参数，更新参数
	getFactorConfig:hostUrl+"rest/services/posCorrect/getFactorConfig",
	ifExitVtStyleByUrl:hostUrl +"rest/services/VectorTileConf/ifExitVtStyleByUrl",
	getVTConfigDetailById:hostUrl +"rest/services/VectorTileConf/getVTConfigDetailById"
};

/**
 * Property: routeNetAnlyseURL
 * {Object} - 网络分析相关地址*地址弃用*.
 * 
 * 服务列表：
 * * shortestPath  最短路径查询
 * * queryNearlyFeatures 路径附近地物查询
 */
var routeNetAnlyseURL = {
	shortestPath : hostUrl + "rest/services/RoadPathAnalysis/shortestPath",//迪杰斯特拉分析路径
	AStarShortestPathByNodeId : hostUrl + "rest/services/AStarAnalysis/AStarAnalysisByNodeId",
	AStarShortestPathByXY : hostUrl + "rest/services/AStarAnalysis/AStarAnalysisByXY",
	nearlyRoadNode : hostUrl + "rest/services/RoadPathAnalysis/nearlyRoadNode"
};

/**
 * Property: roadSignsUrl
 *  路口路标查询
 * 
 */
var roadSignsUrl=hostUrl + "rest/services/roadSigns/queryRoadSigns";//路标路口查询地址

/**
 * Property: safeProxyURL
 * 安全代理的url地址。
 */
var safeProxyURL = "/ngx/proxy?i=";


/**
 * Property: tileCacheProxyURL(暂未启用)
 * 缓存地图切片代理.通过这个代理，保证地图切片从内存中读取，一来省略了切片转换为字节流的时间，二是内存查找速度相对较高。
 */
var tileCacheProxyURL = hostUrl + "/tileCache/getTile";


/**
 * Property: msTiledLayerUrl
 * 马氏切片相关地址.(暂未启用)
 */
//var msTiledLayerUrl = hostUrl + "rest/services/mstile.action";


/**
 * 独立组件包测试地址，不对外开放
 */
var IndividualTestURL={
		cluster1:hostUrl + "rest/services/cluster/testCluster1",
		cluster2:hostUrl + "rest/services/cluster/testCluster2",
		heatLayer: hostUrl + "/individual/heatLayer"
};/**
 * 新的运管体系环境下对于前端跨域问题的解决； 以构筑JSONP的形式模拟js 引用请求
 * @param params
 */
function HgisAjax(params) {   
  params = params || {};   
  params.data = params.data || {};   
  var json = params.jsonp ? jsonp(params) : json(params);      
  /**
   * 构筑jsonp函数
   */
  function jsonp(params) {   
	  //创建script标签并加入到页面中   
	    var callbackName = params.jsonp;   
	    var head = document.getElementsByTagName('head')[0];   
	    // 设置传递给后台的回调参数名   
	    params.data['callback'] = callbackName;   
	    var data = formatParams(params.data);   
	    var script = document.createElement('script');
	    script.type = "text/javascript";
	    head.appendChild(script);    
	    //创建jsonp回调函数   
	    window[callbackName] = function(json) { 
	    /*  head.removeChild(script); */
	      clearTimeout(script.timer);   
	      window[callbackName] = null;   
	      params.success && params.success(json);   
	    };    
	    //发送请求   
	    script.src = params.url + '?' + data;    
	    //为了得知此次请求是否成功，设置超时处理   
	   /* var time = 100 ;  
	    script.timer = setTimeout(function() {   
	       window[callbackName] = null;   
	       head.removeChild(script);   
	       params.error && params.error({   
	         message: '超时'   
	       });   
	     }, time);  */    
   
  };    

  //格式化参数   
  function formatParams(data) {   
		var arr = [];   
		for(var name in data) {   
		  arr.push(encodeURIComponent(name) + '=' + encodeURIComponent(data[name]));   
    };   
    // 添加一个随机数，防止缓存   
    arr.push('v=' + random());   
    return arr.join('&');   

  }   

  // 获取随机数   

  function random() {   
    return Math.floor(Math.random() * 10000 + 500);   
  }
}
/*
 * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
(function(global) {
    'use strict';
    // existing version for noConflict()
    var _Base64 = global.HGISBase64;
    var version = "2.1.9";
    // if node.js, we use Buffer
    var buffer;
    if (typeof module !== 'undefined' && module.exports) {
        try {
            buffer = require('buffer').Buffer;
        } catch (err) {}
    }
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                   + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa ? function(b) {
        return global.btoa(b);
    } : function(b) {
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = buffer ? function (u) {
        return (u.constructor === buffer.constructor ? u : new buffer(u))
        .toString('base64')
    }
    : function (u) { return btoa(utob(u)) }
    ;
    var encode = function(u, urisafe) {
        return !urisafe
            ? _encode(String(u))
            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
                return m0 == '+' ? '-' : '_';
            }).replace(/=/g, '');
    };
    var encodeURI = function(u) { return encode(u, true) };
    // decoder stuff
    var re_btou = new RegExp([
        '[\xC0-\xDF][\x80-\xBF]',
        '[\xE0-\xEF][\x80-\xBF]{2}',
        '[\xF0-\xF7][\x80-\xBF]{3}'
    ].join('|'), 'g');
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var atob = global.atob ? function(a) {
        return global.atob(a);
    } : function(a){
        return a.replace(/[\s\S]{1,4}/g, cb_decode);
    };
    var _decode = buffer ? function(a) {
        return (a.constructor === buffer.constructor
                ? a : new buffer(a, 'base64')).toString();
    }
    : function(a) { return btou(atob(a)) };
    var decode = function(a){
        return _decode(
            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
                .replace(/[^A-Za-z0-9\+\/]/g, '')
        );
    };
    var noConflict = function() {
        var HGISBase64 = global.HGISBase64;
        global.HGISBase64 = _Base64;
        return HGISBase64;
    };
    // export Base64
    global.HGISBase64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.HGISBase64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    // that's it!
    if (global['Meteor']) {
       HGISBase64 = global.HGISBase64; // for normal export in Meteor.js
    }
})(this);HGIS.utils = HGIS.utils || {};
HGIS.utils.FeatureUtil = HGIS.utils.FeatureUtil|| {};
/**
 * Class: HGIS.utils.FeatureUtil 
 * 要素拾取类
 * 
 */
HGIS.utils.FeatureUtil.data = [  
   {
	    "layerType": "line",
	    "type": "DISTRICT_LN",
	    "label": "行政区边界",
	    "featureTypes": [
	      {
	        "label": "市界",
	        "name": "CITY_LN",
	        "minLevel": 9,
	        "maxLevel": 19
	      },
	      {
	        "label": "县界",
	        "name": "COUNTY_LN",
	        "minLevel": 10,
	        "maxLevel": 19
	      },
	      {
	        "label": "镇界",
	        "name": "TOWN_LN",
	        "minLevel": 12,
	        "maxLevel": 19
	      }
	    ]
	  },
	  {
	    "layerType": "polygon",
	    "type": "WATER",
	    "label": "水系",
	    "featureTypes": [
	      {
	        "label": "水系",
	        "name": "WATER",
	        "minLevel": 0,
	        "maxLevel": 20,
	        "featureList": [
	          "HYDSIDE_AREA_PG",
	          "LAKES_PG",
	          "HYDSIDE_A_PG",
	          "HYDSIDE_B_PG",
	          "HYDSIDE_C_PG",
	          "HYDSIDE_D_PG",
	          "HYDSIDE_E_PG"
	        ]
	      }
	    ]
	  },
	  {
	    "layerType": "polygon",
	    "type": "VEGETATION",
	    "label": "绿地",
	    "featureTypes": [
	      {
	        "label": "绿地",
	        "name": "VEGETATION",
	        "minLevel": 7,
	        "maxLevel": 20,
	        "featureList": [
	          "VEGETATION_A_PG",
	          "VEGETATION_B_PG"
	        ]
	      }
	    ]
	  },
	  {
	    "layerType": "polygon",
	    "type": "AREA",
	    "label": "兴趣面",
	    "featureTypes": [
	      {
	        "label": "小区",
	        "name": "RESAREA_PG",
	        "minLevel": 15,
	        "maxLevel": 19
	      },
	      {
	        "label": "景区",
	        "name": "SIGHT_PG",
	        "minLevel": 14,
	        "maxLevel": 19
	      },
	      {
	        "label": "医院面",
	        "name": "HOSPITAL_PG",
	        "minLevel": 15,
	        "maxLevel": 19
	      },
	      {
	        "label": "地铁面",
	        "name": "METROSTATION_PG",
	        "minLevel": 15,
	        "maxLevel": 19
	      },
	      {
	        "label": "火车站面",
	        "name": "TRAFFIC_HUB_PG",
	        "minLevel": 15,
	        "maxLevel": 19
	      },
	      {
	        "label": "大学",
	        "name": "SCHOOL_UNIVERSITY_PG",
	        "minLevel": 15,
	        "maxLevel": 19
	      }
	    ]
	  },
	  {
	    "layerType": "line",
	    "type": "ROAD",
	    "label": "交通要素",
	    "featureTypes": [
	      {
	        "label": "其他道路",
	        "name": "QITADAOLU",
	        "minLevel": 16,
	        "maxLevel": 20
	      },
	      {
	        "label": "乡镇村道",
	        "name": "XIANGZHENCUNDAO",
	        "minLevel": 11,
	        "maxLevel": 20
	      },
	      {
	        "label": "县道",
	        "name": "XIANDAO",
	        "minLevel": 10,
	        "maxLevel": 20
	      },
	      {
	        "label": "地铁",
	        "name": "SUBWAY_LN",
	        "minLevel": 13,
	        "maxLevel": 20
	      },
	      {
	        "label": "铁路",
	        "name": "RAILWAY_LN",
	        "minLevel": 9,
	        "maxLevel": 20,
	        "featureList": [
	          "RAILWAY_A_LN",
	          "RAILWAY_B_LN"
	        ]
	      },
	      {
	        "label": "省道",
	        "name": "SHENGDAO",
	        "minLevel": 11,
	        "maxLevel": 20
	      },
	      {
	        "label": "国道",
	        "name": "GUODAO",
	        "minLevel": 13,
	        "maxLevel": 20
	      },
	      {
	        "label": "高速",
	        "name": "GAOSU",
	        "minLevel": 5,
	        "maxLevel": 20
	      }
	    ]
	  },
	  {
	    "layerType": "point",
	    "type": "KEYPOI",
	    "label": "主要兴趣点",
	    "featureTypes": [
	      {
	        "label": "工业园",
	        "name": "INDUSTRIAL_PT",
	        "minLevel": 19,
	        "maxLevel": 20
	      },
	      {
	        "label": "科研机构",
	        "name": "SECURITIES_PT",
	        "minLevel": 19,
	        "maxLevel": 20
	      },
	      {
	        "label": "码头",
	        "name": "WHARF_PT",
	        "minLevel": 14,
	        "maxLevel": 20,
	        "featureList": [
	          "WHARF_A_PT",
	          "WHARF_B_PT",
	          "WHARF_C_PT"
	        ]
	      },
	      {
	        "label": "农贸市场",
	        "name": "FARMERS_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "汽车用品",
	        "name": "CAR_MAINTENANCE_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "二手车交易所",
	        "name": "CAR_SECONDE_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "高速出入口",
	        "name": "ENTRANCE_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "汽车服务",
	        "name": "CARSERVICE_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "超市",
	        "name": "SUPERMARKET_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "公园",
	        "name": "PARK_PT",
	        "minLevel": 11,
	        "maxLevel": 20,
	        "featureList": [
	          "PARK_A_PT",
	          "PARK_B_PT",
	          "PARK_C_PT"
	        ]
	      },
	      {
	        "label": "博物馆",
	        "name": "MUSEUM_A_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "山",
	        "name": "MOUNTAIN_PT",
	        "minLevel": 13,
	        "maxLevel": 20
	      },
	      {
	        "label": "B类景点",
	        "name": "SIGHT_B_PT",
	        "minLevel": 14,
	        "maxLevel": 20
	      },
	      {
	        "label": "A类景点",
	        "name": "SIGHT_A_PT",
	        "minLevel": 12,
	        "maxLevel": 20
	      },
	      {
	        "label": "五星级宾馆",
	        "name": "HOTEL_A_PT",
	        "minLevel": 13,
	        "maxLevel": 20
	      },
	      {
	        "label": "星级宾馆",
	        "name": "HOTEL_B_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "旅馆",
	        "name": "HOTEL_C_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },      
	      {
	        "label": "银行",
	        "name": "BANK_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "二类医院",
	        "name": "HOSPITAL_B_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "一类医院",
	        "name": "HOSPITAL_A_PT",
	        "minLevel": 13,
	        "maxLevel": 20
	      },
	      {
	        "label": "大学",
	        "name": "SCHOOL_UNIVERSITY_A_PT",
	        "minLevel": 11,
	        "maxLevel": 20
	      },
	      {
	        "label": "会展中心",
	        "name": "EXHCENTER_PT",
	        "minLevel": 14,
	        "maxLevel": 20
	      },
	      {
	        "label": "加油站",
	        "name": "OIL_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "客运汽车站",
	        "name": "CARSTATION_PT",
	        "minLevel": 12,
	        "maxLevel": 20
	      },
	      {
	        "label": "商业点",
	        "name": "BUSINESS_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "收费站",
	        "name": "TOLL_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "植物园",
	        "name": "GARDEN_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "图书馆",
	        "name": "LIBRARY_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "邮局",
	        "name": "POST_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "商业中心",
	        "name": "STORES_A_PT",
	        "minLevel": 13,
	        "maxLevel": 20
	      },
	      {
	        "label": "广场",
	        "name": "SQUARE_PT",
	        "minLevel": 14,
	        "maxLevel": 20
	      },
	      {
	        "label": "桥",
	        "name": "BRIDGE_B_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "立交桥",
	        "name": "BRIDGE_A_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "建筑物",
	        "name": "BUILDING_PT",
	        "minLevel": 13,
	        "maxLevel": 20
	      },
	      {
	        "label": "高速收费站",
	        "name": "HIGH_SPEED_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "警察局",
	        "name": "POLICE_PT",
	        "minLevel": 14,
	        "maxLevel": 20
	      },
	      {
	        "label": "火车站",
	        "name": "TRASTATION_PT",
	        "minLevel": 11,
	        "maxLevel": 20,
	        "featureList": [
	          "TRASTATION_A_PT",
	          "TRASTATION_B_PT"
	        ]
	      },
	      {
	        "label": "飞机场",
	        "name": "AIRPORT_PT",
	        "minLevel": 10,
	        "maxLevel": 20
	      },
	      {
	        "label": "镇政府",
	        "name": "TOWN_PT",
	        "minLevel": 10,
	        "maxLevel": 20,
	        "featureList": [
	          "TOWN_A_PT",
	          "TOWN_B_PT",
	          "TOWN_C_PT"
	        ]
	      },
	      {
	        "label": "市政府",
	        "name": "DISTRICT_A_PT",
	        "minLevel": 9,
	        "maxLevel": 20
	      }
	    ]
	  },
	  {
	    "layerType": "point",
	    "type": "OTHERPOI",
	    "label": "次要兴趣点",
	    "featureTypes": [
	      {
	        "label": "证券公司",
	        "name": "SECURITIES_PT",
	        "minLevel": 19,
	        "maxLevel": 20
	      },
	      {
	        "label": "其他",
	        "name": "OTHER_PT",
	        "minLevel": 19,
	        "maxLevel": 20
	      },
	      {
	        "label": "茶馆",
	        "name": "TEA_PT",
	        "minLevel": 19,
	        "maxLevel": 20
	      },
	      {
	        "label": "家居建材",
	        "name": "HOME_IMPROVEMENT_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "工艺品店",
	        "name": "HANDICRAFT_PT",
	        "minLevel": 19,
	        "maxLevel": 20
	      },
	      {
	        "label": "保险",
	        "name": "INSURANCE_PT",
	        "minLevel": 19,
	        "maxLevel": 20
	      },
	      {
	        "label": "高速服务区",
	        "name": "MOTORWAY_SERVICE_PT",
	        "minLevel": 19,
	        "maxLevel": 20
	      },
	      {
	        "label": "物流基地",
	        "name": "LOGISTICS_PT",
	        "minLevel": 17,
	        "maxLevel": 20,
	        "featureList": [
	          "LOGISTICS_A_PT",
	          "LOGISTICS_B_PT",
	          "LOGISTICS_C_PT"
	        ]
	      },
	      {
	        "label": "自行车店",
	        "name": "BICYCLE_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "体育用品店",
	        "name": "SPORTS_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "电视台",
	        "name": "TV_STATION_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "旅行社",
	        "name": "TRAVEL_PT",
	        "minLevel": 19,
	        "maxLevel": 20
	      },
	      {
	        "label": "培训中心",
	        "name": "TRAINING_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "票务中心",
	        "name": "TICKET_PT",
	        "minLevel": 19,
	        "maxLevel": 20
	      },
	      {
	        "label": "音像店",
	        "name": "VIDEO_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "机动车检测场",
	        "name": "VEHICLE_DETECTION_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "文化用品店",
	        "name": "CULTURAL_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "化妆品专卖店",
	        "name": "COSMETICS_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "花卉店",
	        "name": "FLOWERS_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "服装店",
	        "name": "CLOTHING_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "电脑店",
	        "name": "COMPUTER_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "彩票销售站",
	        "name": "LOTTERYSTATION_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "协会",
	        "name": "ASSOCIATION_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "母婴、儿童用品店",
	        "name": "BABY_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "古玩字画店",
	        "name": "ANTIQUE_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "理发店",
	        "name": "BARBER_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "公司",
	        "name": "COMPANY_PT",
	        "minLevel": 16,
	        "maxLevel": 20
	      },
	      {
	        "label": "厕所",
	        "name": "WC_PT",
	        "minLevel": 18,
	        "maxLevel": 20
	      },
	      {
	        "label": "停车场",
	        "name": "CARPARK_PT",
	        "minLevel": 18,
	        "maxLevel": 20
	      },
	      {
	        "label": "便利店",
	        "name": "CONVENIENCE_PT",
	        "minLevel": 18,
	        "maxLevel": 20
	      },
	      {
	        "label": "ATM",
	        "name": "ATM_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "社区医疗",
	        "name": "COMMUNITY_HOSPITAL_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "牙科",
	        "name": "DENTAL_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "防疫站",
	        "name": "EPIDEMIC_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "药店",
	        "name": "PILL_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "红绿灯",
	        "name": "LIGHT_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "宠物医院",
	        "name": "PET_HOSPITAL_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "宠物超市",
	        "name": "PET_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "报社",
	        "name": "PAPER_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "租车",
	        "name": "CAR_RENTAL_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "科研机构",
	        "name": "SCIENTIFIC_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "小商品城",
	        "name": "COMMODITY_PT",
	        "minLevel": 17,
	        "maxLevel": 20
	      },
	      {
	        "label": "KTV",
	        "name": "KTV_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "快餐店",
	        "name": "FOOD_FAST_PT",
	        "minLevel": 18,
	        "maxLevel": 20
	      },
	      {
	        "label": "咖啡馆",
	        "name": "COFFEE_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "西餐馆",
	        "name": "FOOD_WEST_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "酒吧",
	        "name": "FOOD_BAR_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "中餐馆",
	        "name": "FOOD_CHINA_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "电信营业厅",
	        "name": "MOBILE_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "村委会",
	        "name": "VILLAGE_COMMITTEE_PT",
	        "minLevel": 19,
	        "maxLevel": 20
	      },
	      {
	        "label": "政府机关",
	        "name": "COUNTY_PT",
	        "minLevel": 14,
	        "maxLevel": 20
	      },
	      {
	        "label": "动物园",
	        "name": "ZOO_PT",
	        "minLevel": 12,
	        "maxLevel": 20
	      },
	      {
	        "label": "博物馆",
	        "name": "MUSEUM_B_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "星级博物馆",
	        "name": "MUSEUM_A_PT",
	        "minLevel": 15,
	        "maxLevel": 20
	      },
	      {
	        "label": "电器商场",
	        "name": "MALL_PT",
	        "minLevel": 15,
	        "maxLevel": 20,
	        "featureList": [
	          "Mall_A_pt",
	          "Mall_B_pt"
	        ]
	      }      
	    ]
	  }
 ]
/**
 * APIProperty: options
 * 设置要素工具类的参数  layer 拾取的对象突出  
 * 
 * 示例:
 * (code)
 * HGIS.utils.FeatureUtil.options={"layer":layer}
 * (end)
 * 
 * 参数: 
 * featureType -<String> 要素类型
 */
HGIS.utils.FeatureUtil.options={};
HGIS.utils.FeatureUtil.Types = null;
HGIS.utils.FeatureUtil.getFeatureType = function(subType) {
	// 如果类型<1则进行处理
	if (HGIS.utils.FeatureUtil.Types==null) {
		HGIS.utils.FeatureUtil.Types={};
		var len = HGIS.utils.FeatureUtil.data.length;
		for (var i = 0; i < len; i++) {
			var subLen = HGIS.utils.FeatureUtil.data[i].featureTypes.length;
			for (var j = 0; j < subLen; j++) {
				var value = HGIS.utils.FeatureUtil.data[i].featureTypes[j];
				var key="";
				//如果有子集则遍历子集
				if(HGIS.utils.FeatureUtil.data[i].featureTypes[j].hasOwnProperty("featureList")){
					var feaLen=HGIS.utils.FeatureUtil.data[i].featureTypes[j]["featureList"].length;
					for(var k=0;k<feaLen;k++){
						key=HGIS.utils.FeatureUtil.data[i].featureTypes[j]["featureList"][k];
						HGIS.utils.FeatureUtil.Types[key]=value;
					}
				}else{
					key = HGIS.utils.FeatureUtil.data[i].featureTypes[j]["name"];
					HGIS.utils.FeatureUtil.Types[key]=value;
				}
				
			}
		}
	};
	return HGIS.utils.FeatureUtil.Types[subType];
};
/**
 * APIMethod: getsubTypes
 * 根据要素类型featureType得到对应的subType数组
 * 
 * 参数: 
 * featureType -<String> 要素类型
 */
HGIS.utils.FeatureUtil.getsubTypes = function(featureType) { 
	var subTypes = [];
	var len = HGIS.utils.FeatureUtil.data.length;
	for (var i = 0; i < len; i++) {
		if(HGIS.utils.FeatureUtil.data[i].type == featureType){
			var subLen = HGIS.utils.FeatureUtil.data[i].featureTypes.length;
			for (var j = 0; j < subLen; j++) {
				var value = HGIS.utils.FeatureUtil.data[i].featureTypes[j];
				var key = "";
				if (HGIS.utils.FeatureUtil.data[i].featureTypes[j].hasOwnProperty("featureList")) {
					subTypes = HGIS.utils.FeatureUtil.data[i].featureTypes[j]["featureList"];
					return subTypes;
				}
			}
		}else {
			var subLen = HGIS.utils.FeatureUtil.data[i].featureTypes.length;
			for (var j = 0; j < subLen; j++) {
				var value = HGIS.utils.FeatureUtil.data[i].featureTypes[j];
				var key = "";
				if(value.name == featureType && value.hasOwnProperty("featureList")){
					subTypes = HGIS.utils.FeatureUtil.data[i].featureTypes[j]["featureList"];
					return subTypes;
				}		 
			}			
		}
	}
	return subTypes;
};

HGIS.utils.FeatureUtil.getLayerTypeByFeatureType = function(featureType) {
	 
	var layerType = "polygon";	 
	var len = HGIS.utils.FeatureUtil.data.length;
	for (var i = 0; i < len; i++) {
		var subLen = HGIS.utils.FeatureUtil.data[i].featureTypes.length;
		for (var j = 0; j < subLen; j++) {
			var value = HGIS.utils.FeatureUtil.data[i].featureTypes[j]; 			 
			if(HGIS.utils.FeatureUtil.data[i].featureTypes[j]["name"] == featureType){
				layerType = HGIS.utils.FeatureUtil.data[i].layerType;
				break;
			}			
		}
	}
	 
	return layerType;
};
/**
 * APIMethod: pickFeatureType.
 * 通过像素位置拾取所有要素类型.
 * 
 * 参数:
 * pixX - <int> 像素x坐标.
 * pixY - <int> 像素y坐标.
 * types -<String> 拾取的类型  1 点 2线 3面 "1,2,3" 代表点线面.
 */
HGIS.utils.FeatureUtil.pickFeatureType=function(map,pixX,pixY,types){
	//查找所有要素
	var fTypes=[];
	var fFeatures=[];
	var result=HGIS.utils.FeatureUtil.pickFeatures(map,pixX,pixY,types);
	for(var i=0;i<result.length;i++){
		var subType=result[i][0].attributes.subType;
		var isContains=false;
		for(var item in fTypes){
			if(fTypes[item]==subType){
				isContains=true;
			}
		}
		if(!isContains)
			fTypes.push(subType);
	}
	for(var j=0;j<fTypes.length;j++){
		var ft=HGIS.utils.FeatureUtil.getFeatureType(fTypes[j]);
		if(ft==undefined)
			continue;
		fFeatures.push(ft);
	}
	return fFeatures;
};
/**
 * APIMethod: pickFeatures.
 * 通过像素位置拾取要素.
 * 
 * 参数:
 * pixX  像素x坐标.
 * pixY  像素y坐标.
 * types  拾取的类型  1 点 2线 3面 "1,2,3" 代表点线面.
 */

HGIS.utils.FeatureUtil.pickFeatures=function(map,pixX,pixY,types){
	 //var map=HGIS.utils.FeatureUtil.map;
	 //当前要素点的地理要素
	 var result=new Array();
	 //周边8个要素点的地理要素
	 var result2=new Array();
	 var lonlat = map.getLonLatFromViewPortPx({"x":pixX,"y":pixY});
	 var c=Math.floor((lonlat.lon-HGIS.InitParam.tileOrigin.lon)/(map.resolution*256));
	 var r=Math.floor((HGIS.InitParam.tileOrigin.lat-lonlat.lat)/(map.resolution*256));
	 var code=r+"-"+c;
	 var oLon=c*(map.resolution*256)+HGIS.InitParam.tileOrigin.lon;
	 var oLat=HGIS.InitParam.tileOrigin.lat-r*(map.resolution*256);
	 //计算当前行列号的矩阵信息
	 var matrixC=Math.floor((lonlat.lon-oLon)/(map.resolution*HGIS.Matrix.cellSize));
	 var matrixR=Math.floor((oLat-lonlat.lat)/(map.resolution*HGIS.Matrix.cellSize));
	 //遍历地图上所有要素
	 var features=HGIS.utils.FeatureUtil.options.layer.renderer.features;
	 var objkeys = Object.keys(features);
     objkeys = objkeys.sort();
	 for (var i=objkeys.length-1;i>=0;i--)
	 {
		 //判断地理要素是否通过编码
		if(typeof(features[objkeys[i]][0].attributes.hashcode)!="undefined"){
			//过滤制定切片的数据
			if(features[objkeys[i]][0].origin==code){
				//类型过滤
				if(types.indexOf(features[objkeys[i]][0].type)>=0){
					//像素拾取
					if(features[objkeys[i]][0].attributes.hashcode[matrixR][matrixC]==1){
						result.push(features[objkeys[i]]);
					}
					//周围8个要素点拾取结果,判断是否超出边界
					var f1,f2,f3,f4,f5,f6,f7,f8;
					if(matrixR>0 &&matrixC>0)
						f1=features[objkeys[i]][0].attributes.hashcode[matrixR-1][matrixC-1];
					if(matrixR>0)
						f2=features[objkeys[i]][0].attributes.hashcode[matrixR-1][matrixC];
					if(matrixR>0&&matrixC<HGIS.Matrix.size)
						f3=features[objkeys[i]][0].attributes.hashcode[matrixR-1][matrixC+1];
					if(matrixC>0)
						f4=features[objkeys[i]][0].attributes.hashcode[matrixR][matrixC-1];
					if(matrixC<HGIS.Matrix.size)
						f5=features[objkeys[i]][0].attributes.hashcode[matrixR][matrixC+1];
					if(matrixR<HGIS.Matrix.size&&matrixC>0)
						f6=features[objkeys[i]][0].attributes.hashcode[matrixR+1][matrixC-1];
						f7=features[objkeys[i]][0].attributes.hashcode[matrixR+1][matrixC];
					if(matrixR<HGIS.Matrix.size &&matrixC<HGIS.Matrix.size)
						f8=features[objkeys[i]][0].attributes.hashcode[matrixR+1][matrixC+1];
					if(f1==1||f2==1||f3==1||f4==1||f5==1||f6==1||f7==1||f8==1){
						result2.push(features[objkeys[i]]);
					}
					
//					//像素拾取
//					var code=features[item][0].attributes.hashcode.substr((matrixR*HGIS.Matrix.cellSize+matrixC),1);
//					if(code=="1"){
//						result.push(features[item]);
//					}
//					//周围8个要素点拾取结果,判断是否超出边界
//					var f1,f2,f3,f4,f5,f6,f7,f8;
//					if(matrixR>0 &&matrixC>0)
//						f1=features[item][0].attributes.hashcode.substr((matrixR-1)*HGIS.Matrix.cellSize+matrixC-1,1);
//					if(matrixR>0)
//						f2=features[item][0].attributes.hashcode.substr((matrixR-1)*HGIS.Matrix.cellSize+matrixC,1);
//					if(matrixR>0&&matrixC<HGIS.Matrix.size)
//						f3=features[item][0].attributes.hashcode.substr((matrixR-1)*HGIS.Matrix.cellSize+matrixC+1,1);
//					if(matrixC>0)
//						f4=features[item][0].attributes.hashcode.substr((matrixR)*HGIS.Matrix.cellSize+matrixC-1,1);
//					if(matrixC<HGIS.Matrix.size)
//						f5=features[item][0].attributes.hashcode.substr((matrixR)*HGIS.Matrix.cellSize+matrixC+1,1);
//					if(matrixR<HGIS.Matrix.size&&matrixC>0)
//						f6=features[item][0].attributes.hashcode.substr((matrixR+1)*HGIS.Matrix.cellSize+matrixC-1,1);
//						f7=features[item][0].attributes.hashcode.substr((matrixR+1)*HGIS.Matrix.cellSize+matrixC,1);
//					if(matrixR<HGIS.Matrix.size &&matrixC<HGIS.Matrix.size)
//						f8=features[item][0].attributes.hashcode.substr((matrixR+1)*HGIS.Matrix.cellSize+matrixC+1,1);
//					if(f1=="1"||f2=="1"||f3=="1"||f4=="1"||f5=="1"||f6=="1"||f7=="1"||f8=="1"){
//						result2.push(features[item]);
//					}
				}
		 	}

		}
	 }
	 return result.length<1?result2:result;
};


/**
 * APIMethod: pickFeatures
 * 通过像素位置拾取POI要素
 * 参数:
 * pixX - <int> 像素x坐标
 * pixY - <int> 像素y坐标
 */
HGIS.utils.FeatureUtil.pickPOIs=function(map,pixX,pixY){
	 //当前要素点的地理要素
	 var result=new Array();
	 //周边8个要素点的地理要素
	 var result2=new Array();
	 var lonlat = map.getLonLatFromViewPortPx({"x":pixX,"y":pixY});
	 var c=Math.floor((lonlat.lon-HGIS.InitParam.tileOrigin.lon)/(map.resolution*256));
	 var r=Math.floor((HGIS.InitParam.tileOrigin.lat-lonlat.lat)/(map.resolution*256));
	 var code=r+"-"+c;
	 var oLon=c*(map.resolution*256)+HGIS.InitParam.tileOrigin.lon;
	 var oLat=HGIS.InitParam.tileOrigin.lat-r*(map.resolution*256);
	 //计算当前行列号的矩阵信息
	 var matrixC=Math.floor((lonlat.lon-oLon)/(map.resolution*HGIS.Matrix.cellSize));
	 var matrixR=Math.floor((oLat-lonlat.lat)/(map.resolution*HGIS.Matrix.cellSize));
	 //遍历地图上所有要素
	 var features=HGIS.utils.FeatureUtil.options.layer.renderer.features;
	 for (item in features)
	 {
		 //判断地理要素是否通过编码
		if(typeof(features[item][0].attributes.hashcode)!="undefined"){
			//过滤制定切片的数据
			if(features[item][0].origin==code){
				//类型过滤
				//if(types.indexOf(features[item][0].type)>=0){
				 if(features[item][0].attributes.superType=="POI"){
					//像素拾取
						if(features[item][0].attributes.hashcode[matrixR][matrixC]==1){
							result.push(features[item]);
						}
						//周围8个要素点拾取结果,判断是否超出边界
						var f1,f2,f3,f4,f5,f6,f7,f8;
						if(matrixR>0 &&matrixC>0)
							f1=features[item][0].attributes.hashcode[matrixR-1][matrixC-1];
						if(matrixR>0)
							f2=features[item][0].attributes.hashcode[matrixR-1][matrixC];
						if(matrixR>0&&matrixC<HGIS.Matrix.size)
							f3=features[item][0].attributes.hashcode[matrixR-1][matrixC+1];
						if(matrixC>0)
							f4=features[item][0].attributes.hashcode[matrixR][matrixC-1];
						if(matrixC<HGIS.Matrix.size)
							f5=features[item][0].attributes.hashcode[matrixR][matrixC+1];
						if(matrixR<HGIS.Matrix.size&&matrixC>0)
							f6=features[item][0].attributes.hashcode[matrixR+1][matrixC-1];
							f7=features[item][0].attributes.hashcode[matrixR+1][matrixC];
						if(matrixR<HGIS.Matrix.size &&matrixC<HGIS.Matrix.size)
							f8=features[item][0].attributes.hashcode[matrixR+1][matrixC+1];
						if(f1==1||f2==1||f3==1||f4==1||f5==1||f6==1||f7==1||f8==1){
							result2.push(features[item]);
						}
				}
		 	}

		}
	 }
	 return result.length<1?result2:result;
};
/**
 * 根据layertree Json文件的地址，解析出layertree结构并赋值给HGIS.utils.FeatureUtil.data
 * 
 * @param layerTreeUrl layertree对应json文件的路径
 * @param callback 回调函数，函数参数是解析出来的layertree结构对象
 */
HGIS.utils.FeatureUtil.loadLayerTreeData = function(layerTreeUrl,callback) {
	if(!layerTreeUrl)
		layerTreeUrl = APIAdress + "../../hgis-services/WEB-INF/classes/vtconfigs/LayerTree.json";
	var xmlhttp = new XMLHttpRequest();
	if (xmlhttp == null){
		alert( HGIS.language[HGIS.InitParam.language]["brows_noSupport_AJAX"] );	//'您的浏览器不支持AJAX！'
	}
	xmlhttp.open("GET",layerTreeUrl);
	xmlhttp.setRequestHeader("Content-type","application/json; charset=utf-8");	 
	xmlhttp.send();
	xmlhttp.onreadystatechange=function(){
		if(xmlhttp.readyState==1||xmlhttp.readyState==2||xmlhttp.readyState==3){ //  加载中/处理中
			HGIS.utils.FeatureUtil.data = null;
		}
		if (xmlhttp.readyState==4 && xmlhttp.status==200){
			var res = xmlhttp.responseText; // 返回值
			var json = JSON.parse(res);		 
			HGIS.utils.FeatureUtil.data = json.data.configDetail;			 
			callback(HGIS.utils.FeatureUtil.data);
		}
	};
};HGIS.utils = HGIS.utils || {} ;
HGIS.utils.MapStyleJSON = HGIS.utils.MapStyleJSON|| {};
/**
 * 矢量切片地图样式默认文件类
 */
HGIS.utils.MapStyleJSON.data = 
	{   
		  "rules": [
		            {
		         	    "featureType":"LAND",
		         	    "filter": {
		         	      "type": "==",
		         	      "property": "subType",
		         	      "value": "LAND"
		         	    },	     
		         	    "styles": [{
		         	      "minLevel": 0,
		         	      "maxLevel": 20,
		         	      "symbolizer": {	      
		         	        "fillColor" : "#F9F9F9", 
		         	        "fillOpacity": 1,	         
		         	        "display" : "block"
		         	      }
		         	     }]     
		             }, 
		             {
		         	    "featureType":"CITY_PG",
		         	    "filter": {
		         	      "type": "==",
		         	      "property": "subType",
		         	      "value": "CITY_PG"
		         	    },
		         	    "styles": [{
		         	      "minLevel": 9,
		         	      "maxLevel": 18,
		         	      "symbolizer": {	      
		         	        "strokeWidth": 0,
		         	        "strokeColor" : "rgb(252,245,223)",
		         	        "fillColor" : "#F9F9F9", 
		         	        "label": "${name}", 
		         	        "fontColor": "#FEFEFE",
		         	        "labelOutlineWidth": 0,
		         	        "labelBackgroundColor": "rgb(140,188,240)",     
		         	        "display" : "block"
		         	      }
		         	     }]     
		             }, 
		           	{
		         	    "featureType":"COUNTY_PG",
		         	    "filter": {
		         	      "type": "==",
		         	      "property": "subType",
		         	      "value": "COUNTY_PG"
		         	    },
		         	    "styles": [{
		         	      "minLevel": 0,
		         	      "maxLevel": 0,
		         	      "symbolizer": {	        
		         	        "strokeWidth": 0,
		         	        "strokeColor" : "rgb(252,245,223)",
		         	        "fillColor" : "#F9F9F9",
		         	        "label": "${name}", 
		         	        "fontColor": "#FEFEFE",
		         	        "labelOutlineWidth": 0,
		         	        "labelBackgroundColor": "rgb(140,188,240)",     
		         	        "display" : "block"
		         	      }
		         	     }]     
		             }, 
		             {
		         	    "featureType":"TOWN_PG",
		         	    "filter": {
		         	      "type": "==",
		         	      "property": "subType",
		         	      "value": "TOWN_PG"
		         	    },
		         	    "styles": [{
		         	      "minLevel": 0,
		         	      "maxLevel": 0,
		         	      "symbolizer": {	        
		         	        "strokeWidth": 0,
		         	        "strokeColor" : "rgb(252,245,223)",
		         	        "fillColor" : "#F9F9F9", 
		         	        "label": "${name}",      
		         	        "display" : "block"
		         	      }
		         	     }]     
		             },   
		             {
		               "featureType":"VEGETATION",
		               "filter": {
		                 "type": "~",
		                 "property": "subType",
		                 "value": "VEGETATION"
		                },
		               "styles": [{
		                 "minLevel": 12,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "name": "vegetation",
		                   "strokeWidth": 0,
		                   "strokeColor": "rgb(198,222,191)",
		                   "fillColor": "rgb(198,222,191)",
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 0,
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"WATER",
		               "filter":{
		                 "type": "~",
		                 "property": "subType",
		                 "value": "HYDSIDE"
		                },
		               "styles": [{
		                 "minLevel": 12,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "strokeWidth": 0,
		                   "fillColor" : "rgb(168,206,228)",
		                   "fillOpacity": 1,
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 0,
		                   "display" : "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"WATER",
		               "filter":{
		                 "type": "==",
		                 "property": "subType",
		                 "value": "LAKES_PG"
		               },
		               "styles": [{
		                 "minLevel": 12,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "strokeWidth": 0,
		                   "fillColor" : "rgb(168,206,228)",
		                   "fillOpacity": 1,
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 0,
		                   "display" : "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"RESAREA_PG",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "RESAREA_PG"
		               },
		               "styles": [{
		                 "minLevel": 15,
		                 "maxLevel": 20,
		                 "symbolizer": {         
		                   "strokeWidth": 0,
		                   "strokeColor": "rgb(252,245,223)",
		                   "fillColor": "#ECEAE4",
		                   "label": "${name}",
		                   "fontSize": "7px",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 0,
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"SIGHT_PG",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SIGHT_PG"
		               },
		               "styles": [{
		                 "minLevel": 14,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "strokeWidth": 0,
		                   "strokeColor": "rgb(198,222,191)",
		                   "fillColor": "rgb(198,222,191)",
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 0,
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"HOSPITAL_PG",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "HOSPITAL_PG"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "strokeWidth": 0,
		                   "strokeColor": "rgb(198,222,191)",
		                   "fillColor": "rgb(225,22,11)",
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 0,
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"METROSTATION_PG",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "MATROSTATION_PG"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "strokeWidth": 0,
		                   "strokeColor": "rgb(240,176,168)",
		                   "fillColor": "rgb(240,176,168)",
		                   "fillOpacity": 0.4,
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 0,
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"TRAFFIC_HUB_PG",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "TRAFFIC_HUB_PG"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "strokeWidth": 0,
		                   "strokeColor": "rgb(198,222,191)",
		                   "fillColor": "rgb(225,22,11)",
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 0,
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"SCHOOL_UNIVERSITY_PG",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SCHOOL_UNIVERSITY_PG"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "strokeWidth": 0,
		                   "strokeColor": "rgb(198,222,191)",
		                   "fillColor": "rgb(225,22,11)",
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 1,
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		         	    "featureType":"CITY_LN",
		         	    "filter": {
		         	      "type": "==",
		         	      "property": "subType",
		         	      "value": "CITY_LN"
		         	    },
		         	    "styles": [{
		         	      "minLevel": 9,
		         	      "maxLevel": 18,
		         	      "symbolizer": {	        
		         	          "strokeWidth": 1,
		         	          "strokeColor": "#8C8C8A",	
		         	          "strokeDashstyle": "dash",                  
		         	          "display": "block"
		         	      }
		         	     }]     
		             },
		             {
		         	    "featureType":"COUNTY_LN",
		         	    "filter": {
		         	      "type": "==",
		         	      "property": "subType",
		         	      "value": "COUNTY_LN"
		         	    },
		         	    "styles": [{
		         	      "minLevel": 9,
		         	      "maxLevel": 13,
		         	      "symbolizer": {	        
		         	          "strokeWidth": 2,
		         	          "strokeColor": "#8C8C8A",	
		         	          "strokeDashstyle": "dash",                 
		         	          "display": "block"
		         	      }
		         	     }]     
		             }, 
		             {
		         	    "featureType":"TOWN_LN",
		         	    "filter": {
		         	      "type": "==",
		         	      "property": "subType",
		         	      "value": "TOWN_ln"
		         	    },
		         	    "styles": [{
		         	      "minLevel": 13,
		         	      "maxLevel": 20,
		         	      "symbolizer": {	      
		         	          "strokeWidth": 1,
		         	          "strokeColor": "rgb(255,0,0)",	
		         	          "strokeDashstyle": "dash",                
		         	          "display": "block"
		         	      }
		         	     }]     
		             }, 
		             {
		               "featureType":"RAILWAY_LN",
		               "filter": {
		                 "type": "~",
		                 "property": "subType",
		                 "value": "RAILWAY"
		               },
		               "styles": [{
		                 "minLevel": 9,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "strokeWidth": 2,
		                   "strokeColor" : "rgb(252,249,249)",         
		                   "strokeDashstyle": "dash",
		                   "outlineWidth": 3,
		                   "outlineColor":"rgb(220,220,220)",         
		                   "outlineDashstyle":"solid",
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 1,
		                   "display" : "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"QITADAOLU",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "QITADAOLU"
		               },
		               "styles": [{
		                 "minLevel": 16,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "name": "kind08-0b",
		                   "strokeWidth": 2,
		                   "strokeColor": "rgb(252,249,249)",         
		                   "outlineWidth": 3,
		                   "outlineColor": "rgb(220,220,220)",         
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 1,
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"XIANGZHENCUNDAO",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "XIANGZHENCUNDAO"
		               },
		               "styles": [{   
		                 "minLevel": 12,   
		                 "maxLevel": 20,
		                "symbolizer":{        
		                   "name": "kind06",
		                   "strokeWidth": 3,
		                   "strokeColor": "rgb(252,249,249)",         
		                   "outlineWidth": 5,
		                   "outlineColor": "rgb(200,200,200)",          
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 1,
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"XIANDAO",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "XIANDAO"
		               },
		               "styles": [{
		                 "minLevel": 14,
		                 "maxLevel": 20, 
		                 "symbolizer": {
		                   "name": "kind04",
		                   "strokeWidth": 3,
		                   "strokeColor": "rgb(252,245,223)",        
		                   "outlineWidth": 5,
		                   "outlineColor": "rgb(249,216,174)",         
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 1,
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"SHENGDAO",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SHENGDAO"
		               },
		               "styles": [{
		                 "minLevel": 11,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "name": "kind03",
		                   "strokeWidth": 4,
		                   "strokeColor": "rgb(252,245,223)",        
		                   "outlineWidth": 6,
		                   "outlineColor": "rgb(250,228,181)",         
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 1,
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"GUODAO",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "GUODAO"
		               },
		               "styles": [{  
		                "minLevel": 13,            
		                "maxLevel": 20,        
		                 "symbolizer": {
		                   "strokeWidth": 4,
		                   "strokeColor": "rgb(252,245,223)",         
		                   "outlineWidth": 6,
		                   "outlineColor": "rgb(249,223,169)",         
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 1,
		                   "display": "block"
		                 }
		                 }]
		             },
		                
		               
		             {
		               "featureType":"GAOSU",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "GAOSU"
		               },
		               "styles": [{
		                 "minLevel": 6,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "strokeWidth": 2,
		                   "strokeColor" : "rgb(252,224,156)",         
		                   "outlineWidth": 4,
		                   "outlineColor":"rgb(239,197,117)",         
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 1,
		                   "display" : "block"
		                 }
		               },
		               {
		                 "minLevel": 11,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "strokeWidth": 5,
		                   "strokeColor" : "rgb(252,224,156)",         
		                   "outlineWidth": 7,
		                   "outlineColor":"rgb(239,197,117)",         
		                   "label": "${name}",
		                   "fontColor": "#737063",
		                   "labelOutlineColor": "#FDFCF6",
		                   "labelOutlineWidth": 1,
		                   "display" : "block"
		                 }
		               }]
		             },    
		             {
		               "featureType":"SUBWAY_LN",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SUBWAY_LN"
		               },
		               "styles": [{
		                 "minLevel": 6,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "strokeWidth": 1,
		                   "strokeColor" : "rgb(255,130,117)",        
		                   "outlineWidth": 2,
		                   "outlineColor":"rgb(249,249,249)",         
		                   "label": "${name}",
		                   "fontColor": "rgb(255,130,117)",
		                   "labelOutlineColor": "rgb(249,249,249)",
		                   "labelOutlineWidth": 1,
		                   "display" : "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"BANK_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "BANK_PT"
		               },
		               "styles": [{
		                 "minLevel": 14,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61464;",
		                   "strokeColor" : "rgb(162,143,141)",
		                   "backgroundGraphic" :"&#57346",
		                   "backgroundFillColor" : "rgb(255,255,255)",
		                   "outerStrokeColor":"rgb(129,104,104)",
		                   "iconFont" : "16px",         
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily" : "Arial",
		                   "fontWeight" : "normal",
		                   "fontStyle": "normal",
		                   "fontSize" : "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display" : "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"CARPARK_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CARPARK_PT"
		               },
		               "styles": [{
		                 "minLevel": 16,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61456;",
		                   "strokeColor" : "rgb(154,177,198)",
		                   "backgroundGraphic" :"&#57346",
		                   "backgroundFillColor" : "rgb(255,255,255)",
		                   "outerStrokeColor":"rgb(35,117,209)",
		                   "iconFont" : "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily" : "Arial",
		                   "fontWeight" : "bold",
		                   "fontStyle": "normal",
		                   "fontSize" : "7px",
		                   "fontColor": "rgb(35,117,209)",
		                   "labelAlign": "cb",
		                   "display" : "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"DISTRICT_A_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "DISTRICT_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 8,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "fillColor": "rgb(241,235,235)",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontColor": "#FFFFFF",
		                   "labelOutlineWidth": 1,
		                   "labelBackgroundColor" : "#8CBCF0",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"CHINA_PROCENCITY_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CHINA_PROCENCITY_PT"
		               },
		               "styles": [{
		                 "minLevel": 7,
		                 "maxLevel": 12,
		                 "symbolizer": {
		                   "externalGraphic": "&#39",
		                   "strokeColor": "rgb(224,0,0)",
		                   "backgroundGraphic": "&#39",
		                   "backgroundFillColor": "rgb(229,219,217)",
		                   "outerStrokeColor": "rgb(224,0,0)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"CHINA_PRECENCITY_A_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CHINA_PRECENCITY_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 8,
		                 "maxLevel": 12,
		                 "symbolizer": {
		                   "externalGraphic": "&#77",
		                   "strokeColor": "rgb(149,92,26)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"CHINA_PRECENCITY_B_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CHINA_PRECENCITY_B_PT"
		               },
		               "styles": [{
		                 "minLevel": 10,
		                 "maxLevel": 12,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "fillColor": "rgb(241,235,235)",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"CHINA_PRECENCITY_C_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CHINA_PRECENCITY_C_PT"
		               },
		               "styles": [{
		                 "minLevel": 11,
		                 "maxLevel": 12,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "fillColor": "rgb(241,235,235)",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"SUBSTATION_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SUBSTATION_PT"
		               },
		               "styles": [{
		                 "minLevel": 13,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61493",
		                   "strokeColor": "rgb(255,0,0)",
		                   "backgroundGraphic": "&#57353",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(255,0,0)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"METROSTATION_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "METROSTATION_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#198",
		                   "strokeColor": "rgb(254,233,121)",
		                   "backgroundGraphic": "&#198",
		                   "backgroundFillColor": "rgb(254,233,121)",
		                   "outerStrokeColor": "rgb(0,0,0)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"CHANGESTATION_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CHANGESTATION_PT"
		               },
		               "styles": [{
		                 "minLevel": 15,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61492",
		                   "strokeColor": "rgb(255,255,255)",
		                   "backgroundGraphic": "&#57352",
		                   "backgroundFillColor": "rgb(255,0,0)",
		                   "outerStrokeColor": "rgb(255,0,0)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"OTHER_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "OTHER_PT"
		               },
		               "styles": [{
		                 "minLevel": 19,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"SECURITIES_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SECURITIES_PT"
		               },
		               "styles": [{
		                 "minLevel": 19,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"TEA_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "TEA_PT"
		               },
		               "styles": [{
		                 "minLevel": 19,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"HOME_IMPROVEMENT_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "HOME_IMPROVEMENT_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"HANDICRAFT_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "HANDICRAFT_PT"
		               },
		               "styles": [{
		                 "minLevel": 19,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"INSURANCE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "INSURANCE_PT"
		               },
		               "styles": [{
		                 "minLevel": 19,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"INDUSTRIAL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "INDUSTRIAL_PT"
		               },
		               "styles": [{
		                 "minLevel": 19,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"MOTORWAY_SERVICE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "MOTORWAY_SERVICE_PT"
		               },
		               "styles": [{
		                 "minLevel": 19,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"LOGISTICS_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "LOGISTICS_C_PT"
		               },
		               "styles": [{
		                 "minLevel": 19,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"LOGISTICS_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "LOGISTICS_B_PT"
		               },
		               "styles": [{
		                 "minLevel": 19,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"LOGISTICS_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "LOGISTICS_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"BICYCLE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "BICYCLE_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"VILLAGE_COMMITTEE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "VILLAGE_COMMITTEE_PT"
		               },
		               "styles": [{
		                 "minLevel": 19,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"SPORTS_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SPORTS_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"TV_STATION_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "TV_STATION_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"TRAVEL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "TRAVEL_PT"
		               },
		               "styles": [{
		                 "minLevel": 19,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"TRAINING_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "TRAINING_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"TICKET_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "TICKET_PT"
		               },
		               "styles": [{
		                 "minLevel": 19,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"VIDEO_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "VIDEO_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"VEHICLE_DETECTION_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "VEHICLE_DETECTION_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"CULTURAL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CULTURAL_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"COSMETICS_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "COSMETICS_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"CLOTHING_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CLOTHING_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"OTHER_RENTAL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "OTHER_RENTAL_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"COMPUTER_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "COMPUTER_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"FLOWERS_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "FLOWERS_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"FARMERS_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "FARMERS_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"LOTTERYSTATION_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "LOTTERYSTATION_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"ASSOCIATION_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "ASSOCIATION_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"BABY_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "BABY_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"ANTIQUE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "ANTIQUE_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"BARBER_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "BARBER_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"COMPANY_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "COMPANY_PT"
		               },
		               "styles": [{
		                 "minLevel": 16,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"FOOD_FAST_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "FOOD_FAST_PT"
		               },
		               "styles": [{
		                 "minLevel": 18,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "fillColor": "rgb(241,235,235)",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"WC_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "WC_PT"
		               },
		               "styles": [{
		                 "minLevel": 18,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61489",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"CONVENIENCE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CONVENIENCE_PT"
		               },
		               "styles": [{
		                 "minLevel": 18,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61442",
		                   "strokeColor": "rgb(177,157,203)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(164,151,193)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"RETAIL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "RETAIL_PT"
		               },
		               "styles": [{
		                 "minLevel": 18,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61442",
		                   "strokeColor": "rgb(177,157,203)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(164,151,193)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"ATM_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "ATM_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61463",
		                   "strokeColor": "rgb(129,104,104)",
		                   "backgroundGraphic": "&#57350",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"CAR_MAINTENANCE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CAR_MAINTENANCE_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61448",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"COMMUNITY_HOSPITAL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "COMMUNITY_HOSPITAL_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61472",
		                   "strokeColor": "rgb(193,115,98)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(208,127,112)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"DENTAL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "DENTAL_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61472",
		                   "strokeColor": "rgb(193,115,98)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(208,127,112)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"EPIDEMIC_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "EPIDEMIC_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61472",
		                   "strokeColor": "rgb(193,115,98)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(208,127,112)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"PET_HOSPITAL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "PET_HOSPITAL_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61478",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"LIGHT_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "LIGHT_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "fillColor": "rgb(241,235,235)",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"PILL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "PILL_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61479",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"PET_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "PET_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61478",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"PAPER_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "PAPER_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61525",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"CAR_SECONDE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CAR_SECONDE_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61449",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"CAR_RENTAL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CAR_RENTAL_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61449",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"BRIDGE_B_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "BRIDGE_B_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"WHARF_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "WHARF_C_PT"
		               },
		               "styles": [{
		                 "minLevel": 15,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61491",
		                   "strokeColor": "rgb(168,188,216)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(142,169,192)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"WHARF_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "WHARF_B_PT"
		               },
		               "styles": [{
		                 "minLevel": 15,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61491",
		                   "strokeColor": "rgb(168,188,216)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(142,169,192)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"WHARF_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "WHARF_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 14,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61491",
		                   "strokeColor": "rgb(168,188,216)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(142,169,192)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"SCHOOL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SCHOOL_PT"
		               },
		               "styles": [{
		                 "minLevel": 16,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61481",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"FOOD_WEST_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "FOOD_WEST_PT"
		               },
		               "styles": [{
		                 "minLevel": 16,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61441",
		                   "strokeColor": "rgb(215,135,82)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(197,160,133)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"SCIENTIFIC_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SCIENTIFIC_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61527",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"COMMODITY_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "COMMODITY_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61459",
		                   "strokeColor": "rgb(177,157,203)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(177,157,203)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"KTV_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "KTV_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61474",
		                   "strokeColor": "rgb(177,157,203)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(171,159,196)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"COFFEE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "COFFEE_PT"
		               },
		               "styles": [{
		                 "minLevel": 16,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61465",
		                   "strokeColor": "rgb(215,135,82)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(197,160,133)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"FOOD_BAR_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "FOOD_BAR_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61458",
		                   "strokeColor": "rgb(215,135,82)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(197,160,133)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"FOOD_CHINA_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "FOOD_CHINA_PT"
		               },
		               "styles": [{
		                 "minLevel": 16,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61473",
		                   "strokeColor": "rgb(215,135,82)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(197,160,133)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"ENTRANCE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "ENTRANCE_PT"
		               },
		               "styles": [{
		                 "minLevel": 16,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#57351",
		                   "strokeColor": "rgb(102,171,127)",
		                   "backgroundGraphic": "&#61523",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(255,255,255)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"MOBILE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "MOBILE_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61524",
		                   "strokeColor": "rgb(87,112,157)",
		                   "backgroundGraphic": "&#61523",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(255,255,255)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"COUNTY_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "COUNTY_PT"
		               },
		               "styles": [{
		                 "minLevel": 8,
		                 "maxLevel": 12,
		                 "symbolizer": {
		                   "externalGraphic": "",
		                   "strokeColor": "rgb(193,115,98)",
		                   "backgroundGraphic": "",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(208,127,112)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },    
		             {
		               "featureType":"CARSERVICE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CARSERVICE_PT"
		               },
		               "styles": [{
		                 "minLevel": 18,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61449",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"SUPERMARKET_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SUPERMARKET_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61442",
		                   "strokeColor": "rgb(177,157,203)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(164,151,193)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"STADIUM_B_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "STADIUM_B_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61488",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"STADIUM_A_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "STADIUM_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 12,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61488",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"ZOO_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "ZOO_PT"
		               },
		               "styles": [{
		                 "minLevel": 12,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61490",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"SIGHT_B_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SIGHT_B_PT"
		               },
		               "styles": [{
		                 "minLevel": 13,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61528",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"SIGHT_A_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SIGHT_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 11,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61528",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"PARK_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "PARK_C_PT"
		               },
		               "styles": [{
		                 "minLevel": 18,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61512",
		                   "strokeColor": "rgb(138,162,99)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(148,168,139)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"PARK_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "PARK_B_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61512",
		                   "strokeColor": "rgb(138,162,99)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(148,168,139)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"PARK_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "PARK_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 16,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61512",
		                   "strokeColor": "rgb(138,162,99)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(148,168,139)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"MUSEUM_B_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "MUSEUM_B_PT"
		               },
		               "styles": [{
		                 "minLevel": 18,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61508",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"MUSEUM_A_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "MUSEUM_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 16,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61508",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"MOUNTAIN_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "MOUNTAIN_PT"
		               },
		               "styles": [{
		                 "minLevel": 13,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61477",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"MALL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "MALL_B_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61459",
		                   "strokeColor": "rgb(177,157,203)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(177,157,203)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"MALL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "MALL_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 15,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61459",
		                   "strokeColor": "rgb(177,157,203)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(177,157,203)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"HOTEL_C_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "HOTEL_C_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61510",
		                   "strokeColor": "rgb(150,130,130)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(197,191,184)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"HOTEL_B_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "HOTEL_B_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61510",
		                   "strokeColor": "rgb(150,130,130)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(197,191,184)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"HOTEL_A_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "HOTEL_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 13,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61510",
		                   "strokeColor": "rgb(150,130,130)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(197,191,184)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"HOSPITAL_B_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "HOSPITAL_B_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61472",
		                   "strokeColor": "rgb(193,115,98)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(208,127,112)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"HOSPITAL_A_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "HOSPITAL_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 13,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61472",
		                   "strokeColor": "rgb(193,115,98)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(208,127,112)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"SCHOOL_UNIVERSITY_A_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SCHOOL_UNIVERSITY_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 11,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61522",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"EXHCENTER_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "EXHCENTER_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61508",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"OIL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "OIL_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61511",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"PLACE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "PLACE_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"CARSTATION_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "CARSTATION_PT"
		               },
		               "styles": [{
		                 "minLevel": 12,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61494",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"BUSINESS_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "BUSINESS_PT"
		               },
		               "styles": [{
		                 "minLevel": 15,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"TOLL_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "TOLL_PT"
		               },
		               "styles": [{
		                 "minLevel": 15,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61460",
		                   "strokeColor": "rgb(255,229,221)",
		                   "backgroundGraphic": "&#57349",
		                   "backgroundFillColor": "rgb(245,156,138)",
		                   "outerStrokeColor": "rgb(245,156,138)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"GARDEN_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "GARDEN_PT"
		               },
		               "styles": [{
		                 "minLevel": 15,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61512",
		                   "strokeColor": "rgb(138,162,99)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(148,168,139)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"LIBRARY_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "LIBRARY_PT"
		               },
		               "styles": [{
		                 "minLevel": 15,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61476",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"POST_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "POST_PT"
		               },
		               "styles": [{
		                 "minLevel": 15,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61520",
		                   "strokeColor": "rgb(107,143,77)",
		                   "backgroundGraphic": "&#61523",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(255,255,255)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"STORES_A_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "STORES_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 13,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61459",
		                   "strokeColor": "rgb(177,157,203)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(177,157,203)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"SQUARE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "SQUARE_PT"
		               },
		               "styles": [{
		                 "minLevel": 14,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"BRIDGE_A_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "BRIDGE_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 17,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"BUILDING_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "BUILDING_PT"
		               },
		               "styles": [{
		                 "minLevel": 13,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61447",
		                   "strokeColor": "rgb(156,150,150)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(156,150,150)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"HIGH_SPEED_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "HIGH_SPEED_PT"
		               },
		               "styles": [{
		                 "minLevel": 15,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61509",
		                   "strokeColor": "rgb(168,188,216)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(154,177,198)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"POLICE_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "POLICE_PT"
		               },
		               "styles": [{
		                 "minLevel": 14,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61461",
		                   "strokeColor": "rgb(193,115,98)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(208,127,112)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"GOVERNMENT_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "GOVERNMENT_PT"
		               },
		               "styles": [{
		                 "minLevel": 11,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61461",
		                   "strokeColor": "rgb(193,115,98)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(208,127,112)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"TOWN_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "TOWN_C_PT"
		               },
		               "styles": [{
		                 "minLevel": 13,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"TOWN_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "TOWN_B_PT"
		               },
		               "styles": [{
		                 "minLevel": 12,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"TOWN_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "TOWN_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 11,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61446",
		                   "strokeColor": "rgb(128,103,103)",
		                   "backgroundGraphic": "&#57347",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(162,143,141)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"TRASTATION_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "TRASTATION_B_PT"
		               },
		               "styles": [{
		                 "minLevel": 12,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61462",
		                   "strokeColor": "rgb(168,188,216)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(168,188,216)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"TRASTATION_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "TRASTATION_A_PT"
		               },
		               "styles": [{
		                 "minLevel": 11,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61462",
		                   "strokeColor": "rgb(168,188,216)",
		                   "backgroundGraphic": "&#57345",
		                   "backgroundFillColor": "rgb(255,255,255)",
		                   "outerStrokeColor": "rgb(168,188,216)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             },
		             {
		               "featureType":"AIRPORT_PT",
		               "filter": {
		                 "type": "==",
		                 "property": "subType",
		                 "value": "AIRPORT_PT"
		               },
		               "styles": [{
		                 "minLevel": 10,
		                 "maxLevel": 20,
		                 "symbolizer": {
		                   "externalGraphic": "&#61445",
		                   "strokeColor" : "rgb(35,117,209)",
		                   "backgroundGraphic" :"&#57345",
		                   "backgroundFillColor" : "rgb(255,255,255)",
		                   "outerStrokeColor":"rgb(154,177,198)",
		                   "iconFont": "16px",
		                   "label": "${name}",
		                   "labelOutlineColor": "rgb(255,255,255)",
		                   "labelOutlineWidth": 1,
		                   "fontFamily": "Arial",
		                   "fontWeight": "normal",
		                   "fontStyle": "normal",
		                   "fontSize": "7px",
		                   "fontColor": "rgb(162,143,141)",
		                   "labelAlign": "cb",
		                   "display": "block"
		                 }
		               }]
		             }
		           ]
		         };HGIS.utils = HGIS.utils || {};
HGIS.utils.MapStyleUtil = HGIS.utils.MapStyleUtil|| {};
/**
 * Class: HGIS.utils.MapStyleUtil
 * 为矢量地图配置界面提供的接口
 */
//表示样式的json对象
HGIS.utils.MapStyleUtil.styleJson = null;
//矢量切片图层需要的styleMap
HGIS.utils.MapStyleUtil.styleMap =null;
//HGIS.utils.MapStyleUtil.hvtUrl = APIAdress + "../../GeoData/hvt/${z}/${x}/${y}";
// 矢量切片请求变更之后的跟进 ; 多做的步骤主要为实现在hgis-services的配置界面使用
HGIS.utils.MapStyleUtil.hvtUrl = APIAdress.replace("hgis-web","hgis-services").replace("hgis-services/hgisFrontLib","hgis-services") + "/tileCache/HvtTileCacheServlet?mapType=hvt&tileType=vec&level=${z}&col=${x}&row=${y}";
HGIS.utils.MapStyleUtil.scales = null;
/**
 * 根据样式文件和比例尺数组，解析样式文件，创建StyleMap对象
 * 
 * @param styleJsonUrl 样式json的url地址
 * @param callback json文件加载完之后的回调函数
 *  
 */
HGIS.utils.MapStyleUtil.loadStyleJson = function(styleJsonUrl,callback) {
	if(!styleJsonUrl)
		styleJsonUrl = APIAdress + "gisapi/theme/MapStyle.json";
	var xmlhttp = new XMLHttpRequest();
	if (xmlhttp == null){
		alert( HGIS.language[HGIS.InitParam.language]["DB_fail"] );	//'您的浏览器不支持AJAX！'
	}
	xmlhttp.open("GET",styleJsonUrl);
	xmlhttp.setRequestHeader("Content-type","application/json; charset=utf-8");	 
	xmlhttp.send();
	xmlhttp.onreadystatechange=function(){
		if(xmlhttp.readyState==1||xmlhttp.readyState==2||xmlhttp.readyState==3){ //  加载中/处理中
			HGIS.utils.MapStyleUtil.styleJson = null;
		}
		if (xmlhttp.readyState==4 && xmlhttp.status==200){
			var res = xmlhttp.responseText; // 返回值
			var json = JSON.parse(res);
			if(json.data) {
				HGIS.utils.MapStyleUtil.styleJson = json.data.configDetail;
			}else{
				HGIS.utils.MapStyleUtil.styleJson = json;
			}			 
			callback(HGIS.utils.MapStyleUtil.styleJson);
		}
	};
};


/**
 * 根据样式文件和比例尺数组，解析样式文件，创建StyleMap对象
 * 
 * @param styleJson
 * @param scales
 * @returns {HGIS.StyleMap} stylemap对象
 */
HGIS.utils.MapStyleUtil.createStyleMap = function(styleJson,scales){
	if(styleJson==null)return;
	var style = new HGIS.Style();	
	var rules = null;
	if(styleJson.rules==undefined || styleJson.rules==null){
		rules = styleJson;
	}else{
		rules = styleJson.rules;
	}
	
	for(var i= 0, len = rules.length; i<len; i++){
		var jsonRule = rules[i];
		var ruleFilter = null;
		if(jsonRule.logicalFilter){//复合条件过滤
			ruleFilter = new HGIS.Filter.Logical({
				type :jsonRule.logicalFilter.type
			});
			var filters = jsonRule.logicalFilter.filters;
			for(var j=0; j < filters.length; j++){
				var filter = new HGIS.Filter.Comparison();
				filter.type = filters[j].type;
				filter.prototype = filters[j].property;
				filter.value = filters[j].value;
				ruleFilter.filters.push(filter);
			}
		}else  if(jsonRule.filter){//单一条件过滤
			ruleFilter = new HGIS.Filter.Comparison();
			ruleFilter.type = jsonRule.filter.type;
			ruleFilter.property = jsonRule.filter.property;
			ruleFilter.value = jsonRule.filter.value;
		}

		for(var k=0; k<jsonRule.styles.length; k++){
			var rule1 = new HGIS.Rule(jsonRule.styles[k]);
			rule1.featureType = jsonRule.featureType;
			rule1.filter = ruleFilter;
			rule1.elseFilter = true;
			rule1.maxScaleDenominator = scales[jsonRule.styles[k].minLevel];
			rule1.minScaleDenominator = scales[jsonRule.styles[k].maxLevel];
			rule1.symbolizer = jsonRule.styles[k].symbolizer;
			style.addRules([rule1]);
		}
	}
	HGIS.utils.MapStyleUtil.styleMap = new HGIS.StyleMap({
		'default': style,
		'select': new HGIS.Style(styleJson.select )
	});	
	
	return HGIS.utils.MapStyleUtil.styleMap;
};
/**
 * 根据输入的矢量切片图层、要素类名称、样式、级别更新地图
 * @param vectorTileLayer 矢量切片图层
 * @param type 要素类名称
 * @param style 样式
 * @param level 级别
 */

HGIS.utils.MapStyleUtil.updateStyleMap = function(vectorTileLayer,type,style,level){	
	vectorTileLayer.renderer.changeMapStyle(type, style, level);
	vectorTileLayer.refresh();	 
};
/**
 * 根据传入的矢量切片图层、样式规则
 * @param vectorTileLayer 矢量切片图层
 * @param styleJson 整个完整的样式规则
 */
HGIS.utils.MapStyleUtil.updateMapByRules = function(vectorTileLayer,styleJson){	
	if(HGIS.utils.MapStyleUtil.scales==null)
		HGIS.utils.MapStyleUtil.getMapScales(vectorTileLayer.map.resolutions,HGIS.InitParam.srid);
	
	var styleMap = HGIS.utils.MapStyleUtil.createStyleMap(styleJson,HGIS.utils.MapStyleUtil.scales);
	vectorTileLayer.styleMap = styleMap;	 
	vectorTileLayer.refresh();	 
};

/**
 * 根据分辨率数组和srid(空间参考id)计算对应的比例尺数组
 * 
 * @param resolutions 分辨率数组
 * @param srid 空间参考的id
 * @returns {Array} 比例尺数组
 */
HGIS.utils.MapStyleUtil.getMapScales = function(resolutions,srid){
	var scales = [];
     var dpi =96,inch2meter = 0.0254;
     var pixelPerMeter = dpi/inch2meter;
     var meterPerDegree =  Math.PI * 6378137/180.0;
     for(var i=0,len=resolutions.length; i<len; i++){
         //scaleDenominator = resolutions[i] * dpi/inch2meter;
         var scaleDenominator = resolutions[i] * pixelPerMeter;//分辨率的单位为 米/像素
         if(srid == "4326"){//分辨率的单位为 度/像素
             scaleDenominator = resolutions[i] * meterPerDegree* pixelPerMeter;
         }
         scales.push(scaleDenominator);
     }
     HGIS.utils.MapStyleUtil.scales = scales;
     return scales;
};
/**
 * 根据传入的图层和截图宽高生成图层对应的截图，返回Base64字符串格式的图片。
 * 
 * @param vtLayer 矢量切片图层
 * @param imageWidth 要生成的截图的宽度
 * @param imageHeight 要生成的截图的高度
 * @returns String Base64字符串
 */
HGIS.utils.MapStyleUtil.getMapImage = function(vtLayer,imageWidth,imageHeight,callback){
	var renderer = vtLayer.renderer;
	var canvasWidth = renderer.root.width;
	var canvasHeight = renderer.root.height;
	
	 var myCanvas = document.createElement("canvas"); 
	 myCanvas.width = imageWidth;
	 myCanvas.height = imageHeight;
	 var sx = (canvasWidth - imageWidth)/2;
	 var sy = (canvasHeight -imageHeight)/2;
	 
	 var ctxOut = myCanvas.getContext("2d");
	 var canvas1 = renderer.root;			 			 
	 var imageObject1 = new Image();
	 imageObject1.onload=function(){		 
		//ctx3.drawImage(imageObject1,0,0,imageWidth,imageHeight);//不指定裁剪矩形左上角坐标和矩形宽高，会按照比例自动缩放
		 ctxOut.drawImage(imageObject1,sx,sy,imageWidth,imageHeight,0,0,imageWidth,imageHeight);
		
		var canvas2 = renderer.lineCanvas;			 			 
		var imageObject2 = new Image();
		imageObject2.onload=function(){				
			ctxOut.drawImage(imageObject2,sx,sy,imageWidth,imageHeight,0,0,imageWidth,imageHeight);
			var canvas3 = renderer.hitCanvas;			 			 
			var imageObject3 = new Image();
			imageObject3.onload=function(){		 
				ctxOut.drawImage(imageObject3,sx,sy,imageWidth,imageHeight,0,0,imageWidth,imageHeight);
				
				var image = myCanvas.toDataURL("image/jpeg",1.0); 	
			    //var win=window.open('about:blank','image from canvas');  
			    //win.document.write("<img src='"+image+"' alt='from canvas'/>");	
			    if(callback)
			    	callback(image);
			  
			}
			imageObject3.src = canvas3.toDataURL();		 
		}
		imageObject2.src = canvas2.toDataURL();	
		
	 }
	 imageObject1.src = canvas1.toDataURL();	
};
/**
 * 根据要素类型闪烁该类要素
 * 
 * @param vtLayer 矢量切片图层
 * @param featureType 要素类型
 * @param flickerColor 闪烁的颜色
 *   
 */
HGIS.utils.MapStyleUtil.flickerByFeatureType = function(vtLayer,featureType,flickerColor){	
     var features=new Array();
     
     var highLightStyle = {};
     var subTypes = HGIS.utils.FeatureUtil.getsubTypes(featureType);//根据
     if(subTypes.length == 0){
    	 for(var i=0,len = vtLayer.features.length;i< len;i++){
	         if(vtLayer.features[i].attributes.subType.toUpperCase() == featureType){           
	           features.push(vtLayer.features[i]);
	         }          
	     }    	
     }else if(subTypes.length > 0){
    	 for(var i=0,len = vtLayer.features.length;i< len;i++){
	         if(subTypes.indexOf(vtLayer.features[i].attributes.subType) > -1){           
	           features.push(vtLayer.features[i]);	           
	         }          
	     } 
     }
     if(features.length>1){
    	 //下面的for循环是深度克隆style对象，不能用highLightStyle = features[0].style;
    	 for(var item in features[0].style){
    		 highLightStyle[item] = features[0].style[item];
    		 if(item=="label")
    			 highLightStyle[item]= "";//闪烁时不显示文字
    	 }	     
	     var color = "rgb(255,0,0)";
	     if(flickerColor)
	    	 color = flickerColor;
	     switch(features[0].type){
	     	case 3:
	     		highLightStyle.fillColor = color;
	     		break;
	     	case 2:
	     		highLightStyle.strokeColor = color;
	     		break;
	     	case 1:
	     		highLightStyle.strokeColor = color;
	     		//highLightStyle.backgroundFillColor = color;//改变填充色
	     		break;
	     	default:
	     		highLightStyle.fillColor = "rgb(255,0,0)";	
	     		break;
	     }	    
	     vtLayer.renderer.drawFeaturesSameType(features,highLightStyle);
	     vtLayer.renderer.stopLoop(false);
	     vtLayer.renderer.startLoop();
     }
};
HGIS.utils.MapStyleUtil.flickerByFeatureType.contains = function(arr, obj) {
	  var i = arr.length;
	  while (i--) {
	    if (arr[i] === obj) {
	      return true;
	    }
	  }
	  return false;
}
//修改地图背景色
HGIS.utils.MapStyleUtil.changeBgColor = function(vtLayer,bgColor) {
	if(bgColor){
		vtLayer.renderer.root.style.background = bgColor;
	}else {
		var rules = HGIS.utils.MapStyleUtil.styleJson.rules;		 
		for(var i=0; i<rules.length; i++){
			if(rules[i].featureType=="LAND"){
				vtLayer.renderer.root.style.background = rules[i].styles[0].symbolizer.fillColor;
				return;
			}			
		}		 
	}
}
// 获取地图背景色(陆地颜色)
HGIS.utils.MapStyleUtil.getLandColor = function(styleJson) {	
	var landColor = null;
	var rules=null;
	if(styleJson){
		rules = styleJson.rules;
	}else{
		rules = HGIS.utils.MapStyleUtil.styleJson.rules;	
	}
	for(var i=0; i<rules.length; i++){
		if(rules[i].featureType==="LAND"){
			landColor = rules[i].styles[0].symbolizer.fillColor;
			return landColor;
		}			
	} 
}
/**
* 根据传入的styleName 获取到hvtStyle的样式文件
* @param styleName
*/
HGIS.utils.MapStyleUtil.getVtStylePath = function(styleName){
	var array = APIAdress.split("/");
	var url = array[0]+"//"+array[2]+"/";
	var styleUrl = url + "GeoData/hvtstyles/"+ styleName +"/MapStyle.json";
	return styleUrl;
}
/**
 * 用于判断是否存在相应的json文件 
 * @param vtStyleUrl
 */
HGIS.utils.MapStyleUtil.ifExitVtStyleByUrl = function(vtStyleId){
	var url = mapServerConfigURL.ifExitVtStyleByUrl;
	var params = {
		vtStylepath:vtStyleId	
	};
	var flag = 0;
	var u = HGIS.Utils ;
	u._asynchronous = false;
	u.send( url , params,"POST","json" ,function(res){
		if(res.data){
			flag =1 ;
		}
	},function(){
		
	});
	u._asynchronous = true;
	if (flag === 0) {
		var vtStyleUrl = encodeURI(HGIS.utils.MapStyleUtil.getVtStylePath(vtStyleId));
		throw vtStyleUrl +" not find in the services,please check the vtStyleName";
	}
}
/**
 * 用于通过restful的方式获取 矢量切片 样式信息
 */
HGIS.utils.MapStyleUtil.getHvtStyle = function(vtStyleId){	
	var flag = 0;
	var u = HGIS.Utils ;
	u._asynchronous = false;
	var url = mapServerConfigURL.getVTConfigDetailById+"?vtid="+vtStyleId
	u.send( url , "","get","json" ,function(res){
		if(res.data) {
			HGIS.utils.MapStyleUtil.styleJson = res.data.configDetail;
		}else{
			HGIS.utils.MapStyleUtil.styleJson = res;
		}	
	},function(){
		
	});
	u._asynchronous = true;
}

HGIS=HGIS||{};
HGIS.Matrix={
    m:null,
    cellSize:16,
    size:16,
    init:function(){
    	this.m=[];
    	for(var i=0;i<this.size;i++){
    		this.m[i]=[];
    		for(var j=0;j<this.size;j++){
    			this.m[i][j]=0;
    		}
    	}
    },
    toHash:function(){
    	var v="";
    	var size=this.m.length;
		for(var i=0;i<size;i++){
			for (var j=0;j<size;j++){
				v+=this.m[i][j];
			}
		}
		return v;
    },
    
    move:function(x0,y0){
    	c=Math.round(x0/this.cellSize); 
        r=Math.round(y0/this.cellSize);
        this.setValue(r,c,y0,x0);
    },
    line:function(x0,y0,x1,y1){
        //对网格进行粗粒度划分
        c0=Math.round(x0/this.cellSize);
        c1=Math.round(x1/this.cellSize);
        r0=Math.round(y0/this.cellSize);
        r1=Math.round(y1/this.cellSize);
        //计算当前线段的斜率
        var l=0;
        if(x1==x0){
            l=10000;
        }else {
            l =Math.abs((y1 - y0) / (x1 - x0));
        };
        //当斜率无穷大的时候，处理方法
        if(l==10000){
            if(r0>r1){
                for(var r=r0;r>=r1;r--) {
                	this.setValue(r,c0,r*this.cellSize+y0%this.cellSize,x0);
                }
            }else{
                for(var r=r0;r<=r1;r++) {
                	this.setValue(r,c0,r*this.cellSize+y0%this.cellSize,x0);
                }
            };
        }else{
            //当斜率l<=1的时候遍历col
            if(Math.abs(l)<=1){
                if(x0<x1){
                    for(var x=x0;x<=x1;x=x+this.cellSize){
                        var y=(x-x0)*l+y0;
                        y=Math.round(y);
                        this.setValue(Math.floor(y/this.cellSize),Math.floor(x/this.cellSize),y,x);
                    }
                }else{
                    for(var x=x0;x>=x1;x=x-this.cellSize){
                        var y=(x-x0)*l+y0;
                        y=Math.round(y);
                        this.setValue(Math.floor(y/this.cellSize),Math.floor(x/this.cellSize),y,x);
                    }
                }
                
            }else{
                if(y0<y1){
                    for(var y=y0;y<=y1;y=y+this.cellSize){
                        var x=(y-y0)/l+x0;
                        x=Math.round(x);
                        this.setValue(Math.floor(y/this.cellSize),Math.floor(x/this.cellSize),y,x);
                    }
                }else{
                    for(var y=y0;y>=y1;y=y-this.cellSize){
                        var x=(y-y0)/l+x0;
                        x=Math.round(x);
                        this.setValue(Math.floor(y/this.cellSize),Math.floor(x/this.cellSize),y,x);
                    }
                }
                
            }
        }
    },
    setValue:function(r,c,r0,c0){
    	if(r<0){
    		r=0;	
    	}
    	if(r>this.size-1){
       		r=this.size-1;	
    	}
    	if(c<0){
    		c=0;
    	}
    	if(c>this.size-1){
    		c=this.size-1;
    	}
    	this.m[r][c]=1;
    	if(r0%this.cellSize<=this.cellSize/2 &&c0%this.cellSize<=this.cellSize/2){
    		if(r>0)
    			this.m[r-1][c]=1;
    		if(r>0&& c>0)
    			this.m[r-1][c-1]=1;
    		if(c>0)
    			this.m[r][c-1]=1;
    	}else if(r0%this.cellSize>this.cellSize/2 &&c0%this.cellSize<=this.cellSize/2){
    		if(c>0)
    			this.m[r][c-1]=1;
    		if(r<this.size-1 && c>0)
    			this.m[r+1][c-1]=1;
    		if(r<this.size-1)
    			this.m[r+1][c]=1;
    	}else if(r0%this.cellSize<=this.cellSize/2 &&c0%this.cellSize>this.cellSize/2){
    		if(r>0)
    			this.m[r-1][c]=1;
    		if(r>0 && c<this.size-1)
    			this.m[r-1][c+1]=1;
    		if(c<31)
    			this.m[r][c+1]=1;
    	}else if(r0%this.cellSize>this.cellSize/2 &&c0%this.cellSize>this.cellSize/2){
    		if(c<this.size-1)
    			this.m[r][c+1]=1;
    		if(r<this.size-1)
    			this.m[r+1][c]=1;
    		if(r<this.size-1&&c<this.size-1)
    			this.m[r+1][c+1]=1;
    	}
    		
    },
    /**
     * 如果是面的话则填充数组
     */
    fill:function(){
        for(var r=0;r<this.size;r++){
            var flag=0;//标识找到第一个非0点
            for(var c=0;c<this.size;c++){
                if(this.m[r][c]==0 && flag==0){
                    continue;
                };
                if(this.m[r][c]==1){
                    flag=1;
                    continue;
                };
                for(var k=c;k<this.size;k++){
                    //区分两个点连在一起的情况
                    if(this.m[r][k]==1 && this.m[r][k]^this.m[r][k+1]==1){
                        this.m[r][c]=this.m[r][c]^1;
                    }
                }
            }
        };
    }
}

HGIS.tools = {
	getFactor : function() {
		var url = HGIS.Utils.getUrlByExpolreType(mapServerConfigURL.getFactorConfig);
		if (url.indexOf("jsonp") != -1) {
			HgisAjax({   
				  url: url ,    // 请求地址
				  jsonp: 'jsonp',  // 采用jsonp请求，且回调函数名为"jsonpCallbak"，可以设置为合法的字符串
				  data: {},   // 传输数据
				  success: function(res){ 
					  if(res.code=="0"){
							HGIS.Converter.minLon=res.data.minLon;
							HGIS.Converter.minLat=res.data.minLat;
							HGIS.Converter.maxLon=res.data.maxLon;
							HGIS.Converter.maxLat=res.data.maxLat;
							HGIS.Converter.per=res.data.per;
							HGIS.Converter.Factor=JSON.parse(res.data.factor);
						}
					  },
				  error: function(error) {}   // 请求失败的回调函数
				  });
		}else{
			HGIS.Utils.send(mapServerConfigURL.getFactorConfig, "","get", "json", function(res) {
				if(res.code=="0"){
					HGIS.Converter.minLon=res.data.minLon;
					HGIS.Converter.minLat=res.data.minLat;
					HGIS.Converter.maxLon=res.data.maxLon;
					HGIS.Converter.maxLat=res.data.maxLat;
					HGIS.Converter.per=res.data.per;
					HGIS.Converter.Factor=JSON.parse(res.data.factor);
				}
			},function(err){
				
			});
		}
	}
};
/**
 * Class: HGIS.Utils
 * HGIS引擎JavaScript工具类.
 */
HGIS.Utils = HGIS.Utils || {};
HGIS.Utils = {
	 _map: null,
	/**
	 * APIMethod: getContextRoot
	 * 获取当前部署项目路径.
	 * 
	 * 
	 * Returns:
	 * {String} 当前项目路径
	 */
	 getContextRoot:function() {
            //获取当前网址，如： http://localhost:8083/uimcardprj/share/meun.jsp
            var curWwwPath = window.document.location.href;
            //获取主机地址之后的目录，如： uimcardprj/share/meun.jsp
            var pathName = window.document.location.pathname;
            var pos = curWwwPath.indexOf(pathName);
            //获取主机地址，如： http://localhost:8083
            var localhostPaht = curWwwPath.substring(0, pos);
            //获取带"/"的项目名，如：/uimcardprj
            var projectName = pathName.substring(0, pathName.substr(1).indexOf('/') + 1);
            return (localhostPaht + projectName);
        },
	
	
	/**
	 * APIMethod: geo2Wkt
	 * 将geometry地理对象转为wkt字符串.
	 * 
	 * Parameters:
	 * geom - {object} geometry对象.
	 * 
	 * Returns:
	 * {String} 返回wkt字符串
	 */
	geom2Wkt : function(geom) {
		var wktobj = new HGIS.Format.WKT();
		var wkt = wktobj.extractGeometry(geom);
		return wkt;
	},
	/**
	 * APIMethod: isWithinMap
	 * 判断是否在地图内
	 * 
	 * Parameters:
	 * obj - {object} 数据，类型仅支持lonLat和Geometry两类
	 * 
	 * Returns:
	 * {boolean} 是否在地图范围内
	 */
	isWithinMap : function(obj) {
		//先判断是否传入了map对象，否则使用HGIS.InitParam里面的值
		var tmpBound = null;
		if(HGIS.Utils._map !== null&&HGIS.Utils._map !== ""&&HGIS.Utils._map !== undefined){
			tmpBound = HGIS.Utils._map.maxExtent;
		}else{
			tmpBound = HGIS.InitParam.extent;
		}
		//未判断bound里面的值是否缺省
		if(obj instanceof HGIS.LonLat){
			var isIn1 = true;
			if((obj.lon < tmpBound.left)||(obj.lon > tmpBound.right)){
				isIn1 = false
			}else if((obj.lat > tmpBound.top)||(obj.lat < tmpBound.bottom)){
				isIn1 = false;
			}
			return isIn1;
		}else if(obj instanceof HGIS.Geometry){
			var objBounds = obj.bounds;
			var isIn2 = true;
			if(objBounds.left < tmpBound.left){
				isIn2 = false;
			}else if(objBounds.right > tmpBound.right){
				isIn2 = false;
			}else if(objBounds.top > tmpBound.top){
				inIn2 = false;
			}else if(objBounds.bottom < tmpBound.bottom){
				isIn2 = false;
			}
			return isIn2;
		}else{
			throw new Error('notSupport!');  
		}
	},
	/**
	 * APIMethod: screenShot
	 * 地图截图
	 * 
	 * Parameters:
	 * x - {Int} 截取范围屏幕x坐标, 像素单位
	 * y - {Int} 截取范围屏幕y坐标, 像素 单位
	 * w - {Int} 截取范围宽度,像素单位
	 * h - {Int} 截取范围高度, 像素单位
	 * resultFunction - {Object} 截图成功的回调函数
	 * faultFunction - {Object} 截图失败的回调函数
	 */
	screenShot : function(x, y, w, h, resultFunction, faultFunction) {
		var dom = document.getElementsByTagName('html')[0].innerHTML;// $("html").html();
		dom = '<!DOCTYPE html><html>' + dom + '</html>';
		var url = APIAdress.substr(0, APIAdress.length - 5) + "/";
		dom = dom
				.replace('</title>', '</title><base href=' + url + '/>')
				.replace(
						'smControlDrawFeatureActive" style="position: relative;',
						'smControlDrawFeatureActive" style="position: absolute;');
		dom = encodeURIComponent(dom);
		var params = {
			"dom" : dom,
			"x" : x,
			"y" : y,
			"w" : w,
			"h" : h,
			"width" : document.body.clientWidth,
			"height" : document.body.clientHeight
		};
		HGIS.Utils.send(screenShotUrl,params,"POST","text",resultFunction,faultFunction);
	},

	/**
	 * APIMethod :wkb2geom
	 * WKB转geometry
	 * 
	 * Parameters :
	 * bytes -{Byte[]} 二进制字节数组
	 * 
	 * Returns:
	 * {Geometry} geometry对象
	 * 
	 */
	wkb2geom : function(bytes) {
		var str = "";
		for (var i = 0; i < bytes.length; i++) {
			var tmp = bytes[i].toString(16);
			if (tmp.length == 1) {
				tmp = "0" + tmp;
			}
			str += tmp;
		}
		return str;
	},
	/**
	 * APIMethod: getTextSize
	 * 获取文本内容的大小
	 */
	getTextSize : function(text, fontSize, fontFamily) {
		var textWidthSpan = document.getElementById('text_width_span');
		if (!textWidthSpan) {
			textWidthSpan = document.createElement("span");
			document.body.appendChild(textWidthSpan);
			textWidthSpan.setAttribute('id', 'text_width_span');
			textWidthSpan.style.position = 'absolute';
			textWidthSpan.style.top = '-10000px';
			textWidthSpan.style.left = '-10000px';
		}
		textWidthSpan.style.fontSize = '13px';
		textWidthSpan.style.fontFamily = '\'宋体\'';
		if (fontSize) {
			textWidthSpan.style.fontSize = fontSize + 'px';
		}
		if (fontFamily) {
			textWidthSpan.style.fontFamily = '\'' + fontFamily + '\'';
		}
		textWidthSpan.innerText = text;
		return {
			width : textWidthSpan.offsetWidth,
			height : textWidthSpan.offsetHeight
		};
	},
	/**
	 * APIMethod: wkt2Geom
	 * 将wkt字符串转化为{ <HGIS.Geometry> }对象.
	 * 
	 * Parameters:
	 * wkt - {String} wkt 字符串
	 * 
	 * Returns:
	 * {<HGIS.Geometry>}
	 */
	wkt2Geom : function(wkt) {
		var wktobj = new HGIS.Format.WKT();
		var v = wktobj.read(wkt);
		return v.geometry;
	},
	/**
	 * APIMethod: isSupportCanvas
	 * 判断是否支持Canvas
	 * 
	 * Returns:
	 * {boolean} 是否支持canvas
	 */
	isSupportCanvas:function(){
		 var elem = document.createElement('canvas');
	     return !!(elem.getContext && elem.getContext('2d'));
	},
	/**
	 * APIMethod: createSector
	 * 创建扇形.
	 * 
	 * Parameters:
	 * point - {<HGIS.Geometry.Point>} 扇形圆心.
	 * radius - {Number} 扇形半径.
	 * direction - {Number} 扇形的方向角. 
	 * angle - {Number} 扇形的张角.
	 * arcSegmentNum - {Number} 扇形弧上的分段数，可选参数，默认值为100
	 * 
	 * Returns: 
	 * {<HGIS.Geometry.Polygon>} 返回一个扇形的geometry对象.
	 * 
	 * 示例:
	 *  (code) 
	 *  //创建一个扇形对象 
	 *  var p=new HGIS.Geometry.Point(120,30);
	 *  var sec=HGIS.Util.createSector(p,10,45,120); 
	 * (end)
	 */
	createSector : function(point, radius, direction, angle, arcSegmentNum) {
		if(radius<=0){
			return null;
		}
		// 计算point所在位置每一度能代表多少米
		if (HGIS.InitParam.mapUnit == "degrees") {
			var distSpan = HGIS.MapEx.prototype.degreeSpanToMeter.apply(this, [point.y, "degrees" ]);
			radius = radius / distSpan;
		}
		// 把参数visibleDist转化为地图度
		// 可视域环数组，用来存储每一个圆弧上的点
		// 弧形的分段数，值越大越精细
		var duraSides = arcSegmentNum?arcSegmentNum:100;
		// 起始点弧度 ，本系统以正东为起始方向
		var startAngle = (direction - angle / 2.0) * (Math.PI / 180);
		// 每个点之间的弧度间隔
		var angle = (angle / duraSides) * (Math.PI / 180);
		var points = [];
		points.push(point);
		for (var i = 0; i <= duraSides ; i = i + 1) {
			var rotation = startAngle + i * angle;
			var x = point.x + (radius * Math.cos(rotation));
			var y = point.y + (radius * Math.sin(rotation));
			points.push(new HGIS.Geometry.Point(x, y));
		}
		var ring = new HGIS.Geometry.LinearRing(points);
		var sector = new HGIS.Geometry.Polygon([ ring ]);
		return sector;
	},
	/**
	 * APIMethod: createSectorByEquidistance
	 * 创建扇形.在地理坐标系下扇形边等距
	 * 
	 * Parameters:
	 * point - {<HGIS.Geometry.Point>} 扇形圆心.
	 * radius - {Number} 扇形半径.
	 * direction - {Number} 扇形的方向角. 
	 * angle - {Number} 扇形的张角.
	 * arcSegmentNum - {Number} 扇形弧上的分段数，可选参数，默认值为100
	 * 
	 * Returns: 
	 * {<HGIS.Geometry.Polygon>} 返回一个扇形的geometry对象.
	 * 
	 * 示例:
	 *  (code) 
	 *  //创建一个扇形对象 
	 *  var p=new HGIS.Geometry.Point(120,30);
	 *  var sec=createSectorByEquidistance(p,10,45,120); 
	 * (end)
	 */
	createSectorByEquidistance : function(point, radius, direction, angle, arcSegmentNum) {
		if(radius<=0){
			return null;
		}
		// 可视域环数组，用来存储每一个圆弧上的点
		// 弧形的分段数，值越大越精细
		var duraSides = arcSegmentNum?arcSegmentNum:100;
		// 起始点弧度 ，本系统以正东为起始方向
		var startAngle = (direction - angle / 2.0) * (Math.PI / 180);
		// 每个点之间的弧度间隔
		var angle = (angle / duraSides) * (Math.PI / 180);
		var points = [];
		points.push(point);
		if(HGIS.InitParam.geodesic){
			var centerLonLat = new HGIS.LonLat(point.x,point.y);
			for (var i = 0; i <= duraSides; i = i + 1) {
				rotatedAngle = (startAngle + i * angle)*180/Math.PI;
				plonlat = HGIS.Util.destinationVincenty(centerLonLat,rotatedAngle,radius);
				points.push(  new HGIS.Geometry.Point(plonlat.lon, plonlat.lat) );
			}
		}else{
			for (var i = 0; i <= duraSides; i = i + 1) {
				var rotation = startAngle + i * angle;
				var x = point.x + (radius * Math.cos(rotation));
				var y = point.y + (radius * Math.sin(rotation));
				points.push(new HGIS.Geometry.Point(x, y));
			}
		}
		var ring = new HGIS.Geometry.LinearRing(points);
		var sector = new HGIS.Geometry.Polygon([ ring ]);
		return sector;
	},
	
	/**
	 * APIMethod: createCircle
	 * 创建圆.
	 * 
	 * Parameters:
	 * center - {<HGIS.Geometry.Point>} 中心点.
	 * radius - {Number} 半径,单位米.
	 * arcSegmentNum - {Number} 整个圆被分成的弧段总数,默认值为100，该值可以不传。
	 * 
	 * Returns:
	 * {<HGIS.Geometry.Polygon>} 返回一个扇形的geometry对象.当半径radius小于等于0时，返回null;
	 * 
	 * 示例: 
	 * (code)
	 *  //创建一个扇形对象
	 *  var p=new HGIS.Geometry.Point(120,30); 
	 *  var circle=createCircle(p,10);
	 * (end)
	 */
	createCircle : function(center, radius,arcSegmentNum) {
		if(radius<=0){
			return null;
		}
		// 计算摄像头所在位置每一度能代表多少米
		if (HGIS.InitParam.mapUnit == "degrees") {
			var distSpan = HGIS.MapEx.prototype.degreeSpanToMeter.apply(this, [center.y, "degrees" ]);
			radius = radius / distSpan;
		}
		var segmentNum = arcSegmentNum?arcSegmentNum:100;
		var rings = new Array();// 可视域环数组，用来存储每一个
		var angle = Math.PI * (1 / segmentNum);
		var rotation = 0; // 起点偏转的角度。（以正东方向为起点0度，逆时针方向为正）
		if (rotation) {
			angle += (rotation / 180) * Math.PI;
		}
		var rotatedAngle, x, y;
		var points = [];
		for (var i = 0; i <= segmentNum; i = i + 1) {
			rotatedAngle = angle + (i * 2 * Math.PI / segmentNum);
			x = Number(center.x) + (radius * Math.cos(rotatedAngle));
			y = Number(center.y) + (radius * Math.sin(rotatedAngle));
			points.push(new HGIS.Geometry.Point(x, y));
		}
		var ring = new HGIS.Geometry.LinearRing(points);
		var circle = new HGIS.Geometry.Polygon([ ring ]);
		return circle;
	},
	/**
	 * APIMethod: createCircleByEquidistance
	 * 创建圆.属于实际意义上的圆，在4326坐标系下依据等距原则，因投影转换的原因，直观看到的将是椭圆形;createCircle方法为生成直观意义上的圆
	 * 
	 * Parameters:
	 * center - {<HGIS.Geometry.Point>} 中心点.
	 * radius - {Number} 半径,单位米.
	 * arcSegmentNum - {Number} 整个圆被分成的弧段总数,默认值为100，该值可以不传。
	 * 
	 * Returns:
	 * {<HGIS.Geometry.Polygon>} 返回一个扇形的geometry对象.当半径radius小于等于0时，返回null;
	 * 
	 * 示例: 
	 * (code)
	 *  //创建一个扇形对象
	 *  var p=new HGIS.Geometry.Point(120,30); 
	 *  var circle=createCircleByEquidistance(p,10,100);
	 * (end)
	 */
	createCircleByEquidistance : function(center, radius,arcSegmentNum) {
		if(radius<=0){
			return null;
		}
		var segmentNum = arcSegmentNum?arcSegmentNum:100;
		var rings = new Array();// 可视域环数组，用来存储每一个
		/*var angle = Math.PI * (1 / segmentNum);
		var vangle = 2*angle; // 设定每次计算的角度
		var rotation = 0; // 起点偏转的角度。（以正东方向为起点0度，逆时针方向为正）
		if (rotation) {
			angle += (rotation / 180) * Math.PI;
		}*/
		var points = this.getCruvePoint(center,radius,0,segmentNum);
		var ring = new HGIS.Geometry.LinearRing(points);
		var circle = new HGIS.Geometry.Polygon([ ring ]);
		return circle;
	},
	/**
	 * Method: getCruvePoint
	 * 获取圆弧上的点，适用于 圆、扇形 、圆环的公用方法
	 * center : 中心点
	 * radius ： 半径
	 * rotatedAngle ： 起始角度
	 * angle：
	 */
	getCruvePoint : function(center,radius,rotatedAngle,segmentNum){
		var angle =  Math.PI * (1 / segmentNum)
		var x,y,rotatedAngle,plonlat;
		var points = [];
		if(HGIS.InitParam.geodesic){
			var centerLonLat = new HGIS.LonLat(center.x,center.y);
			for (var i = 0; i <= segmentNum; i = i + 1) {
				rotatedAngle = (angle + i * angle*2)*180/Math.PI;
				plonlat = HGIS.Util.destinationVincenty(centerLonLat,rotatedAngle,radius);
				points.push(  new HGIS.Geometry.Point(plonlat.lon, plonlat.lat) );
			}
		}else{
			for (var i = 0; i <= segmentNum; i = i + 1) {
				rotatedAngle = angle + (i  * angle*2);
				x = Number(center.x) + (radius * Math.cos(rotatedAngle));
				y = Number(center.y) + (radius * Math.sin(rotatedAngle));
				points.push(new HGIS.Geometry.Point(x, y));
			}
		}
		return points;
	},
	
	/**
	 * APIMethod: caculateDistance
	 * 计算两点之间的距离
	 * 
	 * Parameters:
	 * point1 - {<HGIS.Geometry.Point>} 第一个点对象
	 * point2 - {<HGIS.Geometry.Point>} 第二个点对象
	 * 
	 * Returns:
	 * {Number} 两点之间的距离，单位米
	 */
	caculateDistance : function(point1, point2) {
		if (HGIS.InitParam.mapUnit == "degrees") {
			if (typeof (point1.lon) == "undefined") {
				var x1 = point1.x;
				var y1 = point1.y;
				var x2 = point2.x;
				var y2 = point2.y;
				point1 = new HGIS.LonLat();
				point2 = new HGIS.LonLat();
				point1.lon = x1;
				point1.lat = y1;
				point2.lon = x2;
				point2.lat = y2;
			}
			return HGIS.Util.distVincenty(point1, point2) * 1000
		} else {
			var len = 0;
			if (typeof (point1.x) == "undefined")
				len = Math.sqrt((point1.lon - point2.lon)
						* (point1.lon - point2.lon) + (point1.lat - point2.lat)
						* (point1.lat - point2.lat))
			else
				len = Math.sqrt((point1.x - point2.x) * (point1.x - point2.x)
						+ (point1.y - point2.y) * (point1.y - point2.y))
			return parseFloat(len.toFixed(1));
		}
	},
	/**
	 * APIMethod: createCircleRing
	 * 创建圆环.
	 * 
	 * Parameters: 
	 * center - {<HGIS.Geometry.Point>} 中心点. 
	 * minRadius - {Number} 内环半径.
	 * maxRadius - {Number} 外环半径.
	 * 
	 * Returns:
	 * {<HGIS.Geometry.Polygon>} 返回一个扇形的geometry对象.
	 * 
	 * Examples: 
	 * (code)
	 *   //创建一个扇形对象 
	 *	 var p=new HGIS.Geometry.Point(120,30); 
	 * 	 var circle=createCircle(p,10,20); 
	 * (end)
	 */
	createCircleRing : function(center, minRadius, maxRadius,arcSegmentNum) {
		if(minRadius<= 0 || maxRadius<= 0 ){
			return null;
		}
		if (HGIS.InitParam.mapUnit == "degrees") {
			var distSpan = HGIS.MapEx.prototype.degreeSpanToMeter.apply(this, [center.y, "degrees" ]);
			minRadius = minRadius / distSpan;
			maxRadius = maxRadius / distSpan;
		}
		var rings = new Array();// 可视域环数组，用来存储每一个
		var angle = Math.PI * (1 / 50);
		var rotation = 0; // 起点偏转的角度。（以正东方向为起点0度，逆时针方向为正）
		if (rotation) {
			angle += (rotation / 180) * Math.PI;
		}
		var rotatedAngle, x, y;
		// 环的大圆
		var pointsMax = [];
		// 环的小圆
		var pointsMin = [];
		for (var i = 0; i <= 50; i = i + 1) {
			rotatedAngle = angle + (i * 2 * Math.PI / 50);
			x = Number(center.x) + (maxRadius * Math.cos(rotatedAngle));
			y = Number(center.y) + (maxRadius * Math.sin(rotatedAngle));
			pointsMax.push(new HGIS.Geometry.Point(x, y));
		}
		var ringMax = new HGIS.Geometry.LinearRing(pointsMax);

		for (var i = 0; i <= 50; i = i + 1) {
			rotatedAngle = angle + (i * 2 * Math.PI / 50);
			x = center.x + (minRadius * Math.cos(rotatedAngle));
			y = center.y + (minRadius * Math.sin(rotatedAngle));
			pointsMin.push(new HGIS.Geometry.Point(x, y));
		}
		var ringMin = new HGIS.Geometry.LinearRing(pointsMin);
		var polygon = new HGIS.Geometry.Polygon([ ringMax, ringMin ]);
		return polygon;
	},
	
	/**
	 * APIMethod: createCircleRingByEquidistance
	 * 创建圆环.依据等距离原则
	 * 
	 */
	createCircleRingByEquidistance : function(center, minRadius, maxRadius,arcSegmentNum) {
		if(minRadius<= 0 || maxRadius<= 0 ){
			return null;
		}
		var rings = new Array();// 可视域环数组，用来存储每一个
		var segmentNum = arcSegmentNum?arcSegmentNum:100;
		/*var rotatedAngle, x, y;*/
		// 环的大圆
		var pointsMax = [];
		// 环的小圆
		var pointsMin = [];
		var pointsMax = this.getCruvePoint(center,maxRadius,0,segmentNum);
		var pointsMin = this.getCruvePoint(center,minRadius,0,segmentNum);
		var ringMax = new HGIS.Geometry.LinearRing(pointsMax);
		var ringMin = new HGIS.Geometry.LinearRing(pointsMin);
		var polygon = new HGIS.Geometry.Polygon([ ringMin , ringMax ]);
		return polygon;
	},
	/**
	 * APIMethod: tranferDegree
	 * 坐标值数字格式转换,从十进制度转换为度分秒的格式。例如，从XXX.XX度格式转换到XXX度XXX分XXX秒的格式.
	 * 
	 * Parameters:
	 * degree - {Number} 十进制度.
	 * 
	 * Returns:
	 * {String} dms json格式，其中：d表示度，mi表示分，s表示秒.
	 */
	tranferDegree : function(degree) {
		var numArr = degree.toString().split(".");
		var d = numArr[0] * 1;// 度
		var xd = 60 * numArr[1] / Math.pow(10, numArr[1].length);
		var fArr = xd.toString().split(".");
		var f = fArr[0] * 1;
		var m = fArr[1] * 1 / Math.pow(10, fArr[1].length) * 60;
		var tranferedDegree = (d * 3600 + f * 60 + m) * 100;
		var dms = {
			"d" : d,
			"mi" : f,
			"s" : m
		};
		return dms;
	},
	/**
	 * APIMethod: getExendByDiv 
	 * 根据指定的DIV，构造一个含有缓冲带地理边界范围（警卫安保项目,暂不启用）.
	 * 
	 * Parameters:
	 *  map - {<HGIS.Map>} 地图对象.
	 *  divid - {String} 页面div元素标识.
	 *  buffer - {Number} 缓冲距离
	 * 
	 * Returns:
	 * {<HGIS.Bounds>} 返回一个 Bounds 对象.
	 */
	getExendByDiv : function(map, divid, buffer) {
		var div=document.getElementById(divid);
		var ptop = div.offset().top;// 当前元素位置;
		var pleft = div.offset().left;// 当前元素位置;
		var width = div.width(), height =div.height();// 当前元素宽与高
		// 元素四至
		var left = pleft - buffer, bottom = ptop + height + buffer, right = pleft
				+ width + buffer, top = ptop - buffer;
		// 像素位置转换为经纬度位置
		var bounds = new HGIS.Bounds();
		var minPos = map.getLonLatFromPixel(new HGIS.Pixel(left, bottom));
		bounds.extend(minPos);
		var maxPos = map.getLonLatFromPixel(new HGIS.Pixel(right, top));
		bounds.extend(maxPos);
		return bounds;
	},

	/**
	 * APIMethod: getExploreType
	 *  获取当前正在使用浏览器类型.
	 */
	getExploreType : function() {
		if (navigator.userAgent.indexOf("MSIE") > 0) {
			return "MSIE";
		} else if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
			return "Firefox";
		} else if (isSafari = navigator.userAgent.indexOf("Safari") > 0) {
			return "Safari";
		} else if (isCamino = navigator.userAgent.indexOf("Camino") > 0) {
			return "Camino";// Camino浏览器
		} else if (isMozilla = navigator.userAgent.indexOf("Gecko/") > 0) {
			return "Gecko";
		} else {
			return "unkownExplore";
		}
	},
	
	/**
	 * APIMethod: getUrlByExpolreType
	 * 根据浏览器类决定请求市场采用jsonp 还是使用hgis常规的send请求方法
	 */
	getUrlByExpolreType : function(url) {
		if( "MSIE" === HGIS.Utils.getExploreType() ){
			url = url +"?f=jsonp" ;
			return url ;
		}else{
			return url;
		}
	},
	
	/**
	 * send请求异步的的设定,---参数不对外暴露
	 */
	_asynchronous :true ,
	/**
	 * APIFunction: send
	 *  HGIS的统一服务请求类，类似于ajax请求，此处为异步请求.
	 *  
	 * Parameters:
	 * url - {String} 请求地址.
	 * params - {Object} 请求参数.
	 * requestType - {String} 请求方式。一般为"GET"或"POST"
	 * resultType - {String} 返回的数据格式。默认为"json"
	 * successHandler - {Function} 响应成功时的回调函数
	 * errorHandler - {function} 响应失败时的回调函数
	 */
	send : function(url, params, requestType, resultType, successHandler, errorHandler) {
		// 写Http请求
		//判断是否为跨域请求
		var domain = document.domain;
		var port=window.location.port;
		var iscorsdomain=false;
		//如果页面地址和服务地址ip和端口不同则视为跨域
		if(url.indexOf("http")>=0&&url.indexOf(domain+":"+port) <= 0){
			iscorsdomain=true;
		}
		var xmlHttp= new XMLHttpRequest();
		xmlHttp.onreadystatechange = function() {
			if (xmlHttp.readyState == 4) {
				var status = xmlHttp.status;
				if (status >= 200 && status < 300 || status === 304 || status === 1223) {
					var responseStr = xmlHttp.responseText;
					var result = null;
					if (resultType == "text") {
						result = responseStr;
					} else if (resultType == "json") {
						if (responseStr == "")
							result = {
								"message" : "success"
							};
						else{
							result = JSON.parse(responseStr);
						}
							
					} else if (resultType == "xml") {
						result = xmlHttp.responseXML;
					} else {
						alert(HGIS.language[HGIS.InitParam.language]["only_supportType"] ); //"只支持 text json 和 xml三种格式，请检查resultType参数是否正确" 
					}
					successHandler(result);
				} else {
					var errorStr = "error:" + status;
					errorHandler(errorStr);
				}
			}
		};
		if ((navigator.appName == "Microsoft Internet Explorer" && navigator.appVersion
				.split(";")[1].replace(/[ ]/g, "") == "MSIE6.0" && iscorsdomain)
				|| (navigator.appName == "Microsoft Internet Explorer" && navigator.appVersion
						.split(";")[1].replace(/[ ]/g, "") == "MSIE7.0" && iscorsdomain)
				|| (navigator.appName == "Microsoft Internet Explorer" && navigator.appVersion
						.split(";")[1].replace(/[ ]/g, "") == "MSIE8.0" && iscorsdomain)
				|| (navigator.appName == "Microsoft Internet Explorer" && navigator.appVersion
						.split(";")[1].replace(/[ ]/g, "") == "MSIE9.0") && iscorsdomain) {
			params=params||{};
			params.url=url;
			params.requestType=requestType;
			var sendStr = "";
			for ( var key in params) {
				sendStr += key + "=" + params[key] + "&";
			}
			sendStr = sendStr.substring(0, sendStr.length - 1);
			if(HGIS.ProxyUrl){
				url = HGIS.ProxyUrl + "?" + sendStr;
			}
			xmlHttp.open("GET",url, this._asynchronous);
			xmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded;charset=UTF-8");
			xmlHttp.send(sendStr);
		}else{
			xmlHttp.open(requestType, url, this._asynchronous);
			if(requestType.toLowerCase()=="get"){
				xmlHttp.setRequestHeader("Content-Type","text/html;charset=UTF-8");
			}else if(requestType.toLowerCase()=="post"){
				var newParams=params;
				params="";
				var i=0
				for ( key in newParams){
					if(i==0){
						params+=key+"="+newParams[key];
					}else{
						params+="&"+key+"="+newParams[key];
					}
					i++
				} 
				xmlHttp.setRequestHeader("Content-Type","application/x-www-form-urlencoded;charset=UTF-8");
			}
			xmlHttp.send(params);
		}
	},
	
	/**
	 * APIMethod: unionJson
	 * 把多个json合并成一个新的json对象.
	 * 
	 * Parameters:
	 * jsonArr - {Array} JSON数组,例：jsonobj1={"a":1,"b":2} ;jsonobj2={"c":3,"d":4}...
	 */
	unionJson : function(jsonArr) {
		var jsonobj = {};
		// 遍历jsonArr，取出数组中的各个JSON对象
		for (var i = 0; i < jsonArr.length; i = i + 1) {
			for ( var attr in jsonArr[i]) {
				jsonobj[attr] = jsonArr[i][attr];
			}
		}
		return jsonobj;
	},

	/**
	 * APIMethod: randomColor
	 * 生成随机颜色.
	 */
	randomColor : function() {
		var str = "0123456789abcdef";
		var t = "#";
		for (var j = 0; j < 6; j = j + 1) {
			t = t + str.charAt(Math.random() * str.length);
		}
		return t;
	},

	/**
	 * APIMethod: json2str
	 * 将json对象转成string.
	 */
	json2str : function(o) {
		if (o == undefined) {
			return "";
		}
		var r = [];
		if (typeof o == "string")
			return "\""
					+ o.replace(/([\"\\])/g, "\\$1").replace(/(\n)/g, "\\n")
							.replace(/(\r)/g, "\\r").replace(/(\t)/g, "\\t")
					+ "\"";
		if (typeof o == "object") {
			if (!o.sort) {
				for ( var i in o)
					r.push("\"" + i + "\":" + json2str(o[i]));
				if (!!document.all
						&& !/^\n?function\s*toString\(\)\s*\{\n?\s*\[native code\]\n?\s*\}\n?\s*$/
								.test(o.toString)) {
					r.push("toString:" + o.toString.toString());
				}
				r = "{" + r.join() + "}"
			} else {
				for (var i = 0; i < o.length; i++)
					r.push(json2str(o[i]))
				r = "[" + r.join() + "]";
			}
			return r;
		}
		return o.toString().replace(/\"\:/g, '":""');
	},

	/**
	 * APIMethod: objArr2Json
	 * js对象数组转换成json字符串.
	 */
	objArr2Json : function(objArr) {
		var jsonstr = "[";
		for (var i = 0; i < objArr.length; i++) {
			if (i == objArr.length - 1)
				jsonstr = jsonstr + this.json2str(objArr[i]) + "]";
			else
				jsonstr = jsonstr + this.json2str(objArr[i]) + ",";
		}
		return jsonstr;
	},

	/**
	 * APIMethod: checkChinese
	 * 检测一个字符串是中文还是英文.
	 * 
	 * Parameters:
	 * str - {String} 中文或英文字符串.
	 * 
	 * Returns:
	 * {Boolean} 如果是str字符，则返回true,否则返回false.
	 */
	checkChinese : function(str) {
		var reg = new RegExp("[\\u4E00-\\u9FFF]+", "g");
		var flag = reg.test(str);
		return flag;
	},

	/**
	 * APIMethod: JSONResultData
	 * 字符串转化成JSON格式.
	 * 
	 * Parameters:
	 * resultStr - {String} 传入的字符串格式.
	 */
	JSONResultData : function(resultStr) {
		var _returnFlag = -1;
		var _returnInfo = "数据为空！";
		var _data;
		var resultObj;
		{
			if (resultStr == null || resultStr == "") {
				_returnFlag = -1;
				_returnInfo = "数据为空！";
				return;
			}
			try {
				var type = typeof (resultStr);
				if (type == "string") {
					resultObj = JSONUtil["parseJSON"](resultStr);
				} else {
					resultObj = resultStr;
				}
				if (resultObj != null) {
					_returnFlag = resultObj["ReturnFlag"];
					_returnInfo = resultObj["ReturnInfo"];
					_data = resultObj["Data"];
				}
			} catch (e) {
				_returnFlag = -1;
				_returnInfo = "解析列表数据为JSon时出错！";
			}
		}
		this["getData"] = function() {
			try {
				if (_data == null || _data == "") {
					return null;
				}
				if (_data instanceof String) {
					var result = JSONUtil["parseJSON"](_data);
					_data = result;
					return result;
				} else {
					return _data;
				}
			} catch (e) {
				return null;
			}
			return null;
		};
		this["getReturnFlag"] = function() {
			return _returnFlag;
		};
		this["getReturnInfo"] = function() {
			return _returnInfo;
		};
		this["getResult"] = function() {
			return resultObj;
		};

	},
	/**
	 * APIMethod: getSafeAddress
	 * 返回安全的url地址.
	 * 
	 * Parameters:
	 * OriginalUrl - {String} 字符串格式，原始的url.
	 * 
	 * Returns:
	 * {String} 字符串格式 安全的url地址
	 */
	 getSafeAddress:function(originalUrl){	
		var safeUrl = originalUrl;
		//增加安全代理 https://10.33.42.60/ngx/proxy?url=http://10.6.134.34:8083/nexus/images/nexus200x50.png
		if(window.location.protocol=="https:" && (originalUrl.indexOf("https:")<0)){//是https安全请求且originalUrl中不是https地址
			safeUrl= safeProxyURL + HGISBase64.encode(originalUrl);
		}
		return safeUrl;
	}

};

/**
 * APIMethod:Array.max
 * 返回数值型数组的最大值

 * Parameters:
 * array - {Array}数值型数组
 * 
 * Returns:
 * {Number} 数值型数组中的最大值
 */
Array.max = function(array) {
	return Math.max.apply(Math, array);
};

/**
 * APIMethod: Array.min
 * 
 * Parameters:
 * array - {Array} 数值型数组
 * 
 */
Array.min = function(array) {
	return Math.min.apply(Math, array);
};
/**
 * APIMethod: Array.existValue
 * 检测数据组中是否存在某个元素value,如果存在，则返回一个包括存在对象，否则返回false
 * 
 * Parameters:
 *   array - {Array} 数组
 *   value - {Object} 数组中的值
 */
Array.existValue = function(arr, value) {
	var a = {
		arrObj : "undefind",
		flag : false
	};
	for (var i = 0; i < arr.length; i = i + 1) {
		if (arr[i] == value) {
			a.arrObj = arr[i];
			a.flag = true;
			return arrObj;
			break;
		}
	}
	return a;
}
/**
 * APIMethod: Array.in_array
 * 返回要匹配的元素在当前数组中的索引。
 * 
 * Parameters:
 * e - {Object}  用以匹配的某个元素
 * 
 * Returns:
 * {Number} 如果找到了则回索引值，否则返回“undefind”。
 */
Array.prototype.in_array = function(e) {
	var index = "undefind";
	for (var i = 0; i < this.length; i = i + 1) {
		if (this[i] == e) {
			index = i;
			break;
		}
	}
	return index;
};

/*******************************************************************************
 * 字符串和json对象的相互转换 扩展了现代浏览器的JSON对象，实现IE下json和字符串相互转换
 * 
 * @function JSON.parse(string) 将字符串解析程JSON对象
 * @function JSON.stringify(object) 将json转为字符串
 */
/** ***********************JSON对象兼容IE浏览器开始**************************************** */
if (typeof JSON !== 'object') {
	JSON = {};
}
(function() {
	'use strict';
	function f(n) {
		return n < 10 ? '0' + n : n;
	}
	if (typeof Date.prototype.toJSON !== 'function') {

		Date.prototype.toJSON = function() {

			return isFinite(this.valueOf()) ? this.getUTCFullYear() + '-'
					+ f(this.getUTCMonth() + 1) + '-' + f(this.getUTCDate())
					+ 'T' + f(this.getUTCHours()) + ':'
					+ f(this.getUTCMinutes()) + ':' + f(this.getUTCSeconds())
					+ 'Z' : null;
		};
		String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function() {
			return this.valueOf();
		};
	}
	var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = { // table
		// of
		// character
		// substitutions
		'\b' : '\\b',
		'\t' : '\\t',
		'\n' : '\\n',
		'\f' : '\\f',
		'\r' : '\\r',
		'"' : '\\"',
		'\\' : '\\\\'
	}, rep;
	function quote(string) {
		escapable.lastIndex = 0;
		return escapable.test(string) ? '"'
				+ string.replace(escapable,
						function(a) {
							var c = meta[a];
							return typeof c === 'string' ? c : '\\u'
									+ ('0000' + a.charCodeAt(0).toString(16))
											.slice(-4);
						}) + '"' : '"' + string + '"';
	}
	function str(key, holder) {
		var i, // The loop counter.
		k, // The member key.
		v, // The member value.
		length, mind = gap, partial, value = holder[key];
		if (value && typeof value === 'object'
				&& typeof value.toJSON === 'function') {
			value = value.toJSON(key);
		}
		if (typeof rep === 'function') {
			value = rep.call(holder, key, value);
		}
		switch (typeof value) {
		case 'string':
			return quote(value);

		case 'number':
			return isFinite(value) ? String(value) : 'null';
		case 'boolean':
		case 'null':
			return String(value);
		case 'object':
			if (!value) {
				return 'null';
			}
			gap += indent;
			partial = [];
			if (Object.prototype.toString.apply(value) === '[object Array]') {
				length = value.length;
				for (i = 0; i < length; i += 1) {
					partial[i] = str(i, value) || 'null';
				}
				v = partial.length === 0 ? '[]' : gap ? '[\n' + gap
						+ partial.join(',\n' + gap) + '\n' + mind + ']' : '['
						+ partial.join(',') + ']';
				gap = mind;
				return v;
			}
			if (rep && typeof rep === 'object') {
				length = rep.length;
				for (i = 0; i < length; i += 1) {
					if (typeof rep[i] === 'string') {
						k = rep[i];
						v = str(k, value);
						if (v) {
							partial.push(quote(k) + (gap ? ': ' : ':') + v);
						}
					}
				}
			} else {
				for (k in value) {
					if (Object.prototype.hasOwnProperty.call(value, k)) {
						v = str(k, value);
						if (v) {
							partial.push(quote(k) + (gap ? ': ' : ':') + v);
						}
					}
				}
			}
			v = partial.length === 0 ? '{}' : gap ? '{\n' + gap
					+ partial.join(',\n' + gap) + '\n' + mind + '}' : '{'
					+ partial.join(',') + '}';
			gap = mind;
			return v;
		}
	}
	if (typeof JSON.stringify !== 'function') {
		JSON.stringify = function(value, replacer, space) {
			var i;
			gap = '';
			indent = '';
			if (typeof space === 'number') {
				for (i = 0; i < space; i += 1) {
					indent += ' ';
				}
			} else if (typeof space === 'string') {
				indent = space;
			}
			rep = replacer;
			if (replacer
					&& typeof replacer !== 'function'
					&& (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
				throw new Error('JSON.stringify');
			}
			return str('', {
				'' : value
			});
		};
	}
	if (typeof JSON.parse !== 'function') {
		JSON.parse = function(text, reviver) {
			var j;
			function walk(holder, key) {
				var k, v, value = holder[key];
				if (value && typeof value === 'object') {
					for (k in value) {
						if (Object.prototype.hasOwnProperty.call(value, k)) {
							v = walk(value, k);
							if (v !== undefined) {
								value[k] = v;
							} else {
								delete value[k];
							}
						}
					}
				}
				return reviver.call(holder, key, value);
			}
			text = String(text);
			cx.lastIndex = 0;
			if (cx.test(text)) {
				text = text.replace(cx,
						function(a) {
							return '\\u'
									+ ('0000' + a.charCodeAt(0).toString(16))
											.slice(-4);
						});
			}
			if (/^[\],:{}\s]*$/
					.test(text
							.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
							.replace(
									/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
									']').replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
				j = eval('(' + text + ')');
				return typeof reviver === 'function' ? walk({
					'' : j
				}, '') : j;
			}
			throw new SyntaxError('JSON.parse');
		};
	}
}());
/** ***********************JSON对象兼容IE浏览器结束**************************************** */

/** ***********************xml转化成JSON**************************************** */

var xml2Json = {
	parser : function(xmlcode, ignoretags, debug) {
		if (!ignoretags) {
			ignoretags = ""
		}
		xmlcode = xmlcode.replace(/\s*\/>/g, '/>');
		xmlcode = xmlcode.replace(/<\?[^>]*>/g, "").replace(/<\![^>]*>/g, "");
		if (!ignoretags.sort) {
			ignoretags = ignoretags.split(",")
		}
		var x = this.no_fast_endings(xmlcode);
		x = this.attris_to_tags(x);
		x = escape(x);
		x = x.split("%3C").join("<").split("%3E").join(">").split("%3D").join(
				"=").split("%22").join("\"");
		for (var i = 0; i < ignoretags.length; i++) {
			x = x.replace(new RegExp("<" + ignoretags[i] + ">", "g"), "*$**"
					+ ignoretags[i] + "**$*");
			x = x.replace(new RegExp("</" + ignoretags[i] + ">", "g"), "*$***"
					+ ignoretags[i] + "**$*")
		}
		x = '<JSONTAGWRAPPER>' + x + '</JSONTAGWRAPPER>';
		this.xmlobject = {};
		var y = this.xml_to_object(x).jsontagwrapper;
		if (debug) {
			y = this.show_json_structure(y, debug)
		}
		return y
	},
	xml_to_object : function(xmlcode) {
		var x = xmlcode.replace(/<\//g, '?');
		x = x.split("<");
		var y = [];
		var level = 0;
		var opentags = [];
		for (var i = 1; i < x.length; i++) {
			var tagname = x[i].split(">")[0];
			opentags.push(tagname);
			level++
			y.push(level + "<" + x[i].split("?")[0]);
			while (x[i].indexOf("?" + opentags[opentags.length - 1] + ">") >= 0) {
				level--;
				opentags.pop()
			}
		}
		var oldniva = -1;
		var objname = "this.xmlobject";
		for (var i = 0; i < y.length; i++) {
			var preeval = "";
			var niva = y[i].split("<")[0];
			var tagnamn = y[i].split("<")[1].split(">")[0];
			tagnamn = tagnamn.toLowerCase();
			var rest = y[i].split(">")[1];
			if (niva <= oldniva) {
				var tabort = oldniva - niva + 1;
				for (var j = 0; j < tabort; j++) {
					objname = objname.substring(0, objname.lastIndexOf("."))
				}
			}
			objname += "." + tagnamn;
			var pobject = objname.substring(0, objname.lastIndexOf("."));
			if (eval("typeof " + pobject) != "object") {
				preeval += pobject + "={value:" + pobject + "};\n"
			}
			;
			var objlast = objname.substring(objname.lastIndexOf(".") + 1);
			var already = false;
			var temp = eval(pobject);
			for ( var k in temp) {
				if (k == objlast) {
					already = true
				}
			}
			var onlywhites = true;
			for (var s = 0; s < rest.length; s += 3) {
				if (rest.charAt(s) != "%") {
					onlywhites = false
				}
			}
			if (rest != "" && !onlywhites) {
				if (rest / 1 != rest) {
					rest = "'" + rest.replace(/\'/g, "\\'") + "'";
					rest = rest.replace(/\*\$\*\*\*/g, "</");
					rest = rest.replace(/\*\$\*\*/g, "<");
					rest = rest.replace(/\*\*\$\*/g, ">")
				}
			} else {
				rest = "{}"
			}
			if (rest.charAt(0) == "'") {
				rest = 'unescape(' + rest + ')'
			}
			if (already && !eval(objname + ".sort")) {
				preeval += objname + "=[" + objname + "];\n"
			}
			var before = "=";
			after = "";
			if (already) {
				before = ".push(";
				after = ")"
			}
			var toeval = preeval + objname + before + rest + after;
			eval(toeval);
			if (eval(objname + ".sort")) {
				objname += "[" + eval(objname + ".length-1") + "]"
			}
			oldniva = niva
		}
		return this.xmlobject
	},
	show_json_structure : function(obj, debug, l) {
		var x = '';
		if (obj.sort) {
			x += "[\n"
		} else {
			x += "{\n"
		}
		for ( var i in obj) {
			if (!obj.sort) {
				x += i + ":"
			}
			if (typeof obj[i] == "object") {
				x += this.show_json_structure(obj[i], false, 1)
			} else {
				if (typeof obj[i] == "function") {
					var v = obj[i] + "";
					// v=v.replace(/\t/g,"");
					x += v
				} else if (typeof obj[i] != "string") {
					x += obj[i] + ",\n"
				} else {
					x += "'"
							+ obj[i].replace(/\'/g, "\\'")
									.replace(/\n/g, "\\n")
									.replace(/\t/g, "\\t")
									.replace(/\r/g, "\\r") + "',\n"
				}
			}
		}
		if (obj.sort) {
			x += "],\n"
		} else {
			x += "},\n"
		}
		if (!l) {
			x = x.substring(0, x.lastIndexOf(","));
			x = x.replace(new RegExp(",\n}", "g"), "\n}");
			x = x.replace(new RegExp(",\n]", "g"), "\n]");
			var y = x.split("\n");
			x = "";
			var lvl = 0;
			for (var i = 0; i < y.length; i++) {
				if (y[i].indexOf("}") >= 0 || y[i].indexOf("]") >= 0) {
					lvl--
				}
				tabs = "";
				for (var j = 0; j < lvl; j++) {
					tabs += "\t"
				}
				x += tabs + y[i] + "\n";
				if (y[i].indexOf("{") >= 0 || y[i].indexOf("[") >= 0) {
					lvl++
				}
			}
			if (debug == "html") {
				x = x.replace(/</g, "&lt;").replace(/>/g, "&gt;");
				x = x.replace(/\n/g, "<BR>").replace(/\t/g,
						"&nbsp;&nbsp;&nbsp;&nbsp;")
			}
			if (debug == "compact") {
				x = x.replace(/\n/g, "").replace(/\t/g, "")
			}
		}
		return x
	},
	no_fast_endings : function(x) {
		x = x.split("/>");
		for (var i = 1; i < x.length; i++) {
			var t = x[i - 1].substring(x[i - 1].lastIndexOf("<") + 1)
					.split(" ")[0];
			x[i] = "></" + t + ">" + x[i]
		}
		x = x.join("");
		return x
	},
	attris_to_tags : function(x) {
		var d = ' ="\''.split("");
		x = x.split(">");
		for (var i = 0; i < x.length; i++) {
			var temp = x[i].split("<");
			for (var r = 0; r < 4; r++) {
				temp[0] = temp[0].replace(new RegExp(d[r], "g"),
						"_jsonconvtemp" + r + "_")
			}
			if (temp[1]) {
				temp[1] = temp[1].replace(/'/g, '"');
				temp[1] = temp[1].split('"');
				for (var j = 1; j < temp[1].length; j += 2) {
					for (var r = 0; r < 4; r++) {
						temp[1][j] = temp[1][j].replace(new RegExp(d[r], "g"),
								"_jsonconvtemp" + r + "_")
					}
				}
				temp[1] = temp[1].join('"')
			}
			x[i] = temp.join("<")
		}
		x = x.join(">");
		x = x.replace(/ ([^=]*)=([^ |>]*)/g, "><$1>$2</$1");
		x = x.replace(/>"/g, ">").replace(/"</g, "<");
		for (var r = 0; r < 4; r++) {
			x = x.replace(new RegExp("_jsonconvtemp" + r + "_", "g"), d[r])
		}
		return x
	}
}; 

if (!Array.prototype.push) {
	Array.prototype.push = function(x) {
		this[this.length] = x;
		return true;
	}
};

if (!Array.prototype.pop) {
	Array.prototype.pop = function() {
		var response = this[this.length - 1];
		this.length--;
		return response;
	}
};